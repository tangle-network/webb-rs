#[allow(dead_code, unused_imports, non_camel_case_types)]
#[allow(clippy::all)]
pub mod api {
    #[allow(unused_imports)]
    mod root_mod {
        pub use super::*;
    }
    pub static PALLETS: [&str; 42usize] = [
        "System",
        "Timestamp",
        "Sudo",
        "RandomnessCollectiveFlip",
        "Balances",
        "TransactionPayment",
        "Authorship",
        "Aura",
        "Grandpa",
        "DKG",
        "DKGProposals",
        "DKGProposalHandler",
        "BridgeRegistry",
        "Indices",
        "Democracy",
        "Council",
        "Vesting",
        "Claims",
        "Elections",
        "ElectionProviderMultiPhase",
        "Staking",
        "Session",
        "Historical",
        "Treasury",
        "Bounties",
        "ChildBounties",
        "BagsList",
        "NominationPools",
        "Scheduler",
        "Preimage",
        "Offences",
        "TransactionPause",
        "ImOnline",
        "Identity",
        "Utility",
        "Ethereum",
        "EVM",
        "EVMChainId",
        "DynamicFee",
        "BaseFee",
        "HotfixSufficients",
        "Eth2Client",
    ];
    /// The error type returned when there is a runtime issue.
    pub type DispatchError = runtime_types::sp_runtime::DispatchError;
    #[derive(
        ::subxt::ext::codec::Decode,
        ::subxt::ext::codec::Encode,
        ::subxt::ext::scale_decode::DecodeAsType,
        ::subxt::ext::scale_encode::EncodeAsType,
        Clone,
        Debug,
        Eq,
        PartialEq
    )]
    #[codec(crate = ::subxt::ext::codec)]
    #[decode_as_type(crate_path = ":: subxt :: ext :: scale_decode")]
    #[encode_as_type(crate_path = ":: subxt :: ext :: scale_encode")]
    pub enum Event {
        #[codec(index = 0)]
        System(system::Event),
        #[codec(index = 2)]
        Sudo(sudo::Event),
        #[codec(index = 4)]
        Balances(balances::Event),
        #[codec(index = 5)]
        TransactionPayment(transaction_payment::Event),
        #[codec(index = 8)]
        Grandpa(grandpa::Event),
        #[codec(index = 9)]
        DKG(dkg::Event),
        #[codec(index = 10)]
        DKGProposals(dkg_proposals::Event),
        #[codec(index = 11)]
        DKGProposalHandler(dkg_proposal_handler::Event),
        #[codec(index = 12)]
        BridgeRegistry(bridge_registry::Event),
        #[codec(index = 13)]
        Indices(indices::Event),
        #[codec(index = 14)]
        Democracy(democracy::Event),
        #[codec(index = 15)]
        Council(council::Event),
        #[codec(index = 16)]
        Vesting(vesting::Event),
        #[codec(index = 17)]
        Claims(claims::Event),
        #[codec(index = 18)]
        Elections(elections::Event),
        #[codec(index = 19)]
        ElectionProviderMultiPhase(election_provider_multi_phase::Event),
        #[codec(index = 20)]
        Staking(staking::Event),
        #[codec(index = 21)]
        Session(session::Event),
        #[codec(index = 23)]
        Treasury(treasury::Event),
        #[codec(index = 24)]
        Bounties(bounties::Event),
        #[codec(index = 25)]
        ChildBounties(child_bounties::Event),
        #[codec(index = 26)]
        BagsList(bags_list::Event),
        #[codec(index = 27)]
        NominationPools(nomination_pools::Event),
        #[codec(index = 28)]
        Scheduler(scheduler::Event),
        #[codec(index = 29)]
        Preimage(preimage::Event),
        #[codec(index = 30)]
        Offences(offences::Event),
        #[codec(index = 31)]
        TransactionPause(transaction_pause::Event),
        #[codec(index = 32)]
        ImOnline(im_online::Event),
        #[codec(index = 33)]
        Identity(identity::Event),
        #[codec(index = 34)]
        Utility(utility::Event),
        #[codec(index = 35)]
        Ethereum(ethereum::Event),
        #[codec(index = 36)]
        EVM(evm::Event),
        #[codec(index = 39)]
        BaseFee(base_fee::Event),
        #[codec(index = 41)]
        Eth2Client(eth2_client::Event),
    }
    impl ::subxt::events::RootEvent for Event {
        fn root_event(
            pallet_bytes: &[u8],
            pallet_name: &str,
            pallet_ty: u32,
            metadata: &::subxt::Metadata,
        ) -> Result<Self, ::subxt::Error> {
            use ::subxt::metadata::DecodeWithMetadata;
            if pallet_name == "System" {
                return Ok(
                    Event::System(
                        system::Event::decode_with_metadata(
                            &mut &*pallet_bytes,
                            pallet_ty,
                            metadata,
                        )?,
                    ),
                );
            }
            if pallet_name == "Sudo" {
                return Ok(
                    Event::Sudo(
                        sudo::Event::decode_with_metadata(
                            &mut &*pallet_bytes,
                            pallet_ty,
                            metadata,
                        )?,
                    ),
                );
            }
            if pallet_name == "Balances" {
                return Ok(
                    Event::Balances(
                        balances::Event::decode_with_metadata(
                            &mut &*pallet_bytes,
                            pallet_ty,
                            metadata,
                        )?,
                    ),
                );
            }
            if pallet_name == "TransactionPayment" {
                return Ok(
                    Event::TransactionPayment(
                        transaction_payment::Event::decode_with_metadata(
                            &mut &*pallet_bytes,
                            pallet_ty,
                            metadata,
                        )?,
                    ),
                );
            }
            if pallet_name == "Grandpa" {
                return Ok(
                    Event::Grandpa(
                        grandpa::Event::decode_with_metadata(
                            &mut &*pallet_bytes,
                            pallet_ty,
                            metadata,
                        )?,
                    ),
                );
            }
            if pallet_name == "DKG" {
                return Ok(
                    Event::DKG(
                        dkg::Event::decode_with_metadata(
                            &mut &*pallet_bytes,
                            pallet_ty,
                            metadata,
                        )?,
                    ),
                );
            }
            if pallet_name == "DKGProposals" {
                return Ok(
                    Event::DKGProposals(
                        dkg_proposals::Event::decode_with_metadata(
                            &mut &*pallet_bytes,
                            pallet_ty,
                            metadata,
                        )?,
                    ),
                );
            }
            if pallet_name == "DKGProposalHandler" {
                return Ok(
                    Event::DKGProposalHandler(
                        dkg_proposal_handler::Event::decode_with_metadata(
                            &mut &*pallet_bytes,
                            pallet_ty,
                            metadata,
                        )?,
                    ),
                );
            }
            if pallet_name == "BridgeRegistry" {
                return Ok(
                    Event::BridgeRegistry(
                        bridge_registry::Event::decode_with_metadata(
                            &mut &*pallet_bytes,
                            pallet_ty,
                            metadata,
                        )?,
                    ),
                );
            }
            if pallet_name == "Indices" {
                return Ok(
                    Event::Indices(
                        indices::Event::decode_with_metadata(
                            &mut &*pallet_bytes,
                            pallet_ty,
                            metadata,
                        )?,
                    ),
                );
            }
            if pallet_name == "Democracy" {
                return Ok(
                    Event::Democracy(
                        democracy::Event::decode_with_metadata(
                            &mut &*pallet_bytes,
                            pallet_ty,
                            metadata,
                        )?,
                    ),
                );
            }
            if pallet_name == "Council" {
                return Ok(
                    Event::Council(
                        council::Event::decode_with_metadata(
                            &mut &*pallet_bytes,
                            pallet_ty,
                            metadata,
                        )?,
                    ),
                );
            }
            if pallet_name == "Vesting" {
                return Ok(
                    Event::Vesting(
                        vesting::Event::decode_with_metadata(
                            &mut &*pallet_bytes,
                            pallet_ty,
                            metadata,
                        )?,
                    ),
                );
            }
            if pallet_name == "Claims" {
                return Ok(
                    Event::Claims(
                        claims::Event::decode_with_metadata(
                            &mut &*pallet_bytes,
                            pallet_ty,
                            metadata,
                        )?,
                    ),
                );
            }
            if pallet_name == "Elections" {
                return Ok(
                    Event::Elections(
                        elections::Event::decode_with_metadata(
                            &mut &*pallet_bytes,
                            pallet_ty,
                            metadata,
                        )?,
                    ),
                );
            }
            if pallet_name == "ElectionProviderMultiPhase" {
                return Ok(
                    Event::ElectionProviderMultiPhase(
                        election_provider_multi_phase::Event::decode_with_metadata(
                            &mut &*pallet_bytes,
                            pallet_ty,
                            metadata,
                        )?,
                    ),
                );
            }
            if pallet_name == "Staking" {
                return Ok(
                    Event::Staking(
                        staking::Event::decode_with_metadata(
                            &mut &*pallet_bytes,
                            pallet_ty,
                            metadata,
                        )?,
                    ),
                );
            }
            if pallet_name == "Session" {
                return Ok(
                    Event::Session(
                        session::Event::decode_with_metadata(
                            &mut &*pallet_bytes,
                            pallet_ty,
                            metadata,
                        )?,
                    ),
                );
            }
            if pallet_name == "Treasury" {
                return Ok(
                    Event::Treasury(
                        treasury::Event::decode_with_metadata(
                            &mut &*pallet_bytes,
                            pallet_ty,
                            metadata,
                        )?,
                    ),
                );
            }
            if pallet_name == "Bounties" {
                return Ok(
                    Event::Bounties(
                        bounties::Event::decode_with_metadata(
                            &mut &*pallet_bytes,
                            pallet_ty,
                            metadata,
                        )?,
                    ),
                );
            }
            if pallet_name == "ChildBounties" {
                return Ok(
                    Event::ChildBounties(
                        child_bounties::Event::decode_with_metadata(
                            &mut &*pallet_bytes,
                            pallet_ty,
                            metadata,
                        )?,
                    ),
                );
            }
            if pallet_name == "BagsList" {
                return Ok(
                    Event::BagsList(
                        bags_list::Event::decode_with_metadata(
                            &mut &*pallet_bytes,
                            pallet_ty,
                            metadata,
                        )?,
                    ),
                );
            }
            if pallet_name == "NominationPools" {
                return Ok(
                    Event::NominationPools(
                        nomination_pools::Event::decode_with_metadata(
                            &mut &*pallet_bytes,
                            pallet_ty,
                            metadata,
                        )?,
                    ),
                );
            }
            if pallet_name == "Scheduler" {
                return Ok(
                    Event::Scheduler(
                        scheduler::Event::decode_with_metadata(
                            &mut &*pallet_bytes,
                            pallet_ty,
                            metadata,
                        )?,
                    ),
                );
            }
            if pallet_name == "Preimage" {
                return Ok(
                    Event::Preimage(
                        preimage::Event::decode_with_metadata(
                            &mut &*pallet_bytes,
                            pallet_ty,
                            metadata,
                        )?,
                    ),
                );
            }
            if pallet_name == "Offences" {
                return Ok(
                    Event::Offences(
                        offences::Event::decode_with_metadata(
                            &mut &*pallet_bytes,
                            pallet_ty,
                            metadata,
                        )?,
                    ),
                );
            }
            if pallet_name == "TransactionPause" {
                return Ok(
                    Event::TransactionPause(
                        transaction_pause::Event::decode_with_metadata(
                            &mut &*pallet_bytes,
                            pallet_ty,
                            metadata,
                        )?,
                    ),
                );
            }
            if pallet_name == "ImOnline" {
                return Ok(
                    Event::ImOnline(
                        im_online::Event::decode_with_metadata(
                            &mut &*pallet_bytes,
                            pallet_ty,
                            metadata,
                        )?,
                    ),
                );
            }
            if pallet_name == "Identity" {
                return Ok(
                    Event::Identity(
                        identity::Event::decode_with_metadata(
                            &mut &*pallet_bytes,
                            pallet_ty,
                            metadata,
                        )?,
                    ),
                );
            }
            if pallet_name == "Utility" {
                return Ok(
                    Event::Utility(
                        utility::Event::decode_with_metadata(
                            &mut &*pallet_bytes,
                            pallet_ty,
                            metadata,
                        )?,
                    ),
                );
            }
            if pallet_name == "Ethereum" {
                return Ok(
                    Event::Ethereum(
                        ethereum::Event::decode_with_metadata(
                            &mut &*pallet_bytes,
                            pallet_ty,
                            metadata,
                        )?,
                    ),
                );
            }
            if pallet_name == "EVM" {
                return Ok(
                    Event::EVM(
                        evm::Event::decode_with_metadata(
                            &mut &*pallet_bytes,
                            pallet_ty,
                            metadata,
                        )?,
                    ),
                );
            }
            if pallet_name == "BaseFee" {
                return Ok(
                    Event::BaseFee(
                        base_fee::Event::decode_with_metadata(
                            &mut &*pallet_bytes,
                            pallet_ty,
                            metadata,
                        )?,
                    ),
                );
            }
            if pallet_name == "Eth2Client" {
                return Ok(
                    Event::Eth2Client(
                        eth2_client::Event::decode_with_metadata(
                            &mut &*pallet_bytes,
                            pallet_ty,
                            metadata,
                        )?,
                    ),
                );
            }
            Err(
                ::subxt::ext::scale_decode::Error::custom(
                        format!(
                            "Pallet name '{}' not found in root Event enum", pallet_name
                        ),
                    )
                    .into(),
            )
        }
    }
    #[derive(
        ::subxt::ext::codec::Decode,
        ::subxt::ext::codec::Encode,
        ::subxt::ext::scale_decode::DecodeAsType,
        ::subxt::ext::scale_encode::EncodeAsType,
        Clone,
        Debug,
        Eq,
        PartialEq
    )]
    #[codec(crate = ::subxt::ext::codec)]
    #[decode_as_type(crate_path = ":: subxt :: ext :: scale_decode")]
    #[encode_as_type(crate_path = ":: subxt :: ext :: scale_encode")]
    pub enum Call {
        #[codec(index = 0)]
        System(system::Call),
        #[codec(index = 1)]
        Timestamp(timestamp::Call),
        #[codec(index = 2)]
        Sudo(sudo::Call),
        #[codec(index = 4)]
        Balances(balances::Call),
        #[codec(index = 8)]
        Grandpa(grandpa::Call),
        #[codec(index = 9)]
        DKG(dkg::Call),
        #[codec(index = 10)]
        DKGProposals(dkg_proposals::Call),
        #[codec(index = 11)]
        DKGProposalHandler(dkg_proposal_handler::Call),
        #[codec(index = 12)]
        BridgeRegistry(bridge_registry::Call),
        #[codec(index = 13)]
        Indices(indices::Call),
        #[codec(index = 14)]
        Democracy(democracy::Call),
        #[codec(index = 15)]
        Council(council::Call),
        #[codec(index = 16)]
        Vesting(vesting::Call),
        #[codec(index = 17)]
        Claims(claims::Call),
        #[codec(index = 18)]
        Elections(elections::Call),
        #[codec(index = 19)]
        ElectionProviderMultiPhase(election_provider_multi_phase::Call),
        #[codec(index = 20)]
        Staking(staking::Call),
        #[codec(index = 21)]
        Session(session::Call),
        #[codec(index = 23)]
        Treasury(treasury::Call),
        #[codec(index = 24)]
        Bounties(bounties::Call),
        #[codec(index = 25)]
        ChildBounties(child_bounties::Call),
        #[codec(index = 26)]
        BagsList(bags_list::Call),
        #[codec(index = 27)]
        NominationPools(nomination_pools::Call),
        #[codec(index = 28)]
        Scheduler(scheduler::Call),
        #[codec(index = 29)]
        Preimage(preimage::Call),
        #[codec(index = 31)]
        TransactionPause(transaction_pause::Call),
        #[codec(index = 32)]
        ImOnline(im_online::Call),
        #[codec(index = 33)]
        Identity(identity::Call),
        #[codec(index = 34)]
        Utility(utility::Call),
        #[codec(index = 35)]
        Ethereum(ethereum::Call),
        #[codec(index = 36)]
        EVM(evm::Call),
        #[codec(index = 38)]
        DynamicFee(dynamic_fee::Call),
        #[codec(index = 39)]
        BaseFee(base_fee::Call),
        #[codec(index = 40)]
        HotfixSufficients(hotfix_sufficients::Call),
        #[codec(index = 41)]
        Eth2Client(eth2_client::Call),
    }
    impl ::subxt::blocks::RootExtrinsic for Call {
        fn root_extrinsic(
            pallet_bytes: &[u8],
            pallet_name: &str,
            pallet_ty: u32,
            metadata: &::subxt::Metadata,
        ) -> Result<Self, ::subxt::Error> {
            use ::subxt::metadata::DecodeWithMetadata;
            if pallet_name == "System" {
                return Ok(
                    Call::System(
                        system::Call::decode_with_metadata(
                            &mut &*pallet_bytes,
                            pallet_ty,
                            metadata,
                        )?,
                    ),
                );
            }
            if pallet_name == "Timestamp" {
                return Ok(
                    Call::Timestamp(
                        timestamp::Call::decode_with_metadata(
                            &mut &*pallet_bytes,
                            pallet_ty,
                            metadata,
                        )?,
                    ),
                );
            }
            if pallet_name == "Sudo" {
                return Ok(
                    Call::Sudo(
                        sudo::Call::decode_with_metadata(
                            &mut &*pallet_bytes,
                            pallet_ty,
                            metadata,
                        )?,
                    ),
                );
            }
            if pallet_name == "Balances" {
                return Ok(
                    Call::Balances(
                        balances::Call::decode_with_metadata(
                            &mut &*pallet_bytes,
                            pallet_ty,
                            metadata,
                        )?,
                    ),
                );
            }
            if pallet_name == "Grandpa" {
                return Ok(
                    Call::Grandpa(
                        grandpa::Call::decode_with_metadata(
                            &mut &*pallet_bytes,
                            pallet_ty,
                            metadata,
                        )?,
                    ),
                );
            }
            if pallet_name == "DKG" {
                return Ok(
                    Call::DKG(
                        dkg::Call::decode_with_metadata(
                            &mut &*pallet_bytes,
                            pallet_ty,
                            metadata,
                        )?,
                    ),
                );
            }
            if pallet_name == "DKGProposals" {
                return Ok(
                    Call::DKGProposals(
                        dkg_proposals::Call::decode_with_metadata(
                            &mut &*pallet_bytes,
                            pallet_ty,
                            metadata,
                        )?,
                    ),
                );
            }
            if pallet_name == "DKGProposalHandler" {
                return Ok(
                    Call::DKGProposalHandler(
                        dkg_proposal_handler::Call::decode_with_metadata(
                            &mut &*pallet_bytes,
                            pallet_ty,
                            metadata,
                        )?,
                    ),
                );
            }
            if pallet_name == "BridgeRegistry" {
                return Ok(
                    Call::BridgeRegistry(
                        bridge_registry::Call::decode_with_metadata(
                            &mut &*pallet_bytes,
                            pallet_ty,
                            metadata,
                        )?,
                    ),
                );
            }
            if pallet_name == "Indices" {
                return Ok(
                    Call::Indices(
                        indices::Call::decode_with_metadata(
                            &mut &*pallet_bytes,
                            pallet_ty,
                            metadata,
                        )?,
                    ),
                );
            }
            if pallet_name == "Democracy" {
                return Ok(
                    Call::Democracy(
                        democracy::Call::decode_with_metadata(
                            &mut &*pallet_bytes,
                            pallet_ty,
                            metadata,
                        )?,
                    ),
                );
            }
            if pallet_name == "Council" {
                return Ok(
                    Call::Council(
                        council::Call::decode_with_metadata(
                            &mut &*pallet_bytes,
                            pallet_ty,
                            metadata,
                        )?,
                    ),
                );
            }
            if pallet_name == "Vesting" {
                return Ok(
                    Call::Vesting(
                        vesting::Call::decode_with_metadata(
                            &mut &*pallet_bytes,
                            pallet_ty,
                            metadata,
                        )?,
                    ),
                );
            }
            if pallet_name == "Claims" {
                return Ok(
                    Call::Claims(
                        claims::Call::decode_with_metadata(
                            &mut &*pallet_bytes,
                            pallet_ty,
                            metadata,
                        )?,
                    ),
                );
            }
            if pallet_name == "Elections" {
                return Ok(
                    Call::Elections(
                        elections::Call::decode_with_metadata(
                            &mut &*pallet_bytes,
                            pallet_ty,
                            metadata,
                        )?,
                    ),
                );
            }
            if pallet_name == "ElectionProviderMultiPhase" {
                return Ok(
                    Call::ElectionProviderMultiPhase(
                        election_provider_multi_phase::Call::decode_with_metadata(
                            &mut &*pallet_bytes,
                            pallet_ty,
                            metadata,
                        )?,
                    ),
                );
            }
            if pallet_name == "Staking" {
                return Ok(
                    Call::Staking(
                        staking::Call::decode_with_metadata(
                            &mut &*pallet_bytes,
                            pallet_ty,
                            metadata,
                        )?,
                    ),
                );
            }
            if pallet_name == "Session" {
                return Ok(
                    Call::Session(
                        session::Call::decode_with_metadata(
                            &mut &*pallet_bytes,
                            pallet_ty,
                            metadata,
                        )?,
                    ),
                );
            }
            if pallet_name == "Treasury" {
                return Ok(
                    Call::Treasury(
                        treasury::Call::decode_with_metadata(
                            &mut &*pallet_bytes,
                            pallet_ty,
                            metadata,
                        )?,
                    ),
                );
            }
            if pallet_name == "Bounties" {
                return Ok(
                    Call::Bounties(
                        bounties::Call::decode_with_metadata(
                            &mut &*pallet_bytes,
                            pallet_ty,
                            metadata,
                        )?,
                    ),
                );
            }
            if pallet_name == "ChildBounties" {
                return Ok(
                    Call::ChildBounties(
                        child_bounties::Call::decode_with_metadata(
                            &mut &*pallet_bytes,
                            pallet_ty,
                            metadata,
                        )?,
                    ),
                );
            }
            if pallet_name == "BagsList" {
                return Ok(
                    Call::BagsList(
                        bags_list::Call::decode_with_metadata(
                            &mut &*pallet_bytes,
                            pallet_ty,
                            metadata,
                        )?,
                    ),
                );
            }
            if pallet_name == "NominationPools" {
                return Ok(
                    Call::NominationPools(
                        nomination_pools::Call::decode_with_metadata(
                            &mut &*pallet_bytes,
                            pallet_ty,
                            metadata,
                        )?,
                    ),
                );
            }
            if pallet_name == "Scheduler" {
                return Ok(
                    Call::Scheduler(
                        scheduler::Call::decode_with_metadata(
                            &mut &*pallet_bytes,
                            pallet_ty,
                            metadata,
                        )?,
                    ),
                );
            }
            if pallet_name == "Preimage" {
                return Ok(
                    Call::Preimage(
                        preimage::Call::decode_with_metadata(
                            &mut &*pallet_bytes,
                            pallet_ty,
                            metadata,
                        )?,
                    ),
                );
            }
            if pallet_name == "TransactionPause" {
                return Ok(
                    Call::TransactionPause(
                        transaction_pause::Call::decode_with_metadata(
                            &mut &*pallet_bytes,
                            pallet_ty,
                            metadata,
                        )?,
                    ),
                );
            }
            if pallet_name == "ImOnline" {
                return Ok(
                    Call::ImOnline(
                        im_online::Call::decode_with_metadata(
                            &mut &*pallet_bytes,
                            pallet_ty,
                            metadata,
                        )?,
                    ),
                );
            }
            if pallet_name == "Identity" {
                return Ok(
                    Call::Identity(
                        identity::Call::decode_with_metadata(
                            &mut &*pallet_bytes,
                            pallet_ty,
                            metadata,
                        )?,
                    ),
                );
            }
            if pallet_name == "Utility" {
                return Ok(
                    Call::Utility(
                        utility::Call::decode_with_metadata(
                            &mut &*pallet_bytes,
                            pallet_ty,
                            metadata,
                        )?,
                    ),
                );
            }
            if pallet_name == "Ethereum" {
                return Ok(
                    Call::Ethereum(
                        ethereum::Call::decode_with_metadata(
                            &mut &*pallet_bytes,
                            pallet_ty,
                            metadata,
                        )?,
                    ),
                );
            }
            if pallet_name == "EVM" {
                return Ok(
                    Call::EVM(
                        evm::Call::decode_with_metadata(
                            &mut &*pallet_bytes,
                            pallet_ty,
                            metadata,
                        )?,
                    ),
                );
            }
            if pallet_name == "DynamicFee" {
                return Ok(
                    Call::DynamicFee(
                        dynamic_fee::Call::decode_with_metadata(
                            &mut &*pallet_bytes,
                            pallet_ty,
                            metadata,
                        )?,
                    ),
                );
            }
            if pallet_name == "BaseFee" {
                return Ok(
                    Call::BaseFee(
                        base_fee::Call::decode_with_metadata(
                            &mut &*pallet_bytes,
                            pallet_ty,
                            metadata,
                        )?,
                    ),
                );
            }
            if pallet_name == "HotfixSufficients" {
                return Ok(
                    Call::HotfixSufficients(
                        hotfix_sufficients::Call::decode_with_metadata(
                            &mut &*pallet_bytes,
                            pallet_ty,
                            metadata,
                        )?,
                    ),
                );
            }
            if pallet_name == "Eth2Client" {
                return Ok(
                    Call::Eth2Client(
                        eth2_client::Call::decode_with_metadata(
                            &mut &*pallet_bytes,
                            pallet_ty,
                            metadata,
                        )?,
                    ),
                );
            }
            Err(
                ::subxt::ext::scale_decode::Error::custom(
                        format!(
                            "Pallet name '{}' not found in root Call enum", pallet_name
                        ),
                    )
                    .into(),
            )
        }
    }
    #[derive(
        ::subxt::ext::codec::Decode,
        ::subxt::ext::codec::Encode,
        ::subxt::ext::scale_decode::DecodeAsType,
        ::subxt::ext::scale_encode::EncodeAsType,
        Clone,
        Debug,
        Eq,
        PartialEq
    )]
    #[codec(crate = ::subxt::ext::codec)]
    #[decode_as_type(crate_path = ":: subxt :: ext :: scale_decode")]
    #[encode_as_type(crate_path = ":: subxt :: ext :: scale_encode")]
    pub enum Error {
        #[codec(index = 0)]
        System(system::Error),
        #[codec(index = 2)]
        Sudo(sudo::Error),
        #[codec(index = 4)]
        Balances(balances::Error),
        #[codec(index = 8)]
        Grandpa(grandpa::Error),
        #[codec(index = 9)]
        DKG(dkg::Error),
        #[codec(index = 10)]
        DKGProposals(dkg_proposals::Error),
        #[codec(index = 11)]
        DKGProposalHandler(dkg_proposal_handler::Error),
        #[codec(index = 12)]
        BridgeRegistry(bridge_registry::Error),
        #[codec(index = 13)]
        Indices(indices::Error),
        #[codec(index = 14)]
        Democracy(democracy::Error),
        #[codec(index = 15)]
        Council(council::Error),
        #[codec(index = 16)]
        Vesting(vesting::Error),
        #[codec(index = 17)]
        Claims(claims::Error),
        #[codec(index = 18)]
        Elections(elections::Error),
        #[codec(index = 19)]
        ElectionProviderMultiPhase(election_provider_multi_phase::Error),
        #[codec(index = 20)]
        Staking(staking::Error),
        #[codec(index = 21)]
        Session(session::Error),
        #[codec(index = 23)]
        Treasury(treasury::Error),
        #[codec(index = 24)]
        Bounties(bounties::Error),
        #[codec(index = 25)]
        ChildBounties(child_bounties::Error),
        #[codec(index = 26)]
        BagsList(bags_list::Error),
        #[codec(index = 27)]
        NominationPools(nomination_pools::Error),
        #[codec(index = 28)]
        Scheduler(scheduler::Error),
        #[codec(index = 29)]
        Preimage(preimage::Error),
        #[codec(index = 31)]
        TransactionPause(transaction_pause::Error),
        #[codec(index = 32)]
        ImOnline(im_online::Error),
        #[codec(index = 33)]
        Identity(identity::Error),
        #[codec(index = 34)]
        Utility(utility::Error),
        #[codec(index = 35)]
        Ethereum(ethereum::Error),
        #[codec(index = 36)]
        EVM(evm::Error),
        #[codec(index = 40)]
        HotfixSufficients(hotfix_sufficients::Error),
        #[codec(index = 41)]
        Eth2Client(eth2_client::Error),
    }
    impl ::subxt::error::RootError for Error {
        fn root_error(
            pallet_bytes: &[u8],
            pallet_name: &str,
            metadata: &::subxt::Metadata,
        ) -> Result<Self, ::subxt::Error> {
            use ::subxt::metadata::DecodeWithMetadata;
            let cursor = &mut &pallet_bytes[..];
            if pallet_name == "System" {
                let variant_error = system::Error::decode_with_metadata(
                    cursor,
                    163u32,
                    metadata,
                )?;
                return Ok(Error::System(variant_error));
            }
            if pallet_name == "Sudo" {
                let variant_error = sudo::Error::decode_with_metadata(
                    cursor,
                    403u32,
                    metadata,
                )?;
                return Ok(Error::Sudo(variant_error));
            }
            if pallet_name == "Balances" {
                let variant_error = balances::Error::decode_with_metadata(
                    cursor,
                    415u32,
                    metadata,
                )?;
                return Ok(Error::Balances(variant_error));
            }
            if pallet_name == "Grandpa" {
                let variant_error = grandpa::Error::decode_with_metadata(
                    cursor,
                    424u32,
                    metadata,
                )?;
                return Ok(Error::Grandpa(variant_error));
            }
            if pallet_name == "DKG" {
                let variant_error = dkg::Error::decode_with_metadata(
                    cursor,
                    436u32,
                    metadata,
                )?;
                return Ok(Error::DKG(variant_error));
            }
            if pallet_name == "DKGProposals" {
                let variant_error = dkg_proposals::Error::decode_with_metadata(
                    cursor,
                    448u32,
                    metadata,
                )?;
                return Ok(Error::DKGProposals(variant_error));
            }
            if pallet_name == "DKGProposalHandler" {
                let variant_error = dkg_proposal_handler::Error::decode_with_metadata(
                    cursor,
                    454u32,
                    metadata,
                )?;
                return Ok(Error::DKGProposalHandler(variant_error));
            }
            if pallet_name == "BridgeRegistry" {
                let variant_error = bridge_registry::Error::decode_with_metadata(
                    cursor,
                    457u32,
                    metadata,
                )?;
                return Ok(Error::BridgeRegistry(variant_error));
            }
            if pallet_name == "Indices" {
                let variant_error = indices::Error::decode_with_metadata(
                    cursor,
                    459u32,
                    metadata,
                )?;
                return Ok(Error::Indices(variant_error));
            }
            if pallet_name == "Democracy" {
                let variant_error = democracy::Error::decode_with_metadata(
                    cursor,
                    476u32,
                    metadata,
                )?;
                return Ok(Error::Democracy(variant_error));
            }
            if pallet_name == "Council" {
                let variant_error = council::Error::decode_with_metadata(
                    cursor,
                    479u32,
                    metadata,
                )?;
                return Ok(Error::Council(variant_error));
            }
            if pallet_name == "Vesting" {
                let variant_error = vesting::Error::decode_with_metadata(
                    cursor,
                    483u32,
                    metadata,
                )?;
                return Ok(Error::Vesting(variant_error));
            }
            if pallet_name == "Claims" {
                let variant_error = claims::Error::decode_with_metadata(
                    cursor,
                    485u32,
                    metadata,
                )?;
                return Ok(Error::Claims(variant_error));
            }
            if pallet_name == "Elections" {
                let variant_error = elections::Error::decode_with_metadata(
                    cursor,
                    489u32,
                    metadata,
                )?;
                return Ok(Error::Elections(variant_error));
            }
            if pallet_name == "ElectionProviderMultiPhase" {
                let variant_error = election_provider_multi_phase::Error::decode_with_metadata(
                    cursor,
                    500u32,
                    metadata,
                )?;
                return Ok(Error::ElectionProviderMultiPhase(variant_error));
            }
            if pallet_name == "Staking" {
                let variant_error = staking::Error::decode_with_metadata(
                    cursor,
                    520u32,
                    metadata,
                )?;
                return Ok(Error::Staking(variant_error));
            }
            if pallet_name == "Session" {
                let variant_error = session::Error::decode_with_metadata(
                    cursor,
                    525u32,
                    metadata,
                )?;
                return Ok(Error::Session(variant_error));
            }
            if pallet_name == "Treasury" {
                let variant_error = treasury::Error::decode_with_metadata(
                    cursor,
                    531u32,
                    metadata,
                )?;
                return Ok(Error::Treasury(variant_error));
            }
            if pallet_name == "Bounties" {
                let variant_error = bounties::Error::decode_with_metadata(
                    cursor,
                    535u32,
                    metadata,
                )?;
                return Ok(Error::Bounties(variant_error));
            }
            if pallet_name == "ChildBounties" {
                let variant_error = child_bounties::Error::decode_with_metadata(
                    cursor,
                    538u32,
                    metadata,
                )?;
                return Ok(Error::ChildBounties(variant_error));
            }
            if pallet_name == "BagsList" {
                let variant_error = bags_list::Error::decode_with_metadata(
                    cursor,
                    542u32,
                    metadata,
                )?;
                return Ok(Error::BagsList(variant_error));
            }
            if pallet_name == "NominationPools" {
                let variant_error = nomination_pools::Error::decode_with_metadata(
                    cursor,
                    562u32,
                    metadata,
                )?;
                return Ok(Error::NominationPools(variant_error));
            }
            if pallet_name == "Scheduler" {
                let variant_error = scheduler::Error::decode_with_metadata(
                    cursor,
                    568u32,
                    metadata,
                )?;
                return Ok(Error::Scheduler(variant_error));
            }
            if pallet_name == "Preimage" {
                let variant_error = preimage::Error::decode_with_metadata(
                    cursor,
                    572u32,
                    metadata,
                )?;
                return Ok(Error::Preimage(variant_error));
            }
            if pallet_name == "TransactionPause" {
                let variant_error = transaction_pause::Error::decode_with_metadata(
                    cursor,
                    575u32,
                    metadata,
                )?;
                return Ok(Error::TransactionPause(variant_error));
            }
            if pallet_name == "ImOnline" {
                let variant_error = im_online::Error::decode_with_metadata(
                    cursor,
                    583u32,
                    metadata,
                )?;
                return Ok(Error::ImOnline(variant_error));
            }
            if pallet_name == "Identity" {
                let variant_error = identity::Error::decode_with_metadata(
                    cursor,
                    594u32,
                    metadata,
                )?;
                return Ok(Error::Identity(variant_error));
            }
            if pallet_name == "Utility" {
                let variant_error = utility::Error::decode_with_metadata(
                    cursor,
                    595u32,
                    metadata,
                )?;
                return Ok(Error::Utility(variant_error));
            }
            if pallet_name == "Ethereum" {
                let variant_error = ethereum::Error::decode_with_metadata(
                    cursor,
                    609u32,
                    metadata,
                )?;
                return Ok(Error::Ethereum(variant_error));
            }
            if pallet_name == "EVM" {
                let variant_error = evm::Error::decode_with_metadata(
                    cursor,
                    612u32,
                    metadata,
                )?;
                return Ok(Error::EVM(variant_error));
            }
            if pallet_name == "HotfixSufficients" {
                let variant_error = hotfix_sufficients::Error::decode_with_metadata(
                    cursor,
                    613u32,
                    metadata,
                )?;
                return Ok(Error::HotfixSufficients(variant_error));
            }
            if pallet_name == "Eth2Client" {
                let variant_error = eth2_client::Error::decode_with_metadata(
                    cursor,
                    617u32,
                    metadata,
                )?;
                return Ok(Error::Eth2Client(variant_error));
            }
            Err(
                ::subxt::ext::scale_decode::Error::custom(
                        format!(
                            "Pallet name '{}' not found in root Error enum", pallet_name
                        ),
                    )
                    .into(),
            )
        }
    }
    pub fn constants() -> ConstantsApi {
        ConstantsApi
    }
    pub fn storage() -> StorageApi {
        StorageApi
    }
    pub fn tx() -> TransactionApi {
        TransactionApi
    }
    pub fn apis() -> runtime_apis::RuntimeApi {
        runtime_apis::RuntimeApi
    }
    pub mod runtime_apis {
        use super::root_mod;
        use super::runtime_types;
        use ::subxt::ext::codec::Encode;
        pub struct RuntimeApi;
        impl RuntimeApi {}
    }
    pub struct ConstantsApi;
    impl ConstantsApi {
        pub fn system(&self) -> system::constants::ConstantsApi {
            system::constants::ConstantsApi
        }
        pub fn timestamp(&self) -> timestamp::constants::ConstantsApi {
            timestamp::constants::ConstantsApi
        }
        pub fn balances(&self) -> balances::constants::ConstantsApi {
            balances::constants::ConstantsApi
        }
        pub fn transaction_payment(
            &self,
        ) -> transaction_payment::constants::ConstantsApi {
            transaction_payment::constants::ConstantsApi
        }
        pub fn grandpa(&self) -> grandpa::constants::ConstantsApi {
            grandpa::constants::ConstantsApi
        }
        pub fn dkg(&self) -> dkg::constants::ConstantsApi {
            dkg::constants::ConstantsApi
        }
        pub fn dkg_proposals(&self) -> dkg_proposals::constants::ConstantsApi {
            dkg_proposals::constants::ConstantsApi
        }
        pub fn dkg_proposal_handler(
            &self,
        ) -> dkg_proposal_handler::constants::ConstantsApi {
            dkg_proposal_handler::constants::ConstantsApi
        }
        pub fn bridge_registry(&self) -> bridge_registry::constants::ConstantsApi {
            bridge_registry::constants::ConstantsApi
        }
        pub fn indices(&self) -> indices::constants::ConstantsApi {
            indices::constants::ConstantsApi
        }
        pub fn democracy(&self) -> democracy::constants::ConstantsApi {
            democracy::constants::ConstantsApi
        }
        pub fn council(&self) -> council::constants::ConstantsApi {
            council::constants::ConstantsApi
        }
        pub fn vesting(&self) -> vesting::constants::ConstantsApi {
            vesting::constants::ConstantsApi
        }
        pub fn claims(&self) -> claims::constants::ConstantsApi {
            claims::constants::ConstantsApi
        }
        pub fn elections(&self) -> elections::constants::ConstantsApi {
            elections::constants::ConstantsApi
        }
        pub fn election_provider_multi_phase(
            &self,
        ) -> election_provider_multi_phase::constants::ConstantsApi {
            election_provider_multi_phase::constants::ConstantsApi
        }
        pub fn staking(&self) -> staking::constants::ConstantsApi {
            staking::constants::ConstantsApi
        }
        pub fn treasury(&self) -> treasury::constants::ConstantsApi {
            treasury::constants::ConstantsApi
        }
        pub fn bounties(&self) -> bounties::constants::ConstantsApi {
            bounties::constants::ConstantsApi
        }
        pub fn child_bounties(&self) -> child_bounties::constants::ConstantsApi {
            child_bounties::constants::ConstantsApi
        }
        pub fn bags_list(&self) -> bags_list::constants::ConstantsApi {
            bags_list::constants::ConstantsApi
        }
        pub fn nomination_pools(&self) -> nomination_pools::constants::ConstantsApi {
            nomination_pools::constants::ConstantsApi
        }
        pub fn scheduler(&self) -> scheduler::constants::ConstantsApi {
            scheduler::constants::ConstantsApi
        }
        pub fn im_online(&self) -> im_online::constants::ConstantsApi {
            im_online::constants::ConstantsApi
        }
        pub fn identity(&self) -> identity::constants::ConstantsApi {
            identity::constants::ConstantsApi
        }
        pub fn utility(&self) -> utility::constants::ConstantsApi {
            utility::constants::ConstantsApi
        }
        pub fn eth2_client(&self) -> eth2_client::constants::ConstantsApi {
            eth2_client::constants::ConstantsApi
        }
    }
    pub struct StorageApi;
    impl StorageApi {
        pub fn system(&self) -> system::storage::StorageApi {
            system::storage::StorageApi
        }
        pub fn timestamp(&self) -> timestamp::storage::StorageApi {
            timestamp::storage::StorageApi
        }
        pub fn sudo(&self) -> sudo::storage::StorageApi {
            sudo::storage::StorageApi
        }
        pub fn randomness_collective_flip(
            &self,
        ) -> randomness_collective_flip::storage::StorageApi {
            randomness_collective_flip::storage::StorageApi
        }
        pub fn balances(&self) -> balances::storage::StorageApi {
            balances::storage::StorageApi
        }
        pub fn transaction_payment(&self) -> transaction_payment::storage::StorageApi {
            transaction_payment::storage::StorageApi
        }
        pub fn authorship(&self) -> authorship::storage::StorageApi {
            authorship::storage::StorageApi
        }
        pub fn aura(&self) -> aura::storage::StorageApi {
            aura::storage::StorageApi
        }
        pub fn grandpa(&self) -> grandpa::storage::StorageApi {
            grandpa::storage::StorageApi
        }
        pub fn dkg(&self) -> dkg::storage::StorageApi {
            dkg::storage::StorageApi
        }
        pub fn dkg_proposals(&self) -> dkg_proposals::storage::StorageApi {
            dkg_proposals::storage::StorageApi
        }
        pub fn dkg_proposal_handler(&self) -> dkg_proposal_handler::storage::StorageApi {
            dkg_proposal_handler::storage::StorageApi
        }
        pub fn bridge_registry(&self) -> bridge_registry::storage::StorageApi {
            bridge_registry::storage::StorageApi
        }
        pub fn indices(&self) -> indices::storage::StorageApi {
            indices::storage::StorageApi
        }
        pub fn democracy(&self) -> democracy::storage::StorageApi {
            democracy::storage::StorageApi
        }
        pub fn council(&self) -> council::storage::StorageApi {
            council::storage::StorageApi
        }
        pub fn vesting(&self) -> vesting::storage::StorageApi {
            vesting::storage::StorageApi
        }
        pub fn claims(&self) -> claims::storage::StorageApi {
            claims::storage::StorageApi
        }
        pub fn elections(&self) -> elections::storage::StorageApi {
            elections::storage::StorageApi
        }
        pub fn election_provider_multi_phase(
            &self,
        ) -> election_provider_multi_phase::storage::StorageApi {
            election_provider_multi_phase::storage::StorageApi
        }
        pub fn staking(&self) -> staking::storage::StorageApi {
            staking::storage::StorageApi
        }
        pub fn session(&self) -> session::storage::StorageApi {
            session::storage::StorageApi
        }
        pub fn historical(&self) -> historical::storage::StorageApi {
            historical::storage::StorageApi
        }
        pub fn treasury(&self) -> treasury::storage::StorageApi {
            treasury::storage::StorageApi
        }
        pub fn bounties(&self) -> bounties::storage::StorageApi {
            bounties::storage::StorageApi
        }
        pub fn child_bounties(&self) -> child_bounties::storage::StorageApi {
            child_bounties::storage::StorageApi
        }
        pub fn bags_list(&self) -> bags_list::storage::StorageApi {
            bags_list::storage::StorageApi
        }
        pub fn nomination_pools(&self) -> nomination_pools::storage::StorageApi {
            nomination_pools::storage::StorageApi
        }
        pub fn scheduler(&self) -> scheduler::storage::StorageApi {
            scheduler::storage::StorageApi
        }
        pub fn preimage(&self) -> preimage::storage::StorageApi {
            preimage::storage::StorageApi
        }
        pub fn offences(&self) -> offences::storage::StorageApi {
            offences::storage::StorageApi
        }
        pub fn transaction_pause(&self) -> transaction_pause::storage::StorageApi {
            transaction_pause::storage::StorageApi
        }
        pub fn im_online(&self) -> im_online::storage::StorageApi {
            im_online::storage::StorageApi
        }
        pub fn identity(&self) -> identity::storage::StorageApi {
            identity::storage::StorageApi
        }
        pub fn ethereum(&self) -> ethereum::storage::StorageApi {
            ethereum::storage::StorageApi
        }
        pub fn evm(&self) -> evm::storage::StorageApi {
            evm::storage::StorageApi
        }
        pub fn evm_chain_id(&self) -> evm_chain_id::storage::StorageApi {
            evm_chain_id::storage::StorageApi
        }
        pub fn dynamic_fee(&self) -> dynamic_fee::storage::StorageApi {
            dynamic_fee::storage::StorageApi
        }
        pub fn base_fee(&self) -> base_fee::storage::StorageApi {
            base_fee::storage::StorageApi
        }
        pub fn eth2_client(&self) -> eth2_client::storage::StorageApi {
            eth2_client::storage::StorageApi
        }
    }
    pub struct TransactionApi;
    impl TransactionApi {
        pub fn system(&self) -> system::calls::TransactionApi {
            system::calls::TransactionApi
        }
        pub fn timestamp(&self) -> timestamp::calls::TransactionApi {
            timestamp::calls::TransactionApi
        }
        pub fn sudo(&self) -> sudo::calls::TransactionApi {
            sudo::calls::TransactionApi
        }
        pub fn balances(&self) -> balances::calls::TransactionApi {
            balances::calls::TransactionApi
        }
        pub fn grandpa(&self) -> grandpa::calls::TransactionApi {
            grandpa::calls::TransactionApi
        }
        pub fn dkg(&self) -> dkg::calls::TransactionApi {
            dkg::calls::TransactionApi
        }
        pub fn dkg_proposals(&self) -> dkg_proposals::calls::TransactionApi {
            dkg_proposals::calls::TransactionApi
        }
        pub fn dkg_proposal_handler(
            &self,
        ) -> dkg_proposal_handler::calls::TransactionApi {
            dkg_proposal_handler::calls::TransactionApi
        }
        pub fn bridge_registry(&self) -> bridge_registry::calls::TransactionApi {
            bridge_registry::calls::TransactionApi
        }
        pub fn indices(&self) -> indices::calls::TransactionApi {
            indices::calls::TransactionApi
        }
        pub fn democracy(&self) -> democracy::calls::TransactionApi {
            democracy::calls::TransactionApi
        }
        pub fn council(&self) -> council::calls::TransactionApi {
            council::calls::TransactionApi
        }
        pub fn vesting(&self) -> vesting::calls::TransactionApi {
            vesting::calls::TransactionApi
        }
        pub fn claims(&self) -> claims::calls::TransactionApi {
            claims::calls::TransactionApi
        }
        pub fn elections(&self) -> elections::calls::TransactionApi {
            elections::calls::TransactionApi
        }
        pub fn election_provider_multi_phase(
            &self,
        ) -> election_provider_multi_phase::calls::TransactionApi {
            election_provider_multi_phase::calls::TransactionApi
        }
        pub fn staking(&self) -> staking::calls::TransactionApi {
            staking::calls::TransactionApi
        }
        pub fn session(&self) -> session::calls::TransactionApi {
            session::calls::TransactionApi
        }
        pub fn treasury(&self) -> treasury::calls::TransactionApi {
            treasury::calls::TransactionApi
        }
        pub fn bounties(&self) -> bounties::calls::TransactionApi {
            bounties::calls::TransactionApi
        }
        pub fn child_bounties(&self) -> child_bounties::calls::TransactionApi {
            child_bounties::calls::TransactionApi
        }
        pub fn bags_list(&self) -> bags_list::calls::TransactionApi {
            bags_list::calls::TransactionApi
        }
        pub fn nomination_pools(&self) -> nomination_pools::calls::TransactionApi {
            nomination_pools::calls::TransactionApi
        }
        pub fn scheduler(&self) -> scheduler::calls::TransactionApi {
            scheduler::calls::TransactionApi
        }
        pub fn preimage(&self) -> preimage::calls::TransactionApi {
            preimage::calls::TransactionApi
        }
        pub fn transaction_pause(&self) -> transaction_pause::calls::TransactionApi {
            transaction_pause::calls::TransactionApi
        }
        pub fn im_online(&self) -> im_online::calls::TransactionApi {
            im_online::calls::TransactionApi
        }
        pub fn identity(&self) -> identity::calls::TransactionApi {
            identity::calls::TransactionApi
        }
        pub fn utility(&self) -> utility::calls::TransactionApi {
            utility::calls::TransactionApi
        }
        pub fn ethereum(&self) -> ethereum::calls::TransactionApi {
            ethereum::calls::TransactionApi
        }
        pub fn evm(&self) -> evm::calls::TransactionApi {
            evm::calls::TransactionApi
        }
        pub fn dynamic_fee(&self) -> dynamic_fee::calls::TransactionApi {
            dynamic_fee::calls::TransactionApi
        }
        pub fn base_fee(&self) -> base_fee::calls::TransactionApi {
            base_fee::calls::TransactionApi
        }
        pub fn hotfix_sufficients(&self) -> hotfix_sufficients::calls::TransactionApi {
            hotfix_sufficients::calls::TransactionApi
        }
        pub fn eth2_client(&self) -> eth2_client::calls::TransactionApi {
            eth2_client::calls::TransactionApi
        }
    }
    /// check whether the Client you are using is aligned with the statically generated codegen.
    pub fn validate_codegen<T: ::subxt::Config, C: ::subxt::client::OfflineClientT<T>>(
        client: &C,
    ) -> Result<(), ::subxt::error::MetadataError> {
        let runtime_metadata_hash = client
            .metadata()
            .hasher()
            .only_these_pallets(&PALLETS)
            .hash();
        if runtime_metadata_hash
            != [
                55u8,
                103u8,
                74u8,
                189u8,
                219u8,
                176u8,
                77u8,
                118u8,
                125u8,
                31u8,
                15u8,
                246u8,
                178u8,
                184u8,
                169u8,
                62u8,
                187u8,
                13u8,
                124u8,
                47u8,
                188u8,
                208u8,
                164u8,
                48u8,
                242u8,
                146u8,
                42u8,
                75u8,
                47u8,
                59u8,
                215u8,
                157u8,
            ]
        {
            Err(::subxt::error::MetadataError::IncompatibleCodegen)
        } else {
            Ok(())
        }
    }
    pub mod system {
        use super::root_mod;
        use super::runtime_types;
        ///Error for the System pallet
        pub type Error = runtime_types::frame_system::pallet::Error;
        ///Contains one variant per dispatchable that can be called by an extrinsic.
        pub type Call = runtime_types::frame_system::pallet::Call;
        pub mod calls {
            use super::root_mod;
            use super::runtime_types;
            type DispatchError = runtime_types::sp_runtime::DispatchError;
            pub mod types {
                use super::runtime_types;
                #[derive(
                    ::subxt::ext::codec::Decode,
                    ::subxt::ext::codec::Encode,
                    ::subxt::ext::scale_decode::DecodeAsType,
                    ::subxt::ext::scale_encode::EncodeAsType,
                    Clone,
                    Debug,
                    Eq,
                    PartialEq
                )]
                #[codec(crate = ::subxt::ext::codec)]
                #[decode_as_type(crate_path = ":: subxt :: ext :: scale_decode")]
                #[encode_as_type(crate_path = ":: subxt :: ext :: scale_encode")]
                pub struct Remark {
                    pub remark: ::std::vec::Vec<::core::primitive::u8>,
                }
                impl ::subxt::blocks::StaticExtrinsic for Remark {
                    const PALLET: &'static str = "System";
                    const CALL: &'static str = "remark";
                }
                #[derive(
                    ::subxt::ext::codec::CompactAs,
                    ::subxt::ext::codec::Decode,
                    ::subxt::ext::codec::Encode,
                    ::subxt::ext::scale_decode::DecodeAsType,
                    ::subxt::ext::scale_encode::EncodeAsType,
                    Clone,
                    Debug,
                    Eq,
                    PartialEq
                )]
                #[codec(crate = ::subxt::ext::codec)]
                #[decode_as_type(crate_path = ":: subxt :: ext :: scale_decode")]
                #[encode_as_type(crate_path = ":: subxt :: ext :: scale_encode")]
                pub struct SetHeapPages {
                    pub pages: ::core::primitive::u64,
                }
                impl ::subxt::blocks::StaticExtrinsic for SetHeapPages {
                    const PALLET: &'static str = "System";
                    const CALL: &'static str = "set_heap_pages";
                }
                #[derive(
                    ::subxt::ext::codec::Decode,
                    ::subxt::ext::codec::Encode,
                    ::subxt::ext::scale_decode::DecodeAsType,
                    ::subxt::ext::scale_encode::EncodeAsType,
                    Clone,
                    Debug,
                    Eq,
                    PartialEq
                )]
                #[codec(crate = ::subxt::ext::codec)]
                #[decode_as_type(crate_path = ":: subxt :: ext :: scale_decode")]
                #[encode_as_type(crate_path = ":: subxt :: ext :: scale_encode")]
                pub struct SetCode {
                    pub code: ::std::vec::Vec<::core::primitive::u8>,
                }
                impl ::subxt::blocks::StaticExtrinsic for SetCode {
                    const PALLET: &'static str = "System";
                    const CALL: &'static str = "set_code";
                }
                #[derive(
                    ::subxt::ext::codec::Decode,
                    ::subxt::ext::codec::Encode,
                    ::subxt::ext::scale_decode::DecodeAsType,
                    ::subxt::ext::scale_encode::EncodeAsType,
                    Clone,
                    Debug,
                    Eq,
                    PartialEq
                )]
                #[codec(crate = ::subxt::ext::codec)]
                #[decode_as_type(crate_path = ":: subxt :: ext :: scale_decode")]
                #[encode_as_type(crate_path = ":: subxt :: ext :: scale_encode")]
                pub struct SetCodeWithoutChecks {
                    pub code: ::std::vec::Vec<::core::primitive::u8>,
                }
                impl ::subxt::blocks::StaticExtrinsic for SetCodeWithoutChecks {
                    const PALLET: &'static str = "System";
                    const CALL: &'static str = "set_code_without_checks";
                }
                #[derive(
                    ::subxt::ext::codec::Decode,
                    ::subxt::ext::codec::Encode,
                    ::subxt::ext::scale_decode::DecodeAsType,
                    ::subxt::ext::scale_encode::EncodeAsType,
                    Clone,
                    Debug,
                    Eq,
                    PartialEq
                )]
                #[codec(crate = ::subxt::ext::codec)]
                #[decode_as_type(crate_path = ":: subxt :: ext :: scale_decode")]
                #[encode_as_type(crate_path = ":: subxt :: ext :: scale_encode")]
                pub struct SetStorage {
                    pub items: ::std::vec::Vec<
                        (
                            ::std::vec::Vec<::core::primitive::u8>,
                            ::std::vec::Vec<::core::primitive::u8>,
                        ),
                    >,
                }
                impl ::subxt::blocks::StaticExtrinsic for SetStorage {
                    const PALLET: &'static str = "System";
                    const CALL: &'static str = "set_storage";
                }
                #[derive(
                    ::subxt::ext::codec::Decode,
                    ::subxt::ext::codec::Encode,
                    ::subxt::ext::scale_decode::DecodeAsType,
                    ::subxt::ext::scale_encode::EncodeAsType,
                    Clone,
                    Debug,
                    Eq,
                    PartialEq
                )]
                #[codec(crate = ::subxt::ext::codec)]
                #[decode_as_type(crate_path = ":: subxt :: ext :: scale_decode")]
                #[encode_as_type(crate_path = ":: subxt :: ext :: scale_encode")]
                pub struct KillStorage {
                    pub keys: ::std::vec::Vec<::std::vec::Vec<::core::primitive::u8>>,
                }
                impl ::subxt::blocks::StaticExtrinsic for KillStorage {
                    const PALLET: &'static str = "System";
                    const CALL: &'static str = "kill_storage";
                }
                #[derive(
                    ::subxt::ext::codec::Decode,
                    ::subxt::ext::codec::Encode,
                    ::subxt::ext::scale_decode::DecodeAsType,
                    ::subxt::ext::scale_encode::EncodeAsType,
                    Clone,
                    Debug,
                    Eq,
                    PartialEq
                )]
                #[codec(crate = ::subxt::ext::codec)]
                #[decode_as_type(crate_path = ":: subxt :: ext :: scale_decode")]
                #[encode_as_type(crate_path = ":: subxt :: ext :: scale_encode")]
                pub struct KillPrefix {
                    pub prefix: ::std::vec::Vec<::core::primitive::u8>,
                    pub subkeys: ::core::primitive::u32,
                }
                impl ::subxt::blocks::StaticExtrinsic for KillPrefix {
                    const PALLET: &'static str = "System";
                    const CALL: &'static str = "kill_prefix";
                }
                #[derive(
                    ::subxt::ext::codec::Decode,
                    ::subxt::ext::codec::Encode,
                    ::subxt::ext::scale_decode::DecodeAsType,
                    ::subxt::ext::scale_encode::EncodeAsType,
                    Clone,
                    Debug,
                    Eq,
                    PartialEq
                )]
                #[codec(crate = ::subxt::ext::codec)]
                #[decode_as_type(crate_path = ":: subxt :: ext :: scale_decode")]
                #[encode_as_type(crate_path = ":: subxt :: ext :: scale_encode")]
                pub struct RemarkWithEvent {
                    pub remark: ::std::vec::Vec<::core::primitive::u8>,
                }
                impl ::subxt::blocks::StaticExtrinsic for RemarkWithEvent {
                    const PALLET: &'static str = "System";
                    const CALL: &'static str = "remark_with_event";
                }
            }
            pub struct TransactionApi;
            impl TransactionApi {
                ///Make some on-chain remark.
                ///
                ///- `O(1)`
                pub fn remark(
                    &self,
                    remark: ::std::vec::Vec<::core::primitive::u8>,
                ) -> ::subxt::tx::Payload<types::Remark> {
                    ::subxt::tx::Payload::new_static(
                        "System",
                        "remark",
                        types::Remark { remark },
                        [
                            43u8,
                            126u8,
                            180u8,
                            174u8,
                            141u8,
                            48u8,
                            52u8,
                            125u8,
                            166u8,
                            212u8,
                            216u8,
                            98u8,
                            100u8,
                            24u8,
                            132u8,
                            71u8,
                            101u8,
                            64u8,
                            246u8,
                            169u8,
                            33u8,
                            250u8,
                            147u8,
                            208u8,
                            2u8,
                            40u8,
                            129u8,
                            209u8,
                            232u8,
                            207u8,
                            207u8,
                            13u8,
                        ],
                    )
                }
                ///Set the number of pages in the WebAssembly environment's heap.
                pub fn set_heap_pages(
                    &self,
                    pages: ::core::primitive::u64,
                ) -> ::subxt::tx::Payload<types::SetHeapPages> {
                    ::subxt::tx::Payload::new_static(
                        "System",
                        "set_heap_pages",
                        types::SetHeapPages { pages },
                        [
                            188u8,
                            191u8,
                            99u8,
                            216u8,
                            219u8,
                            109u8,
                            141u8,
                            50u8,
                            78u8,
                            235u8,
                            215u8,
                            242u8,
                            195u8,
                            24u8,
                            111u8,
                            76u8,
                            229u8,
                            64u8,
                            99u8,
                            225u8,
                            134u8,
                            121u8,
                            81u8,
                            209u8,
                            127u8,
                            223u8,
                            98u8,
                            215u8,
                            150u8,
                            70u8,
                            57u8,
                            147u8,
                        ],
                    )
                }
                ///Set the new runtime code.
                pub fn set_code(
                    &self,
                    code: ::std::vec::Vec<::core::primitive::u8>,
                ) -> ::subxt::tx::Payload<types::SetCode> {
                    ::subxt::tx::Payload::new_static(
                        "System",
                        "set_code",
                        types::SetCode { code },
                        [
                            233u8,
                            248u8,
                            88u8,
                            245u8,
                            28u8,
                            65u8,
                            25u8,
                            169u8,
                            35u8,
                            237u8,
                            19u8,
                            203u8,
                            136u8,
                            160u8,
                            18u8,
                            3u8,
                            20u8,
                            197u8,
                            81u8,
                            169u8,
                            244u8,
                            188u8,
                            27u8,
                            147u8,
                            147u8,
                            236u8,
                            65u8,
                            25u8,
                            3u8,
                            143u8,
                            182u8,
                            22u8,
                        ],
                    )
                }
                ///Set the new runtime code without doing any checks of the given `code`.
                pub fn set_code_without_checks(
                    &self,
                    code: ::std::vec::Vec<::core::primitive::u8>,
                ) -> ::subxt::tx::Payload<types::SetCodeWithoutChecks> {
                    ::subxt::tx::Payload::new_static(
                        "System",
                        "set_code_without_checks",
                        types::SetCodeWithoutChecks {
                            code,
                        },
                        [
                            82u8,
                            212u8,
                            157u8,
                            44u8,
                            70u8,
                            0u8,
                            143u8,
                            15u8,
                            109u8,
                            109u8,
                            107u8,
                            157u8,
                            141u8,
                            42u8,
                            169u8,
                            11u8,
                            15u8,
                            186u8,
                            252u8,
                            138u8,
                            10u8,
                            147u8,
                            15u8,
                            178u8,
                            247u8,
                            229u8,
                            213u8,
                            98u8,
                            207u8,
                            231u8,
                            119u8,
                            115u8,
                        ],
                    )
                }
                ///Set some items of storage.
                pub fn set_storage(
                    &self,
                    items: ::std::vec::Vec<
                        (
                            ::std::vec::Vec<::core::primitive::u8>,
                            ::std::vec::Vec<::core::primitive::u8>,
                        ),
                    >,
                ) -> ::subxt::tx::Payload<types::SetStorage> {
                    ::subxt::tx::Payload::new_static(
                        "System",
                        "set_storage",
                        types::SetStorage { items },
                        [
                            184u8,
                            169u8,
                            248u8,
                            68u8,
                            40u8,
                            193u8,
                            190u8,
                            151u8,
                            96u8,
                            159u8,
                            19u8,
                            237u8,
                            241u8,
                            156u8,
                            5u8,
                            158u8,
                            191u8,
                            237u8,
                            9u8,
                            13u8,
                            86u8,
                            213u8,
                            77u8,
                            58u8,
                            48u8,
                            139u8,
                            1u8,
                            85u8,
                            220u8,
                            233u8,
                            139u8,
                            164u8,
                        ],
                    )
                }
                ///Kill some items from storage.
                pub fn kill_storage(
                    &self,
                    keys: ::std::vec::Vec<::std::vec::Vec<::core::primitive::u8>>,
                ) -> ::subxt::tx::Payload<types::KillStorage> {
                    ::subxt::tx::Payload::new_static(
                        "System",
                        "kill_storage",
                        types::KillStorage { keys },
                        [
                            73u8,
                            63u8,
                            196u8,
                            36u8,
                            144u8,
                            114u8,
                            34u8,
                            213u8,
                            108u8,
                            93u8,
                            209u8,
                            234u8,
                            153u8,
                            185u8,
                            33u8,
                            91u8,
                            187u8,
                            195u8,
                            223u8,
                            130u8,
                            58u8,
                            156u8,
                            63u8,
                            47u8,
                            228u8,
                            249u8,
                            216u8,
                            139u8,
                            143u8,
                            177u8,
                            41u8,
                            35u8,
                        ],
                    )
                }
                ///Kill all storage items with a key that starts with the given prefix.
                ///
                ///**NOTE:** We rely on the Root origin to provide us the number of subkeys under
                ///the prefix we are removing to accurately calculate the weight of this function.
                pub fn kill_prefix(
                    &self,
                    prefix: ::std::vec::Vec<::core::primitive::u8>,
                    subkeys: ::core::primitive::u32,
                ) -> ::subxt::tx::Payload<types::KillPrefix> {
                    ::subxt::tx::Payload::new_static(
                        "System",
                        "kill_prefix",
                        types::KillPrefix {
                            prefix,
                            subkeys,
                        },
                        [
                            184u8,
                            57u8,
                            139u8,
                            24u8,
                            208u8,
                            87u8,
                            108u8,
                            215u8,
                            198u8,
                            189u8,
                            175u8,
                            242u8,
                            167u8,
                            215u8,
                            97u8,
                            63u8,
                            110u8,
                            166u8,
                            238u8,
                            98u8,
                            67u8,
                            236u8,
                            111u8,
                            110u8,
                            234u8,
                            81u8,
                            102u8,
                            5u8,
                            182u8,
                            5u8,
                            214u8,
                            85u8,
                        ],
                    )
                }
                ///Make some on-chain remark and emit event.
                pub fn remark_with_event(
                    &self,
                    remark: ::std::vec::Vec<::core::primitive::u8>,
                ) -> ::subxt::tx::Payload<types::RemarkWithEvent> {
                    ::subxt::tx::Payload::new_static(
                        "System",
                        "remark_with_event",
                        types::RemarkWithEvent { remark },
                        [
                            120u8,
                            120u8,
                            153u8,
                            92u8,
                            184u8,
                            85u8,
                            34u8,
                            2u8,
                            174u8,
                            206u8,
                            105u8,
                            228u8,
                            233u8,
                            130u8,
                            80u8,
                            246u8,
                            228u8,
                            59u8,
                            234u8,
                            240u8,
                            4u8,
                            49u8,
                            147u8,
                            170u8,
                            115u8,
                            91u8,
                            149u8,
                            200u8,
                            228u8,
                            181u8,
                            8u8,
                            154u8,
                        ],
                    )
                }
            }
        }
        ///Event for the System pallet.
        pub type Event = runtime_types::frame_system::pallet::Event;
        pub mod events {
            use super::runtime_types;
            #[derive(
                ::subxt::ext::codec::Decode,
                ::subxt::ext::codec::Encode,
                ::subxt::ext::scale_decode::DecodeAsType,
                ::subxt::ext::scale_encode::EncodeAsType,
                Clone,
                Debug,
                Eq,
                PartialEq
            )]
            #[codec(crate = ::subxt::ext::codec)]
            #[decode_as_type(crate_path = ":: subxt :: ext :: scale_decode")]
            #[encode_as_type(crate_path = ":: subxt :: ext :: scale_encode")]
            ///An extrinsic completed successfully.
            pub struct ExtrinsicSuccess {
                pub dispatch_info: runtime_types::frame_support::dispatch::DispatchInfo,
            }
            impl ::subxt::events::StaticEvent for ExtrinsicSuccess {
                const PALLET: &'static str = "System";
                const EVENT: &'static str = "ExtrinsicSuccess";
            }
            #[derive(
                ::subxt::ext::codec::Decode,
                ::subxt::ext::codec::Encode,
                ::subxt::ext::scale_decode::DecodeAsType,
                ::subxt::ext::scale_encode::EncodeAsType,
                Clone,
                Debug,
                Eq,
                PartialEq
            )]
            #[codec(crate = ::subxt::ext::codec)]
            #[decode_as_type(crate_path = ":: subxt :: ext :: scale_decode")]
            #[encode_as_type(crate_path = ":: subxt :: ext :: scale_encode")]
            ///An extrinsic failed.
            pub struct ExtrinsicFailed {
                pub dispatch_error: runtime_types::sp_runtime::DispatchError,
                pub dispatch_info: runtime_types::frame_support::dispatch::DispatchInfo,
            }
            impl ::subxt::events::StaticEvent for ExtrinsicFailed {
                const PALLET: &'static str = "System";
                const EVENT: &'static str = "ExtrinsicFailed";
            }
            #[derive(
                ::subxt::ext::codec::Decode,
                ::subxt::ext::codec::Encode,
                ::subxt::ext::scale_decode::DecodeAsType,
                ::subxt::ext::scale_encode::EncodeAsType,
                Clone,
                Debug,
                Eq,
                PartialEq
            )]
            #[codec(crate = ::subxt::ext::codec)]
            #[decode_as_type(crate_path = ":: subxt :: ext :: scale_decode")]
            #[encode_as_type(crate_path = ":: subxt :: ext :: scale_encode")]
            ///`:code` was updated.
            pub struct CodeUpdated;
            impl ::subxt::events::StaticEvent for CodeUpdated {
                const PALLET: &'static str = "System";
                const EVENT: &'static str = "CodeUpdated";
            }
            #[derive(
                ::subxt::ext::codec::Decode,
                ::subxt::ext::codec::Encode,
                ::subxt::ext::scale_decode::DecodeAsType,
                ::subxt::ext::scale_encode::EncodeAsType,
                Clone,
                Debug,
                Eq,
                PartialEq
            )]
            #[codec(crate = ::subxt::ext::codec)]
            #[decode_as_type(crate_path = ":: subxt :: ext :: scale_decode")]
            #[encode_as_type(crate_path = ":: subxt :: ext :: scale_encode")]
            ///A new account was created.
            pub struct NewAccount {
                pub account: ::subxt::utils::AccountId32,
            }
            impl ::subxt::events::StaticEvent for NewAccount {
                const PALLET: &'static str = "System";
                const EVENT: &'static str = "NewAccount";
            }
            #[derive(
                ::subxt::ext::codec::Decode,
                ::subxt::ext::codec::Encode,
                ::subxt::ext::scale_decode::DecodeAsType,
                ::subxt::ext::scale_encode::EncodeAsType,
                Clone,
                Debug,
                Eq,
                PartialEq
            )]
            #[codec(crate = ::subxt::ext::codec)]
            #[decode_as_type(crate_path = ":: subxt :: ext :: scale_decode")]
            #[encode_as_type(crate_path = ":: subxt :: ext :: scale_encode")]
            ///An account was reaped.
            pub struct KilledAccount {
                pub account: ::subxt::utils::AccountId32,
            }
            impl ::subxt::events::StaticEvent for KilledAccount {
                const PALLET: &'static str = "System";
                const EVENT: &'static str = "KilledAccount";
            }
            #[derive(
                ::subxt::ext::codec::Decode,
                ::subxt::ext::codec::Encode,
                ::subxt::ext::scale_decode::DecodeAsType,
                ::subxt::ext::scale_encode::EncodeAsType,
                Clone,
                Debug,
                Eq,
                PartialEq
            )]
            #[codec(crate = ::subxt::ext::codec)]
            #[decode_as_type(crate_path = ":: subxt :: ext :: scale_decode")]
            #[encode_as_type(crate_path = ":: subxt :: ext :: scale_encode")]
            ///On on-chain remark happened.
            pub struct Remarked {
                pub sender: ::subxt::utils::AccountId32,
                pub hash: ::subxt::utils::H256,
            }
            impl ::subxt::events::StaticEvent for Remarked {
                const PALLET: &'static str = "System";
                const EVENT: &'static str = "Remarked";
            }
        }
        pub mod storage {
            use super::runtime_types;
            pub struct StorageApi;
            impl StorageApi {
                /// The full account information for a particular account ID.
                pub fn account(
                    &self,
                    _0: impl ::std::borrow::Borrow<::subxt::utils::AccountId32>,
                ) -> ::subxt::storage::address::Address<
                    ::subxt::storage::address::StaticStorageMapKey,
                    runtime_types::frame_system::AccountInfo<
                        ::core::primitive::u32,
                        runtime_types::pallet_balances::types::AccountData<
                            ::core::primitive::u128,
                        >,
                    >,
                    ::subxt::storage::address::Yes,
                    ::subxt::storage::address::Yes,
                    ::subxt::storage::address::Yes,
                > {
                    ::subxt::storage::address::Address::new_static(
                        "System",
                        "Account",
                        vec![
                            ::subxt::storage::address::make_static_storage_map_key(_0
                            .borrow())
                        ],
                        [
                            234u8,
                            12u8,
                            167u8,
                            96u8,
                            2u8,
                            244u8,
                            235u8,
                            62u8,
                            153u8,
                            200u8,
                            96u8,
                            74u8,
                            135u8,
                            8u8,
                            35u8,
                            188u8,
                            146u8,
                            249u8,
                            246u8,
                            40u8,
                            224u8,
                            22u8,
                            15u8,
                            99u8,
                            150u8,
                            222u8,
                            82u8,
                            85u8,
                            123u8,
                            123u8,
                            19u8,
                            110u8,
                        ],
                    )
                }
                /// The full account information for a particular account ID.
                pub fn account_root(
                    &self,
                ) -> ::subxt::storage::address::Address<
                    ::subxt::storage::address::StaticStorageMapKey,
                    runtime_types::frame_system::AccountInfo<
                        ::core::primitive::u32,
                        runtime_types::pallet_balances::types::AccountData<
                            ::core::primitive::u128,
                        >,
                    >,
                    (),
                    ::subxt::storage::address::Yes,
                    ::subxt::storage::address::Yes,
                > {
                    ::subxt::storage::address::Address::new_static(
                        "System",
                        "Account",
                        Vec::new(),
                        [
                            234u8,
                            12u8,
                            167u8,
                            96u8,
                            2u8,
                            244u8,
                            235u8,
                            62u8,
                            153u8,
                            200u8,
                            96u8,
                            74u8,
                            135u8,
                            8u8,
                            35u8,
                            188u8,
                            146u8,
                            249u8,
                            246u8,
                            40u8,
                            224u8,
                            22u8,
                            15u8,
                            99u8,
                            150u8,
                            222u8,
                            82u8,
                            85u8,
                            123u8,
                            123u8,
                            19u8,
                            110u8,
                        ],
                    )
                }
                /// Total extrinsics count for the current block.
                pub fn extrinsic_count(
                    &self,
                ) -> ::subxt::storage::address::Address<
                    ::subxt::storage::address::StaticStorageMapKey,
                    ::core::primitive::u32,
                    ::subxt::storage::address::Yes,
                    (),
                    (),
                > {
                    ::subxt::storage::address::Address::new_static(
                        "System",
                        "ExtrinsicCount",
                        vec![],
                        [
                            102u8,
                            76u8,
                            236u8,
                            42u8,
                            40u8,
                            231u8,
                            33u8,
                            222u8,
                            123u8,
                            147u8,
                            153u8,
                            148u8,
                            234u8,
                            203u8,
                            181u8,
                            119u8,
                            6u8,
                            187u8,
                            177u8,
                            199u8,
                            120u8,
                            47u8,
                            137u8,
                            254u8,
                            96u8,
                            100u8,
                            165u8,
                            182u8,
                            249u8,
                            230u8,
                            159u8,
                            79u8,
                        ],
                    )
                }
                /// The current weight for the block.
                pub fn block_weight(
                    &self,
                ) -> ::subxt::storage::address::Address<
                    ::subxt::storage::address::StaticStorageMapKey,
                    runtime_types::frame_support::dispatch::PerDispatchClass<
                        runtime_types::sp_weights::weight_v2::Weight,
                    >,
                    ::subxt::storage::address::Yes,
                    ::subxt::storage::address::Yes,
                    (),
                > {
                    ::subxt::storage::address::Address::new_static(
                        "System",
                        "BlockWeight",
                        vec![],
                        [
                            52u8,
                            191u8,
                            212u8,
                            137u8,
                            26u8,
                            39u8,
                            239u8,
                            35u8,
                            182u8,
                            32u8,
                            39u8,
                            103u8,
                            56u8,
                            184u8,
                            60u8,
                            159u8,
                            167u8,
                            232u8,
                            193u8,
                            116u8,
                            105u8,
                            56u8,
                            98u8,
                            127u8,
                            124u8,
                            188u8,
                            214u8,
                            154u8,
                            160u8,
                            41u8,
                            20u8,
                            162u8,
                        ],
                    )
                }
                /// Total length (in bytes) for all extrinsics put together, for the current block.
                pub fn all_extrinsics_len(
                    &self,
                ) -> ::subxt::storage::address::Address<
                    ::subxt::storage::address::StaticStorageMapKey,
                    ::core::primitive::u32,
                    ::subxt::storage::address::Yes,
                    (),
                    (),
                > {
                    ::subxt::storage::address::Address::new_static(
                        "System",
                        "AllExtrinsicsLen",
                        vec![],
                        [
                            117u8,
                            86u8,
                            61u8,
                            243u8,
                            41u8,
                            51u8,
                            102u8,
                            214u8,
                            137u8,
                            100u8,
                            243u8,
                            185u8,
                            122u8,
                            174u8,
                            187u8,
                            117u8,
                            86u8,
                            189u8,
                            63u8,
                            135u8,
                            101u8,
                            218u8,
                            203u8,
                            201u8,
                            237u8,
                            254u8,
                            128u8,
                            183u8,
                            169u8,
                            221u8,
                            242u8,
                            65u8,
                        ],
                    )
                }
                /// Map of block numbers to block hashes.
                pub fn block_hash(
                    &self,
                    _0: impl ::std::borrow::Borrow<::core::primitive::u32>,
                ) -> ::subxt::storage::address::Address<
                    ::subxt::storage::address::StaticStorageMapKey,
                    ::subxt::utils::H256,
                    ::subxt::storage::address::Yes,
                    ::subxt::storage::address::Yes,
                    ::subxt::storage::address::Yes,
                > {
                    ::subxt::storage::address::Address::new_static(
                        "System",
                        "BlockHash",
                        vec![
                            ::subxt::storage::address::make_static_storage_map_key(_0
                            .borrow())
                        ],
                        [
                            217u8,
                            32u8,
                            215u8,
                            253u8,
                            24u8,
                            182u8,
                            207u8,
                            178u8,
                            157u8,
                            24u8,
                            103u8,
                            100u8,
                            195u8,
                            165u8,
                            69u8,
                            152u8,
                            112u8,
                            181u8,
                            56u8,
                            192u8,
                            164u8,
                            16u8,
                            20u8,
                            222u8,
                            28u8,
                            214u8,
                            144u8,
                            142u8,
                            146u8,
                            69u8,
                            202u8,
                            118u8,
                        ],
                    )
                }
                /// Map of block numbers to block hashes.
                pub fn block_hash_root(
                    &self,
                ) -> ::subxt::storage::address::Address<
                    ::subxt::storage::address::StaticStorageMapKey,
                    ::subxt::utils::H256,
                    (),
                    ::subxt::storage::address::Yes,
                    ::subxt::storage::address::Yes,
                > {
                    ::subxt::storage::address::Address::new_static(
                        "System",
                        "BlockHash",
                        Vec::new(),
                        [
                            217u8,
                            32u8,
                            215u8,
                            253u8,
                            24u8,
                            182u8,
                            207u8,
                            178u8,
                            157u8,
                            24u8,
                            103u8,
                            100u8,
                            195u8,
                            165u8,
                            69u8,
                            152u8,
                            112u8,
                            181u8,
                            56u8,
                            192u8,
                            164u8,
                            16u8,
                            20u8,
                            222u8,
                            28u8,
                            214u8,
                            144u8,
                            142u8,
                            146u8,
                            69u8,
                            202u8,
                            118u8,
                        ],
                    )
                }
                /// Extrinsics data for the current block (maps an extrinsic's index to its data).
                pub fn extrinsic_data(
                    &self,
                    _0: impl ::std::borrow::Borrow<::core::primitive::u32>,
                ) -> ::subxt::storage::address::Address<
                    ::subxt::storage::address::StaticStorageMapKey,
                    ::std::vec::Vec<::core::primitive::u8>,
                    ::subxt::storage::address::Yes,
                    ::subxt::storage::address::Yes,
                    ::subxt::storage::address::Yes,
                > {
                    ::subxt::storage::address::Address::new_static(
                        "System",
                        "ExtrinsicData",
                        vec![
                            ::subxt::storage::address::make_static_storage_map_key(_0
                            .borrow())
                        ],
                        [
                            160u8,
                            180u8,
                            122u8,
                            18u8,
                            196u8,
                            26u8,
                            2u8,
                            37u8,
                            115u8,
                            232u8,
                            133u8,
                            220u8,
                            106u8,
                            245u8,
                            4u8,
                            129u8,
                            42u8,
                            84u8,
                            241u8,
                            45u8,
                            199u8,
                            179u8,
                            128u8,
                            61u8,
                            170u8,
                            137u8,
                            231u8,
                            156u8,
                            247u8,
                            57u8,
                            47u8,
                            38u8,
                        ],
                    )
                }
                /// Extrinsics data for the current block (maps an extrinsic's index to its data).
                pub fn extrinsic_data_root(
                    &self,
                ) -> ::subxt::storage::address::Address<
                    ::subxt::storage::address::StaticStorageMapKey,
                    ::std::vec::Vec<::core::primitive::u8>,
                    (),
                    ::subxt::storage::address::Yes,
                    ::subxt::storage::address::Yes,
                > {
                    ::subxt::storage::address::Address::new_static(
                        "System",
                        "ExtrinsicData",
                        Vec::new(),
                        [
                            160u8,
                            180u8,
                            122u8,
                            18u8,
                            196u8,
                            26u8,
                            2u8,
                            37u8,
                            115u8,
                            232u8,
                            133u8,
                            220u8,
                            106u8,
                            245u8,
                            4u8,
                            129u8,
                            42u8,
                            84u8,
                            241u8,
                            45u8,
                            199u8,
                            179u8,
                            128u8,
                            61u8,
                            170u8,
                            137u8,
                            231u8,
                            156u8,
                            247u8,
                            57u8,
                            47u8,
                            38u8,
                        ],
                    )
                }
                /// The current block number being processed. Set by `execute_block`.
                pub fn number(
                    &self,
                ) -> ::subxt::storage::address::Address<
                    ::subxt::storage::address::StaticStorageMapKey,
                    ::core::primitive::u32,
                    ::subxt::storage::address::Yes,
                    ::subxt::storage::address::Yes,
                    (),
                > {
                    ::subxt::storage::address::Address::new_static(
                        "System",
                        "Number",
                        vec![],
                        [
                            30u8,
                            194u8,
                            177u8,
                            90u8,
                            194u8,
                            232u8,
                            46u8,
                            180u8,
                            85u8,
                            129u8,
                            14u8,
                            9u8,
                            8u8,
                            8u8,
                            23u8,
                            95u8,
                            230u8,
                            5u8,
                            13u8,
                            105u8,
                            125u8,
                            2u8,
                            22u8,
                            200u8,
                            78u8,
                            93u8,
                            115u8,
                            28u8,
                            150u8,
                            113u8,
                            48u8,
                            53u8,
                        ],
                    )
                }
                /// Hash of the previous block.
                pub fn parent_hash(
                    &self,
                ) -> ::subxt::storage::address::Address<
                    ::subxt::storage::address::StaticStorageMapKey,
                    ::subxt::utils::H256,
                    ::subxt::storage::address::Yes,
                    ::subxt::storage::address::Yes,
                    (),
                > {
                    ::subxt::storage::address::Address::new_static(
                        "System",
                        "ParentHash",
                        vec![],
                        [
                            26u8,
                            130u8,
                            11u8,
                            216u8,
                            155u8,
                            71u8,
                            128u8,
                            170u8,
                            30u8,
                            153u8,
                            21u8,
                            192u8,
                            62u8,
                            93u8,
                            137u8,
                            80u8,
                            120u8,
                            81u8,
                            202u8,
                            94u8,
                            248u8,
                            125u8,
                            71u8,
                            82u8,
                            141u8,
                            229u8,
                            32u8,
                            56u8,
                            73u8,
                            50u8,
                            101u8,
                            78u8,
                        ],
                    )
                }
                /// Digest of the current block, also part of the block header.
                pub fn digest(
                    &self,
                ) -> ::subxt::storage::address::Address<
                    ::subxt::storage::address::StaticStorageMapKey,
                    runtime_types::sp_runtime::generic::digest::Digest,
                    ::subxt::storage::address::Yes,
                    ::subxt::storage::address::Yes,
                    (),
                > {
                    ::subxt::storage::address::Address::new_static(
                        "System",
                        "Digest",
                        vec![],
                        [
                            70u8,
                            156u8,
                            127u8,
                            89u8,
                            115u8,
                            250u8,
                            103u8,
                            62u8,
                            185u8,
                            153u8,
                            26u8,
                            72u8,
                            39u8,
                            226u8,
                            181u8,
                            97u8,
                            137u8,
                            225u8,
                            45u8,
                            158u8,
                            212u8,
                            254u8,
                            142u8,
                            136u8,
                            90u8,
                            22u8,
                            243u8,
                            125u8,
                            226u8,
                            49u8,
                            235u8,
                            215u8,
                        ],
                    )
                }
                /// Events deposited for the current block.
                ///
                /// NOTE: The item is unbound and should therefore never be read on chain.
                /// It could otherwise inflate the PoV size of a block.
                ///
                /// Events have a large in-memory size. Box the events to not go out-of-memory
                /// just in case someone still reads them from within the runtime.
                pub fn events(
                    &self,
                ) -> ::subxt::storage::address::Address<
                    ::subxt::storage::address::StaticStorageMapKey,
                    ::std::vec::Vec<
                        runtime_types::frame_system::EventRecord<
                            runtime_types::tangle_standalone_runtime::RuntimeEvent,
                            ::subxt::utils::H256,
                        >,
                    >,
                    ::subxt::storage::address::Yes,
                    ::subxt::storage::address::Yes,
                    (),
                > {
                    ::subxt::storage::address::Address::new_static(
                        "System",
                        "Events",
                        vec![],
                        [
                            17u8,
                            132u8,
                            208u8,
                            42u8,
                            131u8,
                            220u8,
                            75u8,
                            19u8,
                            44u8,
                            13u8,
                            120u8,
                            137u8,
                            194u8,
                            248u8,
                            174u8,
                            202u8,
                            129u8,
                            30u8,
                            1u8,
                            88u8,
                            25u8,
                            31u8,
                            34u8,
                            193u8,
                            1u8,
                            36u8,
                            89u8,
                            170u8,
                            227u8,
                            195u8,
                            227u8,
                            212u8,
                        ],
                    )
                }
                /// The number of events in the `Events<T>` list.
                pub fn event_count(
                    &self,
                ) -> ::subxt::storage::address::Address<
                    ::subxt::storage::address::StaticStorageMapKey,
                    ::core::primitive::u32,
                    ::subxt::storage::address::Yes,
                    ::subxt::storage::address::Yes,
                    (),
                > {
                    ::subxt::storage::address::Address::new_static(
                        "System",
                        "EventCount",
                        vec![],
                        [
                            175u8,
                            24u8,
                            252u8,
                            184u8,
                            210u8,
                            167u8,
                            146u8,
                            143u8,
                            164u8,
                            80u8,
                            151u8,
                            205u8,
                            189u8,
                            189u8,
                            55u8,
                            220u8,
                            47u8,
                            101u8,
                            181u8,
                            33u8,
                            254u8,
                            131u8,
                            13u8,
                            143u8,
                            3u8,
                            244u8,
                            245u8,
                            45u8,
                            2u8,
                            210u8,
                            79u8,
                            133u8,
                        ],
                    )
                }
                /// Mapping between a topic (represented by T::Hash) and a vector of indexes
                /// of events in the `<Events<T>>` list.
                ///
                /// All topic vectors have deterministic storage locations depending on the topic. This
                /// allows light-clients to leverage the changes trie storage tracking mechanism and
                /// in case of changes fetch the list of events of interest.
                ///
                /// The value has the type `(T::BlockNumber, EventIndex)` because if we used only just
                /// the `EventIndex` then in case if the topic has the same contents on the next block
                /// no notification will be triggered thus the event might be lost.
                pub fn event_topics(
                    &self,
                    _0: impl ::std::borrow::Borrow<::subxt::utils::H256>,
                ) -> ::subxt::storage::address::Address<
                    ::subxt::storage::address::StaticStorageMapKey,
                    ::std::vec::Vec<(::core::primitive::u32, ::core::primitive::u32)>,
                    ::subxt::storage::address::Yes,
                    ::subxt::storage::address::Yes,
                    ::subxt::storage::address::Yes,
                > {
                    ::subxt::storage::address::Address::new_static(
                        "System",
                        "EventTopics",
                        vec![
                            ::subxt::storage::address::make_static_storage_map_key(_0
                            .borrow())
                        ],
                        [
                            154u8,
                            29u8,
                            31u8,
                            148u8,
                            254u8,
                            7u8,
                            124u8,
                            251u8,
                            241u8,
                            77u8,
                            24u8,
                            37u8,
                            28u8,
                            75u8,
                            205u8,
                            17u8,
                            159u8,
                            79u8,
                            239u8,
                            62u8,
                            67u8,
                            60u8,
                            252u8,
                            112u8,
                            215u8,
                            145u8,
                            103u8,
                            170u8,
                            110u8,
                            186u8,
                            221u8,
                            76u8,
                        ],
                    )
                }
                /// Mapping between a topic (represented by T::Hash) and a vector of indexes
                /// of events in the `<Events<T>>` list.
                ///
                /// All topic vectors have deterministic storage locations depending on the topic. This
                /// allows light-clients to leverage the changes trie storage tracking mechanism and
                /// in case of changes fetch the list of events of interest.
                ///
                /// The value has the type `(T::BlockNumber, EventIndex)` because if we used only just
                /// the `EventIndex` then in case if the topic has the same contents on the next block
                /// no notification will be triggered thus the event might be lost.
                pub fn event_topics_root(
                    &self,
                ) -> ::subxt::storage::address::Address<
                    ::subxt::storage::address::StaticStorageMapKey,
                    ::std::vec::Vec<(::core::primitive::u32, ::core::primitive::u32)>,
                    (),
                    ::subxt::storage::address::Yes,
                    ::subxt::storage::address::Yes,
                > {
                    ::subxt::storage::address::Address::new_static(
                        "System",
                        "EventTopics",
                        Vec::new(),
                        [
                            154u8,
                            29u8,
                            31u8,
                            148u8,
                            254u8,
                            7u8,
                            124u8,
                            251u8,
                            241u8,
                            77u8,
                            24u8,
                            37u8,
                            28u8,
                            75u8,
                            205u8,
                            17u8,
                            159u8,
                            79u8,
                            239u8,
                            62u8,
                            67u8,
                            60u8,
                            252u8,
                            112u8,
                            215u8,
                            145u8,
                            103u8,
                            170u8,
                            110u8,
                            186u8,
                            221u8,
                            76u8,
                        ],
                    )
                }
                /// Stores the `spec_version` and `spec_name` of when the last runtime upgrade happened.
                pub fn last_runtime_upgrade(
                    &self,
                ) -> ::subxt::storage::address::Address<
                    ::subxt::storage::address::StaticStorageMapKey,
                    runtime_types::frame_system::LastRuntimeUpgradeInfo,
                    ::subxt::storage::address::Yes,
                    (),
                    (),
                > {
                    ::subxt::storage::address::Address::new_static(
                        "System",
                        "LastRuntimeUpgrade",
                        vec![],
                        [
                            137u8,
                            29u8,
                            175u8,
                            75u8,
                            197u8,
                            208u8,
                            91u8,
                            207u8,
                            156u8,
                            87u8,
                            148u8,
                            68u8,
                            91u8,
                            140u8,
                            22u8,
                            233u8,
                            1u8,
                            229u8,
                            56u8,
                            34u8,
                            40u8,
                            194u8,
                            253u8,
                            30u8,
                            163u8,
                            39u8,
                            54u8,
                            209u8,
                            13u8,
                            27u8,
                            139u8,
                            184u8,
                        ],
                    )
                }
                /// True if we have upgraded so that `type RefCount` is `u32`. False (default) if not.
                pub fn upgraded_to_u32_ref_count(
                    &self,
                ) -> ::subxt::storage::address::Address<
                    ::subxt::storage::address::StaticStorageMapKey,
                    ::core::primitive::bool,
                    ::subxt::storage::address::Yes,
                    ::subxt::storage::address::Yes,
                    (),
                > {
                    ::subxt::storage::address::Address::new_static(
                        "System",
                        "UpgradedToU32RefCount",
                        vec![],
                        [
                            229u8,
                            73u8,
                            9u8,
                            132u8,
                            186u8,
                            116u8,
                            151u8,
                            171u8,
                            145u8,
                            29u8,
                            34u8,
                            130u8,
                            52u8,
                            146u8,
                            124u8,
                            175u8,
                            79u8,
                            189u8,
                            147u8,
                            230u8,
                            234u8,
                            107u8,
                            124u8,
                            31u8,
                            2u8,
                            22u8,
                            86u8,
                            190u8,
                            4u8,
                            147u8,
                            50u8,
                            245u8,
                        ],
                    )
                }
                /// True if we have upgraded so that AccountInfo contains three types of `RefCount`. False
                /// (default) if not.
                pub fn upgraded_to_triple_ref_count(
                    &self,
                ) -> ::subxt::storage::address::Address<
                    ::subxt::storage::address::StaticStorageMapKey,
                    ::core::primitive::bool,
                    ::subxt::storage::address::Yes,
                    ::subxt::storage::address::Yes,
                    (),
                > {
                    ::subxt::storage::address::Address::new_static(
                        "System",
                        "UpgradedToTripleRefCount",
                        vec![],
                        [
                            97u8,
                            66u8,
                            124u8,
                            243u8,
                            27u8,
                            167u8,
                            147u8,
                            81u8,
                            254u8,
                            201u8,
                            101u8,
                            24u8,
                            40u8,
                            231u8,
                            14u8,
                            179u8,
                            154u8,
                            163u8,
                            71u8,
                            81u8,
                            185u8,
                            167u8,
                            82u8,
                            254u8,
                            189u8,
                            3u8,
                            101u8,
                            207u8,
                            206u8,
                            194u8,
                            155u8,
                            151u8,
                        ],
                    )
                }
                /// The execution phase of the block.
                pub fn execution_phase(
                    &self,
                ) -> ::subxt::storage::address::Address<
                    ::subxt::storage::address::StaticStorageMapKey,
                    runtime_types::frame_system::Phase,
                    ::subxt::storage::address::Yes,
                    (),
                    (),
                > {
                    ::subxt::storage::address::Address::new_static(
                        "System",
                        "ExecutionPhase",
                        vec![],
                        [
                            191u8,
                            129u8,
                            100u8,
                            134u8,
                            126u8,
                            116u8,
                            154u8,
                            203u8,
                            220u8,
                            200u8,
                            0u8,
                            26u8,
                            161u8,
                            250u8,
                            133u8,
                            205u8,
                            146u8,
                            24u8,
                            5u8,
                            156u8,
                            158u8,
                            35u8,
                            36u8,
                            253u8,
                            52u8,
                            235u8,
                            86u8,
                            167u8,
                            35u8,
                            100u8,
                            119u8,
                            27u8,
                        ],
                    )
                }
            }
        }
        pub mod constants {
            use super::runtime_types;
            pub struct ConstantsApi;
            impl ConstantsApi {
                /// Block & extrinsics weights: base values and limits.
                pub fn block_weights(
                    &self,
                ) -> ::subxt::constants::Address<
                    runtime_types::frame_system::limits::BlockWeights,
                > {
                    ::subxt::constants::Address::new_static(
                        "System",
                        "BlockWeights",
                        [
                            238u8,
                            20u8,
                            221u8,
                            11u8,
                            146u8,
                            236u8,
                            47u8,
                            103u8,
                            8u8,
                            239u8,
                            13u8,
                            176u8,
                            202u8,
                            10u8,
                            151u8,
                            68u8,
                            110u8,
                            162u8,
                            99u8,
                            40u8,
                            211u8,
                            136u8,
                            71u8,
                            82u8,
                            50u8,
                            80u8,
                            244u8,
                            211u8,
                            231u8,
                            198u8,
                            36u8,
                            152u8,
                        ],
                    )
                }
                /// The maximum length of a block (in bytes).
                pub fn block_length(
                    &self,
                ) -> ::subxt::constants::Address<
                    runtime_types::frame_system::limits::BlockLength,
                > {
                    ::subxt::constants::Address::new_static(
                        "System",
                        "BlockLength",
                        [
                            117u8,
                            144u8,
                            154u8,
                            125u8,
                            106u8,
                            34u8,
                            224u8,
                            228u8,
                            80u8,
                            76u8,
                            126u8,
                            0u8,
                            177u8,
                            223u8,
                            116u8,
                            244u8,
                            167u8,
                            23u8,
                            253u8,
                            44u8,
                            128u8,
                            116u8,
                            155u8,
                            245u8,
                            163u8,
                            20u8,
                            21u8,
                            222u8,
                            174u8,
                            237u8,
                            162u8,
                            240u8,
                        ],
                    )
                }
                /// Maximum number of block number to block hash mappings to keep (oldest pruned first).
                pub fn block_hash_count(
                    &self,
                ) -> ::subxt::constants::Address<::core::primitive::u32> {
                    ::subxt::constants::Address::new_static(
                        "System",
                        "BlockHashCount",
                        [
                            98u8,
                            252u8,
                            116u8,
                            72u8,
                            26u8,
                            180u8,
                            225u8,
                            83u8,
                            200u8,
                            157u8,
                            125u8,
                            151u8,
                            53u8,
                            76u8,
                            168u8,
                            26u8,
                            10u8,
                            9u8,
                            98u8,
                            68u8,
                            9u8,
                            178u8,
                            197u8,
                            113u8,
                            31u8,
                            79u8,
                            200u8,
                            90u8,
                            203u8,
                            100u8,
                            41u8,
                            145u8,
                        ],
                    )
                }
                /// The weight of runtime database operations the runtime can invoke.
                pub fn db_weight(
                    &self,
                ) -> ::subxt::constants::Address<
                    runtime_types::sp_weights::RuntimeDbWeight,
                > {
                    ::subxt::constants::Address::new_static(
                        "System",
                        "DbWeight",
                        [
                            206u8,
                            53u8,
                            134u8,
                            247u8,
                            42u8,
                            38u8,
                            197u8,
                            59u8,
                            191u8,
                            83u8,
                            160u8,
                            9u8,
                            207u8,
                            133u8,
                            108u8,
                            152u8,
                            150u8,
                            103u8,
                            109u8,
                            228u8,
                            218u8,
                            24u8,
                            27u8,
                            210u8,
                            106u8,
                            252u8,
                            74u8,
                            93u8,
                            27u8,
                            63u8,
                            109u8,
                            252u8,
                        ],
                    )
                }
                /// Get the chain's current version.
                pub fn version(
                    &self,
                ) -> ::subxt::constants::Address<
                    runtime_types::sp_version::RuntimeVersion,
                > {
                    ::subxt::constants::Address::new_static(
                        "System",
                        "Version",
                        [
                            134u8,
                            0u8,
                            23u8,
                            0u8,
                            199u8,
                            213u8,
                            89u8,
                            240u8,
                            194u8,
                            186u8,
                            239u8,
                            157u8,
                            168u8,
                            211u8,
                            223u8,
                            156u8,
                            138u8,
                            140u8,
                            194u8,
                            23u8,
                            167u8,
                            158u8,
                            195u8,
                            233u8,
                            25u8,
                            165u8,
                            27u8,
                            237u8,
                            198u8,
                            206u8,
                            233u8,
                            28u8,
                        ],
                    )
                }
                /// The designated SS58 prefix of this chain.
                ///
                /// This replaces the "ss58Format" property declared in the chain spec. Reason is
                /// that the runtime should know about the prefix in order to make use of it as
                /// an identifier of the chain.
                pub fn ss58_prefix(
                    &self,
                ) -> ::subxt::constants::Address<::core::primitive::u16> {
                    ::subxt::constants::Address::new_static(
                        "System",
                        "SS58Prefix",
                        [
                            116u8,
                            33u8,
                            2u8,
                            170u8,
                            181u8,
                            147u8,
                            171u8,
                            169u8,
                            167u8,
                            227u8,
                            41u8,
                            144u8,
                            11u8,
                            236u8,
                            82u8,
                            100u8,
                            74u8,
                            60u8,
                            184u8,
                            72u8,
                            169u8,
                            90u8,
                            208u8,
                            135u8,
                            15u8,
                            117u8,
                            10u8,
                            123u8,
                            128u8,
                            193u8,
                            29u8,
                            70u8,
                        ],
                    )
                }
            }
        }
    }
    pub mod timestamp {
        use super::root_mod;
        use super::runtime_types;
        ///Contains one variant per dispatchable that can be called by an extrinsic.
        pub type Call = runtime_types::pallet_timestamp::pallet::Call;
        pub mod calls {
            use super::root_mod;
            use super::runtime_types;
            type DispatchError = runtime_types::sp_runtime::DispatchError;
            pub mod types {
                use super::runtime_types;
                #[derive(
                    ::subxt::ext::codec::Decode,
                    ::subxt::ext::codec::Encode,
                    ::subxt::ext::scale_decode::DecodeAsType,
                    ::subxt::ext::scale_encode::EncodeAsType,
                    Clone,
                    Debug,
                    Eq,
                    PartialEq
                )]
                #[codec(crate = ::subxt::ext::codec)]
                #[decode_as_type(crate_path = ":: subxt :: ext :: scale_decode")]
                #[encode_as_type(crate_path = ":: subxt :: ext :: scale_encode")]
                pub struct Set {
                    #[codec(compact)]
                    pub now: ::core::primitive::u64,
                }
                impl ::subxt::blocks::StaticExtrinsic for Set {
                    const PALLET: &'static str = "Timestamp";
                    const CALL: &'static str = "set";
                }
            }
            pub struct TransactionApi;
            impl TransactionApi {
                ///Set the current time.
                ///
                ///This call should be invoked exactly once per block. It will panic at the finalization
                ///phase, if this call hasn't been invoked by that time.
                ///
                ///The timestamp should be greater than the previous one by the amount specified by
                ///`MinimumPeriod`.
                ///
                ///The dispatch origin for this call must be `Inherent`.
                ///
                ///## Complexity
                ///- `O(1)` (Note that implementations of `OnTimestampSet` must also be `O(1)`)
                ///- 1 storage read and 1 storage mutation (codec `O(1)`). (because of `DidUpdate::take` in
                ///  `on_finalize`)
                ///- 1 event handler `on_timestamp_set`. Must be `O(1)`.
                pub fn set(
                    &self,
                    now: ::core::primitive::u64,
                ) -> ::subxt::tx::Payload<types::Set> {
                    ::subxt::tx::Payload::new_static(
                        "Timestamp",
                        "set",
                        types::Set { now },
                        [
                            37u8,
                            95u8,
                            49u8,
                            218u8,
                            24u8,
                            22u8,
                            0u8,
                            95u8,
                            72u8,
                            35u8,
                            155u8,
                            199u8,
                            213u8,
                            54u8,
                            207u8,
                            22u8,
                            185u8,
                            193u8,
                            221u8,
                            70u8,
                            18u8,
                            200u8,
                            4u8,
                            231u8,
                            195u8,
                            173u8,
                            6u8,
                            122u8,
                            11u8,
                            203u8,
                            231u8,
                            227u8,
                        ],
                    )
                }
            }
        }
        pub mod storage {
            use super::runtime_types;
            pub struct StorageApi;
            impl StorageApi {
                /// Current time for the current block.
                pub fn now(
                    &self,
                ) -> ::subxt::storage::address::Address<
                    ::subxt::storage::address::StaticStorageMapKey,
                    ::core::primitive::u64,
                    ::subxt::storage::address::Yes,
                    ::subxt::storage::address::Yes,
                    (),
                > {
                    ::subxt::storage::address::Address::new_static(
                        "Timestamp",
                        "Now",
                        vec![],
                        [
                            44u8,
                            50u8,
                            80u8,
                            30u8,
                            195u8,
                            146u8,
                            123u8,
                            238u8,
                            8u8,
                            163u8,
                            187u8,
                            92u8,
                            61u8,
                            39u8,
                            51u8,
                            29u8,
                            173u8,
                            169u8,
                            217u8,
                            158u8,
                            85u8,
                            187u8,
                            141u8,
                            26u8,
                            12u8,
                            115u8,
                            51u8,
                            11u8,
                            200u8,
                            244u8,
                            138u8,
                            152u8,
                        ],
                    )
                }
                /// Did the timestamp get updated in this block?
                pub fn did_update(
                    &self,
                ) -> ::subxt::storage::address::Address<
                    ::subxt::storage::address::StaticStorageMapKey,
                    ::core::primitive::bool,
                    ::subxt::storage::address::Yes,
                    ::subxt::storage::address::Yes,
                    (),
                > {
                    ::subxt::storage::address::Address::new_static(
                        "Timestamp",
                        "DidUpdate",
                        vec![],
                        [
                            229u8,
                            175u8,
                            246u8,
                            102u8,
                            237u8,
                            158u8,
                            212u8,
                            229u8,
                            238u8,
                            214u8,
                            205u8,
                            160u8,
                            164u8,
                            252u8,
                            195u8,
                            75u8,
                            139u8,
                            110u8,
                            22u8,
                            34u8,
                            248u8,
                            204u8,
                            107u8,
                            46u8,
                            20u8,
                            200u8,
                            238u8,
                            167u8,
                            71u8,
                            41u8,
                            214u8,
                            140u8,
                        ],
                    )
                }
            }
        }
        pub mod constants {
            use super::runtime_types;
            pub struct ConstantsApi;
            impl ConstantsApi {
                /// The minimum period between blocks. Beware that this is different to the *expected*
                /// period that the block production apparatus provides. Your chosen consensus system will
                /// generally work with this to determine a sensible block time. e.g. For Aura, it will be
                /// double this period on default settings.
                pub fn minimum_period(
                    &self,
                ) -> ::subxt::constants::Address<::core::primitive::u64> {
                    ::subxt::constants::Address::new_static(
                        "Timestamp",
                        "MinimumPeriod",
                        [
                            128u8,
                            214u8,
                            205u8,
                            242u8,
                            181u8,
                            142u8,
                            124u8,
                            231u8,
                            190u8,
                            146u8,
                            59u8,
                            226u8,
                            157u8,
                            101u8,
                            103u8,
                            117u8,
                            249u8,
                            65u8,
                            18u8,
                            191u8,
                            103u8,
                            119u8,
                            53u8,
                            85u8,
                            81u8,
                            96u8,
                            220u8,
                            42u8,
                            184u8,
                            239u8,
                            42u8,
                            246u8,
                        ],
                    )
                }
            }
        }
    }
    pub mod sudo {
        use super::root_mod;
        use super::runtime_types;
        ///Error for the Sudo pallet
        pub type Error = runtime_types::pallet_sudo::pallet::Error;
        ///Contains one variant per dispatchable that can be called by an extrinsic.
        pub type Call = runtime_types::pallet_sudo::pallet::Call;
        pub mod calls {
            use super::root_mod;
            use super::runtime_types;
            type DispatchError = runtime_types::sp_runtime::DispatchError;
            pub mod types {
                use super::runtime_types;
                #[derive(
                    ::subxt::ext::codec::Decode,
                    ::subxt::ext::codec::Encode,
                    ::subxt::ext::scale_decode::DecodeAsType,
                    ::subxt::ext::scale_encode::EncodeAsType,
                    Clone,
                    Debug,
                    Eq,
                    PartialEq
                )]
                #[codec(crate = ::subxt::ext::codec)]
                #[decode_as_type(crate_path = ":: subxt :: ext :: scale_decode")]
                #[encode_as_type(crate_path = ":: subxt :: ext :: scale_encode")]
                pub struct Sudo {
                    pub call: ::std::boxed::Box<
                        runtime_types::tangle_standalone_runtime::RuntimeCall,
                    >,
                }
                impl ::subxt::blocks::StaticExtrinsic for Sudo {
                    const PALLET: &'static str = "Sudo";
                    const CALL: &'static str = "sudo";
                }
                #[derive(
                    ::subxt::ext::codec::Decode,
                    ::subxt::ext::codec::Encode,
                    ::subxt::ext::scale_decode::DecodeAsType,
                    ::subxt::ext::scale_encode::EncodeAsType,
                    Clone,
                    Debug,
                    Eq,
                    PartialEq
                )]
                #[codec(crate = ::subxt::ext::codec)]
                #[decode_as_type(crate_path = ":: subxt :: ext :: scale_decode")]
                #[encode_as_type(crate_path = ":: subxt :: ext :: scale_encode")]
                pub struct SudoUncheckedWeight {
                    pub call: ::std::boxed::Box<
                        runtime_types::tangle_standalone_runtime::RuntimeCall,
                    >,
                    pub weight: runtime_types::sp_weights::weight_v2::Weight,
                }
                impl ::subxt::blocks::StaticExtrinsic for SudoUncheckedWeight {
                    const PALLET: &'static str = "Sudo";
                    const CALL: &'static str = "sudo_unchecked_weight";
                }
                #[derive(
                    ::subxt::ext::codec::Decode,
                    ::subxt::ext::codec::Encode,
                    ::subxt::ext::scale_decode::DecodeAsType,
                    ::subxt::ext::scale_encode::EncodeAsType,
                    Clone,
                    Debug,
                    Eq,
                    PartialEq
                )]
                #[codec(crate = ::subxt::ext::codec)]
                #[decode_as_type(crate_path = ":: subxt :: ext :: scale_decode")]
                #[encode_as_type(crate_path = ":: subxt :: ext :: scale_encode")]
                pub struct SetKey {
                    pub new: ::subxt::utils::MultiAddress<
                        ::subxt::utils::AccountId32,
                        ::core::primitive::u32,
                    >,
                }
                impl ::subxt::blocks::StaticExtrinsic for SetKey {
                    const PALLET: &'static str = "Sudo";
                    const CALL: &'static str = "set_key";
                }
                #[derive(
                    ::subxt::ext::codec::Decode,
                    ::subxt::ext::codec::Encode,
                    ::subxt::ext::scale_decode::DecodeAsType,
                    ::subxt::ext::scale_encode::EncodeAsType,
                    Clone,
                    Debug,
                    Eq,
                    PartialEq
                )]
                #[codec(crate = ::subxt::ext::codec)]
                #[decode_as_type(crate_path = ":: subxt :: ext :: scale_decode")]
                #[encode_as_type(crate_path = ":: subxt :: ext :: scale_encode")]
                pub struct SudoAs {
                    pub who: ::subxt::utils::MultiAddress<
                        ::subxt::utils::AccountId32,
                        ::core::primitive::u32,
                    >,
                    pub call: ::std::boxed::Box<
                        runtime_types::tangle_standalone_runtime::RuntimeCall,
                    >,
                }
                impl ::subxt::blocks::StaticExtrinsic for SudoAs {
                    const PALLET: &'static str = "Sudo";
                    const CALL: &'static str = "sudo_as";
                }
            }
            pub struct TransactionApi;
            impl TransactionApi {
                ///Authenticates the sudo key and dispatches a function call with `Root` origin.
                ///
                ///The dispatch origin for this call must be _Signed_.
                ///
                ///## Complexity
                ///- O(1).
                pub fn sudo(
                    &self,
                    call: runtime_types::tangle_standalone_runtime::RuntimeCall,
                ) -> ::subxt::tx::Payload<types::Sudo> {
                    ::subxt::tx::Payload::new_static(
                        "Sudo",
                        "sudo",
                        types::Sudo {
                            call: ::std::boxed::Box::new(call),
                        },
                        [
                            22u8,
                            67u8,
                            184u8,
                            94u8,
                            251u8,
                            64u8,
                            140u8,
                            143u8,
                            179u8,
                            80u8,
                            221u8,
                            59u8,
                            12u8,
                            36u8,
                            32u8,
                            63u8,
                            87u8,
                            246u8,
                            14u8,
                            104u8,
                            168u8,
                            208u8,
                            74u8,
                            203u8,
                            254u8,
                            235u8,
                            226u8,
                            198u8,
                            10u8,
                            251u8,
                            222u8,
                            253u8,
                        ],
                    )
                }
                ///Authenticates the sudo key and dispatches a function call with `Root` origin.
                ///This function does not check the weight of the call, and instead allows the
                ///Sudo user to specify the weight of the call.
                ///
                ///The dispatch origin for this call must be _Signed_.
                ///
                ///## Complexity
                ///- O(1).
                pub fn sudo_unchecked_weight(
                    &self,
                    call: runtime_types::tangle_standalone_runtime::RuntimeCall,
                    weight: runtime_types::sp_weights::weight_v2::Weight,
                ) -> ::subxt::tx::Payload<types::SudoUncheckedWeight> {
                    ::subxt::tx::Payload::new_static(
                        "Sudo",
                        "sudo_unchecked_weight",
                        types::SudoUncheckedWeight {
                            call: ::std::boxed::Box::new(call),
                            weight,
                        },
                        [
                            165u8,
                            186u8,
                            12u8,
                            210u8,
                            46u8,
                            155u8,
                            106u8,
                            230u8,
                            42u8,
                            188u8,
                            233u8,
                            30u8,
                            103u8,
                            222u8,
                            29u8,
                            70u8,
                            148u8,
                            217u8,
                            219u8,
                            51u8,
                            223u8,
                            254u8,
                            39u8,
                            102u8,
                            209u8,
                            235u8,
                            177u8,
                            141u8,
                            74u8,
                            25u8,
                            172u8,
                            62u8,
                        ],
                    )
                }
                ///Authenticates the current sudo key and sets the given AccountId (`new`) as the new sudo
                ///key.
                ///
                ///The dispatch origin for this call must be _Signed_.
                ///
                ///## Complexity
                ///- O(1).
                pub fn set_key(
                    &self,
                    new: ::subxt::utils::MultiAddress<
                        ::subxt::utils::AccountId32,
                        ::core::primitive::u32,
                    >,
                ) -> ::subxt::tx::Payload<types::SetKey> {
                    ::subxt::tx::Payload::new_static(
                        "Sudo",
                        "set_key",
                        types::SetKey { new },
                        [
                            46u8,
                            208u8,
                            84u8,
                            223u8,
                            141u8,
                            188u8,
                            184u8,
                            156u8,
                            101u8,
                            97u8,
                            255u8,
                            166u8,
                            168u8,
                            102u8,
                            75u8,
                            3u8,
                            149u8,
                            105u8,
                            202u8,
                            220u8,
                            187u8,
                            117u8,
                            156u8,
                            83u8,
                            159u8,
                            115u8,
                            231u8,
                            201u8,
                            171u8,
                            47u8,
                            170u8,
                            36u8,
                        ],
                    )
                }
                ///Authenticates the sudo key and dispatches a function call with `Signed` origin from
                ///a given account.
                ///
                ///The dispatch origin for this call must be _Signed_.
                ///
                ///## Complexity
                ///- O(1).
                pub fn sudo_as(
                    &self,
                    who: ::subxt::utils::MultiAddress<
                        ::subxt::utils::AccountId32,
                        ::core::primitive::u32,
                    >,
                    call: runtime_types::tangle_standalone_runtime::RuntimeCall,
                ) -> ::subxt::tx::Payload<types::SudoAs> {
                    ::subxt::tx::Payload::new_static(
                        "Sudo",
                        "sudo_as",
                        types::SudoAs {
                            who,
                            call: ::std::boxed::Box::new(call),
                        },
                        [
                            16u8,
                            144u8,
                            209u8,
                            214u8,
                            43u8,
                            83u8,
                            11u8,
                            97u8,
                            56u8,
                            26u8,
                            97u8,
                            86u8,
                            122u8,
                            206u8,
                            221u8,
                            151u8,
                            108u8,
                            189u8,
                            99u8,
                            216u8,
                            55u8,
                            18u8,
                            98u8,
                            108u8,
                            139u8,
                            54u8,
                            136u8,
                            78u8,
                            58u8,
                            197u8,
                            92u8,
                            156u8,
                        ],
                    )
                }
            }
        }
        /**
			The [event](https://docs.substrate.io/main-docs/build/events-errors/) emitted
			by this pallet.
			*/
        pub type Event = runtime_types::pallet_sudo::pallet::Event;
        pub mod events {
            use super::runtime_types;
            #[derive(
                ::subxt::ext::codec::Decode,
                ::subxt::ext::codec::Encode,
                ::subxt::ext::scale_decode::DecodeAsType,
                ::subxt::ext::scale_encode::EncodeAsType,
                Clone,
                Debug,
                Eq,
                PartialEq
            )]
            #[codec(crate = ::subxt::ext::codec)]
            #[decode_as_type(crate_path = ":: subxt :: ext :: scale_decode")]
            #[encode_as_type(crate_path = ":: subxt :: ext :: scale_encode")]
            ///A sudo just took place. \[result\]
            pub struct Sudid {
                pub sudo_result: ::core::result::Result<
                    (),
                    runtime_types::sp_runtime::DispatchError,
                >,
            }
            impl ::subxt::events::StaticEvent for Sudid {
                const PALLET: &'static str = "Sudo";
                const EVENT: &'static str = "Sudid";
            }
            #[derive(
                ::subxt::ext::codec::Decode,
                ::subxt::ext::codec::Encode,
                ::subxt::ext::scale_decode::DecodeAsType,
                ::subxt::ext::scale_encode::EncodeAsType,
                Clone,
                Debug,
                Eq,
                PartialEq
            )]
            #[codec(crate = ::subxt::ext::codec)]
            #[decode_as_type(crate_path = ":: subxt :: ext :: scale_decode")]
            #[encode_as_type(crate_path = ":: subxt :: ext :: scale_encode")]
            ///The \[sudoer\] just switched identity; the old key is supplied if one existed.
            pub struct KeyChanged {
                pub old_sudoer: ::core::option::Option<::subxt::utils::AccountId32>,
            }
            impl ::subxt::events::StaticEvent for KeyChanged {
                const PALLET: &'static str = "Sudo";
                const EVENT: &'static str = "KeyChanged";
            }
            #[derive(
                ::subxt::ext::codec::Decode,
                ::subxt::ext::codec::Encode,
                ::subxt::ext::scale_decode::DecodeAsType,
                ::subxt::ext::scale_encode::EncodeAsType,
                Clone,
                Debug,
                Eq,
                PartialEq
            )]
            #[codec(crate = ::subxt::ext::codec)]
            #[decode_as_type(crate_path = ":: subxt :: ext :: scale_decode")]
            #[encode_as_type(crate_path = ":: subxt :: ext :: scale_encode")]
            ///A sudo just took place. \[result\]
            pub struct SudoAsDone {
                pub sudo_result: ::core::result::Result<
                    (),
                    runtime_types::sp_runtime::DispatchError,
                >,
            }
            impl ::subxt::events::StaticEvent for SudoAsDone {
                const PALLET: &'static str = "Sudo";
                const EVENT: &'static str = "SudoAsDone";
            }
        }
        pub mod storage {
            use super::runtime_types;
            pub struct StorageApi;
            impl StorageApi {
                /// The `AccountId` of the sudo key.
                pub fn key(
                    &self,
                ) -> ::subxt::storage::address::Address<
                    ::subxt::storage::address::StaticStorageMapKey,
                    ::subxt::utils::AccountId32,
                    ::subxt::storage::address::Yes,
                    (),
                    (),
                > {
                    ::subxt::storage::address::Address::new_static(
                        "Sudo",
                        "Key",
                        vec![],
                        [
                            72u8,
                            14u8,
                            225u8,
                            162u8,
                            205u8,
                            247u8,
                            227u8,
                            105u8,
                            116u8,
                            57u8,
                            4u8,
                            31u8,
                            84u8,
                            137u8,
                            227u8,
                            228u8,
                            133u8,
                            245u8,
                            206u8,
                            227u8,
                            117u8,
                            36u8,
                            252u8,
                            151u8,
                            107u8,
                            15u8,
                            180u8,
                            4u8,
                            4u8,
                            152u8,
                            195u8,
                            144u8,
                        ],
                    )
                }
            }
        }
    }
    pub mod randomness_collective_flip {
        use super::root_mod;
        use super::runtime_types;
        pub mod storage {
            use super::runtime_types;
            pub struct StorageApi;
            impl StorageApi {
                /// Series of block headers from the last 81 blocks that acts as random seed material. This
                /// is arranged as a ring buffer with `block_number % 81` being the index into the `Vec` of
                /// the oldest hash.
                pub fn random_material(
                    &self,
                ) -> ::subxt::storage::address::Address<
                    ::subxt::storage::address::StaticStorageMapKey,
                    runtime_types::bounded_collections::bounded_vec::BoundedVec<
                        ::subxt::utils::H256,
                    >,
                    ::subxt::storage::address::Yes,
                    ::subxt::storage::address::Yes,
                    (),
                > {
                    ::subxt::storage::address::Address::new_static(
                        "RandomnessCollectiveFlip",
                        "RandomMaterial",
                        vec![],
                        [
                            195u8,
                            232u8,
                            244u8,
                            162u8,
                            110u8,
                            137u8,
                            66u8,
                            57u8,
                            51u8,
                            221u8,
                            143u8,
                            38u8,
                            51u8,
                            183u8,
                            105u8,
                            245u8,
                            175u8,
                            13u8,
                            33u8,
                            192u8,
                            53u8,
                            16u8,
                            161u8,
                            76u8,
                            219u8,
                            177u8,
                            144u8,
                            192u8,
                            96u8,
                            166u8,
                            117u8,
                            247u8,
                        ],
                    )
                }
            }
        }
    }
    pub mod balances {
        use super::root_mod;
        use super::runtime_types;
        /**
			Custom [dispatch errors](https://docs.substrate.io/main-docs/build/events-errors/)
			of this pallet.
			*/
        pub type Error = runtime_types::pallet_balances::pallet::Error;
        ///Contains one variant per dispatchable that can be called by an extrinsic.
        pub type Call = runtime_types::pallet_balances::pallet::Call;
        pub mod calls {
            use super::root_mod;
            use super::runtime_types;
            type DispatchError = runtime_types::sp_runtime::DispatchError;
            pub mod types {
                use super::runtime_types;
                #[derive(
                    ::subxt::ext::codec::Decode,
                    ::subxt::ext::codec::Encode,
                    ::subxt::ext::scale_decode::DecodeAsType,
                    ::subxt::ext::scale_encode::EncodeAsType,
                    Clone,
                    Debug,
                    Eq,
                    PartialEq
                )]
                #[codec(crate = ::subxt::ext::codec)]
                #[decode_as_type(crate_path = ":: subxt :: ext :: scale_decode")]
                #[encode_as_type(crate_path = ":: subxt :: ext :: scale_encode")]
                pub struct TransferAllowDeath {
                    pub dest: ::subxt::utils::MultiAddress<
                        ::subxt::utils::AccountId32,
                        ::core::primitive::u32,
                    >,
                    #[codec(compact)]
                    pub value: ::core::primitive::u128,
                }
                impl ::subxt::blocks::StaticExtrinsic for TransferAllowDeath {
                    const PALLET: &'static str = "Balances";
                    const CALL: &'static str = "transfer_allow_death";
                }
                #[derive(
                    ::subxt::ext::codec::Decode,
                    ::subxt::ext::codec::Encode,
                    ::subxt::ext::scale_decode::DecodeAsType,
                    ::subxt::ext::scale_encode::EncodeAsType,
                    Clone,
                    Debug,
                    Eq,
                    PartialEq
                )]
                #[codec(crate = ::subxt::ext::codec)]
                #[decode_as_type(crate_path = ":: subxt :: ext :: scale_decode")]
                #[encode_as_type(crate_path = ":: subxt :: ext :: scale_encode")]
                pub struct SetBalanceDeprecated {
                    pub who: ::subxt::utils::MultiAddress<
                        ::subxt::utils::AccountId32,
                        ::core::primitive::u32,
                    >,
                    #[codec(compact)]
                    pub new_free: ::core::primitive::u128,
                    #[codec(compact)]
                    pub old_reserved: ::core::primitive::u128,
                }
                impl ::subxt::blocks::StaticExtrinsic for SetBalanceDeprecated {
                    const PALLET: &'static str = "Balances";
                    const CALL: &'static str = "set_balance_deprecated";
                }
                #[derive(
                    ::subxt::ext::codec::Decode,
                    ::subxt::ext::codec::Encode,
                    ::subxt::ext::scale_decode::DecodeAsType,
                    ::subxt::ext::scale_encode::EncodeAsType,
                    Clone,
                    Debug,
                    Eq,
                    PartialEq
                )]
                #[codec(crate = ::subxt::ext::codec)]
                #[decode_as_type(crate_path = ":: subxt :: ext :: scale_decode")]
                #[encode_as_type(crate_path = ":: subxt :: ext :: scale_encode")]
                pub struct ForceTransfer {
                    pub source: ::subxt::utils::MultiAddress<
                        ::subxt::utils::AccountId32,
                        ::core::primitive::u32,
                    >,
                    pub dest: ::subxt::utils::MultiAddress<
                        ::subxt::utils::AccountId32,
                        ::core::primitive::u32,
                    >,
                    #[codec(compact)]
                    pub value: ::core::primitive::u128,
                }
                impl ::subxt::blocks::StaticExtrinsic for ForceTransfer {
                    const PALLET: &'static str = "Balances";
                    const CALL: &'static str = "force_transfer";
                }
                #[derive(
                    ::subxt::ext::codec::Decode,
                    ::subxt::ext::codec::Encode,
                    ::subxt::ext::scale_decode::DecodeAsType,
                    ::subxt::ext::scale_encode::EncodeAsType,
                    Clone,
                    Debug,
                    Eq,
                    PartialEq
                )]
                #[codec(crate = ::subxt::ext::codec)]
                #[decode_as_type(crate_path = ":: subxt :: ext :: scale_decode")]
                #[encode_as_type(crate_path = ":: subxt :: ext :: scale_encode")]
                pub struct TransferKeepAlive {
                    pub dest: ::subxt::utils::MultiAddress<
                        ::subxt::utils::AccountId32,
                        ::core::primitive::u32,
                    >,
                    #[codec(compact)]
                    pub value: ::core::primitive::u128,
                }
                impl ::subxt::blocks::StaticExtrinsic for TransferKeepAlive {
                    const PALLET: &'static str = "Balances";
                    const CALL: &'static str = "transfer_keep_alive";
                }
                #[derive(
                    ::subxt::ext::codec::Decode,
                    ::subxt::ext::codec::Encode,
                    ::subxt::ext::scale_decode::DecodeAsType,
                    ::subxt::ext::scale_encode::EncodeAsType,
                    Clone,
                    Debug,
                    Eq,
                    PartialEq
                )]
                #[codec(crate = ::subxt::ext::codec)]
                #[decode_as_type(crate_path = ":: subxt :: ext :: scale_decode")]
                #[encode_as_type(crate_path = ":: subxt :: ext :: scale_encode")]
                pub struct TransferAll {
                    pub dest: ::subxt::utils::MultiAddress<
                        ::subxt::utils::AccountId32,
                        ::core::primitive::u32,
                    >,
                    pub keep_alive: ::core::primitive::bool,
                }
                impl ::subxt::blocks::StaticExtrinsic for TransferAll {
                    const PALLET: &'static str = "Balances";
                    const CALL: &'static str = "transfer_all";
                }
                #[derive(
                    ::subxt::ext::codec::Decode,
                    ::subxt::ext::codec::Encode,
                    ::subxt::ext::scale_decode::DecodeAsType,
                    ::subxt::ext::scale_encode::EncodeAsType,
                    Clone,
                    Debug,
                    Eq,
                    PartialEq
                )]
                #[codec(crate = ::subxt::ext::codec)]
                #[decode_as_type(crate_path = ":: subxt :: ext :: scale_decode")]
                #[encode_as_type(crate_path = ":: subxt :: ext :: scale_encode")]
                pub struct ForceUnreserve {
                    pub who: ::subxt::utils::MultiAddress<
                        ::subxt::utils::AccountId32,
                        ::core::primitive::u32,
                    >,
                    pub amount: ::core::primitive::u128,
                }
                impl ::subxt::blocks::StaticExtrinsic for ForceUnreserve {
                    const PALLET: &'static str = "Balances";
                    const CALL: &'static str = "force_unreserve";
                }
                #[derive(
                    ::subxt::ext::codec::Decode,
                    ::subxt::ext::codec::Encode,
                    ::subxt::ext::scale_decode::DecodeAsType,
                    ::subxt::ext::scale_encode::EncodeAsType,
                    Clone,
                    Debug,
                    Eq,
                    PartialEq
                )]
                #[codec(crate = ::subxt::ext::codec)]
                #[decode_as_type(crate_path = ":: subxt :: ext :: scale_decode")]
                #[encode_as_type(crate_path = ":: subxt :: ext :: scale_encode")]
                pub struct UpgradeAccounts {
                    pub who: ::std::vec::Vec<::subxt::utils::AccountId32>,
                }
                impl ::subxt::blocks::StaticExtrinsic for UpgradeAccounts {
                    const PALLET: &'static str = "Balances";
                    const CALL: &'static str = "upgrade_accounts";
                }
                #[derive(
                    ::subxt::ext::codec::Decode,
                    ::subxt::ext::codec::Encode,
                    ::subxt::ext::scale_decode::DecodeAsType,
                    ::subxt::ext::scale_encode::EncodeAsType,
                    Clone,
                    Debug,
                    Eq,
                    PartialEq
                )]
                #[codec(crate = ::subxt::ext::codec)]
                #[decode_as_type(crate_path = ":: subxt :: ext :: scale_decode")]
                #[encode_as_type(crate_path = ":: subxt :: ext :: scale_encode")]
                pub struct Transfer {
                    pub dest: ::subxt::utils::MultiAddress<
                        ::subxt::utils::AccountId32,
                        ::core::primitive::u32,
                    >,
                    #[codec(compact)]
                    pub value: ::core::primitive::u128,
                }
                impl ::subxt::blocks::StaticExtrinsic for Transfer {
                    const PALLET: &'static str = "Balances";
                    const CALL: &'static str = "transfer";
                }
                #[derive(
                    ::subxt::ext::codec::Decode,
                    ::subxt::ext::codec::Encode,
                    ::subxt::ext::scale_decode::DecodeAsType,
                    ::subxt::ext::scale_encode::EncodeAsType,
                    Clone,
                    Debug,
                    Eq,
                    PartialEq
                )]
                #[codec(crate = ::subxt::ext::codec)]
                #[decode_as_type(crate_path = ":: subxt :: ext :: scale_decode")]
                #[encode_as_type(crate_path = ":: subxt :: ext :: scale_encode")]
                pub struct ForceSetBalance {
                    pub who: ::subxt::utils::MultiAddress<
                        ::subxt::utils::AccountId32,
                        ::core::primitive::u32,
                    >,
                    #[codec(compact)]
                    pub new_free: ::core::primitive::u128,
                }
                impl ::subxt::blocks::StaticExtrinsic for ForceSetBalance {
                    const PALLET: &'static str = "Balances";
                    const CALL: &'static str = "force_set_balance";
                }
            }
            pub struct TransactionApi;
            impl TransactionApi {
                ///Transfer some liquid free balance to another account.
                ///
                ///`transfer_allow_death` will set the `FreeBalance` of the sender and receiver.
                ///If the sender's account is below the existential deposit as a result
                ///of the transfer, the account will be reaped.
                ///
                ///The dispatch origin for this call must be `Signed` by the transactor.
                pub fn transfer_allow_death(
                    &self,
                    dest: ::subxt::utils::MultiAddress<
                        ::subxt::utils::AccountId32,
                        ::core::primitive::u32,
                    >,
                    value: ::core::primitive::u128,
                ) -> ::subxt::tx::Payload<types::TransferAllowDeath> {
                    ::subxt::tx::Payload::new_static(
                        "Balances",
                        "transfer_allow_death",
                        types::TransferAllowDeath {
                            dest,
                            value,
                        },
                        [
                            100u8,
                            112u8,
                            63u8,
                            118u8,
                            67u8,
                            47u8,
                            63u8,
                            58u8,
                            249u8,
                            180u8,
                            242u8,
                            65u8,
                            237u8,
                            246u8,
                            118u8,
                            80u8,
                            181u8,
                            220u8,
                            5u8,
                            1u8,
                            144u8,
                            184u8,
                            214u8,
                            24u8,
                            170u8,
                            165u8,
                            227u8,
                            142u8,
                            9u8,
                            43u8,
                            152u8,
                            101u8,
                        ],
                    )
                }
                ///Set the regular balance of a given account; it also takes a reserved balance but this
                ///must be the same as the account's current reserved balance.
                ///
                ///The dispatch origin for this call is `root`.
                ///
                ///WARNING: This call is DEPRECATED! Use `force_set_balance` instead.
                pub fn set_balance_deprecated(
                    &self,
                    who: ::subxt::utils::MultiAddress<
                        ::subxt::utils::AccountId32,
                        ::core::primitive::u32,
                    >,
                    new_free: ::core::primitive::u128,
                    old_reserved: ::core::primitive::u128,
                ) -> ::subxt::tx::Payload<types::SetBalanceDeprecated> {
                    ::subxt::tx::Payload::new_static(
                        "Balances",
                        "set_balance_deprecated",
                        types::SetBalanceDeprecated {
                            who,
                            new_free,
                            old_reserved,
                        },
                        [
                            135u8,
                            204u8,
                            148u8,
                            253u8,
                            76u8,
                            20u8,
                            79u8,
                            5u8,
                            133u8,
                            232u8,
                            10u8,
                            79u8,
                            199u8,
                            52u8,
                            199u8,
                            42u8,
                            124u8,
                            55u8,
                            82u8,
                            71u8,
                            102u8,
                            81u8,
                            46u8,
                            101u8,
                            38u8,
                            183u8,
                            219u8,
                            188u8,
                            227u8,
                            255u8,
                            136u8,
                            124u8,
                        ],
                    )
                }
                ///Exactly as `transfer_allow_death`, except the origin must be root and the source account
                ///may be specified.
                pub fn force_transfer(
                    &self,
                    source: ::subxt::utils::MultiAddress<
                        ::subxt::utils::AccountId32,
                        ::core::primitive::u32,
                    >,
                    dest: ::subxt::utils::MultiAddress<
                        ::subxt::utils::AccountId32,
                        ::core::primitive::u32,
                    >,
                    value: ::core::primitive::u128,
                ) -> ::subxt::tx::Payload<types::ForceTransfer> {
                    ::subxt::tx::Payload::new_static(
                        "Balances",
                        "force_transfer",
                        types::ForceTransfer {
                            source,
                            dest,
                            value,
                        },
                        [
                            192u8,
                            208u8,
                            171u8,
                            116u8,
                            91u8,
                            20u8,
                            177u8,
                            202u8,
                            113u8,
                            195u8,
                            44u8,
                            49u8,
                            140u8,
                            190u8,
                            168u8,
                            41u8,
                            165u8,
                            202u8,
                            68u8,
                            127u8,
                            247u8,
                            183u8,
                            126u8,
                            38u8,
                            124u8,
                            41u8,
                            13u8,
                            11u8,
                            69u8,
                            32u8,
                            35u8,
                            12u8,
                        ],
                    )
                }
                ///Same as the [`transfer_allow_death`] call, but with a check that the transfer will not
                ///kill the origin account.
                ///
                ///99% of the time you want [`transfer_allow_death`] instead.
                ///
                ///[`transfer_allow_death`]: struct.Pallet.html#method.transfer
                pub fn transfer_keep_alive(
                    &self,
                    dest: ::subxt::utils::MultiAddress<
                        ::subxt::utils::AccountId32,
                        ::core::primitive::u32,
                    >,
                    value: ::core::primitive::u128,
                ) -> ::subxt::tx::Payload<types::TransferKeepAlive> {
                    ::subxt::tx::Payload::new_static(
                        "Balances",
                        "transfer_keep_alive",
                        types::TransferKeepAlive {
                            dest,
                            value,
                        },
                        [
                            186u8,
                            56u8,
                            39u8,
                            71u8,
                            205u8,
                            98u8,
                            251u8,
                            252u8,
                            106u8,
                            6u8,
                            92u8,
                            217u8,
                            254u8,
                            186u8,
                            113u8,
                            196u8,
                            114u8,
                            248u8,
                            54u8,
                            226u8,
                            53u8,
                            73u8,
                            6u8,
                            66u8,
                            96u8,
                            54u8,
                            117u8,
                            23u8,
                            34u8,
                            200u8,
                            84u8,
                            227u8,
                        ],
                    )
                }
                ///Transfer the entire transferable balance from the caller account.
                ///
                ///NOTE: This function only attempts to transfer _transferable_ balances. This means that
                ///any locked, reserved, or existential deposits (when `keep_alive` is `true`), will not be
                ///transferred by this function. To ensure that this function results in a killed account,
                ///you might need to prepare the account by removing any reference counters, storage
                ///deposits, etc...
                ///
                ///The dispatch origin of this call must be Signed.
                ///
                ///- `dest`: The recipient of the transfer.
                ///- `keep_alive`: A boolean to determine if the `transfer_all` operation should send all
                ///  of the funds the account has, causing the sender account to be killed (false), or
                ///  transfer everything except at least the existential deposit, which will guarantee to
                ///  keep the sender account alive (true).
                pub fn transfer_all(
                    &self,
                    dest: ::subxt::utils::MultiAddress<
                        ::subxt::utils::AccountId32,
                        ::core::primitive::u32,
                    >,
                    keep_alive: ::core::primitive::bool,
                ) -> ::subxt::tx::Payload<types::TransferAll> {
                    ::subxt::tx::Payload::new_static(
                        "Balances",
                        "transfer_all",
                        types::TransferAll {
                            dest,
                            keep_alive,
                        },
                        [
                            39u8,
                            244u8,
                            99u8,
                            182u8,
                            181u8,
                            159u8,
                            95u8,
                            217u8,
                            8u8,
                            210u8,
                            113u8,
                            254u8,
                            171u8,
                            199u8,
                            93u8,
                            146u8,
                            209u8,
                            229u8,
                            55u8,
                            97u8,
                            131u8,
                            226u8,
                            155u8,
                            41u8,
                            199u8,
                            145u8,
                            177u8,
                            137u8,
                            198u8,
                            241u8,
                            90u8,
                            20u8,
                        ],
                    )
                }
                ///Unreserve some balance from a user by force.
                ///
                ///Can only be called by ROOT.
                pub fn force_unreserve(
                    &self,
                    who: ::subxt::utils::MultiAddress<
                        ::subxt::utils::AccountId32,
                        ::core::primitive::u32,
                    >,
                    amount: ::core::primitive::u128,
                ) -> ::subxt::tx::Payload<types::ForceUnreserve> {
                    ::subxt::tx::Payload::new_static(
                        "Balances",
                        "force_unreserve",
                        types::ForceUnreserve {
                            who,
                            amount,
                        },
                        [
                            153u8,
                            166u8,
                            64u8,
                            196u8,
                            251u8,
                            238u8,
                            79u8,
                            171u8,
                            169u8,
                            183u8,
                            68u8,
                            220u8,
                            117u8,
                            237u8,
                            231u8,
                            156u8,
                            6u8,
                            186u8,
                            196u8,
                            238u8,
                            195u8,
                            16u8,
                            84u8,
                            236u8,
                            40u8,
                            6u8,
                            228u8,
                            211u8,
                            19u8,
                            248u8,
                            171u8,
                            137u8,
                        ],
                    )
                }
                ///Upgrade a specified account.
                ///
                ///- `origin`: Must be `Signed`.
                ///- `who`: The account to be upgraded.
                ///
                ///This will waive the transaction fee if at least all but 10% of the accounts needed to
                ///be upgraded. (We let some not have to be upgraded just in order to allow for the
                ///possibililty of churn).
                pub fn upgrade_accounts(
                    &self,
                    who: ::std::vec::Vec<::subxt::utils::AccountId32>,
                ) -> ::subxt::tx::Payload<types::UpgradeAccounts> {
                    ::subxt::tx::Payload::new_static(
                        "Balances",
                        "upgrade_accounts",
                        types::UpgradeAccounts { who },
                        [
                            66u8,
                            200u8,
                            179u8,
                            104u8,
                            65u8,
                            2u8,
                            101u8,
                            56u8,
                            130u8,
                            161u8,
                            224u8,
                            233u8,
                            255u8,
                            124u8,
                            70u8,
                            122u8,
                            8u8,
                            49u8,
                            103u8,
                            178u8,
                            68u8,
                            47u8,
                            214u8,
                            166u8,
                            217u8,
                            116u8,
                            178u8,
                            50u8,
                            212u8,
                            164u8,
                            98u8,
                            226u8,
                        ],
                    )
                }
                ///Alias for `transfer_allow_death`, provided only for name-wise compatibility.
                ///
                ///WARNING: DEPRECATED! Will be released in approximately 3 months.
                pub fn transfer(
                    &self,
                    dest: ::subxt::utils::MultiAddress<
                        ::subxt::utils::AccountId32,
                        ::core::primitive::u32,
                    >,
                    value: ::core::primitive::u128,
                ) -> ::subxt::tx::Payload<types::Transfer> {
                    ::subxt::tx::Payload::new_static(
                        "Balances",
                        "transfer",
                        types::Transfer { dest, value },
                        [
                            78u8,
                            137u8,
                            180u8,
                            250u8,
                            225u8,
                            152u8,
                            150u8,
                            139u8,
                            30u8,
                            4u8,
                            57u8,
                            241u8,
                            135u8,
                            108u8,
                            67u8,
                            239u8,
                            65u8,
                            13u8,
                            10u8,
                            205u8,
                            125u8,
                            208u8,
                            237u8,
                            60u8,
                            18u8,
                            13u8,
                            232u8,
                            47u8,
                            47u8,
                            151u8,
                            79u8,
                            23u8,
                        ],
                    )
                }
                ///Set the regular balance of a given account.
                ///
                ///The dispatch origin for this call is `root`.
                pub fn force_set_balance(
                    &self,
                    who: ::subxt::utils::MultiAddress<
                        ::subxt::utils::AccountId32,
                        ::core::primitive::u32,
                    >,
                    new_free: ::core::primitive::u128,
                ) -> ::subxt::tx::Payload<types::ForceSetBalance> {
                    ::subxt::tx::Payload::new_static(
                        "Balances",
                        "force_set_balance",
                        types::ForceSetBalance {
                            who,
                            new_free,
                        },
                        [
                            171u8,
                            138u8,
                            53u8,
                            85u8,
                            202u8,
                            35u8,
                            151u8,
                            115u8,
                            143u8,
                            67u8,
                            81u8,
                            25u8,
                            250u8,
                            108u8,
                            179u8,
                            46u8,
                            194u8,
                            23u8,
                            169u8,
                            223u8,
                            6u8,
                            179u8,
                            240u8,
                            4u8,
                            26u8,
                            9u8,
                            229u8,
                            29u8,
                            248u8,
                            6u8,
                            23u8,
                            232u8,
                        ],
                    )
                }
            }
        }
        /**
			The [event](https://docs.substrate.io/main-docs/build/events-errors/) emitted
			by this pallet.
			*/
        pub type Event = runtime_types::pallet_balances::pallet::Event;
        pub mod events {
            use super::runtime_types;
            #[derive(
                ::subxt::ext::codec::Decode,
                ::subxt::ext::codec::Encode,
                ::subxt::ext::scale_decode::DecodeAsType,
                ::subxt::ext::scale_encode::EncodeAsType,
                Clone,
                Debug,
                Eq,
                PartialEq
            )]
            #[codec(crate = ::subxt::ext::codec)]
            #[decode_as_type(crate_path = ":: subxt :: ext :: scale_decode")]
            #[encode_as_type(crate_path = ":: subxt :: ext :: scale_encode")]
            ///An account was created with some free balance.
            pub struct Endowed {
                pub account: ::subxt::utils::AccountId32,
                pub free_balance: ::core::primitive::u128,
            }
            impl ::subxt::events::StaticEvent for Endowed {
                const PALLET: &'static str = "Balances";
                const EVENT: &'static str = "Endowed";
            }
            #[derive(
                ::subxt::ext::codec::Decode,
                ::subxt::ext::codec::Encode,
                ::subxt::ext::scale_decode::DecodeAsType,
                ::subxt::ext::scale_encode::EncodeAsType,
                Clone,
                Debug,
                Eq,
                PartialEq
            )]
            #[codec(crate = ::subxt::ext::codec)]
            #[decode_as_type(crate_path = ":: subxt :: ext :: scale_decode")]
            #[encode_as_type(crate_path = ":: subxt :: ext :: scale_encode")]
            ///An account was removed whose balance was non-zero but below ExistentialDeposit,
            ///resulting in an outright loss.
            pub struct DustLost {
                pub account: ::subxt::utils::AccountId32,
                pub amount: ::core::primitive::u128,
            }
            impl ::subxt::events::StaticEvent for DustLost {
                const PALLET: &'static str = "Balances";
                const EVENT: &'static str = "DustLost";
            }
            #[derive(
                ::subxt::ext::codec::Decode,
                ::subxt::ext::codec::Encode,
                ::subxt::ext::scale_decode::DecodeAsType,
                ::subxt::ext::scale_encode::EncodeAsType,
                Clone,
                Debug,
                Eq,
                PartialEq
            )]
            #[codec(crate = ::subxt::ext::codec)]
            #[decode_as_type(crate_path = ":: subxt :: ext :: scale_decode")]
            #[encode_as_type(crate_path = ":: subxt :: ext :: scale_encode")]
            ///Transfer succeeded.
            pub struct Transfer {
                pub from: ::subxt::utils::AccountId32,
                pub to: ::subxt::utils::AccountId32,
                pub amount: ::core::primitive::u128,
            }
            impl ::subxt::events::StaticEvent for Transfer {
                const PALLET: &'static str = "Balances";
                const EVENT: &'static str = "Transfer";
            }
            #[derive(
                ::subxt::ext::codec::Decode,
                ::subxt::ext::codec::Encode,
                ::subxt::ext::scale_decode::DecodeAsType,
                ::subxt::ext::scale_encode::EncodeAsType,
                Clone,
                Debug,
                Eq,
                PartialEq
            )]
            #[codec(crate = ::subxt::ext::codec)]
            #[decode_as_type(crate_path = ":: subxt :: ext :: scale_decode")]
            #[encode_as_type(crate_path = ":: subxt :: ext :: scale_encode")]
            ///A balance was set by root.
            pub struct BalanceSet {
                pub who: ::subxt::utils::AccountId32,
                pub free: ::core::primitive::u128,
            }
            impl ::subxt::events::StaticEvent for BalanceSet {
                const PALLET: &'static str = "Balances";
                const EVENT: &'static str = "BalanceSet";
            }
            #[derive(
                ::subxt::ext::codec::Decode,
                ::subxt::ext::codec::Encode,
                ::subxt::ext::scale_decode::DecodeAsType,
                ::subxt::ext::scale_encode::EncodeAsType,
                Clone,
                Debug,
                Eq,
                PartialEq
            )]
            #[codec(crate = ::subxt::ext::codec)]
            #[decode_as_type(crate_path = ":: subxt :: ext :: scale_decode")]
            #[encode_as_type(crate_path = ":: subxt :: ext :: scale_encode")]
            ///Some balance was reserved (moved from free to reserved).
            pub struct Reserved {
                pub who: ::subxt::utils::AccountId32,
                pub amount: ::core::primitive::u128,
            }
            impl ::subxt::events::StaticEvent for Reserved {
                const PALLET: &'static str = "Balances";
                const EVENT: &'static str = "Reserved";
            }
            #[derive(
                ::subxt::ext::codec::Decode,
                ::subxt::ext::codec::Encode,
                ::subxt::ext::scale_decode::DecodeAsType,
                ::subxt::ext::scale_encode::EncodeAsType,
                Clone,
                Debug,
                Eq,
                PartialEq
            )]
            #[codec(crate = ::subxt::ext::codec)]
            #[decode_as_type(crate_path = ":: subxt :: ext :: scale_decode")]
            #[encode_as_type(crate_path = ":: subxt :: ext :: scale_encode")]
            ///Some balance was unreserved (moved from reserved to free).
            pub struct Unreserved {
                pub who: ::subxt::utils::AccountId32,
                pub amount: ::core::primitive::u128,
            }
            impl ::subxt::events::StaticEvent for Unreserved {
                const PALLET: &'static str = "Balances";
                const EVENT: &'static str = "Unreserved";
            }
            #[derive(
                ::subxt::ext::codec::Decode,
                ::subxt::ext::codec::Encode,
                ::subxt::ext::scale_decode::DecodeAsType,
                ::subxt::ext::scale_encode::EncodeAsType,
                Clone,
                Debug,
                Eq,
                PartialEq
            )]
            #[codec(crate = ::subxt::ext::codec)]
            #[decode_as_type(crate_path = ":: subxt :: ext :: scale_decode")]
            #[encode_as_type(crate_path = ":: subxt :: ext :: scale_encode")]
            ///Some balance was moved from the reserve of the first account to the second account.
            ///Final argument indicates the destination balance type.
            pub struct ReserveRepatriated {
                pub from: ::subxt::utils::AccountId32,
                pub to: ::subxt::utils::AccountId32,
                pub amount: ::core::primitive::u128,
                pub destination_status: runtime_types::frame_support::traits::tokens::misc::BalanceStatus,
            }
            impl ::subxt::events::StaticEvent for ReserveRepatriated {
                const PALLET: &'static str = "Balances";
                const EVENT: &'static str = "ReserveRepatriated";
            }
            #[derive(
                ::subxt::ext::codec::Decode,
                ::subxt::ext::codec::Encode,
                ::subxt::ext::scale_decode::DecodeAsType,
                ::subxt::ext::scale_encode::EncodeAsType,
                Clone,
                Debug,
                Eq,
                PartialEq
            )]
            #[codec(crate = ::subxt::ext::codec)]
            #[decode_as_type(crate_path = ":: subxt :: ext :: scale_decode")]
            #[encode_as_type(crate_path = ":: subxt :: ext :: scale_encode")]
            ///Some amount was deposited (e.g. for transaction fees).
            pub struct Deposit {
                pub who: ::subxt::utils::AccountId32,
                pub amount: ::core::primitive::u128,
            }
            impl ::subxt::events::StaticEvent for Deposit {
                const PALLET: &'static str = "Balances";
                const EVENT: &'static str = "Deposit";
            }
            #[derive(
                ::subxt::ext::codec::Decode,
                ::subxt::ext::codec::Encode,
                ::subxt::ext::scale_decode::DecodeAsType,
                ::subxt::ext::scale_encode::EncodeAsType,
                Clone,
                Debug,
                Eq,
                PartialEq
            )]
            #[codec(crate = ::subxt::ext::codec)]
            #[decode_as_type(crate_path = ":: subxt :: ext :: scale_decode")]
            #[encode_as_type(crate_path = ":: subxt :: ext :: scale_encode")]
            ///Some amount was withdrawn from the account (e.g. for transaction fees).
            pub struct Withdraw {
                pub who: ::subxt::utils::AccountId32,
                pub amount: ::core::primitive::u128,
            }
            impl ::subxt::events::StaticEvent for Withdraw {
                const PALLET: &'static str = "Balances";
                const EVENT: &'static str = "Withdraw";
            }
            #[derive(
                ::subxt::ext::codec::Decode,
                ::subxt::ext::codec::Encode,
                ::subxt::ext::scale_decode::DecodeAsType,
                ::subxt::ext::scale_encode::EncodeAsType,
                Clone,
                Debug,
                Eq,
                PartialEq
            )]
            #[codec(crate = ::subxt::ext::codec)]
            #[decode_as_type(crate_path = ":: subxt :: ext :: scale_decode")]
            #[encode_as_type(crate_path = ":: subxt :: ext :: scale_encode")]
            ///Some amount was removed from the account (e.g. for misbehavior).
            pub struct Slashed {
                pub who: ::subxt::utils::AccountId32,
                pub amount: ::core::primitive::u128,
            }
            impl ::subxt::events::StaticEvent for Slashed {
                const PALLET: &'static str = "Balances";
                const EVENT: &'static str = "Slashed";
            }
            #[derive(
                ::subxt::ext::codec::Decode,
                ::subxt::ext::codec::Encode,
                ::subxt::ext::scale_decode::DecodeAsType,
                ::subxt::ext::scale_encode::EncodeAsType,
                Clone,
                Debug,
                Eq,
                PartialEq
            )]
            #[codec(crate = ::subxt::ext::codec)]
            #[decode_as_type(crate_path = ":: subxt :: ext :: scale_decode")]
            #[encode_as_type(crate_path = ":: subxt :: ext :: scale_encode")]
            ///Some amount was minted into an account.
            pub struct Minted {
                pub who: ::subxt::utils::AccountId32,
                pub amount: ::core::primitive::u128,
            }
            impl ::subxt::events::StaticEvent for Minted {
                const PALLET: &'static str = "Balances";
                const EVENT: &'static str = "Minted";
            }
            #[derive(
                ::subxt::ext::codec::Decode,
                ::subxt::ext::codec::Encode,
                ::subxt::ext::scale_decode::DecodeAsType,
                ::subxt::ext::scale_encode::EncodeAsType,
                Clone,
                Debug,
                Eq,
                PartialEq
            )]
            #[codec(crate = ::subxt::ext::codec)]
            #[decode_as_type(crate_path = ":: subxt :: ext :: scale_decode")]
            #[encode_as_type(crate_path = ":: subxt :: ext :: scale_encode")]
            ///Some amount was burned from an account.
            pub struct Burned {
                pub who: ::subxt::utils::AccountId32,
                pub amount: ::core::primitive::u128,
            }
            impl ::subxt::events::StaticEvent for Burned {
                const PALLET: &'static str = "Balances";
                const EVENT: &'static str = "Burned";
            }
            #[derive(
                ::subxt::ext::codec::Decode,
                ::subxt::ext::codec::Encode,
                ::subxt::ext::scale_decode::DecodeAsType,
                ::subxt::ext::scale_encode::EncodeAsType,
                Clone,
                Debug,
                Eq,
                PartialEq
            )]
            #[codec(crate = ::subxt::ext::codec)]
            #[decode_as_type(crate_path = ":: subxt :: ext :: scale_decode")]
            #[encode_as_type(crate_path = ":: subxt :: ext :: scale_encode")]
            ///Some amount was suspended from an account (it can be restored later).
            pub struct Suspended {
                pub who: ::subxt::utils::AccountId32,
                pub amount: ::core::primitive::u128,
            }
            impl ::subxt::events::StaticEvent for Suspended {
                const PALLET: &'static str = "Balances";
                const EVENT: &'static str = "Suspended";
            }
            #[derive(
                ::subxt::ext::codec::Decode,
                ::subxt::ext::codec::Encode,
                ::subxt::ext::scale_decode::DecodeAsType,
                ::subxt::ext::scale_encode::EncodeAsType,
                Clone,
                Debug,
                Eq,
                PartialEq
            )]
            #[codec(crate = ::subxt::ext::codec)]
            #[decode_as_type(crate_path = ":: subxt :: ext :: scale_decode")]
            #[encode_as_type(crate_path = ":: subxt :: ext :: scale_encode")]
            ///Some amount was restored into an account.
            pub struct Restored {
                pub who: ::subxt::utils::AccountId32,
                pub amount: ::core::primitive::u128,
            }
            impl ::subxt::events::StaticEvent for Restored {
                const PALLET: &'static str = "Balances";
                const EVENT: &'static str = "Restored";
            }
            #[derive(
                ::subxt::ext::codec::Decode,
                ::subxt::ext::codec::Encode,
                ::subxt::ext::scale_decode::DecodeAsType,
                ::subxt::ext::scale_encode::EncodeAsType,
                Clone,
                Debug,
                Eq,
                PartialEq
            )]
            #[codec(crate = ::subxt::ext::codec)]
            #[decode_as_type(crate_path = ":: subxt :: ext :: scale_decode")]
            #[encode_as_type(crate_path = ":: subxt :: ext :: scale_encode")]
            ///An account was upgraded.
            pub struct Upgraded {
                pub who: ::subxt::utils::AccountId32,
            }
            impl ::subxt::events::StaticEvent for Upgraded {
                const PALLET: &'static str = "Balances";
                const EVENT: &'static str = "Upgraded";
            }
            #[derive(
                ::subxt::ext::codec::CompactAs,
                ::subxt::ext::codec::Decode,
                ::subxt::ext::codec::Encode,
                ::subxt::ext::scale_decode::DecodeAsType,
                ::subxt::ext::scale_encode::EncodeAsType,
                Clone,
                Debug,
                Eq,
                PartialEq
            )]
            #[codec(crate = ::subxt::ext::codec)]
            #[decode_as_type(crate_path = ":: subxt :: ext :: scale_decode")]
            #[encode_as_type(crate_path = ":: subxt :: ext :: scale_encode")]
            ///Total issuance was increased by `amount`, creating a credit to be balanced.
            pub struct Issued {
                pub amount: ::core::primitive::u128,
            }
            impl ::subxt::events::StaticEvent for Issued {
                const PALLET: &'static str = "Balances";
                const EVENT: &'static str = "Issued";
            }
            #[derive(
                ::subxt::ext::codec::CompactAs,
                ::subxt::ext::codec::Decode,
                ::subxt::ext::codec::Encode,
                ::subxt::ext::scale_decode::DecodeAsType,
                ::subxt::ext::scale_encode::EncodeAsType,
                Clone,
                Debug,
                Eq,
                PartialEq
            )]
            #[codec(crate = ::subxt::ext::codec)]
            #[decode_as_type(crate_path = ":: subxt :: ext :: scale_decode")]
            #[encode_as_type(crate_path = ":: subxt :: ext :: scale_encode")]
            ///Total issuance was decreased by `amount`, creating a debt to be balanced.
            pub struct Rescinded {
                pub amount: ::core::primitive::u128,
            }
            impl ::subxt::events::StaticEvent for Rescinded {
                const PALLET: &'static str = "Balances";
                const EVENT: &'static str = "Rescinded";
            }
            #[derive(
                ::subxt::ext::codec::Decode,
                ::subxt::ext::codec::Encode,
                ::subxt::ext::scale_decode::DecodeAsType,
                ::subxt::ext::scale_encode::EncodeAsType,
                Clone,
                Debug,
                Eq,
                PartialEq
            )]
            #[codec(crate = ::subxt::ext::codec)]
            #[decode_as_type(crate_path = ":: subxt :: ext :: scale_decode")]
            #[encode_as_type(crate_path = ":: subxt :: ext :: scale_encode")]
            ///Some balance was locked.
            pub struct Locked {
                pub who: ::subxt::utils::AccountId32,
                pub amount: ::core::primitive::u128,
            }
            impl ::subxt::events::StaticEvent for Locked {
                const PALLET: &'static str = "Balances";
                const EVENT: &'static str = "Locked";
            }
            #[derive(
                ::subxt::ext::codec::Decode,
                ::subxt::ext::codec::Encode,
                ::subxt::ext::scale_decode::DecodeAsType,
                ::subxt::ext::scale_encode::EncodeAsType,
                Clone,
                Debug,
                Eq,
                PartialEq
            )]
            #[codec(crate = ::subxt::ext::codec)]
            #[decode_as_type(crate_path = ":: subxt :: ext :: scale_decode")]
            #[encode_as_type(crate_path = ":: subxt :: ext :: scale_encode")]
            ///Some balance was unlocked.
            pub struct Unlocked {
                pub who: ::subxt::utils::AccountId32,
                pub amount: ::core::primitive::u128,
            }
            impl ::subxt::events::StaticEvent for Unlocked {
                const PALLET: &'static str = "Balances";
                const EVENT: &'static str = "Unlocked";
            }
            #[derive(
                ::subxt::ext::codec::Decode,
                ::subxt::ext::codec::Encode,
                ::subxt::ext::scale_decode::DecodeAsType,
                ::subxt::ext::scale_encode::EncodeAsType,
                Clone,
                Debug,
                Eq,
                PartialEq
            )]
            #[codec(crate = ::subxt::ext::codec)]
            #[decode_as_type(crate_path = ":: subxt :: ext :: scale_decode")]
            #[encode_as_type(crate_path = ":: subxt :: ext :: scale_encode")]
            ///Some balance was frozen.
            pub struct Frozen {
                pub who: ::subxt::utils::AccountId32,
                pub amount: ::core::primitive::u128,
            }
            impl ::subxt::events::StaticEvent for Frozen {
                const PALLET: &'static str = "Balances";
                const EVENT: &'static str = "Frozen";
            }
            #[derive(
                ::subxt::ext::codec::Decode,
                ::subxt::ext::codec::Encode,
                ::subxt::ext::scale_decode::DecodeAsType,
                ::subxt::ext::scale_encode::EncodeAsType,
                Clone,
                Debug,
                Eq,
                PartialEq
            )]
            #[codec(crate = ::subxt::ext::codec)]
            #[decode_as_type(crate_path = ":: subxt :: ext :: scale_decode")]
            #[encode_as_type(crate_path = ":: subxt :: ext :: scale_encode")]
            ///Some balance was thawed.
            pub struct Thawed {
                pub who: ::subxt::utils::AccountId32,
                pub amount: ::core::primitive::u128,
            }
            impl ::subxt::events::StaticEvent for Thawed {
                const PALLET: &'static str = "Balances";
                const EVENT: &'static str = "Thawed";
            }
        }
        pub mod storage {
            use super::runtime_types;
            pub struct StorageApi;
            impl StorageApi {
                /// The total units issued in the system.
                pub fn total_issuance(
                    &self,
                ) -> ::subxt::storage::address::Address<
                    ::subxt::storage::address::StaticStorageMapKey,
                    ::core::primitive::u128,
                    ::subxt::storage::address::Yes,
                    ::subxt::storage::address::Yes,
                    (),
                > {
                    ::subxt::storage::address::Address::new_static(
                        "Balances",
                        "TotalIssuance",
                        vec![],
                        [
                            116u8,
                            70u8,
                            119u8,
                            194u8,
                            69u8,
                            37u8,
                            116u8,
                            206u8,
                            171u8,
                            70u8,
                            171u8,
                            210u8,
                            226u8,
                            111u8,
                            184u8,
                            204u8,
                            206u8,
                            11u8,
                            68u8,
                            72u8,
                            255u8,
                            19u8,
                            194u8,
                            11u8,
                            27u8,
                            194u8,
                            81u8,
                            204u8,
                            59u8,
                            224u8,
                            202u8,
                            185u8,
                        ],
                    )
                }
                /// The total units of outstanding deactivated balance in the system.
                pub fn inactive_issuance(
                    &self,
                ) -> ::subxt::storage::address::Address<
                    ::subxt::storage::address::StaticStorageMapKey,
                    ::core::primitive::u128,
                    ::subxt::storage::address::Yes,
                    ::subxt::storage::address::Yes,
                    (),
                > {
                    ::subxt::storage::address::Address::new_static(
                        "Balances",
                        "InactiveIssuance",
                        vec![],
                        [
                            212u8,
                            185u8,
                            19u8,
                            50u8,
                            250u8,
                            72u8,
                            173u8,
                            50u8,
                            4u8,
                            104u8,
                            161u8,
                            249u8,
                            77u8,
                            247u8,
                            204u8,
                            248u8,
                            11u8,
                            18u8,
                            57u8,
                            4u8,
                            82u8,
                            110u8,
                            30u8,
                            216u8,
                            16u8,
                            37u8,
                            87u8,
                            67u8,
                            189u8,
                            235u8,
                            214u8,
                            155u8,
                        ],
                    )
                }
                /// The Balances pallet example of storing the balance of an account.
                ///
                /// # Example
                ///
                /// ```nocompile
                ///  impl pallet_balances::Config for Runtime {
                ///    type AccountStore = StorageMapShim<Self::Account<Runtime>, frame_system::Provider<Runtime>, AccountId, Self::AccountData<Balance>>
                ///  }
                /// ```
                ///
                /// You can also store the balance of an account in the `System` pallet.
                ///
                /// # Example
                ///
                /// ```nocompile
                ///  impl pallet_balances::Config for Runtime {
                ///   type AccountStore = System
                ///  }
                /// ```
                ///
                /// But this comes with tradeoffs, storing account balances in the system pallet stores
                /// `frame_system` data alongside the account data contrary to storing account balances in the
                /// `Balances` pallet, which uses a `StorageMap` to store balances data only.
                /// NOTE: This is only used in the case that this pallet is used to store balances.
                pub fn account(
                    &self,
                    _0: impl ::std::borrow::Borrow<::subxt::utils::AccountId32>,
                ) -> ::subxt::storage::address::Address<
                    ::subxt::storage::address::StaticStorageMapKey,
                    runtime_types::pallet_balances::types::AccountData<
                        ::core::primitive::u128,
                    >,
                    ::subxt::storage::address::Yes,
                    ::subxt::storage::address::Yes,
                    ::subxt::storage::address::Yes,
                > {
                    ::subxt::storage::address::Address::new_static(
                        "Balances",
                        "Account",
                        vec![
                            ::subxt::storage::address::make_static_storage_map_key(_0
                            .borrow())
                        ],
                        [
                            47u8,
                            253u8,
                            83u8,
                            165u8,
                            18u8,
                            176u8,
                            62u8,
                            239u8,
                            78u8,
                            85u8,
                            231u8,
                            235u8,
                            157u8,
                            145u8,
                            251u8,
                            35u8,
                            225u8,
                            171u8,
                            82u8,
                            167u8,
                            68u8,
                            206u8,
                            28u8,
                            169u8,
                            8u8,
                            93u8,
                            169u8,
                            101u8,
                            180u8,
                            206u8,
                            231u8,
                            143u8,
                        ],
                    )
                }
                /// The Balances pallet example of storing the balance of an account.
                ///
                /// # Example
                ///
                /// ```nocompile
                ///  impl pallet_balances::Config for Runtime {
                ///    type AccountStore = StorageMapShim<Self::Account<Runtime>, frame_system::Provider<Runtime>, AccountId, Self::AccountData<Balance>>
                ///  }
                /// ```
                ///
                /// You can also store the balance of an account in the `System` pallet.
                ///
                /// # Example
                ///
                /// ```nocompile
                ///  impl pallet_balances::Config for Runtime {
                ///   type AccountStore = System
                ///  }
                /// ```
                ///
                /// But this comes with tradeoffs, storing account balances in the system pallet stores
                /// `frame_system` data alongside the account data contrary to storing account balances in the
                /// `Balances` pallet, which uses a `StorageMap` to store balances data only.
                /// NOTE: This is only used in the case that this pallet is used to store balances.
                pub fn account_root(
                    &self,
                ) -> ::subxt::storage::address::Address<
                    ::subxt::storage::address::StaticStorageMapKey,
                    runtime_types::pallet_balances::types::AccountData<
                        ::core::primitive::u128,
                    >,
                    (),
                    ::subxt::storage::address::Yes,
                    ::subxt::storage::address::Yes,
                > {
                    ::subxt::storage::address::Address::new_static(
                        "Balances",
                        "Account",
                        Vec::new(),
                        [
                            47u8,
                            253u8,
                            83u8,
                            165u8,
                            18u8,
                            176u8,
                            62u8,
                            239u8,
                            78u8,
                            85u8,
                            231u8,
                            235u8,
                            157u8,
                            145u8,
                            251u8,
                            35u8,
                            225u8,
                            171u8,
                            82u8,
                            167u8,
                            68u8,
                            206u8,
                            28u8,
                            169u8,
                            8u8,
                            93u8,
                            169u8,
                            101u8,
                            180u8,
                            206u8,
                            231u8,
                            143u8,
                        ],
                    )
                }
                /// Any liquidity locks on some account balances.
                /// NOTE: Should only be accessed when setting, changing and freeing a lock.
                pub fn locks(
                    &self,
                    _0: impl ::std::borrow::Borrow<::subxt::utils::AccountId32>,
                ) -> ::subxt::storage::address::Address<
                    ::subxt::storage::address::StaticStorageMapKey,
                    runtime_types::bounded_collections::weak_bounded_vec::WeakBoundedVec<
                        runtime_types::pallet_balances::types::BalanceLock<
                            ::core::primitive::u128,
                        >,
                    >,
                    ::subxt::storage::address::Yes,
                    ::subxt::storage::address::Yes,
                    ::subxt::storage::address::Yes,
                > {
                    ::subxt::storage::address::Address::new_static(
                        "Balances",
                        "Locks",
                        vec![
                            ::subxt::storage::address::make_static_storage_map_key(_0
                            .borrow())
                        ],
                        [
                            44u8,
                            44u8,
                            48u8,
                            20u8,
                            121u8,
                            168u8,
                            200u8,
                            87u8,
                            205u8,
                            172u8,
                            111u8,
                            208u8,
                            62u8,
                            243u8,
                            225u8,
                            223u8,
                            181u8,
                            36u8,
                            197u8,
                            9u8,
                            52u8,
                            182u8,
                            113u8,
                            55u8,
                            126u8,
                            164u8,
                            82u8,
                            209u8,
                            151u8,
                            126u8,
                            186u8,
                            85u8,
                        ],
                    )
                }
                /// Any liquidity locks on some account balances.
                /// NOTE: Should only be accessed when setting, changing and freeing a lock.
                pub fn locks_root(
                    &self,
                ) -> ::subxt::storage::address::Address<
                    ::subxt::storage::address::StaticStorageMapKey,
                    runtime_types::bounded_collections::weak_bounded_vec::WeakBoundedVec<
                        runtime_types::pallet_balances::types::BalanceLock<
                            ::core::primitive::u128,
                        >,
                    >,
                    (),
                    ::subxt::storage::address::Yes,
                    ::subxt::storage::address::Yes,
                > {
                    ::subxt::storage::address::Address::new_static(
                        "Balances",
                        "Locks",
                        Vec::new(),
                        [
                            44u8,
                            44u8,
                            48u8,
                            20u8,
                            121u8,
                            168u8,
                            200u8,
                            87u8,
                            205u8,
                            172u8,
                            111u8,
                            208u8,
                            62u8,
                            243u8,
                            225u8,
                            223u8,
                            181u8,
                            36u8,
                            197u8,
                            9u8,
                            52u8,
                            182u8,
                            113u8,
                            55u8,
                            126u8,
                            164u8,
                            82u8,
                            209u8,
                            151u8,
                            126u8,
                            186u8,
                            85u8,
                        ],
                    )
                }
                /// Named reserves on some account balances.
                pub fn reserves(
                    &self,
                    _0: impl ::std::borrow::Borrow<::subxt::utils::AccountId32>,
                ) -> ::subxt::storage::address::Address<
                    ::subxt::storage::address::StaticStorageMapKey,
                    runtime_types::bounded_collections::bounded_vec::BoundedVec<
                        runtime_types::pallet_balances::types::ReserveData<
                            [::core::primitive::u8; 8usize],
                            ::core::primitive::u128,
                        >,
                    >,
                    ::subxt::storage::address::Yes,
                    ::subxt::storage::address::Yes,
                    ::subxt::storage::address::Yes,
                > {
                    ::subxt::storage::address::Address::new_static(
                        "Balances",
                        "Reserves",
                        vec![
                            ::subxt::storage::address::make_static_storage_map_key(_0
                            .borrow())
                        ],
                        [
                            192u8,
                            99u8,
                            91u8,
                            129u8,
                            195u8,
                            73u8,
                            153u8,
                            126u8,
                            82u8,
                            52u8,
                            56u8,
                            85u8,
                            105u8,
                            178u8,
                            113u8,
                            101u8,
                            229u8,
                            37u8,
                            242u8,
                            174u8,
                            166u8,
                            244u8,
                            68u8,
                            173u8,
                            14u8,
                            225u8,
                            172u8,
                            70u8,
                            181u8,
                            211u8,
                            165u8,
                            134u8,
                        ],
                    )
                }
                /// Named reserves on some account balances.
                pub fn reserves_root(
                    &self,
                ) -> ::subxt::storage::address::Address<
                    ::subxt::storage::address::StaticStorageMapKey,
                    runtime_types::bounded_collections::bounded_vec::BoundedVec<
                        runtime_types::pallet_balances::types::ReserveData<
                            [::core::primitive::u8; 8usize],
                            ::core::primitive::u128,
                        >,
                    >,
                    (),
                    ::subxt::storage::address::Yes,
                    ::subxt::storage::address::Yes,
                > {
                    ::subxt::storage::address::Address::new_static(
                        "Balances",
                        "Reserves",
                        Vec::new(),
                        [
                            192u8,
                            99u8,
                            91u8,
                            129u8,
                            195u8,
                            73u8,
                            153u8,
                            126u8,
                            82u8,
                            52u8,
                            56u8,
                            85u8,
                            105u8,
                            178u8,
                            113u8,
                            101u8,
                            229u8,
                            37u8,
                            242u8,
                            174u8,
                            166u8,
                            244u8,
                            68u8,
                            173u8,
                            14u8,
                            225u8,
                            172u8,
                            70u8,
                            181u8,
                            211u8,
                            165u8,
                            134u8,
                        ],
                    )
                }
                /// Holds on account balances.
                pub fn holds(
                    &self,
                    _0: impl ::std::borrow::Borrow<::subxt::utils::AccountId32>,
                ) -> ::subxt::storage::address::Address<
                    ::subxt::storage::address::StaticStorageMapKey,
                    runtime_types::bounded_collections::bounded_vec::BoundedVec<
                        runtime_types::pallet_balances::types::IdAmount<
                            (),
                            ::core::primitive::u128,
                        >,
                    >,
                    ::subxt::storage::address::Yes,
                    ::subxt::storage::address::Yes,
                    ::subxt::storage::address::Yes,
                > {
                    ::subxt::storage::address::Address::new_static(
                        "Balances",
                        "Holds",
                        vec![
                            ::subxt::storage::address::make_static_storage_map_key(_0
                            .borrow())
                        ],
                        [
                            53u8,
                            126u8,
                            215u8,
                            237u8,
                            42u8,
                            223u8,
                            188u8,
                            150u8,
                            230u8,
                            107u8,
                            95u8,
                            24u8,
                            26u8,
                            235u8,
                            158u8,
                            149u8,
                            193u8,
                            191u8,
                            10u8,
                            194u8,
                            231u8,
                            59u8,
                            35u8,
                            167u8,
                            186u8,
                            89u8,
                            43u8,
                            126u8,
                            215u8,
                            117u8,
                            1u8,
                            202u8,
                        ],
                    )
                }
                /// Holds on account balances.
                pub fn holds_root(
                    &self,
                ) -> ::subxt::storage::address::Address<
                    ::subxt::storage::address::StaticStorageMapKey,
                    runtime_types::bounded_collections::bounded_vec::BoundedVec<
                        runtime_types::pallet_balances::types::IdAmount<
                            (),
                            ::core::primitive::u128,
                        >,
                    >,
                    (),
                    ::subxt::storage::address::Yes,
                    ::subxt::storage::address::Yes,
                > {
                    ::subxt::storage::address::Address::new_static(
                        "Balances",
                        "Holds",
                        Vec::new(),
                        [
                            53u8,
                            126u8,
                            215u8,
                            237u8,
                            42u8,
                            223u8,
                            188u8,
                            150u8,
                            230u8,
                            107u8,
                            95u8,
                            24u8,
                            26u8,
                            235u8,
                            158u8,
                            149u8,
                            193u8,
                            191u8,
                            10u8,
                            194u8,
                            231u8,
                            59u8,
                            35u8,
                            167u8,
                            186u8,
                            89u8,
                            43u8,
                            126u8,
                            215u8,
                            117u8,
                            1u8,
                            202u8,
                        ],
                    )
                }
                /// Freeze locks on account balances.
                pub fn freezes(
                    &self,
                    _0: impl ::std::borrow::Borrow<::subxt::utils::AccountId32>,
                ) -> ::subxt::storage::address::Address<
                    ::subxt::storage::address::StaticStorageMapKey,
                    runtime_types::bounded_collections::bounded_vec::BoundedVec<
                        runtime_types::pallet_balances::types::IdAmount<
                            (),
                            ::core::primitive::u128,
                        >,
                    >,
                    ::subxt::storage::address::Yes,
                    ::subxt::storage::address::Yes,
                    ::subxt::storage::address::Yes,
                > {
                    ::subxt::storage::address::Address::new_static(
                        "Balances",
                        "Freezes",
                        vec![
                            ::subxt::storage::address::make_static_storage_map_key(_0
                            .borrow())
                        ],
                        [
                            69u8,
                            49u8,
                            165u8,
                            76u8,
                            135u8,
                            142u8,
                            179u8,
                            118u8,
                            50u8,
                            109u8,
                            53u8,
                            112u8,
                            110u8,
                            94u8,
                            30u8,
                            93u8,
                            173u8,
                            38u8,
                            27u8,
                            142u8,
                            19u8,
                            5u8,
                            163u8,
                            4u8,
                            68u8,
                            218u8,
                            179u8,
                            224u8,
                            118u8,
                            218u8,
                            115u8,
                            64u8,
                        ],
                    )
                }
                /// Freeze locks on account balances.
                pub fn freezes_root(
                    &self,
                ) -> ::subxt::storage::address::Address<
                    ::subxt::storage::address::StaticStorageMapKey,
                    runtime_types::bounded_collections::bounded_vec::BoundedVec<
                        runtime_types::pallet_balances::types::IdAmount<
                            (),
                            ::core::primitive::u128,
                        >,
                    >,
                    (),
                    ::subxt::storage::address::Yes,
                    ::subxt::storage::address::Yes,
                > {
                    ::subxt::storage::address::Address::new_static(
                        "Balances",
                        "Freezes",
                        Vec::new(),
                        [
                            69u8,
                            49u8,
                            165u8,
                            76u8,
                            135u8,
                            142u8,
                            179u8,
                            118u8,
                            50u8,
                            109u8,
                            53u8,
                            112u8,
                            110u8,
                            94u8,
                            30u8,
                            93u8,
                            173u8,
                            38u8,
                            27u8,
                            142u8,
                            19u8,
                            5u8,
                            163u8,
                            4u8,
                            68u8,
                            218u8,
                            179u8,
                            224u8,
                            118u8,
                            218u8,
                            115u8,
                            64u8,
                        ],
                    )
                }
            }
        }
        pub mod constants {
            use super::runtime_types;
            pub struct ConstantsApi;
            impl ConstantsApi {
                /// The minimum amount required to keep an account open. MUST BE GREATER THAN ZERO!
                ///
                /// If you *really* need it to be zero, you can enable the feature `insecure_zero_ed` for
                /// this pallet. However, you do so at your own risk: this will open up a major DoS vector.
                /// In case you have multiple sources of provider references, you may also get unexpected
                /// behaviour if you set this to zero.
                ///
                /// Bottom line: Do yourself a favour and make it at least one!
                pub fn existential_deposit(
                    &self,
                ) -> ::subxt::constants::Address<::core::primitive::u128> {
                    ::subxt::constants::Address::new_static(
                        "Balances",
                        "ExistentialDeposit",
                        [
                            84u8,
                            157u8,
                            140u8,
                            4u8,
                            93u8,
                            57u8,
                            29u8,
                            133u8,
                            105u8,
                            200u8,
                            214u8,
                            27u8,
                            144u8,
                            208u8,
                            218u8,
                            160u8,
                            130u8,
                            109u8,
                            101u8,
                            54u8,
                            210u8,
                            136u8,
                            71u8,
                            63u8,
                            49u8,
                            237u8,
                            234u8,
                            15u8,
                            178u8,
                            98u8,
                            148u8,
                            156u8,
                        ],
                    )
                }
                /// The maximum number of locks that should exist on an account.
                /// Not strictly enforced, but used for weight estimation.
                pub fn max_locks(
                    &self,
                ) -> ::subxt::constants::Address<::core::primitive::u32> {
                    ::subxt::constants::Address::new_static(
                        "Balances",
                        "MaxLocks",
                        [
                            98u8,
                            252u8,
                            116u8,
                            72u8,
                            26u8,
                            180u8,
                            225u8,
                            83u8,
                            200u8,
                            157u8,
                            125u8,
                            151u8,
                            53u8,
                            76u8,
                            168u8,
                            26u8,
                            10u8,
                            9u8,
                            98u8,
                            68u8,
                            9u8,
                            178u8,
                            197u8,
                            113u8,
                            31u8,
                            79u8,
                            200u8,
                            90u8,
                            203u8,
                            100u8,
                            41u8,
                            145u8,
                        ],
                    )
                }
                /// The maximum number of named reserves that can exist on an account.
                pub fn max_reserves(
                    &self,
                ) -> ::subxt::constants::Address<::core::primitive::u32> {
                    ::subxt::constants::Address::new_static(
                        "Balances",
                        "MaxReserves",
                        [
                            98u8,
                            252u8,
                            116u8,
                            72u8,
                            26u8,
                            180u8,
                            225u8,
                            83u8,
                            200u8,
                            157u8,
                            125u8,
                            151u8,
                            53u8,
                            76u8,
                            168u8,
                            26u8,
                            10u8,
                            9u8,
                            98u8,
                            68u8,
                            9u8,
                            178u8,
                            197u8,
                            113u8,
                            31u8,
                            79u8,
                            200u8,
                            90u8,
                            203u8,
                            100u8,
                            41u8,
                            145u8,
                        ],
                    )
                }
                /// The maximum number of holds that can exist on an account at any time.
                pub fn max_holds(
                    &self,
                ) -> ::subxt::constants::Address<::core::primitive::u32> {
                    ::subxt::constants::Address::new_static(
                        "Balances",
                        "MaxHolds",
                        [
                            98u8,
                            252u8,
                            116u8,
                            72u8,
                            26u8,
                            180u8,
                            225u8,
                            83u8,
                            200u8,
                            157u8,
                            125u8,
                            151u8,
                            53u8,
                            76u8,
                            168u8,
                            26u8,
                            10u8,
                            9u8,
                            98u8,
                            68u8,
                            9u8,
                            178u8,
                            197u8,
                            113u8,
                            31u8,
                            79u8,
                            200u8,
                            90u8,
                            203u8,
                            100u8,
                            41u8,
                            145u8,
                        ],
                    )
                }
                /// The maximum number of individual freeze locks that can exist on an account at any time.
                pub fn max_freezes(
                    &self,
                ) -> ::subxt::constants::Address<::core::primitive::u32> {
                    ::subxt::constants::Address::new_static(
                        "Balances",
                        "MaxFreezes",
                        [
                            98u8,
                            252u8,
                            116u8,
                            72u8,
                            26u8,
                            180u8,
                            225u8,
                            83u8,
                            200u8,
                            157u8,
                            125u8,
                            151u8,
                            53u8,
                            76u8,
                            168u8,
                            26u8,
                            10u8,
                            9u8,
                            98u8,
                            68u8,
                            9u8,
                            178u8,
                            197u8,
                            113u8,
                            31u8,
                            79u8,
                            200u8,
                            90u8,
                            203u8,
                            100u8,
                            41u8,
                            145u8,
                        ],
                    )
                }
            }
        }
    }
    pub mod transaction_payment {
        use super::root_mod;
        use super::runtime_types;
        /**
			The [event](https://docs.substrate.io/main-docs/build/events-errors/) emitted
			by this pallet.
			*/
        pub type Event = runtime_types::pallet_transaction_payment::pallet::Event;
        pub mod events {
            use super::runtime_types;
            #[derive(
                ::subxt::ext::codec::Decode,
                ::subxt::ext::codec::Encode,
                ::subxt::ext::scale_decode::DecodeAsType,
                ::subxt::ext::scale_encode::EncodeAsType,
                Clone,
                Debug,
                Eq,
                PartialEq
            )]
            #[codec(crate = ::subxt::ext::codec)]
            #[decode_as_type(crate_path = ":: subxt :: ext :: scale_decode")]
            #[encode_as_type(crate_path = ":: subxt :: ext :: scale_encode")]
            ///A transaction fee `actual_fee`, of which `tip` was added to the minimum inclusion fee,
            ///has been paid by `who`.
            pub struct TransactionFeePaid {
                pub who: ::subxt::utils::AccountId32,
                pub actual_fee: ::core::primitive::u128,
                pub tip: ::core::primitive::u128,
            }
            impl ::subxt::events::StaticEvent for TransactionFeePaid {
                const PALLET: &'static str = "TransactionPayment";
                const EVENT: &'static str = "TransactionFeePaid";
            }
        }
        pub mod storage {
            use super::runtime_types;
            pub struct StorageApi;
            impl StorageApi {
                pub fn next_fee_multiplier(
                    &self,
                ) -> ::subxt::storage::address::Address<
                    ::subxt::storage::address::StaticStorageMapKey,
                    runtime_types::sp_arithmetic::fixed_point::FixedU128,
                    ::subxt::storage::address::Yes,
                    ::subxt::storage::address::Yes,
                    (),
                > {
                    ::subxt::storage::address::Address::new_static(
                        "TransactionPayment",
                        "NextFeeMultiplier",
                        vec![],
                        [
                            247u8,
                            39u8,
                            81u8,
                            170u8,
                            225u8,
                            226u8,
                            82u8,
                            147u8,
                            34u8,
                            113u8,
                            147u8,
                            213u8,
                            59u8,
                            80u8,
                            139u8,
                            35u8,
                            36u8,
                            196u8,
                            152u8,
                            19u8,
                            9u8,
                            159u8,
                            176u8,
                            79u8,
                            249u8,
                            201u8,
                            170u8,
                            1u8,
                            129u8,
                            79u8,
                            146u8,
                            197u8,
                        ],
                    )
                }
                pub fn storage_version(
                    &self,
                ) -> ::subxt::storage::address::Address<
                    ::subxt::storage::address::StaticStorageMapKey,
                    runtime_types::pallet_transaction_payment::Releases,
                    ::subxt::storage::address::Yes,
                    ::subxt::storage::address::Yes,
                    (),
                > {
                    ::subxt::storage::address::Address::new_static(
                        "TransactionPayment",
                        "StorageVersion",
                        vec![],
                        [
                            105u8,
                            243u8,
                            158u8,
                            241u8,
                            159u8,
                            231u8,
                            253u8,
                            6u8,
                            4u8,
                            32u8,
                            85u8,
                            178u8,
                            126u8,
                            31u8,
                            203u8,
                            134u8,
                            154u8,
                            38u8,
                            122u8,
                            155u8,
                            150u8,
                            251u8,
                            174u8,
                            15u8,
                            74u8,
                            134u8,
                            216u8,
                            244u8,
                            168u8,
                            175u8,
                            158u8,
                            144u8,
                        ],
                    )
                }
            }
        }
        pub mod constants {
            use super::runtime_types;
            pub struct ConstantsApi;
            impl ConstantsApi {
                /// A fee mulitplier for `Operational` extrinsics to compute "virtual tip" to boost their
                /// `priority`
                ///
                /// This value is multipled by the `final_fee` to obtain a "virtual tip" that is later
                /// added to a tip component in regular `priority` calculations.
                /// It means that a `Normal` transaction can front-run a similarly-sized `Operational`
                /// extrinsic (with no tip), by including a tip value greater than the virtual tip.
                ///
                /// ```rust,ignore
                /// // For `Normal`
                /// let priority = priority_calc(tip);
                ///
                /// // For `Operational`
                /// let virtual_tip = (inclusion_fee + tip) * OperationalFeeMultiplier;
                /// let priority = priority_calc(tip + virtual_tip);
                /// ```
                ///
                /// Note that since we use `final_fee` the multiplier applies also to the regular `tip`
                /// sent with the transaction. So, not only does the transaction get a priority bump based
                /// on the `inclusion_fee`, but we also amplify the impact of tips applied to `Operational`
                /// transactions.
                pub fn operational_fee_multiplier(
                    &self,
                ) -> ::subxt::constants::Address<::core::primitive::u8> {
                    ::subxt::constants::Address::new_static(
                        "TransactionPayment",
                        "OperationalFeeMultiplier",
                        [
                            141u8,
                            130u8,
                            11u8,
                            35u8,
                            226u8,
                            114u8,
                            92u8,
                            179u8,
                            168u8,
                            110u8,
                            28u8,
                            91u8,
                            221u8,
                            64u8,
                            4u8,
                            148u8,
                            201u8,
                            193u8,
                            185u8,
                            66u8,
                            226u8,
                            114u8,
                            97u8,
                            79u8,
                            62u8,
                            212u8,
                            202u8,
                            114u8,
                            237u8,
                            228u8,
                            183u8,
                            165u8,
                        ],
                    )
                }
            }
        }
    }
    pub mod authorship {
        use super::root_mod;
        use super::runtime_types;
        pub mod storage {
            use super::runtime_types;
            pub struct StorageApi;
            impl StorageApi {
                /// Author of current block.
                pub fn author(
                    &self,
                ) -> ::subxt::storage::address::Address<
                    ::subxt::storage::address::StaticStorageMapKey,
                    ::subxt::utils::AccountId32,
                    ::subxt::storage::address::Yes,
                    (),
                    (),
                > {
                    ::subxt::storage::address::Address::new_static(
                        "Authorship",
                        "Author",
                        vec![],
                        [
                            247u8,
                            192u8,
                            118u8,
                            227u8,
                            47u8,
                            20u8,
                            203u8,
                            199u8,
                            216u8,
                            87u8,
                            220u8,
                            50u8,
                            166u8,
                            61u8,
                            168u8,
                            213u8,
                            253u8,
                            62u8,
                            202u8,
                            199u8,
                            61u8,
                            192u8,
                            237u8,
                            53u8,
                            22u8,
                            148u8,
                            164u8,
                            245u8,
                            99u8,
                            24u8,
                            146u8,
                            18u8,
                        ],
                    )
                }
            }
        }
    }
    pub mod aura {
        use super::root_mod;
        use super::runtime_types;
        pub mod storage {
            use super::runtime_types;
            pub struct StorageApi;
            impl StorageApi {
                /// The current authority set.
                pub fn authorities(
                    &self,
                ) -> ::subxt::storage::address::Address<
                    ::subxt::storage::address::StaticStorageMapKey,
                    runtime_types::bounded_collections::bounded_vec::BoundedVec<
                        runtime_types::sp_consensus_aura::sr25519::app_sr25519::Public,
                    >,
                    ::subxt::storage::address::Yes,
                    ::subxt::storage::address::Yes,
                    (),
                > {
                    ::subxt::storage::address::Address::new_static(
                        "Aura",
                        "Authorities",
                        vec![],
                        [
                            232u8,
                            129u8,
                            167u8,
                            104u8,
                            47u8,
                            188u8,
                            238u8,
                            164u8,
                            6u8,
                            29u8,
                            129u8,
                            45u8,
                            64u8,
                            182u8,
                            194u8,
                            47u8,
                            0u8,
                            73u8,
                            63u8,
                            102u8,
                            204u8,
                            94u8,
                            111u8,
                            96u8,
                            137u8,
                            7u8,
                            141u8,
                            110u8,
                            180u8,
                            80u8,
                            228u8,
                            16u8,
                        ],
                    )
                }
                /// The current slot of this block.
                ///
                /// This will be set in `on_initialize`.
                pub fn current_slot(
                    &self,
                ) -> ::subxt::storage::address::Address<
                    ::subxt::storage::address::StaticStorageMapKey,
                    runtime_types::sp_consensus_slots::Slot,
                    ::subxt::storage::address::Yes,
                    ::subxt::storage::address::Yes,
                    (),
                > {
                    ::subxt::storage::address::Address::new_static(
                        "Aura",
                        "CurrentSlot",
                        vec![],
                        [
                            112u8,
                            199u8,
                            115u8,
                            248u8,
                            217u8,
                            242u8,
                            45u8,
                            231u8,
                            178u8,
                            53u8,
                            236u8,
                            167u8,
                            219u8,
                            238u8,
                            81u8,
                            243u8,
                            39u8,
                            140u8,
                            68u8,
                            19u8,
                            201u8,
                            169u8,
                            211u8,
                            133u8,
                            135u8,
                            213u8,
                            150u8,
                            105u8,
                            60u8,
                            252u8,
                            43u8,
                            57u8,
                        ],
                    )
                }
            }
        }
    }
    pub mod grandpa {
        use super::root_mod;
        use super::runtime_types;
        /**
			Custom [dispatch errors](https://docs.substrate.io/main-docs/build/events-errors/)
			of this pallet.
			*/
        pub type Error = runtime_types::pallet_grandpa::pallet::Error;
        ///Contains one variant per dispatchable that can be called by an extrinsic.
        pub type Call = runtime_types::pallet_grandpa::pallet::Call;
        pub mod calls {
            use super::root_mod;
            use super::runtime_types;
            type DispatchError = runtime_types::sp_runtime::DispatchError;
            pub mod types {
                use super::runtime_types;
                #[derive(
                    ::subxt::ext::codec::Decode,
                    ::subxt::ext::codec::Encode,
                    ::subxt::ext::scale_decode::DecodeAsType,
                    ::subxt::ext::scale_encode::EncodeAsType,
                    Clone,
                    Debug,
                    Eq,
                    PartialEq
                )]
                #[codec(crate = ::subxt::ext::codec)]
                #[decode_as_type(crate_path = ":: subxt :: ext :: scale_decode")]
                #[encode_as_type(crate_path = ":: subxt :: ext :: scale_encode")]
                pub struct ReportEquivocation {
                    pub equivocation_proof: ::std::boxed::Box<
                        runtime_types::sp_consensus_grandpa::EquivocationProof<
                            ::subxt::utils::H256,
                            ::core::primitive::u32,
                        >,
                    >,
                    pub key_owner_proof: runtime_types::sp_core::Void,
                }
                impl ::subxt::blocks::StaticExtrinsic for ReportEquivocation {
                    const PALLET: &'static str = "Grandpa";
                    const CALL: &'static str = "report_equivocation";
                }
                #[derive(
                    ::subxt::ext::codec::Decode,
                    ::subxt::ext::codec::Encode,
                    ::subxt::ext::scale_decode::DecodeAsType,
                    ::subxt::ext::scale_encode::EncodeAsType,
                    Clone,
                    Debug,
                    Eq,
                    PartialEq
                )]
                #[codec(crate = ::subxt::ext::codec)]
                #[decode_as_type(crate_path = ":: subxt :: ext :: scale_decode")]
                #[encode_as_type(crate_path = ":: subxt :: ext :: scale_encode")]
                pub struct ReportEquivocationUnsigned {
                    pub equivocation_proof: ::std::boxed::Box<
                        runtime_types::sp_consensus_grandpa::EquivocationProof<
                            ::subxt::utils::H256,
                            ::core::primitive::u32,
                        >,
                    >,
                    pub key_owner_proof: runtime_types::sp_core::Void,
                }
                impl ::subxt::blocks::StaticExtrinsic for ReportEquivocationUnsigned {
                    const PALLET: &'static str = "Grandpa";
                    const CALL: &'static str = "report_equivocation_unsigned";
                }
                #[derive(
                    ::subxt::ext::codec::Decode,
                    ::subxt::ext::codec::Encode,
                    ::subxt::ext::scale_decode::DecodeAsType,
                    ::subxt::ext::scale_encode::EncodeAsType,
                    Clone,
                    Debug,
                    Eq,
                    PartialEq
                )]
                #[codec(crate = ::subxt::ext::codec)]
                #[decode_as_type(crate_path = ":: subxt :: ext :: scale_decode")]
                #[encode_as_type(crate_path = ":: subxt :: ext :: scale_encode")]
                pub struct NoteStalled {
                    pub delay: ::core::primitive::u32,
                    pub best_finalized_block_number: ::core::primitive::u32,
                }
                impl ::subxt::blocks::StaticExtrinsic for NoteStalled {
                    const PALLET: &'static str = "Grandpa";
                    const CALL: &'static str = "note_stalled";
                }
            }
            pub struct TransactionApi;
            impl TransactionApi {
                ///Report voter equivocation/misbehavior. This method will verify the
                ///equivocation proof and validate the given key ownership proof
                ///against the extracted offender. If both are valid, the offence
                ///will be reported.
                pub fn report_equivocation(
                    &self,
                    equivocation_proof: runtime_types::sp_consensus_grandpa::EquivocationProof<
                        ::subxt::utils::H256,
                        ::core::primitive::u32,
                    >,
                    key_owner_proof: runtime_types::sp_core::Void,
                ) -> ::subxt::tx::Payload<types::ReportEquivocation> {
                    ::subxt::tx::Payload::new_static(
                        "Grandpa",
                        "report_equivocation",
                        types::ReportEquivocation {
                            equivocation_proof: ::std::boxed::Box::new(
                                equivocation_proof,
                            ),
                            key_owner_proof,
                        },
                        [
                            73u8,
                            240u8,
                            131u8,
                            56u8,
                            54u8,
                            150u8,
                            13u8,
                            201u8,
                            230u8,
                            52u8,
                            71u8,
                            43u8,
                            28u8,
                            181u8,
                            156u8,
                            145u8,
                            127u8,
                            42u8,
                            13u8,
                            57u8,
                            54u8,
                            163u8,
                            117u8,
                            191u8,
                            174u8,
                            64u8,
                            229u8,
                            156u8,
                            28u8,
                            181u8,
                            230u8,
                            42u8,
                        ],
                    )
                }
                ///Report voter equivocation/misbehavior. This method will verify the
                ///equivocation proof and validate the given key ownership proof
                ///against the extracted offender. If both are valid, the offence
                ///will be reported.
                ///
                ///This extrinsic must be called unsigned and it is expected that only
                ///block authors will call it (validated in `ValidateUnsigned`), as such
                ///if the block author is defined it will be defined as the equivocation
                ///reporter.
                pub fn report_equivocation_unsigned(
                    &self,
                    equivocation_proof: runtime_types::sp_consensus_grandpa::EquivocationProof<
                        ::subxt::utils::H256,
                        ::core::primitive::u32,
                    >,
                    key_owner_proof: runtime_types::sp_core::Void,
                ) -> ::subxt::tx::Payload<types::ReportEquivocationUnsigned> {
                    ::subxt::tx::Payload::new_static(
                        "Grandpa",
                        "report_equivocation_unsigned",
                        types::ReportEquivocationUnsigned {
                            equivocation_proof: ::std::boxed::Box::new(
                                equivocation_proof,
                            ),
                            key_owner_proof,
                        },
                        [
                            164u8,
                            101u8,
                            158u8,
                            143u8,
                            211u8,
                            35u8,
                            126u8,
                            243u8,
                            179u8,
                            133u8,
                            231u8,
                            44u8,
                            17u8,
                            234u8,
                            224u8,
                            191u8,
                            242u8,
                            206u8,
                            8u8,
                            205u8,
                            191u8,
                            103u8,
                            140u8,
                            184u8,
                            236u8,
                            195u8,
                            162u8,
                            148u8,
                            246u8,
                            147u8,
                            87u8,
                            247u8,
                        ],
                    )
                }
                ///Note that the current authority set of the GRANDPA finality gadget has stalled.
                ///
                ///This will trigger a forced authority set change at the beginning of the next session, to
                ///be enacted `delay` blocks after that. The `delay` should be high enough to safely assume
                ///that the block signalling the forced change will not be re-orged e.g. 1000 blocks.
                ///The block production rate (which may be slowed down because of finality lagging) should
                ///be taken into account when choosing the `delay`. The GRANDPA voters based on the new
                ///authority will start voting on top of `best_finalized_block_number` for new finalized
                ///blocks. `best_finalized_block_number` should be the highest of the latest finalized
                ///block of all validators of the new authority set.
                ///
                ///Only callable by root.
                pub fn note_stalled(
                    &self,
                    delay: ::core::primitive::u32,
                    best_finalized_block_number: ::core::primitive::u32,
                ) -> ::subxt::tx::Payload<types::NoteStalled> {
                    ::subxt::tx::Payload::new_static(
                        "Grandpa",
                        "note_stalled",
                        types::NoteStalled {
                            delay,
                            best_finalized_block_number,
                        },
                        [
                            232u8,
                            162u8,
                            42u8,
                            199u8,
                            101u8,
                            116u8,
                            38u8,
                            27u8,
                            147u8,
                            15u8,
                            224u8,
                            76u8,
                            229u8,
                            244u8,
                            13u8,
                            49u8,
                            218u8,
                            232u8,
                            253u8,
                            37u8,
                            7u8,
                            222u8,
                            97u8,
                            158u8,
                            201u8,
                            199u8,
                            169u8,
                            218u8,
                            201u8,
                            136u8,
                            192u8,
                            128u8,
                        ],
                    )
                }
            }
        }
        /**
			The [event](https://docs.substrate.io/main-docs/build/events-errors/) emitted
			by this pallet.
			*/
        pub type Event = runtime_types::pallet_grandpa::pallet::Event;
        pub mod events {
            use super::runtime_types;
            #[derive(
                ::subxt::ext::codec::Decode,
                ::subxt::ext::codec::Encode,
                ::subxt::ext::scale_decode::DecodeAsType,
                ::subxt::ext::scale_encode::EncodeAsType,
                Clone,
                Debug,
                Eq,
                PartialEq
            )]
            #[codec(crate = ::subxt::ext::codec)]
            #[decode_as_type(crate_path = ":: subxt :: ext :: scale_decode")]
            #[encode_as_type(crate_path = ":: subxt :: ext :: scale_encode")]
            ///New authority set has been applied.
            pub struct NewAuthorities {
                pub authority_set: ::std::vec::Vec<
                    (
                        runtime_types::sp_consensus_grandpa::app::Public,
                        ::core::primitive::u64,
                    ),
                >,
            }
            impl ::subxt::events::StaticEvent for NewAuthorities {
                const PALLET: &'static str = "Grandpa";
                const EVENT: &'static str = "NewAuthorities";
            }
            #[derive(
                ::subxt::ext::codec::Decode,
                ::subxt::ext::codec::Encode,
                ::subxt::ext::scale_decode::DecodeAsType,
                ::subxt::ext::scale_encode::EncodeAsType,
                Clone,
                Debug,
                Eq,
                PartialEq
            )]
            #[codec(crate = ::subxt::ext::codec)]
            #[decode_as_type(crate_path = ":: subxt :: ext :: scale_decode")]
            #[encode_as_type(crate_path = ":: subxt :: ext :: scale_encode")]
            ///Current authority set has been paused.
            pub struct Paused;
            impl ::subxt::events::StaticEvent for Paused {
                const PALLET: &'static str = "Grandpa";
                const EVENT: &'static str = "Paused";
            }
            #[derive(
                ::subxt::ext::codec::Decode,
                ::subxt::ext::codec::Encode,
                ::subxt::ext::scale_decode::DecodeAsType,
                ::subxt::ext::scale_encode::EncodeAsType,
                Clone,
                Debug,
                Eq,
                PartialEq
            )]
            #[codec(crate = ::subxt::ext::codec)]
            #[decode_as_type(crate_path = ":: subxt :: ext :: scale_decode")]
            #[encode_as_type(crate_path = ":: subxt :: ext :: scale_encode")]
            ///Current authority set has been resumed.
            pub struct Resumed;
            impl ::subxt::events::StaticEvent for Resumed {
                const PALLET: &'static str = "Grandpa";
                const EVENT: &'static str = "Resumed";
            }
        }
        pub mod storage {
            use super::runtime_types;
            pub struct StorageApi;
            impl StorageApi {
                /// State of the current authority set.
                pub fn state(
                    &self,
                ) -> ::subxt::storage::address::Address<
                    ::subxt::storage::address::StaticStorageMapKey,
                    runtime_types::pallet_grandpa::StoredState<::core::primitive::u32>,
                    ::subxt::storage::address::Yes,
                    ::subxt::storage::address::Yes,
                    (),
                > {
                    ::subxt::storage::address::Address::new_static(
                        "Grandpa",
                        "State",
                        vec![],
                        [
                            254u8,
                            81u8,
                            54u8,
                            203u8,
                            26u8,
                            74u8,
                            162u8,
                            215u8,
                            165u8,
                            247u8,
                            143u8,
                            139u8,
                            242u8,
                            164u8,
                            67u8,
                            27u8,
                            97u8,
                            172u8,
                            66u8,
                            98u8,
                            28u8,
                            151u8,
                            32u8,
                            38u8,
                            209u8,
                            82u8,
                            41u8,
                            209u8,
                            72u8,
                            3u8,
                            167u8,
                            42u8,
                        ],
                    )
                }
                /// Pending change: (signaled at, scheduled change).
                pub fn pending_change(
                    &self,
                ) -> ::subxt::storage::address::Address<
                    ::subxt::storage::address::StaticStorageMapKey,
                    runtime_types::pallet_grandpa::StoredPendingChange<
                        ::core::primitive::u32,
                    >,
                    ::subxt::storage::address::Yes,
                    (),
                    (),
                > {
                    ::subxt::storage::address::Address::new_static(
                        "Grandpa",
                        "PendingChange",
                        vec![],
                        [
                            207u8,
                            134u8,
                            15u8,
                            77u8,
                            9u8,
                            253u8,
                            20u8,
                            132u8,
                            226u8,
                            115u8,
                            150u8,
                            184u8,
                            18u8,
                            15u8,
                            143u8,
                            172u8,
                            71u8,
                            114u8,
                            221u8,
                            162u8,
                            174u8,
                            205u8,
                            46u8,
                            144u8,
                            70u8,
                            116u8,
                            18u8,
                            105u8,
                            250u8,
                            44u8,
                            75u8,
                            27u8,
                        ],
                    )
                }
                /// next block number where we can force a change.
                pub fn next_forced(
                    &self,
                ) -> ::subxt::storage::address::Address<
                    ::subxt::storage::address::StaticStorageMapKey,
                    ::core::primitive::u32,
                    ::subxt::storage::address::Yes,
                    (),
                    (),
                > {
                    ::subxt::storage::address::Address::new_static(
                        "Grandpa",
                        "NextForced",
                        vec![],
                        [
                            3u8,
                            231u8,
                            56u8,
                            18u8,
                            87u8,
                            112u8,
                            227u8,
                            126u8,
                            180u8,
                            131u8,
                            255u8,
                            141u8,
                            82u8,
                            34u8,
                            61u8,
                            47u8,
                            234u8,
                            37u8,
                            95u8,
                            62u8,
                            33u8,
                            235u8,
                            231u8,
                            122u8,
                            125u8,
                            8u8,
                            223u8,
                            95u8,
                            255u8,
                            204u8,
                            40u8,
                            97u8,
                        ],
                    )
                }
                /// `true` if we are currently stalled.
                pub fn stalled(
                    &self,
                ) -> ::subxt::storage::address::Address<
                    ::subxt::storage::address::StaticStorageMapKey,
                    (::core::primitive::u32, ::core::primitive::u32),
                    ::subxt::storage::address::Yes,
                    (),
                    (),
                > {
                    ::subxt::storage::address::Address::new_static(
                        "Grandpa",
                        "Stalled",
                        vec![],
                        [
                            146u8,
                            18u8,
                            59u8,
                            59u8,
                            21u8,
                            246u8,
                            5u8,
                            167u8,
                            221u8,
                            8u8,
                            230u8,
                            74u8,
                            81u8,
                            217u8,
                            67u8,
                            158u8,
                            136u8,
                            36u8,
                            23u8,
                            106u8,
                            136u8,
                            89u8,
                            110u8,
                            217u8,
                            31u8,
                            138u8,
                            107u8,
                            251u8,
                            164u8,
                            10u8,
                            119u8,
                            18u8,
                        ],
                    )
                }
                /// The number of changes (both in terms of keys and underlying economic responsibilities)
                /// in the "set" of Grandpa validators from genesis.
                pub fn current_set_id(
                    &self,
                ) -> ::subxt::storage::address::Address<
                    ::subxt::storage::address::StaticStorageMapKey,
                    ::core::primitive::u64,
                    ::subxt::storage::address::Yes,
                    ::subxt::storage::address::Yes,
                    (),
                > {
                    ::subxt::storage::address::Address::new_static(
                        "Grandpa",
                        "CurrentSetId",
                        vec![],
                        [
                            234u8,
                            215u8,
                            218u8,
                            42u8,
                            30u8,
                            76u8,
                            129u8,
                            40u8,
                            125u8,
                            137u8,
                            207u8,
                            47u8,
                            46u8,
                            213u8,
                            159u8,
                            50u8,
                            175u8,
                            81u8,
                            155u8,
                            123u8,
                            246u8,
                            175u8,
                            156u8,
                            68u8,
                            22u8,
                            113u8,
                            135u8,
                            137u8,
                            163u8,
                            18u8,
                            115u8,
                            73u8,
                        ],
                    )
                }
                /// A mapping from grandpa set ID to the index of the *most recent* session for which its
                /// members were responsible.
                ///
                /// This is only used for validating equivocation proofs. An equivocation proof must
                /// contains a key-ownership proof for a given session, therefore we need a way to tie
                /// together sessions and GRANDPA set ids, i.e. we need to validate that a validator
                /// was the owner of a given key on a given session, and what the active set ID was
                /// during that session.
                ///
                /// TWOX-NOTE: `SetId` is not under user control.
                pub fn set_id_session(
                    &self,
                    _0: impl ::std::borrow::Borrow<::core::primitive::u64>,
                ) -> ::subxt::storage::address::Address<
                    ::subxt::storage::address::StaticStorageMapKey,
                    ::core::primitive::u32,
                    ::subxt::storage::address::Yes,
                    (),
                    ::subxt::storage::address::Yes,
                > {
                    ::subxt::storage::address::Address::new_static(
                        "Grandpa",
                        "SetIdSession",
                        vec![
                            ::subxt::storage::address::make_static_storage_map_key(_0
                            .borrow())
                        ],
                        [
                            47u8,
                            0u8,
                            239u8,
                            121u8,
                            187u8,
                            213u8,
                            254u8,
                            50u8,
                            238u8,
                            10u8,
                            162u8,
                            65u8,
                            189u8,
                            166u8,
                            37u8,
                            74u8,
                            82u8,
                            81u8,
                            160u8,
                            20u8,
                            180u8,
                            253u8,
                            238u8,
                            18u8,
                            209u8,
                            203u8,
                            38u8,
                            148u8,
                            16u8,
                            105u8,
                            72u8,
                            169u8,
                        ],
                    )
                }
                /// A mapping from grandpa set ID to the index of the *most recent* session for which its
                /// members were responsible.
                ///
                /// This is only used for validating equivocation proofs. An equivocation proof must
                /// contains a key-ownership proof for a given session, therefore we need a way to tie
                /// together sessions and GRANDPA set ids, i.e. we need to validate that a validator
                /// was the owner of a given key on a given session, and what the active set ID was
                /// during that session.
                ///
                /// TWOX-NOTE: `SetId` is not under user control.
                pub fn set_id_session_root(
                    &self,
                ) -> ::subxt::storage::address::Address<
                    ::subxt::storage::address::StaticStorageMapKey,
                    ::core::primitive::u32,
                    (),
                    (),
                    ::subxt::storage::address::Yes,
                > {
                    ::subxt::storage::address::Address::new_static(
                        "Grandpa",
                        "SetIdSession",
                        Vec::new(),
                        [
                            47u8,
                            0u8,
                            239u8,
                            121u8,
                            187u8,
                            213u8,
                            254u8,
                            50u8,
                            238u8,
                            10u8,
                            162u8,
                            65u8,
                            189u8,
                            166u8,
                            37u8,
                            74u8,
                            82u8,
                            81u8,
                            160u8,
                            20u8,
                            180u8,
                            253u8,
                            238u8,
                            18u8,
                            209u8,
                            203u8,
                            38u8,
                            148u8,
                            16u8,
                            105u8,
                            72u8,
                            169u8,
                        ],
                    )
                }
            }
        }
        pub mod constants {
            use super::runtime_types;
            pub struct ConstantsApi;
            impl ConstantsApi {
                /// Max Authorities in use
                pub fn max_authorities(
                    &self,
                ) -> ::subxt::constants::Address<::core::primitive::u32> {
                    ::subxt::constants::Address::new_static(
                        "Grandpa",
                        "MaxAuthorities",
                        [
                            98u8,
                            252u8,
                            116u8,
                            72u8,
                            26u8,
                            180u8,
                            225u8,
                            83u8,
                            200u8,
                            157u8,
                            125u8,
                            151u8,
                            53u8,
                            76u8,
                            168u8,
                            26u8,
                            10u8,
                            9u8,
                            98u8,
                            68u8,
                            9u8,
                            178u8,
                            197u8,
                            113u8,
                            31u8,
                            79u8,
                            200u8,
                            90u8,
                            203u8,
                            100u8,
                            41u8,
                            145u8,
                        ],
                    )
                }
                /// The maximum number of entries to keep in the set id to session index mapping.
                ///
                /// Since the `SetIdSession` map is only used for validating equivocations this
                /// value should relate to the bonding duration of whatever staking system is
                /// being used (if any). If equivocation handling is not enabled then this value
                /// can be zero.
                pub fn max_set_id_session_entries(
                    &self,
                ) -> ::subxt::constants::Address<::core::primitive::u64> {
                    ::subxt::constants::Address::new_static(
                        "Grandpa",
                        "MaxSetIdSessionEntries",
                        [
                            128u8,
                            214u8,
                            205u8,
                            242u8,
                            181u8,
                            142u8,
                            124u8,
                            231u8,
                            190u8,
                            146u8,
                            59u8,
                            226u8,
                            157u8,
                            101u8,
                            103u8,
                            117u8,
                            249u8,
                            65u8,
                            18u8,
                            191u8,
                            103u8,
                            119u8,
                            53u8,
                            85u8,
                            81u8,
                            96u8,
                            220u8,
                            42u8,
                            184u8,
                            239u8,
                            42u8,
                            246u8,
                        ],
                    )
                }
            }
        }
    }
    pub mod dkg {
        use super::root_mod;
        use super::runtime_types;
        /**
			Custom [dispatch errors](https://docs.substrate.io/main-docs/build/events-errors/)
			of this pallet.
			*/
        pub type Error = runtime_types::pallet_dkg_metadata::pallet::Error;
        ///Contains one variant per dispatchable that can be called by an extrinsic.
        pub type Call = runtime_types::pallet_dkg_metadata::pallet::Call;
        pub mod calls {
            use super::root_mod;
            use super::runtime_types;
            type DispatchError = runtime_types::sp_runtime::DispatchError;
            pub mod types {
                use super::runtime_types;
                #[derive(
                    ::subxt::ext::codec::CompactAs,
                    ::subxt::ext::codec::Decode,
                    ::subxt::ext::codec::Encode,
                    ::subxt::ext::scale_decode::DecodeAsType,
                    ::subxt::ext::scale_encode::EncodeAsType,
                    Clone,
                    Debug,
                    Eq,
                    PartialEq
                )]
                #[codec(crate = ::subxt::ext::codec)]
                #[decode_as_type(crate_path = ":: subxt :: ext :: scale_decode")]
                #[encode_as_type(crate_path = ":: subxt :: ext :: scale_encode")]
                pub struct SetSignatureThreshold {
                    pub new_threshold: ::core::primitive::u16,
                }
                impl ::subxt::blocks::StaticExtrinsic for SetSignatureThreshold {
                    const PALLET: &'static str = "DKG";
                    const CALL: &'static str = "set_signature_threshold";
                }
                #[derive(
                    ::subxt::ext::codec::CompactAs,
                    ::subxt::ext::codec::Decode,
                    ::subxt::ext::codec::Encode,
                    ::subxt::ext::scale_decode::DecodeAsType,
                    ::subxt::ext::scale_encode::EncodeAsType,
                    Clone,
                    Debug,
                    Eq,
                    PartialEq
                )]
                #[codec(crate = ::subxt::ext::codec)]
                #[decode_as_type(crate_path = ":: subxt :: ext :: scale_decode")]
                #[encode_as_type(crate_path = ":: subxt :: ext :: scale_encode")]
                pub struct SetKeygenThreshold {
                    pub new_threshold: ::core::primitive::u16,
                }
                impl ::subxt::blocks::StaticExtrinsic for SetKeygenThreshold {
                    const PALLET: &'static str = "DKG";
                    const CALL: &'static str = "set_keygen_threshold";
                }
                #[derive(
                    ::subxt::ext::codec::Decode,
                    ::subxt::ext::codec::Encode,
                    ::subxt::ext::scale_decode::DecodeAsType,
                    ::subxt::ext::scale_encode::EncodeAsType,
                    Clone,
                    Debug,
                    Eq,
                    PartialEq
                )]
                #[codec(crate = ::subxt::ext::codec)]
                #[decode_as_type(crate_path = ":: subxt :: ext :: scale_decode")]
                #[encode_as_type(crate_path = ":: subxt :: ext :: scale_encode")]
                pub struct SubmitPublicKey {
                    pub keys_and_signatures: runtime_types::dkg_runtime_primitives::AggregatedPublicKeys,
                }
                impl ::subxt::blocks::StaticExtrinsic for SubmitPublicKey {
                    const PALLET: &'static str = "DKG";
                    const CALL: &'static str = "submit_public_key";
                }
                #[derive(
                    ::subxt::ext::codec::Decode,
                    ::subxt::ext::codec::Encode,
                    ::subxt::ext::scale_decode::DecodeAsType,
                    ::subxt::ext::scale_encode::EncodeAsType,
                    Clone,
                    Debug,
                    Eq,
                    PartialEq
                )]
                #[codec(crate = ::subxt::ext::codec)]
                #[decode_as_type(crate_path = ":: subxt :: ext :: scale_decode")]
                #[encode_as_type(crate_path = ":: subxt :: ext :: scale_encode")]
                pub struct SubmitNextPublicKey {
                    pub keys_and_signatures: runtime_types::dkg_runtime_primitives::AggregatedPublicKeys,
                }
                impl ::subxt::blocks::StaticExtrinsic for SubmitNextPublicKey {
                    const PALLET: &'static str = "DKG";
                    const CALL: &'static str = "submit_next_public_key";
                }
                #[derive(
                    ::subxt::ext::codec::Decode,
                    ::subxt::ext::codec::Encode,
                    ::subxt::ext::scale_decode::DecodeAsType,
                    ::subxt::ext::scale_encode::EncodeAsType,
                    Clone,
                    Debug,
                    Eq,
                    PartialEq
                )]
                #[codec(crate = ::subxt::ext::codec)]
                #[decode_as_type(crate_path = ":: subxt :: ext :: scale_decode")]
                #[encode_as_type(crate_path = ":: subxt :: ext :: scale_encode")]
                pub struct SubmitMisbehaviourReports {
                    pub reports: runtime_types::dkg_runtime_primitives::AggregatedMisbehaviourReports<
                        runtime_types::dkg_runtime_primitives::crypto::Public,
                        runtime_types::dkg_runtime_primitives::CustomU32Getter3,
                        runtime_types::dkg_runtime_primitives::CustomU32Getter4,
                    >,
                }
                impl ::subxt::blocks::StaticExtrinsic for SubmitMisbehaviourReports {
                    const PALLET: &'static str = "DKG";
                    const CALL: &'static str = "submit_misbehaviour_reports";
                }
                #[derive(
                    ::subxt::ext::codec::Decode,
                    ::subxt::ext::codec::Encode,
                    ::subxt::ext::scale_decode::DecodeAsType,
                    ::subxt::ext::scale_encode::EncodeAsType,
                    Clone,
                    Debug,
                    Eq,
                    PartialEq
                )]
                #[codec(crate = ::subxt::ext::codec)]
                #[decode_as_type(crate_path = ":: subxt :: ext :: scale_decode")]
                #[encode_as_type(crate_path = ":: subxt :: ext :: scale_encode")]
                pub struct Unjail;
                impl ::subxt::blocks::StaticExtrinsic for Unjail {
                    const PALLET: &'static str = "DKG";
                    const CALL: &'static str = "unjail";
                }
                #[derive(
                    ::subxt::ext::codec::Decode,
                    ::subxt::ext::codec::Encode,
                    ::subxt::ext::scale_decode::DecodeAsType,
                    ::subxt::ext::scale_encode::EncodeAsType,
                    Clone,
                    Debug,
                    Eq,
                    PartialEq
                )]
                #[codec(crate = ::subxt::ext::codec)]
                #[decode_as_type(crate_path = ":: subxt :: ext :: scale_decode")]
                #[encode_as_type(crate_path = ":: subxt :: ext :: scale_encode")]
                pub struct ForceUnjailKeygen {
                    pub authority: runtime_types::dkg_runtime_primitives::crypto::Public,
                }
                impl ::subxt::blocks::StaticExtrinsic for ForceUnjailKeygen {
                    const PALLET: &'static str = "DKG";
                    const CALL: &'static str = "force_unjail_keygen";
                }
                #[derive(
                    ::subxt::ext::codec::Decode,
                    ::subxt::ext::codec::Encode,
                    ::subxt::ext::scale_decode::DecodeAsType,
                    ::subxt::ext::scale_encode::EncodeAsType,
                    Clone,
                    Debug,
                    Eq,
                    PartialEq
                )]
                #[codec(crate = ::subxt::ext::codec)]
                #[decode_as_type(crate_path = ":: subxt :: ext :: scale_decode")]
                #[encode_as_type(crate_path = ":: subxt :: ext :: scale_encode")]
                pub struct ForceUnjailSigning {
                    pub authority: runtime_types::dkg_runtime_primitives::crypto::Public,
                }
                impl ::subxt::blocks::StaticExtrinsic for ForceUnjailSigning {
                    const PALLET: &'static str = "DKG";
                    const CALL: &'static str = "force_unjail_signing";
                }
                #[derive(
                    ::subxt::ext::codec::Decode,
                    ::subxt::ext::codec::Encode,
                    ::subxt::ext::scale_decode::DecodeAsType,
                    ::subxt::ext::scale_encode::EncodeAsType,
                    Clone,
                    Debug,
                    Eq,
                    PartialEq
                )]
                #[codec(crate = ::subxt::ext::codec)]
                #[decode_as_type(crate_path = ":: subxt :: ext :: scale_decode")]
                #[encode_as_type(crate_path = ":: subxt :: ext :: scale_encode")]
                pub struct ForceChangeAuthorities;
                impl ::subxt::blocks::StaticExtrinsic for ForceChangeAuthorities {
                    const PALLET: &'static str = "DKG";
                    const CALL: &'static str = "force_change_authorities";
                }
                #[derive(
                    ::subxt::ext::codec::Decode,
                    ::subxt::ext::codec::Encode,
                    ::subxt::ext::scale_decode::DecodeAsType,
                    ::subxt::ext::scale_encode::EncodeAsType,
                    Clone,
                    Debug,
                    Eq,
                    PartialEq
                )]
                #[codec(crate = ::subxt::ext::codec)]
                #[decode_as_type(crate_path = ":: subxt :: ext :: scale_decode")]
                #[encode_as_type(crate_path = ":: subxt :: ext :: scale_encode")]
                pub struct TriggerEmergencyKeygen;
                impl ::subxt::blocks::StaticExtrinsic for TriggerEmergencyKeygen {
                    const PALLET: &'static str = "DKG";
                    const CALL: &'static str = "trigger_emergency_keygen";
                }
            }
            pub struct TransactionApi;
            impl TransactionApi {
                ///Set the pending signature threshold for the session following the next session.
                ///
                ///We cannot assume that the next DKG has not already completed keygen.
                ///After all, if we are in a new session the next DKG may have already completed.
                ///Therefore, when we update the thresholds we are updating a threshold
                ///that will become the next threshold after the next session update.
                ///
                ///* `origin` - The account origin.
                ///* `new_threshold` - The new signature threshold for the DKG.
                pub fn set_signature_threshold(
                    &self,
                    new_threshold: ::core::primitive::u16,
                ) -> ::subxt::tx::Payload<types::SetSignatureThreshold> {
                    ::subxt::tx::Payload::new_static(
                        "DKG",
                        "set_signature_threshold",
                        types::SetSignatureThreshold {
                            new_threshold,
                        },
                        [
                            73u8,
                            175u8,
                            180u8,
                            207u8,
                            148u8,
                            79u8,
                            19u8,
                            231u8,
                            20u8,
                            17u8,
                            103u8,
                            30u8,
                            1u8,
                            186u8,
                            14u8,
                            254u8,
                            133u8,
                            167u8,
                            141u8,
                            165u8,
                            78u8,
                            75u8,
                            102u8,
                            175u8,
                            181u8,
                            158u8,
                            233u8,
                            106u8,
                            231u8,
                            216u8,
                            245u8,
                            136u8,
                        ],
                    )
                }
                ///Set the pending keygen threshold for the session following the next session.
                ///
                ///We cannot assume that the next DKG has not already completed keygen.
                ///After all, if we are in a new session the next DKG may have already completed.
                ///Therefore, when we update the thresholds we are updating a threshold
                ///that will become the next threshold after the next session update.
                ///
                ///* `origin` - The account origin.
                ///* `new_threshold` - The new keygen threshold for the DKG.
                pub fn set_keygen_threshold(
                    &self,
                    new_threshold: ::core::primitive::u16,
                ) -> ::subxt::tx::Payload<types::SetKeygenThreshold> {
                    ::subxt::tx::Payload::new_static(
                        "DKG",
                        "set_keygen_threshold",
                        types::SetKeygenThreshold {
                            new_threshold,
                        },
                        [
                            58u8,
                            48u8,
                            120u8,
                            42u8,
                            23u8,
                            175u8,
                            237u8,
                            180u8,
                            13u8,
                            15u8,
                            247u8,
                            204u8,
                            151u8,
                            176u8,
                            221u8,
                            50u8,
                            10u8,
                            126u8,
                            149u8,
                            223u8,
                            222u8,
                            210u8,
                            68u8,
                            29u8,
                            165u8,
                            205u8,
                            249u8,
                            254u8,
                            102u8,
                            77u8,
                            43u8,
                            178u8,
                        ],
                    )
                }
                ///Submits and stores the active public key for the genesis session into the on-chain
                ///storage. This is primarily used to separate the genesis public key submission from
                ///non-genesis rounds.
                ///
                ///Can only be submitted by the current authorities. It is also required that a
                ///`SignatureThreshold` of submissions is reached in order to successfully
                ///store the public key on-chain.
                ///
                ///* `origin` - The account origin.
                ///* `keys_and_signatures` - The aggregated public keys and signatures for possible current
                ///  DKG public keys.
                pub fn submit_public_key(
                    &self,
                    keys_and_signatures: runtime_types::dkg_runtime_primitives::AggregatedPublicKeys,
                ) -> ::subxt::tx::Payload<types::SubmitPublicKey> {
                    ::subxt::tx::Payload::new_static(
                        "DKG",
                        "submit_public_key",
                        types::SubmitPublicKey {
                            keys_and_signatures,
                        },
                        [
                            4u8,
                            0u8,
                            104u8,
                            200u8,
                            187u8,
                            148u8,
                            153u8,
                            55u8,
                            236u8,
                            234u8,
                            26u8,
                            82u8,
                            96u8,
                            87u8,
                            43u8,
                            171u8,
                            242u8,
                            129u8,
                            238u8,
                            32u8,
                            116u8,
                            141u8,
                            237u8,
                            42u8,
                            67u8,
                            34u8,
                            221u8,
                            7u8,
                            25u8,
                            154u8,
                            212u8,
                            100u8,
                        ],
                    )
                }
                ///Submits and stores the next public key for the next session into the on-chain storage.
                ///
                ///Can only be submitted by the next authorities. It is also required that a
                ///`NextSignatureThreshold` of submissions is reached in order to successfully
                ///store the public key on-chain.
                ///
                ///* `origin` - The account origin.
                ///* `keys_and_signatures` - The aggregated public keys and signatures for possible next
                ///  DKG public keys.
                pub fn submit_next_public_key(
                    &self,
                    keys_and_signatures: runtime_types::dkg_runtime_primitives::AggregatedPublicKeys,
                ) -> ::subxt::tx::Payload<types::SubmitNextPublicKey> {
                    ::subxt::tx::Payload::new_static(
                        "DKG",
                        "submit_next_public_key",
                        types::SubmitNextPublicKey {
                            keys_and_signatures,
                        },
                        [
                            14u8,
                            171u8,
                            73u8,
                            71u8,
                            69u8,
                            184u8,
                            159u8,
                            38u8,
                            223u8,
                            124u8,
                            213u8,
                            118u8,
                            111u8,
                            123u8,
                            236u8,
                            182u8,
                            127u8,
                            45u8,
                            138u8,
                            125u8,
                            170u8,
                            235u8,
                            47u8,
                            90u8,
                            79u8,
                            165u8,
                            214u8,
                            32u8,
                            16u8,
                            103u8,
                            173u8,
                            234u8,
                        ],
                    )
                }
                ///Submits misbehaviour reports on chain. Signatures of the offending authority are
                ///verified against the current or next authorities depending on the type of misbehaviour.
                ///- Keygen: Verifies against the next authorities, since they are doing keygen.
                ///- Signing: Verifies against the current authorities, since they are doing signing.
                ///
                ///Verifies the reports against the respective thresholds and if enough reports are met
                ///begins to jail and decrease the reputation of the offending authority.
                ///
                ///The misbehaviour reputation update is:
                ///	AUTHORITY_REPUTATION = DECAY_PERCENTAGE * AUTHORITY_REPUTATION
                ///
                ///If there are not enough unjailed keygen authorities to perform a keygen after the next
                ///session, then we deduct the pending keygen threshold (and pending signing threshold)
                ///accordingly.
                ///
                ///* `origin` - The account origin.
                ///* `reports` - The aggregated misbehaviour reports containing signatures of an offending
                ///  authority
                pub fn submit_misbehaviour_reports(
                    &self,
                    reports: runtime_types::dkg_runtime_primitives::AggregatedMisbehaviourReports<
                        runtime_types::dkg_runtime_primitives::crypto::Public,
                        runtime_types::dkg_runtime_primitives::CustomU32Getter3,
                        runtime_types::dkg_runtime_primitives::CustomU32Getter4,
                    >,
                ) -> ::subxt::tx::Payload<types::SubmitMisbehaviourReports> {
                    ::subxt::tx::Payload::new_static(
                        "DKG",
                        "submit_misbehaviour_reports",
                        types::SubmitMisbehaviourReports {
                            reports,
                        },
                        [
                            72u8,
                            173u8,
                            232u8,
                            123u8,
                            62u8,
                            187u8,
                            44u8,
                            241u8,
                            148u8,
                            250u8,
                            123u8,
                            34u8,
                            213u8,
                            84u8,
                            217u8,
                            245u8,
                            113u8,
                            132u8,
                            203u8,
                            217u8,
                            12u8,
                            186u8,
                            14u8,
                            77u8,
                            126u8,
                            214u8,
                            67u8,
                            224u8,
                            200u8,
                            186u8,
                            156u8,
                            20u8,
                        ],
                    )
                }
                ///Attempts to remove an authority from all possible jails (keygen & signing).
                ///This can only be called by the controller of the authority in jail. The
                ///origin must map directly to the authority in jail.
                ///
                ///The authority's jail sentence for either keygen or signing must be elapsed
                ///for the authority to be removed from the jail.
                ///
                ///* `origin` - The account origin.
                pub fn unjail(&self) -> ::subxt::tx::Payload<types::Unjail> {
                    ::subxt::tx::Payload::new_static(
                        "DKG",
                        "unjail",
                        types::Unjail {},
                        [
                            111u8,
                            106u8,
                            139u8,
                            191u8,
                            73u8,
                            20u8,
                            85u8,
                            41u8,
                            157u8,
                            255u8,
                            214u8,
                            182u8,
                            192u8,
                            55u8,
                            158u8,
                            158u8,
                            190u8,
                            123u8,
                            191u8,
                            223u8,
                            19u8,
                            128u8,
                            0u8,
                            68u8,
                            217u8,
                            216u8,
                            121u8,
                            108u8,
                            78u8,
                            85u8,
                            19u8,
                            161u8,
                        ],
                    )
                }
                ///Force removes an authority from keygen jail.
                ///
                ///Can only be called by DKG
                ///* `origin` - The account origin.
                ///* `authority` - The authority to be removed from the keygen jail.
                pub fn force_unjail_keygen(
                    &self,
                    authority: runtime_types::dkg_runtime_primitives::crypto::Public,
                ) -> ::subxt::tx::Payload<types::ForceUnjailKeygen> {
                    ::subxt::tx::Payload::new_static(
                        "DKG",
                        "force_unjail_keygen",
                        types::ForceUnjailKeygen {
                            authority,
                        },
                        [
                            231u8,
                            54u8,
                            102u8,
                            170u8,
                            249u8,
                            26u8,
                            7u8,
                            237u8,
                            255u8,
                            88u8,
                            73u8,
                            91u8,
                            198u8,
                            73u8,
                            51u8,
                            126u8,
                            144u8,
                            196u8,
                            30u8,
                            57u8,
                            175u8,
                            66u8,
                            210u8,
                            240u8,
                            147u8,
                            8u8,
                            159u8,
                            9u8,
                            108u8,
                            244u8,
                            61u8,
                            47u8,
                        ],
                    )
                }
                ///Force removes an authority from signing jail.
                ///
                ///Can only be called by the root origin.
                ///
                ///* `origin` - The account origin.
                ///* `authority` - The authority to be removed from the signing jail.
                pub fn force_unjail_signing(
                    &self,
                    authority: runtime_types::dkg_runtime_primitives::crypto::Public,
                ) -> ::subxt::tx::Payload<types::ForceUnjailSigning> {
                    ::subxt::tx::Payload::new_static(
                        "DKG",
                        "force_unjail_signing",
                        types::ForceUnjailSigning {
                            authority,
                        },
                        [
                            234u8,
                            22u8,
                            118u8,
                            154u8,
                            131u8,
                            206u8,
                            30u8,
                            127u8,
                            212u8,
                            11u8,
                            158u8,
                            49u8,
                            178u8,
                            21u8,
                            184u8,
                            159u8,
                            234u8,
                            122u8,
                            230u8,
                            69u8,
                            242u8,
                            19u8,
                            96u8,
                            106u8,
                            63u8,
                            241u8,
                            144u8,
                            167u8,
                            108u8,
                            78u8,
                            21u8,
                            81u8,
                        ],
                    )
                }
                ///Forcefully rotate the DKG
                ///
                ///This forces the next authorities into the current authority spot and
                ///automatically increments the authority ID. It uses `change_authorities`
                ///to execute the rotation forcefully.
                pub fn force_change_authorities(
                    &self,
                ) -> ::subxt::tx::Payload<types::ForceChangeAuthorities> {
                    ::subxt::tx::Payload::new_static(
                        "DKG",
                        "force_change_authorities",
                        types::ForceChangeAuthorities {},
                        [
                            115u8,
                            53u8,
                            99u8,
                            150u8,
                            158u8,
                            193u8,
                            233u8,
                            82u8,
                            3u8,
                            60u8,
                            18u8,
                            228u8,
                            204u8,
                            177u8,
                            92u8,
                            221u8,
                            208u8,
                            179u8,
                            64u8,
                            88u8,
                            254u8,
                            88u8,
                            127u8,
                            26u8,
                            218u8,
                            63u8,
                            153u8,
                            33u8,
                            38u8,
                            66u8,
                            56u8,
                            150u8,
                        ],
                    )
                }
                ///Triggers an Emergency Keygen Protocol.
                ///
                ///The keygen protocol will then be executed and the result will be stored in the off chain
                ///storage, which will be picked up by the on chain worker and stored on chain.
                ///
                ///Note that, this will clear the next public key and its signature, if any.
                pub fn trigger_emergency_keygen(
                    &self,
                ) -> ::subxt::tx::Payload<types::TriggerEmergencyKeygen> {
                    ::subxt::tx::Payload::new_static(
                        "DKG",
                        "trigger_emergency_keygen",
                        types::TriggerEmergencyKeygen {},
                        [
                            36u8,
                            247u8,
                            184u8,
                            243u8,
                            173u8,
                            138u8,
                            232u8,
                            26u8,
                            194u8,
                            165u8,
                            100u8,
                            141u8,
                            54u8,
                            206u8,
                            181u8,
                            120u8,
                            245u8,
                            22u8,
                            247u8,
                            0u8,
                            232u8,
                            96u8,
                            97u8,
                            218u8,
                            150u8,
                            212u8,
                            123u8,
                            21u8,
                            238u8,
                            57u8,
                            147u8,
                            2u8,
                        ],
                    )
                }
            }
        }
        /**
			The [event](https://docs.substrate.io/main-docs/build/events-errors/) emitted
			by this pallet.
			*/
        pub type Event = runtime_types::pallet_dkg_metadata::pallet::Event;
        pub mod events {
            use super::runtime_types;
            #[derive(
                ::subxt::ext::codec::Decode,
                ::subxt::ext::codec::Encode,
                ::subxt::ext::scale_decode::DecodeAsType,
                ::subxt::ext::scale_encode::EncodeAsType,
                Clone,
                Debug,
                Eq,
                PartialEq
            )]
            #[codec(crate = ::subxt::ext::codec)]
            #[decode_as_type(crate_path = ":: subxt :: ext :: scale_decode")]
            #[encode_as_type(crate_path = ":: subxt :: ext :: scale_encode")]
            ///Current public key submitted
            pub struct PublicKeySubmitted {
                pub compressed_pub_key: ::std::vec::Vec<::core::primitive::u8>,
            }
            impl ::subxt::events::StaticEvent for PublicKeySubmitted {
                const PALLET: &'static str = "DKG";
                const EVENT: &'static str = "PublicKeySubmitted";
            }
            #[derive(
                ::subxt::ext::codec::Decode,
                ::subxt::ext::codec::Encode,
                ::subxt::ext::scale_decode::DecodeAsType,
                ::subxt::ext::scale_encode::EncodeAsType,
                Clone,
                Debug,
                Eq,
                PartialEq
            )]
            #[codec(crate = ::subxt::ext::codec)]
            #[decode_as_type(crate_path = ":: subxt :: ext :: scale_decode")]
            #[encode_as_type(crate_path = ":: subxt :: ext :: scale_encode")]
            ///Next public key submitted
            pub struct NextPublicKeySubmitted {
                pub compressed_pub_key: ::std::vec::Vec<::core::primitive::u8>,
            }
            impl ::subxt::events::StaticEvent for NextPublicKeySubmitted {
                const PALLET: &'static str = "DKG";
                const EVENT: &'static str = "NextPublicKeySubmitted";
            }
            #[derive(
                ::subxt::ext::codec::Decode,
                ::subxt::ext::codec::Encode,
                ::subxt::ext::scale_decode::DecodeAsType,
                ::subxt::ext::scale_encode::EncodeAsType,
                Clone,
                Debug,
                Eq,
                PartialEq
            )]
            #[codec(crate = ::subxt::ext::codec)]
            #[decode_as_type(crate_path = ":: subxt :: ext :: scale_decode")]
            #[encode_as_type(crate_path = ":: subxt :: ext :: scale_encode")]
            ///Next public key signature submitted
            pub struct NextPublicKeySignatureSubmitted {
                pub voter_merkle_root: [::core::primitive::u8; 32usize],
                pub session_length: ::core::primitive::u64,
                pub voter_count: ::core::primitive::u32,
                pub nonce: runtime_types::webb_proposals::nonce::Nonce,
                pub pub_key: ::std::vec::Vec<::core::primitive::u8>,
                pub signature: ::std::vec::Vec<::core::primitive::u8>,
            }
            impl ::subxt::events::StaticEvent for NextPublicKeySignatureSubmitted {
                const PALLET: &'static str = "DKG";
                const EVENT: &'static str = "NextPublicKeySignatureSubmitted";
            }
            #[derive(
                ::subxt::ext::codec::Decode,
                ::subxt::ext::codec::Encode,
                ::subxt::ext::scale_decode::DecodeAsType,
                ::subxt::ext::scale_encode::EncodeAsType,
                Clone,
                Debug,
                Eq,
                PartialEq
            )]
            #[codec(crate = ::subxt::ext::codec)]
            #[decode_as_type(crate_path = ":: subxt :: ext :: scale_decode")]
            #[encode_as_type(crate_path = ":: subxt :: ext :: scale_encode")]
            ///Current Public Key Changed.
            pub struct PublicKeyChanged {
                pub compressed_pub_key: ::std::vec::Vec<::core::primitive::u8>,
            }
            impl ::subxt::events::StaticEvent for PublicKeyChanged {
                const PALLET: &'static str = "DKG";
                const EVENT: &'static str = "PublicKeyChanged";
            }
            #[derive(
                ::subxt::ext::codec::Decode,
                ::subxt::ext::codec::Encode,
                ::subxt::ext::scale_decode::DecodeAsType,
                ::subxt::ext::scale_encode::EncodeAsType,
                Clone,
                Debug,
                Eq,
                PartialEq
            )]
            #[codec(crate = ::subxt::ext::codec)]
            #[decode_as_type(crate_path = ":: subxt :: ext :: scale_decode")]
            #[encode_as_type(crate_path = ":: subxt :: ext :: scale_encode")]
            ///Current Public Key Signature Changed.
            pub struct PublicKeySignatureChanged {
                pub voter_merkle_root: [::core::primitive::u8; 32usize],
                pub session_length: ::core::primitive::u64,
                pub voter_count: ::core::primitive::u32,
                pub nonce: runtime_types::webb_proposals::nonce::Nonce,
                pub pub_key: ::std::vec::Vec<::core::primitive::u8>,
                pub signature: ::std::vec::Vec<::core::primitive::u8>,
            }
            impl ::subxt::events::StaticEvent for PublicKeySignatureChanged {
                const PALLET: &'static str = "DKG";
                const EVENT: &'static str = "PublicKeySignatureChanged";
            }
            #[derive(
                ::subxt::ext::codec::Decode,
                ::subxt::ext::codec::Encode,
                ::subxt::ext::scale_decode::DecodeAsType,
                ::subxt::ext::scale_encode::EncodeAsType,
                Clone,
                Debug,
                Eq,
                PartialEq
            )]
            #[codec(crate = ::subxt::ext::codec)]
            #[decode_as_type(crate_path = ":: subxt :: ext :: scale_decode")]
            #[encode_as_type(crate_path = ":: subxt :: ext :: scale_encode")]
            ///Misbehaviour reports submitted
            pub struct MisbehaviourReportsSubmitted {
                pub misbehaviour_type: runtime_types::dkg_runtime_primitives::MisbehaviourType,
                pub reporters: ::std::vec::Vec<
                    runtime_types::dkg_runtime_primitives::crypto::Public,
                >,
                pub offender: runtime_types::dkg_runtime_primitives::crypto::Public,
            }
            impl ::subxt::events::StaticEvent for MisbehaviourReportsSubmitted {
                const PALLET: &'static str = "DKG";
                const EVENT: &'static str = "MisbehaviourReportsSubmitted";
            }
            #[derive(
                ::subxt::ext::codec::Decode,
                ::subxt::ext::codec::Encode,
                ::subxt::ext::scale_decode::DecodeAsType,
                ::subxt::ext::scale_encode::EncodeAsType,
                Clone,
                Debug,
                Eq,
                PartialEq
            )]
            #[codec(crate = ::subxt::ext::codec)]
            #[decode_as_type(crate_path = ":: subxt :: ext :: scale_decode")]
            #[encode_as_type(crate_path = ":: subxt :: ext :: scale_encode")]
            ///Proposer votes submitted
            pub struct ProposerSetVotesSubmitted {
                pub voters: ::std::vec::Vec<
                    runtime_types::dkg_runtime_primitives::crypto::Public,
                >,
                pub signatures: ::std::vec::Vec<::std::vec::Vec<::core::primitive::u8>>,
                pub vote: ::std::vec::Vec<::core::primitive::u8>,
            }
            impl ::subxt::events::StaticEvent for ProposerSetVotesSubmitted {
                const PALLET: &'static str = "DKG";
                const EVENT: &'static str = "ProposerSetVotesSubmitted";
            }
            #[derive(
                ::subxt::ext::codec::CompactAs,
                ::subxt::ext::codec::Decode,
                ::subxt::ext::codec::Encode,
                ::subxt::ext::scale_decode::DecodeAsType,
                ::subxt::ext::scale_encode::EncodeAsType,
                Clone,
                Debug,
                Eq,
                PartialEq
            )]
            #[codec(crate = ::subxt::ext::codec)]
            #[decode_as_type(crate_path = ":: subxt :: ext :: scale_decode")]
            #[encode_as_type(crate_path = ":: subxt :: ext :: scale_encode")]
            ///Refresh DKG Keys Finished (forcefully).
            pub struct RefreshKeysFinished {
                pub next_authority_set_id: ::core::primitive::u64,
            }
            impl ::subxt::events::StaticEvent for RefreshKeysFinished {
                const PALLET: &'static str = "DKG";
                const EVENT: &'static str = "RefreshKeysFinished";
            }
            #[derive(
                ::subxt::ext::codec::CompactAs,
                ::subxt::ext::codec::Decode,
                ::subxt::ext::codec::Encode,
                ::subxt::ext::scale_decode::DecodeAsType,
                ::subxt::ext::scale_encode::EncodeAsType,
                Clone,
                Debug,
                Eq,
                PartialEq
            )]
            #[codec(crate = ::subxt::ext::codec)]
            #[decode_as_type(crate_path = ":: subxt :: ext :: scale_decode")]
            #[encode_as_type(crate_path = ":: subxt :: ext :: scale_encode")]
            ///NextKeygenThreshold updated
            pub struct NextKeygenThresholdUpdated {
                pub next_keygen_threshold: ::core::primitive::u16,
            }
            impl ::subxt::events::StaticEvent for NextKeygenThresholdUpdated {
                const PALLET: &'static str = "DKG";
                const EVENT: &'static str = "NextKeygenThresholdUpdated";
            }
            #[derive(
                ::subxt::ext::codec::CompactAs,
                ::subxt::ext::codec::Decode,
                ::subxt::ext::codec::Encode,
                ::subxt::ext::scale_decode::DecodeAsType,
                ::subxt::ext::scale_encode::EncodeAsType,
                Clone,
                Debug,
                Eq,
                PartialEq
            )]
            #[codec(crate = ::subxt::ext::codec)]
            #[decode_as_type(crate_path = ":: subxt :: ext :: scale_decode")]
            #[encode_as_type(crate_path = ":: subxt :: ext :: scale_encode")]
            ///NextSignatureThreshold updated
            pub struct NextSignatureThresholdUpdated {
                pub next_signature_threshold: ::core::primitive::u16,
            }
            impl ::subxt::events::StaticEvent for NextSignatureThresholdUpdated {
                const PALLET: &'static str = "DKG";
                const EVENT: &'static str = "NextSignatureThresholdUpdated";
            }
            #[derive(
                ::subxt::ext::codec::CompactAs,
                ::subxt::ext::codec::Decode,
                ::subxt::ext::codec::Encode,
                ::subxt::ext::scale_decode::DecodeAsType,
                ::subxt::ext::scale_encode::EncodeAsType,
                Clone,
                Debug,
                Eq,
                PartialEq
            )]
            #[codec(crate = ::subxt::ext::codec)]
            #[decode_as_type(crate_path = ":: subxt :: ext :: scale_decode")]
            #[encode_as_type(crate_path = ":: subxt :: ext :: scale_encode")]
            ///PendingKeygenThreshold updated
            pub struct PendingKeygenThresholdUpdated {
                pub pending_keygen_threshold: ::core::primitive::u16,
            }
            impl ::subxt::events::StaticEvent for PendingKeygenThresholdUpdated {
                const PALLET: &'static str = "DKG";
                const EVENT: &'static str = "PendingKeygenThresholdUpdated";
            }
            #[derive(
                ::subxt::ext::codec::CompactAs,
                ::subxt::ext::codec::Decode,
                ::subxt::ext::codec::Encode,
                ::subxt::ext::scale_decode::DecodeAsType,
                ::subxt::ext::scale_encode::EncodeAsType,
                Clone,
                Debug,
                Eq,
                PartialEq
            )]
            #[codec(crate = ::subxt::ext::codec)]
            #[decode_as_type(crate_path = ":: subxt :: ext :: scale_decode")]
            #[encode_as_type(crate_path = ":: subxt :: ext :: scale_encode")]
            ///PendingSignatureThreshold updated
            pub struct PendingSignatureThresholdUpdated {
                pub pending_signature_threshold: ::core::primitive::u16,
            }
            impl ::subxt::events::StaticEvent for PendingSignatureThresholdUpdated {
                const PALLET: &'static str = "DKG";
                const EVENT: &'static str = "PendingSignatureThresholdUpdated";
            }
            #[derive(
                ::subxt::ext::codec::Decode,
                ::subxt::ext::codec::Encode,
                ::subxt::ext::scale_decode::DecodeAsType,
                ::subxt::ext::scale_encode::EncodeAsType,
                Clone,
                Debug,
                Eq,
                PartialEq
            )]
            #[codec(crate = ::subxt::ext::codec)]
            #[decode_as_type(crate_path = ":: subxt :: ext :: scale_decode")]
            #[encode_as_type(crate_path = ":: subxt :: ext :: scale_encode")]
            ///An Emergency Keygen Protocol was triggered.
            pub struct EmergencyKeygenTriggered;
            impl ::subxt::events::StaticEvent for EmergencyKeygenTriggered {
                const PALLET: &'static str = "DKG";
                const EVENT: &'static str = "EmergencyKeygenTriggered";
            }
            #[derive(
                ::subxt::ext::codec::Decode,
                ::subxt::ext::codec::Encode,
                ::subxt::ext::scale_decode::DecodeAsType,
                ::subxt::ext::scale_encode::EncodeAsType,
                Clone,
                Debug,
                Eq,
                PartialEq
            )]
            #[codec(crate = ::subxt::ext::codec)]
            #[decode_as_type(crate_path = ":: subxt :: ext :: scale_decode")]
            #[encode_as_type(crate_path = ":: subxt :: ext :: scale_encode")]
            ///An authority has been jailed for misbehaviour
            pub struct AuthorityJailed {
                pub misbehaviour_type: runtime_types::dkg_runtime_primitives::MisbehaviourType,
                pub authority: runtime_types::dkg_runtime_primitives::crypto::Public,
            }
            impl ::subxt::events::StaticEvent for AuthorityJailed {
                const PALLET: &'static str = "DKG";
                const EVENT: &'static str = "AuthorityJailed";
            }
            #[derive(
                ::subxt::ext::codec::Decode,
                ::subxt::ext::codec::Encode,
                ::subxt::ext::scale_decode::DecodeAsType,
                ::subxt::ext::scale_encode::EncodeAsType,
                Clone,
                Debug,
                Eq,
                PartialEq
            )]
            #[codec(crate = ::subxt::ext::codec)]
            #[decode_as_type(crate_path = ":: subxt :: ext :: scale_decode")]
            #[encode_as_type(crate_path = ":: subxt :: ext :: scale_encode")]
            ///An authority has been unjailed
            pub struct AuthorityUnJailed {
                pub authority: runtime_types::dkg_runtime_primitives::crypto::Public,
            }
            impl ::subxt::events::StaticEvent for AuthorityUnJailed {
                const PALLET: &'static str = "DKG";
                const EVENT: &'static str = "AuthorityUnJailed";
            }
        }
        pub mod storage {
            use super::runtime_types;
            pub struct StorageApi;
            impl StorageApi {
                /// Public key Signatures for past sessions
                pub fn used_signatures(
                    &self,
                ) -> ::subxt::storage::address::Address<
                    ::subxt::storage::address::StaticStorageMapKey,
                    runtime_types::bounded_collections::bounded_vec::BoundedVec<
                        runtime_types::bounded_collections::bounded_vec::BoundedVec<
                            ::core::primitive::u8,
                        >,
                    >,
                    ::subxt::storage::address::Yes,
                    ::subxt::storage::address::Yes,
                    (),
                > {
                    ::subxt::storage::address::Address::new_static(
                        "DKG",
                        "UsedSignatures",
                        vec![],
                        [
                            28u8,
                            233u8,
                            127u8,
                            27u8,
                            246u8,
                            167u8,
                            128u8,
                            37u8,
                            187u8,
                            166u8,
                            241u8,
                            115u8,
                            199u8,
                            75u8,
                            23u8,
                            247u8,
                            102u8,
                            184u8,
                            227u8,
                            110u8,
                            129u8,
                            30u8,
                            89u8,
                            24u8,
                            107u8,
                            252u8,
                            77u8,
                            88u8,
                            29u8,
                            178u8,
                            220u8,
                            114u8,
                        ],
                    )
                }
                /// Nonce value for next refresh proposal
                pub fn refresh_nonce(
                    &self,
                ) -> ::subxt::storage::address::Address<
                    ::subxt::storage::address::StaticStorageMapKey,
                    ::core::primitive::u32,
                    ::subxt::storage::address::Yes,
                    ::subxt::storage::address::Yes,
                    (),
                > {
                    ::subxt::storage::address::Address::new_static(
                        "DKG",
                        "RefreshNonce",
                        vec![],
                        [
                            52u8,
                            38u8,
                            189u8,
                            83u8,
                            196u8,
                            34u8,
                            12u8,
                            223u8,
                            171u8,
                            166u8,
                            38u8,
                            253u8,
                            199u8,
                            225u8,
                            74u8,
                            29u8,
                            159u8,
                            104u8,
                            104u8,
                            226u8,
                            138u8,
                            210u8,
                            123u8,
                            125u8,
                            3u8,
                            193u8,
                            158u8,
                            105u8,
                            212u8,
                            172u8,
                            201u8,
                            19u8,
                        ],
                    )
                }
                /// Defines the block when next unsigned transaction will be accepted.
                ///
                /// To prevent spam of unsigned (and unpayed!) transactions on the network,
                /// we only allow one transaction every `T::UnsignedInterval` blocks.
                /// This storage entry defines when new transaction is going to be accepted.
                pub fn next_unsigned_at(
                    &self,
                ) -> ::subxt::storage::address::Address<
                    ::subxt::storage::address::StaticStorageMapKey,
                    ::core::primitive::u32,
                    ::subxt::storage::address::Yes,
                    ::subxt::storage::address::Yes,
                    (),
                > {
                    ::subxt::storage::address::Address::new_static(
                        "DKG",
                        "NextUnsignedAt",
                        vec![],
                        [
                            128u8,
                            69u8,
                            217u8,
                            175u8,
                            94u8,
                            131u8,
                            228u8,
                            97u8,
                            2u8,
                            91u8,
                            12u8,
                            95u8,
                            35u8,
                            105u8,
                            136u8,
                            55u8,
                            49u8,
                            3u8,
                            224u8,
                            213u8,
                            96u8,
                            45u8,
                            19u8,
                            217u8,
                            5u8,
                            6u8,
                            20u8,
                            51u8,
                            219u8,
                            66u8,
                            143u8,
                            50u8,
                        ],
                    )
                }
                /// Check if there is a refresh in progress.
                pub fn refresh_in_progress(
                    &self,
                ) -> ::subxt::storage::address::Address<
                    ::subxt::storage::address::StaticStorageMapKey,
                    ::core::primitive::bool,
                    ::subxt::storage::address::Yes,
                    ::subxt::storage::address::Yes,
                    (),
                > {
                    ::subxt::storage::address::Address::new_static(
                        "DKG",
                        "RefreshInProgress",
                        vec![],
                        [
                            36u8,
                            138u8,
                            169u8,
                            157u8,
                            5u8,
                            122u8,
                            158u8,
                            110u8,
                            168u8,
                            132u8,
                            243u8,
                            17u8,
                            156u8,
                            47u8,
                            34u8,
                            103u8,
                            52u8,
                            205u8,
                            216u8,
                            23u8,
                            51u8,
                            85u8,
                            255u8,
                            187u8,
                            118u8,
                            226u8,
                            175u8,
                            11u8,
                            131u8,
                            83u8,
                            60u8,
                            211u8,
                        ],
                    )
                }
                /// Should we start a new Keygen
                pub fn should_execute_new_keygen(
                    &self,
                ) -> ::subxt::storage::address::Address<
                    ::subxt::storage::address::StaticStorageMapKey,
                    (::core::primitive::bool, ::core::primitive::bool),
                    ::subxt::storage::address::Yes,
                    ::subxt::storage::address::Yes,
                    (),
                > {
                    ::subxt::storage::address::Address::new_static(
                        "DKG",
                        "ShouldExecuteNewKeygen",
                        vec![],
                        [
                            144u8,
                            13u8,
                            44u8,
                            55u8,
                            75u8,
                            7u8,
                            211u8,
                            236u8,
                            151u8,
                            254u8,
                            214u8,
                            201u8,
                            53u8,
                            10u8,
                            47u8,
                            160u8,
                            123u8,
                            37u8,
                            151u8,
                            172u8,
                            43u8,
                            245u8,
                            52u8,
                            237u8,
                            52u8,
                            57u8,
                            120u8,
                            226u8,
                            6u8,
                            119u8,
                            105u8,
                            208u8,
                        ],
                    )
                }
                /// Should we submit a vote for the new DKG governor if we are a proposer
                pub fn should_submit_proposer_vote(
                    &self,
                ) -> ::subxt::storage::address::Address<
                    ::subxt::storage::address::StaticStorageMapKey,
                    ::core::primitive::bool,
                    ::subxt::storage::address::Yes,
                    ::subxt::storage::address::Yes,
                    (),
                > {
                    ::subxt::storage::address::Address::new_static(
                        "DKG",
                        "ShouldSubmitProposerVote",
                        vec![],
                        [
                            214u8,
                            211u8,
                            161u8,
                            216u8,
                            62u8,
                            255u8,
                            251u8,
                            198u8,
                            111u8,
                            172u8,
                            229u8,
                            248u8,
                            145u8,
                            58u8,
                            20u8,
                            89u8,
                            69u8,
                            235u8,
                            68u8,
                            47u8,
                            168u8,
                            224u8,
                            61u8,
                            215u8,
                            121u8,
                            197u8,
                            94u8,
                            25u8,
                            93u8,
                            23u8,
                            124u8,
                            93u8,
                        ],
                    )
                }
                /// Holds public key for next session
                pub fn next_dkg_public_key(
                    &self,
                ) -> ::subxt::storage::address::Address<
                    ::subxt::storage::address::StaticStorageMapKey,
                    (
                        ::core::primitive::u64,
                        runtime_types::bounded_collections::bounded_vec::BoundedVec<
                            ::core::primitive::u8,
                        >,
                    ),
                    ::subxt::storage::address::Yes,
                    (),
                    (),
                > {
                    ::subxt::storage::address::Address::new_static(
                        "DKG",
                        "NextDKGPublicKey",
                        vec![],
                        [
                            180u8,
                            19u8,
                            199u8,
                            43u8,
                            154u8,
                            33u8,
                            16u8,
                            202u8,
                            96u8,
                            99u8,
                            235u8,
                            88u8,
                            5u8,
                            49u8,
                            129u8,
                            239u8,
                            30u8,
                            106u8,
                            76u8,
                            82u8,
                            102u8,
                            57u8,
                            122u8,
                            127u8,
                            105u8,
                            33u8,
                            159u8,
                            22u8,
                            113u8,
                            247u8,
                            110u8,
                            9u8,
                        ],
                    )
                }
                /// Signature of the DKG public key for the next session
                pub fn next_public_key_signature(
                    &self,
                ) -> ::subxt::storage::address::Address<
                    ::subxt::storage::address::StaticStorageMapKey,
                    runtime_types::bounded_collections::bounded_vec::BoundedVec<
                        ::core::primitive::u8,
                    >,
                    ::subxt::storage::address::Yes,
                    (),
                    (),
                > {
                    ::subxt::storage::address::Address::new_static(
                        "DKG",
                        "NextPublicKeySignature",
                        vec![],
                        [
                            133u8,
                            74u8,
                            189u8,
                            29u8,
                            12u8,
                            54u8,
                            213u8,
                            12u8,
                            121u8,
                            135u8,
                            254u8,
                            174u8,
                            37u8,
                            3u8,
                            211u8,
                            252u8,
                            29u8,
                            210u8,
                            16u8,
                            131u8,
                            229u8,
                            255u8,
                            240u8,
                            213u8,
                            23u8,
                            142u8,
                            171u8,
                            59u8,
                            164u8,
                            16u8,
                            235u8,
                            7u8,
                        ],
                    )
                }
                /// Holds active public key for ongoing session
                pub fn dkg_public_key(
                    &self,
                ) -> ::subxt::storage::address::Address<
                    ::subxt::storage::address::StaticStorageMapKey,
                    (
                        ::core::primitive::u64,
                        runtime_types::bounded_collections::bounded_vec::BoundedVec<
                            ::core::primitive::u8,
                        >,
                    ),
                    ::subxt::storage::address::Yes,
                    ::subxt::storage::address::Yes,
                    (),
                > {
                    ::subxt::storage::address::Address::new_static(
                        "DKG",
                        "DKGPublicKey",
                        vec![],
                        [
                            88u8,
                            180u8,
                            20u8,
                            255u8,
                            87u8,
                            119u8,
                            82u8,
                            8u8,
                            90u8,
                            134u8,
                            188u8,
                            118u8,
                            118u8,
                            55u8,
                            41u8,
                            4u8,
                            227u8,
                            65u8,
                            41u8,
                            129u8,
                            20u8,
                            113u8,
                            123u8,
                            213u8,
                            128u8,
                            71u8,
                            78u8,
                            124u8,
                            115u8,
                            74u8,
                            81u8,
                            85u8,
                        ],
                    )
                }
                /// Signature of the current DKG public key
                pub fn dkg_public_key_signature(
                    &self,
                ) -> ::subxt::storage::address::Address<
                    ::subxt::storage::address::StaticStorageMapKey,
                    runtime_types::bounded_collections::bounded_vec::BoundedVec<
                        ::core::primitive::u8,
                    >,
                    ::subxt::storage::address::Yes,
                    ::subxt::storage::address::Yes,
                    (),
                > {
                    ::subxt::storage::address::Address::new_static(
                        "DKG",
                        "DKGPublicKeySignature",
                        vec![],
                        [
                            247u8,
                            227u8,
                            60u8,
                            70u8,
                            125u8,
                            30u8,
                            53u8,
                            216u8,
                            101u8,
                            177u8,
                            174u8,
                            9u8,
                            148u8,
                            124u8,
                            106u8,
                            71u8,
                            59u8,
                            98u8,
                            100u8,
                            117u8,
                            62u8,
                            231u8,
                            181u8,
                            23u8,
                            242u8,
                            100u8,
                            233u8,
                            135u8,
                            220u8,
                            88u8,
                            67u8,
                            230u8,
                        ],
                    )
                }
                /// Holds public key for immediate past session
                pub fn previous_public_key(
                    &self,
                ) -> ::subxt::storage::address::Address<
                    ::subxt::storage::address::StaticStorageMapKey,
                    (
                        ::core::primitive::u64,
                        runtime_types::bounded_collections::bounded_vec::BoundedVec<
                            ::core::primitive::u8,
                        >,
                    ),
                    ::subxt::storage::address::Yes,
                    ::subxt::storage::address::Yes,
                    (),
                > {
                    ::subxt::storage::address::Address::new_static(
                        "DKG",
                        "PreviousPublicKey",
                        vec![],
                        [
                            194u8,
                            139u8,
                            212u8,
                            138u8,
                            198u8,
                            148u8,
                            5u8,
                            83u8,
                            168u8,
                            219u8,
                            206u8,
                            48u8,
                            97u8,
                            210u8,
                            189u8,
                            222u8,
                            246u8,
                            35u8,
                            164u8,
                            28u8,
                            240u8,
                            71u8,
                            42u8,
                            190u8,
                            96u8,
                            21u8,
                            115u8,
                            130u8,
                            15u8,
                            63u8,
                            154u8,
                            186u8,
                        ],
                    )
                }
                /// Tracks current voter set
                pub fn historical_rounds(
                    &self,
                    _0: impl ::std::borrow::Borrow<::core::primitive::u64>,
                ) -> ::subxt::storage::address::Address<
                    ::subxt::storage::address::StaticStorageMapKey,
                    runtime_types::pallet_dkg_metadata::types::RoundMetadata<
                        runtime_types::dkg_runtime_primitives::CustomU32Getter3,
                        runtime_types::dkg_runtime_primitives::CustomU32Getter3,
                    >,
                    ::subxt::storage::address::Yes,
                    ::subxt::storage::address::Yes,
                    ::subxt::storage::address::Yes,
                > {
                    ::subxt::storage::address::Address::new_static(
                        "DKG",
                        "HistoricalRounds",
                        vec![
                            ::subxt::storage::address::make_static_storage_map_key(_0
                            .borrow())
                        ],
                        [
                            138u8,
                            239u8,
                            135u8,
                            210u8,
                            36u8,
                            1u8,
                            181u8,
                            134u8,
                            97u8,
                            0u8,
                            233u8,
                            128u8,
                            66u8,
                            214u8,
                            244u8,
                            252u8,
                            162u8,
                            23u8,
                            80u8,
                            203u8,
                            196u8,
                            230u8,
                            6u8,
                            99u8,
                            189u8,
                            150u8,
                            254u8,
                            3u8,
                            66u8,
                            72u8,
                            213u8,
                            66u8,
                        ],
                    )
                }
                /// Tracks current voter set
                pub fn historical_rounds_root(
                    &self,
                ) -> ::subxt::storage::address::Address<
                    ::subxt::storage::address::StaticStorageMapKey,
                    runtime_types::pallet_dkg_metadata::types::RoundMetadata<
                        runtime_types::dkg_runtime_primitives::CustomU32Getter3,
                        runtime_types::dkg_runtime_primitives::CustomU32Getter3,
                    >,
                    (),
                    ::subxt::storage::address::Yes,
                    ::subxt::storage::address::Yes,
                > {
                    ::subxt::storage::address::Address::new_static(
                        "DKG",
                        "HistoricalRounds",
                        Vec::new(),
                        [
                            138u8,
                            239u8,
                            135u8,
                            210u8,
                            36u8,
                            1u8,
                            181u8,
                            134u8,
                            97u8,
                            0u8,
                            233u8,
                            128u8,
                            66u8,
                            214u8,
                            244u8,
                            252u8,
                            162u8,
                            23u8,
                            80u8,
                            203u8,
                            196u8,
                            230u8,
                            6u8,
                            99u8,
                            189u8,
                            150u8,
                            254u8,
                            3u8,
                            66u8,
                            72u8,
                            213u8,
                            66u8,
                        ],
                    )
                }
                /// The current signature threshold (i.e. the `t` in t-of-n)
                pub fn signature_threshold(
                    &self,
                ) -> ::subxt::storage::address::Address<
                    ::subxt::storage::address::StaticStorageMapKey,
                    ::core::primitive::u16,
                    ::subxt::storage::address::Yes,
                    ::subxt::storage::address::Yes,
                    (),
                > {
                    ::subxt::storage::address::Address::new_static(
                        "DKG",
                        "SignatureThreshold",
                        vec![],
                        [
                            184u8,
                            92u8,
                            77u8,
                            107u8,
                            220u8,
                            185u8,
                            13u8,
                            198u8,
                            141u8,
                            143u8,
                            190u8,
                            12u8,
                            98u8,
                            228u8,
                            176u8,
                            253u8,
                            178u8,
                            119u8,
                            78u8,
                            18u8,
                            112u8,
                            66u8,
                            154u8,
                            163u8,
                            27u8,
                            221u8,
                            33u8,
                            26u8,
                            68u8,
                            207u8,
                            204u8,
                            42u8,
                        ],
                    )
                }
                /// The current signature threshold (i.e. the `n` in t-of-n)
                pub fn keygen_threshold(
                    &self,
                ) -> ::subxt::storage::address::Address<
                    ::subxt::storage::address::StaticStorageMapKey,
                    ::core::primitive::u16,
                    ::subxt::storage::address::Yes,
                    ::subxt::storage::address::Yes,
                    (),
                > {
                    ::subxt::storage::address::Address::new_static(
                        "DKG",
                        "KeygenThreshold",
                        vec![],
                        [
                            92u8,
                            35u8,
                            248u8,
                            4u8,
                            222u8,
                            170u8,
                            154u8,
                            157u8,
                            87u8,
                            18u8,
                            235u8,
                            6u8,
                            187u8,
                            166u8,
                            223u8,
                            73u8,
                            150u8,
                            26u8,
                            121u8,
                            173u8,
                            57u8,
                            241u8,
                            241u8,
                            150u8,
                            176u8,
                            106u8,
                            195u8,
                            152u8,
                            148u8,
                            29u8,
                            92u8,
                            89u8,
                        ],
                    )
                }
                /// The current signature threshold (i.e. the `t` in t-of-n)
                pub fn next_signature_threshold(
                    &self,
                ) -> ::subxt::storage::address::Address<
                    ::subxt::storage::address::StaticStorageMapKey,
                    ::core::primitive::u16,
                    ::subxt::storage::address::Yes,
                    ::subxt::storage::address::Yes,
                    (),
                > {
                    ::subxt::storage::address::Address::new_static(
                        "DKG",
                        "NextSignatureThreshold",
                        vec![],
                        [
                            14u8,
                            124u8,
                            254u8,
                            33u8,
                            18u8,
                            121u8,
                            117u8,
                            199u8,
                            248u8,
                            169u8,
                            167u8,
                            124u8,
                            46u8,
                            13u8,
                            110u8,
                            8u8,
                            243u8,
                            194u8,
                            65u8,
                            145u8,
                            196u8,
                            40u8,
                            190u8,
                            126u8,
                            144u8,
                            123u8,
                            188u8,
                            220u8,
                            169u8,
                            217u8,
                            15u8,
                            106u8,
                        ],
                    )
                }
                /// The current signature threshold (i.e. the `n` in t-of-n)
                pub fn next_keygen_threshold(
                    &self,
                ) -> ::subxt::storage::address::Address<
                    ::subxt::storage::address::StaticStorageMapKey,
                    ::core::primitive::u16,
                    ::subxt::storage::address::Yes,
                    ::subxt::storage::address::Yes,
                    (),
                > {
                    ::subxt::storage::address::Address::new_static(
                        "DKG",
                        "NextKeygenThreshold",
                        vec![],
                        [
                            129u8,
                            150u8,
                            252u8,
                            3u8,
                            4u8,
                            210u8,
                            28u8,
                            76u8,
                            103u8,
                            39u8,
                            225u8,
                            148u8,
                            197u8,
                            14u8,
                            53u8,
                            19u8,
                            212u8,
                            21u8,
                            15u8,
                            137u8,
                            84u8,
                            236u8,
                            189u8,
                            247u8,
                            58u8,
                            150u8,
                            98u8,
                            234u8,
                            132u8,
                            53u8,
                            132u8,
                            173u8,
                        ],
                    )
                }
                /// The pending signature threshold (i.e. the `t` in t-of-n)
                pub fn pending_signature_threshold(
                    &self,
                ) -> ::subxt::storage::address::Address<
                    ::subxt::storage::address::StaticStorageMapKey,
                    ::core::primitive::u16,
                    ::subxt::storage::address::Yes,
                    ::subxt::storage::address::Yes,
                    (),
                > {
                    ::subxt::storage::address::Address::new_static(
                        "DKG",
                        "PendingSignatureThreshold",
                        vec![],
                        [
                            56u8,
                            126u8,
                            123u8,
                            150u8,
                            41u8,
                            230u8,
                            230u8,
                            223u8,
                            87u8,
                            76u8,
                            64u8,
                            237u8,
                            214u8,
                            185u8,
                            37u8,
                            21u8,
                            206u8,
                            49u8,
                            237u8,
                            131u8,
                            141u8,
                            210u8,
                            121u8,
                            38u8,
                            98u8,
                            49u8,
                            43u8,
                            124u8,
                            95u8,
                            116u8,
                            37u8,
                            190u8,
                        ],
                    )
                }
                /// The pending signature threshold (i.e. the `n` in t-of-n)
                pub fn pending_keygen_threshold(
                    &self,
                ) -> ::subxt::storage::address::Address<
                    ::subxt::storage::address::StaticStorageMapKey,
                    ::core::primitive::u16,
                    ::subxt::storage::address::Yes,
                    ::subxt::storage::address::Yes,
                    (),
                > {
                    ::subxt::storage::address::Address::new_static(
                        "DKG",
                        "PendingKeygenThreshold",
                        vec![],
                        [
                            239u8,
                            193u8,
                            105u8,
                            65u8,
                            252u8,
                            192u8,
                            122u8,
                            62u8,
                            115u8,
                            222u8,
                            14u8,
                            248u8,
                            62u8,
                            79u8,
                            132u8,
                            217u8,
                            85u8,
                            171u8,
                            254u8,
                            145u8,
                            139u8,
                            56u8,
                            117u8,
                            222u8,
                            220u8,
                            29u8,
                            174u8,
                            98u8,
                            173u8,
                            122u8,
                            41u8,
                            59u8,
                        ],
                    )
                }
                /// The current authorities set
                pub fn authorities(
                    &self,
                ) -> ::subxt::storage::address::Address<
                    ::subxt::storage::address::StaticStorageMapKey,
                    runtime_types::bounded_collections::bounded_vec::BoundedVec<
                        runtime_types::dkg_runtime_primitives::crypto::Public,
                    >,
                    ::subxt::storage::address::Yes,
                    ::subxt::storage::address::Yes,
                    (),
                > {
                    ::subxt::storage::address::Address::new_static(
                        "DKG",
                        "Authorities",
                        vec![],
                        [
                            53u8,
                            171u8,
                            94u8,
                            33u8,
                            46u8,
                            83u8,
                            105u8,
                            120u8,
                            123u8,
                            201u8,
                            141u8,
                            71u8,
                            131u8,
                            150u8,
                            51u8,
                            121u8,
                            67u8,
                            45u8,
                            249u8,
                            146u8,
                            85u8,
                            113u8,
                            23u8,
                            59u8,
                            59u8,
                            41u8,
                            0u8,
                            226u8,
                            98u8,
                            166u8,
                            253u8,
                            59u8,
                        ],
                    )
                }
                /// The current authority set id
                pub fn authority_set_id(
                    &self,
                ) -> ::subxt::storage::address::Address<
                    ::subxt::storage::address::StaticStorageMapKey,
                    ::core::primitive::u64,
                    ::subxt::storage::address::Yes,
                    ::subxt::storage::address::Yes,
                    (),
                > {
                    ::subxt::storage::address::Address::new_static(
                        "DKG",
                        "AuthoritySetId",
                        vec![],
                        [
                            77u8,
                            71u8,
                            25u8,
                            7u8,
                            186u8,
                            84u8,
                            65u8,
                            61u8,
                            103u8,
                            125u8,
                            147u8,
                            28u8,
                            6u8,
                            32u8,
                            153u8,
                            18u8,
                            237u8,
                            162u8,
                            5u8,
                            166u8,
                            51u8,
                            162u8,
                            231u8,
                            251u8,
                            232u8,
                            157u8,
                            83u8,
                            226u8,
                            20u8,
                            47u8,
                            219u8,
                            154u8,
                        ],
                    )
                }
                /// The next authority set id
                pub fn next_authority_set_id(
                    &self,
                ) -> ::subxt::storage::address::Address<
                    ::subxt::storage::address::StaticStorageMapKey,
                    ::core::primitive::u64,
                    ::subxt::storage::address::Yes,
                    ::subxt::storage::address::Yes,
                    (),
                > {
                    ::subxt::storage::address::Address::new_static(
                        "DKG",
                        "NextAuthoritySetId",
                        vec![],
                        [
                            69u8,
                            50u8,
                            176u8,
                            141u8,
                            138u8,
                            179u8,
                            51u8,
                            104u8,
                            26u8,
                            64u8,
                            106u8,
                            90u8,
                            148u8,
                            51u8,
                            19u8,
                            39u8,
                            33u8,
                            1u8,
                            49u8,
                            105u8,
                            196u8,
                            160u8,
                            241u8,
                            160u8,
                            207u8,
                            136u8,
                            243u8,
                            74u8,
                            63u8,
                            196u8,
                            251u8,
                            107u8,
                        ],
                    )
                }
                /// Authorities set scheduled to be used with the next session
                pub fn next_authorities(
                    &self,
                ) -> ::subxt::storage::address::Address<
                    ::subxt::storage::address::StaticStorageMapKey,
                    runtime_types::bounded_collections::bounded_vec::BoundedVec<
                        runtime_types::dkg_runtime_primitives::crypto::Public,
                    >,
                    ::subxt::storage::address::Yes,
                    ::subxt::storage::address::Yes,
                    (),
                > {
                    ::subxt::storage::address::Address::new_static(
                        "DKG",
                        "NextAuthorities",
                        vec![],
                        [
                            87u8,
                            180u8,
                            0u8,
                            85u8,
                            209u8,
                            13u8,
                            131u8,
                            103u8,
                            8u8,
                            226u8,
                            42u8,
                            72u8,
                            38u8,
                            47u8,
                            190u8,
                            78u8,
                            62u8,
                            4u8,
                            161u8,
                            130u8,
                            87u8,
                            196u8,
                            13u8,
                            209u8,
                            205u8,
                            98u8,
                            104u8,
                            91u8,
                            3u8,
                            47u8,
                            82u8,
                            11u8,
                        ],
                    )
                }
                /// Accounts for the current authorities
                pub fn current_authorities_accounts(
                    &self,
                ) -> ::subxt::storage::address::Address<
                    ::subxt::storage::address::StaticStorageMapKey,
                    runtime_types::bounded_collections::bounded_vec::BoundedVec<
                        ::subxt::utils::AccountId32,
                    >,
                    ::subxt::storage::address::Yes,
                    ::subxt::storage::address::Yes,
                    (),
                > {
                    ::subxt::storage::address::Address::new_static(
                        "DKG",
                        "CurrentAuthoritiesAccounts",
                        vec![],
                        [
                            156u8,
                            122u8,
                            60u8,
                            135u8,
                            155u8,
                            134u8,
                            214u8,
                            166u8,
                            58u8,
                            162u8,
                            239u8,
                            199u8,
                            111u8,
                            68u8,
                            166u8,
                            17u8,
                            251u8,
                            99u8,
                            113u8,
                            247u8,
                            32u8,
                            14u8,
                            245u8,
                            94u8,
                            214u8,
                            212u8,
                            187u8,
                            160u8,
                            177u8,
                            228u8,
                            17u8,
                            209u8,
                        ],
                    )
                }
                /// Authority account ids scheduled for the next session
                pub fn next_authorities_accounts(
                    &self,
                ) -> ::subxt::storage::address::Address<
                    ::subxt::storage::address::StaticStorageMapKey,
                    runtime_types::bounded_collections::bounded_vec::BoundedVec<
                        ::subxt::utils::AccountId32,
                    >,
                    ::subxt::storage::address::Yes,
                    ::subxt::storage::address::Yes,
                    (),
                > {
                    ::subxt::storage::address::Address::new_static(
                        "DKG",
                        "NextAuthoritiesAccounts",
                        vec![],
                        [
                            151u8,
                            246u8,
                            186u8,
                            8u8,
                            153u8,
                            60u8,
                            232u8,
                            7u8,
                            117u8,
                            163u8,
                            41u8,
                            112u8,
                            223u8,
                            97u8,
                            66u8,
                            252u8,
                            39u8,
                            84u8,
                            130u8,
                            47u8,
                            107u8,
                            1u8,
                            154u8,
                            134u8,
                            52u8,
                            92u8,
                            220u8,
                            233u8,
                            102u8,
                            98u8,
                            2u8,
                            163u8,
                        ],
                    )
                }
                /// Authority account ids scheduled for the next session
                pub fn account_to_authority(
                    &self,
                    _0: impl ::std::borrow::Borrow<::subxt::utils::AccountId32>,
                ) -> ::subxt::storage::address::Address<
                    ::subxt::storage::address::StaticStorageMapKey,
                    runtime_types::dkg_runtime_primitives::crypto::Public,
                    ::subxt::storage::address::Yes,
                    (),
                    ::subxt::storage::address::Yes,
                > {
                    ::subxt::storage::address::Address::new_static(
                        "DKG",
                        "AccountToAuthority",
                        vec![
                            ::subxt::storage::address::make_static_storage_map_key(_0
                            .borrow())
                        ],
                        [
                            225u8,
                            159u8,
                            34u8,
                            162u8,
                            115u8,
                            136u8,
                            176u8,
                            245u8,
                            209u8,
                            84u8,
                            20u8,
                            81u8,
                            170u8,
                            220u8,
                            67u8,
                            18u8,
                            217u8,
                            206u8,
                            120u8,
                            241u8,
                            11u8,
                            73u8,
                            193u8,
                            177u8,
                            16u8,
                            66u8,
                            188u8,
                            21u8,
                            67u8,
                            78u8,
                            250u8,
                            94u8,
                        ],
                    )
                }
                /// Authority account ids scheduled for the next session
                pub fn account_to_authority_root(
                    &self,
                ) -> ::subxt::storage::address::Address<
                    ::subxt::storage::address::StaticStorageMapKey,
                    runtime_types::dkg_runtime_primitives::crypto::Public,
                    (),
                    (),
                    ::subxt::storage::address::Yes,
                > {
                    ::subxt::storage::address::Address::new_static(
                        "DKG",
                        "AccountToAuthority",
                        Vec::new(),
                        [
                            225u8,
                            159u8,
                            34u8,
                            162u8,
                            115u8,
                            136u8,
                            176u8,
                            245u8,
                            209u8,
                            84u8,
                            20u8,
                            81u8,
                            170u8,
                            220u8,
                            67u8,
                            18u8,
                            217u8,
                            206u8,
                            120u8,
                            241u8,
                            11u8,
                            73u8,
                            193u8,
                            177u8,
                            16u8,
                            66u8,
                            188u8,
                            21u8,
                            67u8,
                            78u8,
                            250u8,
                            94u8,
                        ],
                    )
                }
                /// Tracks misbehaviour reports
                pub fn misbehaviour_reports(
                    &self,
                    _0: impl ::std::borrow::Borrow<
                        runtime_types::dkg_runtime_primitives::MisbehaviourType,
                    >,
                    _1: impl ::std::borrow::Borrow<::core::primitive::u64>,
                    _2: impl ::std::borrow::Borrow<
                        runtime_types::dkg_runtime_primitives::crypto::Public,
                    >,
                ) -> ::subxt::storage::address::Address<
                    ::subxt::storage::address::StaticStorageMapKey,
                    runtime_types::dkg_runtime_primitives::AggregatedMisbehaviourReports<
                        runtime_types::dkg_runtime_primitives::crypto::Public,
                        runtime_types::dkg_runtime_primitives::CustomU32Getter3,
                        runtime_types::dkg_runtime_primitives::CustomU32Getter4,
                    >,
                    ::subxt::storage::address::Yes,
                    (),
                    ::subxt::storage::address::Yes,
                > {
                    ::subxt::storage::address::Address::new_static(
                        "DKG",
                        "MisbehaviourReports",
                        vec![
                            ::subxt::storage::address::make_static_storage_map_key(_0
                            .borrow()),
                            ::subxt::storage::address::make_static_storage_map_key(_1
                            .borrow()),
                            ::subxt::storage::address::make_static_storage_map_key(_2
                            .borrow())
                        ],
                        [
                            171u8,
                            79u8,
                            198u8,
                            127u8,
                            112u8,
                            30u8,
                            83u8,
                            187u8,
                            108u8,
                            9u8,
                            182u8,
                            17u8,
                            175u8,
                            16u8,
                            51u8,
                            51u8,
                            89u8,
                            209u8,
                            230u8,
                            37u8,
                            19u8,
                            166u8,
                            159u8,
                            139u8,
                            62u8,
                            216u8,
                            21u8,
                            213u8,
                            111u8,
                            86u8,
                            210u8,
                            203u8,
                        ],
                    )
                }
                /// Tracks misbehaviour reports
                pub fn misbehaviour_reports_root(
                    &self,
                ) -> ::subxt::storage::address::Address<
                    ::subxt::storage::address::StaticStorageMapKey,
                    runtime_types::dkg_runtime_primitives::AggregatedMisbehaviourReports<
                        runtime_types::dkg_runtime_primitives::crypto::Public,
                        runtime_types::dkg_runtime_primitives::CustomU32Getter3,
                        runtime_types::dkg_runtime_primitives::CustomU32Getter4,
                    >,
                    (),
                    (),
                    ::subxt::storage::address::Yes,
                > {
                    ::subxt::storage::address::Address::new_static(
                        "DKG",
                        "MisbehaviourReports",
                        Vec::new(),
                        [
                            171u8,
                            79u8,
                            198u8,
                            127u8,
                            112u8,
                            30u8,
                            83u8,
                            187u8,
                            108u8,
                            9u8,
                            182u8,
                            17u8,
                            175u8,
                            16u8,
                            51u8,
                            51u8,
                            89u8,
                            209u8,
                            230u8,
                            37u8,
                            19u8,
                            166u8,
                            159u8,
                            139u8,
                            62u8,
                            216u8,
                            21u8,
                            213u8,
                            111u8,
                            86u8,
                            210u8,
                            203u8,
                        ],
                    )
                }
                /// Tracks authority reputations
                pub fn authority_reputations(
                    &self,
                    _0: impl ::std::borrow::Borrow<
                        runtime_types::dkg_runtime_primitives::crypto::Public,
                    >,
                ) -> ::subxt::storage::address::Address<
                    ::subxt::storage::address::StaticStorageMapKey,
                    ::core::primitive::u128,
                    ::subxt::storage::address::Yes,
                    ::subxt::storage::address::Yes,
                    ::subxt::storage::address::Yes,
                > {
                    ::subxt::storage::address::Address::new_static(
                        "DKG",
                        "AuthorityReputations",
                        vec![
                            ::subxt::storage::address::make_static_storage_map_key(_0
                            .borrow())
                        ],
                        [
                            19u8,
                            245u8,
                            5u8,
                            216u8,
                            182u8,
                            106u8,
                            213u8,
                            138u8,
                            216u8,
                            24u8,
                            169u8,
                            16u8,
                            23u8,
                            88u8,
                            39u8,
                            25u8,
                            200u8,
                            84u8,
                            253u8,
                            232u8,
                            250u8,
                            147u8,
                            78u8,
                            211u8,
                            141u8,
                            37u8,
                            98u8,
                            121u8,
                            139u8,
                            48u8,
                            25u8,
                            101u8,
                        ],
                    )
                }
                /// Tracks authority reputations
                pub fn authority_reputations_root(
                    &self,
                ) -> ::subxt::storage::address::Address<
                    ::subxt::storage::address::StaticStorageMapKey,
                    ::core::primitive::u128,
                    (),
                    ::subxt::storage::address::Yes,
                    ::subxt::storage::address::Yes,
                > {
                    ::subxt::storage::address::Address::new_static(
                        "DKG",
                        "AuthorityReputations",
                        Vec::new(),
                        [
                            19u8,
                            245u8,
                            5u8,
                            216u8,
                            182u8,
                            106u8,
                            213u8,
                            138u8,
                            216u8,
                            24u8,
                            169u8,
                            16u8,
                            23u8,
                            88u8,
                            39u8,
                            25u8,
                            200u8,
                            84u8,
                            253u8,
                            232u8,
                            250u8,
                            147u8,
                            78u8,
                            211u8,
                            141u8,
                            37u8,
                            98u8,
                            121u8,
                            139u8,
                            48u8,
                            25u8,
                            101u8,
                        ],
                    )
                }
                /// Tracks jailed authorities for keygen by mapping
                /// to the block number when the authority was last jailed
                pub fn jailed_keygen_authorities(
                    &self,
                    _0: impl ::std::borrow::Borrow<
                        runtime_types::dkg_runtime_primitives::crypto::Public,
                    >,
                ) -> ::subxt::storage::address::Address<
                    ::subxt::storage::address::StaticStorageMapKey,
                    ::core::primitive::u32,
                    ::subxt::storage::address::Yes,
                    ::subxt::storage::address::Yes,
                    ::subxt::storage::address::Yes,
                > {
                    ::subxt::storage::address::Address::new_static(
                        "DKG",
                        "JailedKeygenAuthorities",
                        vec![
                            ::subxt::storage::address::make_static_storage_map_key(_0
                            .borrow())
                        ],
                        [
                            143u8,
                            133u8,
                            141u8,
                            48u8,
                            122u8,
                            81u8,
                            62u8,
                            94u8,
                            51u8,
                            106u8,
                            249u8,
                            75u8,
                            234u8,
                            96u8,
                            106u8,
                            130u8,
                            242u8,
                            202u8,
                            37u8,
                            123u8,
                            218u8,
                            184u8,
                            201u8,
                            216u8,
                            10u8,
                            15u8,
                            48u8,
                            218u8,
                            67u8,
                            144u8,
                            53u8,
                            143u8,
                        ],
                    )
                }
                /// Tracks jailed authorities for keygen by mapping
                /// to the block number when the authority was last jailed
                pub fn jailed_keygen_authorities_root(
                    &self,
                ) -> ::subxt::storage::address::Address<
                    ::subxt::storage::address::StaticStorageMapKey,
                    ::core::primitive::u32,
                    (),
                    ::subxt::storage::address::Yes,
                    ::subxt::storage::address::Yes,
                > {
                    ::subxt::storage::address::Address::new_static(
                        "DKG",
                        "JailedKeygenAuthorities",
                        Vec::new(),
                        [
                            143u8,
                            133u8,
                            141u8,
                            48u8,
                            122u8,
                            81u8,
                            62u8,
                            94u8,
                            51u8,
                            106u8,
                            249u8,
                            75u8,
                            234u8,
                            96u8,
                            106u8,
                            130u8,
                            242u8,
                            202u8,
                            37u8,
                            123u8,
                            218u8,
                            184u8,
                            201u8,
                            216u8,
                            10u8,
                            15u8,
                            48u8,
                            218u8,
                            67u8,
                            144u8,
                            53u8,
                            143u8,
                        ],
                    )
                }
                /// Tracks jailed authorities for signing by mapping
                /// to the block number when the authority was last jailed
                pub fn jailed_signing_authorities(
                    &self,
                    _0: impl ::std::borrow::Borrow<
                        runtime_types::dkg_runtime_primitives::crypto::Public,
                    >,
                ) -> ::subxt::storage::address::Address<
                    ::subxt::storage::address::StaticStorageMapKey,
                    ::core::primitive::u32,
                    ::subxt::storage::address::Yes,
                    ::subxt::storage::address::Yes,
                    ::subxt::storage::address::Yes,
                > {
                    ::subxt::storage::address::Address::new_static(
                        "DKG",
                        "JailedSigningAuthorities",
                        vec![
                            ::subxt::storage::address::make_static_storage_map_key(_0
                            .borrow())
                        ],
                        [
                            42u8,
                            185u8,
                            129u8,
                            65u8,
                            71u8,
                            185u8,
                            40u8,
                            227u8,
                            138u8,
                            92u8,
                            105u8,
                            97u8,
                            139u8,
                            160u8,
                            25u8,
                            220u8,
                            203u8,
                            250u8,
                            242u8,
                            157u8,
                            51u8,
                            143u8,
                            47u8,
                            62u8,
                            186u8,
                            248u8,
                            99u8,
                            40u8,
                            102u8,
                            181u8,
                            31u8,
                            100u8,
                        ],
                    )
                }
                /// Tracks jailed authorities for signing by mapping
                /// to the block number when the authority was last jailed
                pub fn jailed_signing_authorities_root(
                    &self,
                ) -> ::subxt::storage::address::Address<
                    ::subxt::storage::address::StaticStorageMapKey,
                    ::core::primitive::u32,
                    (),
                    ::subxt::storage::address::Yes,
                    ::subxt::storage::address::Yes,
                > {
                    ::subxt::storage::address::Address::new_static(
                        "DKG",
                        "JailedSigningAuthorities",
                        Vec::new(),
                        [
                            42u8,
                            185u8,
                            129u8,
                            65u8,
                            71u8,
                            185u8,
                            40u8,
                            227u8,
                            138u8,
                            92u8,
                            105u8,
                            97u8,
                            139u8,
                            160u8,
                            25u8,
                            220u8,
                            203u8,
                            250u8,
                            242u8,
                            157u8,
                            51u8,
                            143u8,
                            47u8,
                            62u8,
                            186u8,
                            248u8,
                            99u8,
                            40u8,
                            102u8,
                            181u8,
                            31u8,
                            100u8,
                        ],
                    )
                }
                /// The current best authorities of the active keygen set
                pub fn best_authorities(
                    &self,
                ) -> ::subxt::storage::address::Address<
                    ::subxt::storage::address::StaticStorageMapKey,
                    runtime_types::bounded_collections::bounded_vec::BoundedVec<
                        (
                            ::core::primitive::u16,
                            runtime_types::dkg_runtime_primitives::crypto::Public,
                        ),
                    >,
                    ::subxt::storage::address::Yes,
                    ::subxt::storage::address::Yes,
                    (),
                > {
                    ::subxt::storage::address::Address::new_static(
                        "DKG",
                        "BestAuthorities",
                        vec![],
                        [
                            69u8,
                            22u8,
                            131u8,
                            206u8,
                            244u8,
                            125u8,
                            196u8,
                            99u8,
                            38u8,
                            142u8,
                            26u8,
                            224u8,
                            8u8,
                            127u8,
                            78u8,
                            209u8,
                            215u8,
                            50u8,
                            34u8,
                            238u8,
                            80u8,
                            155u8,
                            242u8,
                            241u8,
                            1u8,
                            10u8,
                            71u8,
                            176u8,
                            65u8,
                            28u8,
                            244u8,
                            62u8,
                        ],
                    )
                }
                /// The next best authorities of the active keygen set
                pub fn next_best_authorities(
                    &self,
                ) -> ::subxt::storage::address::Address<
                    ::subxt::storage::address::StaticStorageMapKey,
                    runtime_types::bounded_collections::bounded_vec::BoundedVec<
                        (
                            ::core::primitive::u16,
                            runtime_types::dkg_runtime_primitives::crypto::Public,
                        ),
                    >,
                    ::subxt::storage::address::Yes,
                    ::subxt::storage::address::Yes,
                    (),
                > {
                    ::subxt::storage::address::Address::new_static(
                        "DKG",
                        "NextBestAuthorities",
                        vec![],
                        [
                            86u8,
                            250u8,
                            160u8,
                            155u8,
                            28u8,
                            165u8,
                            124u8,
                            100u8,
                            95u8,
                            55u8,
                            91u8,
                            193u8,
                            3u8,
                            20u8,
                            128u8,
                            70u8,
                            180u8,
                            122u8,
                            202u8,
                            216u8,
                            92u8,
                            55u8,
                            15u8,
                            219u8,
                            217u8,
                            197u8,
                            0u8,
                            11u8,
                            167u8,
                            171u8,
                            113u8,
                            53u8,
                        ],
                    )
                }
                /// The last BlockNumber at which the session rotation happened
                pub fn last_session_rotation_block(
                    &self,
                ) -> ::subxt::storage::address::Address<
                    ::subxt::storage::address::StaticStorageMapKey,
                    ::core::primitive::u32,
                    ::subxt::storage::address::Yes,
                    ::subxt::storage::address::Yes,
                    (),
                > {
                    ::subxt::storage::address::Address::new_static(
                        "DKG",
                        "LastSessionRotationBlock",
                        vec![],
                        [
                            154u8,
                            46u8,
                            45u8,
                            246u8,
                            74u8,
                            245u8,
                            35u8,
                            239u8,
                            188u8,
                            35u8,
                            171u8,
                            175u8,
                            172u8,
                            119u8,
                            248u8,
                            0u8,
                            208u8,
                            84u8,
                            154u8,
                            181u8,
                            125u8,
                            249u8,
                            198u8,
                            29u8,
                            197u8,
                            199u8,
                            189u8,
                            227u8,
                            215u8,
                            194u8,
                            107u8,
                            27u8,
                        ],
                    )
                }
                /// The pending refresh proposal waiting for signature
                pub fn pending_refresh_proposal(
                    &self,
                ) -> ::subxt::storage::address::Address<
                    ::subxt::storage::address::StaticStorageMapKey,
                    runtime_types::dkg_runtime_primitives::proposal::RefreshProposal,
                    ::subxt::storage::address::Yes,
                    (),
                    (),
                > {
                    ::subxt::storage::address::Address::new_static(
                        "DKG",
                        "PendingRefreshProposal",
                        vec![],
                        [
                            170u8,
                            79u8,
                            167u8,
                            3u8,
                            128u8,
                            156u8,
                            7u8,
                            124u8,
                            130u8,
                            39u8,
                            16u8,
                            116u8,
                            71u8,
                            81u8,
                            2u8,
                            255u8,
                            61u8,
                            28u8,
                            125u8,
                            187u8,
                            160u8,
                            82u8,
                            45u8,
                            21u8,
                            140u8,
                            220u8,
                            239u8,
                            211u8,
                            222u8,
                            211u8,
                            144u8,
                            97u8,
                        ],
                    )
                }
                /// The current refresh proposal signed and ready to process
                pub fn current_refresh_proposal(
                    &self,
                ) -> ::subxt::storage::address::Address<
                    ::subxt::storage::address::StaticStorageMapKey,
                    runtime_types::dkg_runtime_primitives::proposal::RefreshProposal,
                    ::subxt::storage::address::Yes,
                    (),
                    (),
                > {
                    ::subxt::storage::address::Address::new_static(
                        "DKG",
                        "CurrentRefreshProposal",
                        vec![],
                        [
                            206u8,
                            78u8,
                            0u8,
                            48u8,
                            70u8,
                            78u8,
                            76u8,
                            195u8,
                            11u8,
                            77u8,
                            51u8,
                            9u8,
                            214u8,
                            172u8,
                            229u8,
                            25u8,
                            197u8,
                            10u8,
                            136u8,
                            5u8,
                            138u8,
                            38u8,
                            87u8,
                            11u8,
                            73u8,
                            34u8,
                            28u8,
                            32u8,
                            47u8,
                            45u8,
                            77u8,
                            147u8,
                        ],
                    )
                }
            }
        }
        pub mod constants {
            use super::runtime_types;
            pub struct ConstantsApi;
            impl ConstantsApi {
                /// Number of blocks of cooldown after unsigned transaction is included.
                ///
                /// This ensures that we only accept unsigned transactions once, every `UnsignedInterval`
                /// blocks.
                pub fn unsigned_interval(
                    &self,
                ) -> ::subxt::constants::Address<::core::primitive::u32> {
                    ::subxt::constants::Address::new_static(
                        "DKG",
                        "UnsignedInterval",
                        [
                            98u8,
                            252u8,
                            116u8,
                            72u8,
                            26u8,
                            180u8,
                            225u8,
                            83u8,
                            200u8,
                            157u8,
                            125u8,
                            151u8,
                            53u8,
                            76u8,
                            168u8,
                            26u8,
                            10u8,
                            9u8,
                            98u8,
                            68u8,
                            9u8,
                            178u8,
                            197u8,
                            113u8,
                            31u8,
                            79u8,
                            200u8,
                            90u8,
                            203u8,
                            100u8,
                            41u8,
                            145u8,
                        ],
                    )
                }
                /// A configuration for base priority of unsigned transactions.
                ///
                /// This is exposed so that it can be tuned for particular runtime, when
                /// multiple pallets send unsigned transactions.
                pub fn unsigned_priority(
                    &self,
                ) -> ::subxt::constants::Address<::core::primitive::u64> {
                    ::subxt::constants::Address::new_static(
                        "DKG",
                        "UnsignedPriority",
                        [
                            128u8,
                            214u8,
                            205u8,
                            242u8,
                            181u8,
                            142u8,
                            124u8,
                            231u8,
                            190u8,
                            146u8,
                            59u8,
                            226u8,
                            157u8,
                            101u8,
                            103u8,
                            117u8,
                            249u8,
                            65u8,
                            18u8,
                            191u8,
                            103u8,
                            119u8,
                            53u8,
                            85u8,
                            81u8,
                            96u8,
                            220u8,
                            42u8,
                            184u8,
                            239u8,
                            42u8,
                            246u8,
                        ],
                    )
                }
                /// Session length helper allowing to query session length across runtime upgrades.
                pub fn session_period(
                    &self,
                ) -> ::subxt::constants::Address<::core::primitive::u32> {
                    ::subxt::constants::Address::new_static(
                        "DKG",
                        "SessionPeriod",
                        [
                            98u8,
                            252u8,
                            116u8,
                            72u8,
                            26u8,
                            180u8,
                            225u8,
                            83u8,
                            200u8,
                            157u8,
                            125u8,
                            151u8,
                            53u8,
                            76u8,
                            168u8,
                            26u8,
                            10u8,
                            9u8,
                            98u8,
                            68u8,
                            9u8,
                            178u8,
                            197u8,
                            113u8,
                            31u8,
                            79u8,
                            200u8,
                            90u8,
                            203u8,
                            100u8,
                            41u8,
                            145u8,
                        ],
                    )
                }
                /// MaxLength for keys
                pub fn max_key_length(
                    &self,
                ) -> ::subxt::constants::Address<::core::primitive::u32> {
                    ::subxt::constants::Address::new_static(
                        "DKG",
                        "MaxKeyLength",
                        [
                            98u8,
                            252u8,
                            116u8,
                            72u8,
                            26u8,
                            180u8,
                            225u8,
                            83u8,
                            200u8,
                            157u8,
                            125u8,
                            151u8,
                            53u8,
                            76u8,
                            168u8,
                            26u8,
                            10u8,
                            9u8,
                            98u8,
                            68u8,
                            9u8,
                            178u8,
                            197u8,
                            113u8,
                            31u8,
                            79u8,
                            200u8,
                            90u8,
                            203u8,
                            100u8,
                            41u8,
                            145u8,
                        ],
                    )
                }
                /// MaxLength for signature
                pub fn max_signature_length(
                    &self,
                ) -> ::subxt::constants::Address<::core::primitive::u32> {
                    ::subxt::constants::Address::new_static(
                        "DKG",
                        "MaxSignatureLength",
                        [
                            98u8,
                            252u8,
                            116u8,
                            72u8,
                            26u8,
                            180u8,
                            225u8,
                            83u8,
                            200u8,
                            157u8,
                            125u8,
                            151u8,
                            53u8,
                            76u8,
                            168u8,
                            26u8,
                            10u8,
                            9u8,
                            98u8,
                            68u8,
                            9u8,
                            178u8,
                            197u8,
                            113u8,
                            31u8,
                            79u8,
                            200u8,
                            90u8,
                            203u8,
                            100u8,
                            41u8,
                            145u8,
                        ],
                    )
                }
                /// Max authorities to store
                pub fn max_authorities(
                    &self,
                ) -> ::subxt::constants::Address<::core::primitive::u32> {
                    ::subxt::constants::Address::new_static(
                        "DKG",
                        "MaxAuthorities",
                        [
                            98u8,
                            252u8,
                            116u8,
                            72u8,
                            26u8,
                            180u8,
                            225u8,
                            83u8,
                            200u8,
                            157u8,
                            125u8,
                            151u8,
                            53u8,
                            76u8,
                            168u8,
                            26u8,
                            10u8,
                            9u8,
                            98u8,
                            68u8,
                            9u8,
                            178u8,
                            197u8,
                            113u8,
                            31u8,
                            79u8,
                            200u8,
                            90u8,
                            203u8,
                            100u8,
                            41u8,
                            145u8,
                        ],
                    )
                }
                /// Max reporters to store
                pub fn max_reporters(
                    &self,
                ) -> ::subxt::constants::Address<::core::primitive::u32> {
                    ::subxt::constants::Address::new_static(
                        "DKG",
                        "MaxReporters",
                        [
                            98u8,
                            252u8,
                            116u8,
                            72u8,
                            26u8,
                            180u8,
                            225u8,
                            83u8,
                            200u8,
                            157u8,
                            125u8,
                            151u8,
                            53u8,
                            76u8,
                            168u8,
                            26u8,
                            10u8,
                            9u8,
                            98u8,
                            68u8,
                            9u8,
                            178u8,
                            197u8,
                            113u8,
                            31u8,
                            79u8,
                            200u8,
                            90u8,
                            203u8,
                            100u8,
                            41u8,
                            145u8,
                        ],
                    )
                }
                /// Length of encoded proposer vote
                pub fn vote_length(
                    &self,
                ) -> ::subxt::constants::Address<::core::primitive::u32> {
                    ::subxt::constants::Address::new_static(
                        "DKG",
                        "VoteLength",
                        [
                            98u8,
                            252u8,
                            116u8,
                            72u8,
                            26u8,
                            180u8,
                            225u8,
                            83u8,
                            200u8,
                            157u8,
                            125u8,
                            151u8,
                            53u8,
                            76u8,
                            168u8,
                            26u8,
                            10u8,
                            9u8,
                            98u8,
                            68u8,
                            9u8,
                            178u8,
                            197u8,
                            113u8,
                            31u8,
                            79u8,
                            200u8,
                            90u8,
                            203u8,
                            100u8,
                            41u8,
                            145u8,
                        ],
                    )
                }
                /// Max length of a proposal
                pub fn max_proposal_length(
                    &self,
                ) -> ::subxt::constants::Address<::core::primitive::u32> {
                    ::subxt::constants::Address::new_static(
                        "DKG",
                        "MaxProposalLength",
                        [
                            98u8,
                            252u8,
                            116u8,
                            72u8,
                            26u8,
                            180u8,
                            225u8,
                            83u8,
                            200u8,
                            157u8,
                            125u8,
                            151u8,
                            53u8,
                            76u8,
                            168u8,
                            26u8,
                            10u8,
                            9u8,
                            98u8,
                            68u8,
                            9u8,
                            178u8,
                            197u8,
                            113u8,
                            31u8,
                            79u8,
                            200u8,
                            90u8,
                            203u8,
                            100u8,
                            41u8,
                            145u8,
                        ],
                    )
                }
            }
        }
    }
    pub mod dkg_proposals {
        use super::root_mod;
        use super::runtime_types;
        /**
			Custom [dispatch errors](https://docs.substrate.io/main-docs/build/events-errors/)
			of this pallet.
			*/
        pub type Error = runtime_types::pallet_dkg_proposals::pallet::Error;
        ///Contains one variant per dispatchable that can be called by an extrinsic.
        pub type Call = runtime_types::pallet_dkg_proposals::pallet::Call;
        pub mod calls {
            use super::root_mod;
            use super::runtime_types;
            type DispatchError = runtime_types::sp_runtime::DispatchError;
            pub mod types {
                use super::runtime_types;
                #[derive(
                    ::subxt::ext::codec::CompactAs,
                    ::subxt::ext::codec::Decode,
                    ::subxt::ext::codec::Encode,
                    ::subxt::ext::scale_decode::DecodeAsType,
                    ::subxt::ext::scale_encode::EncodeAsType,
                    Clone,
                    Debug,
                    Eq,
                    PartialEq
                )]
                #[codec(crate = ::subxt::ext::codec)]
                #[decode_as_type(crate_path = ":: subxt :: ext :: scale_decode")]
                #[encode_as_type(crate_path = ":: subxt :: ext :: scale_encode")]
                pub struct SetThreshold {
                    pub threshold: ::core::primitive::u32,
                }
                impl ::subxt::blocks::StaticExtrinsic for SetThreshold {
                    const PALLET: &'static str = "DKGProposals";
                    const CALL: &'static str = "set_threshold";
                }
                #[derive(
                    ::subxt::ext::codec::Decode,
                    ::subxt::ext::codec::Encode,
                    ::subxt::ext::scale_decode::DecodeAsType,
                    ::subxt::ext::scale_encode::EncodeAsType,
                    Clone,
                    Debug,
                    Eq,
                    PartialEq
                )]
                #[codec(crate = ::subxt::ext::codec)]
                #[decode_as_type(crate_path = ":: subxt :: ext :: scale_decode")]
                #[encode_as_type(crate_path = ":: subxt :: ext :: scale_encode")]
                pub struct SetResource {
                    pub id: runtime_types::webb_proposals::header::ResourceId,
                    pub method: ::std::vec::Vec<::core::primitive::u8>,
                }
                impl ::subxt::blocks::StaticExtrinsic for SetResource {
                    const PALLET: &'static str = "DKGProposals";
                    const CALL: &'static str = "set_resource";
                }
                #[derive(
                    ::subxt::ext::codec::Decode,
                    ::subxt::ext::codec::Encode,
                    ::subxt::ext::scale_decode::DecodeAsType,
                    ::subxt::ext::scale_encode::EncodeAsType,
                    Clone,
                    Debug,
                    Eq,
                    PartialEq
                )]
                #[codec(crate = ::subxt::ext::codec)]
                #[decode_as_type(crate_path = ":: subxt :: ext :: scale_decode")]
                #[encode_as_type(crate_path = ":: subxt :: ext :: scale_encode")]
                pub struct RemoveResource {
                    pub id: runtime_types::webb_proposals::header::ResourceId,
                }
                impl ::subxt::blocks::StaticExtrinsic for RemoveResource {
                    const PALLET: &'static str = "DKGProposals";
                    const CALL: &'static str = "remove_resource";
                }
                #[derive(
                    ::subxt::ext::codec::Decode,
                    ::subxt::ext::codec::Encode,
                    ::subxt::ext::scale_decode::DecodeAsType,
                    ::subxt::ext::scale_encode::EncodeAsType,
                    Clone,
                    Debug,
                    Eq,
                    PartialEq
                )]
                #[codec(crate = ::subxt::ext::codec)]
                #[decode_as_type(crate_path = ":: subxt :: ext :: scale_decode")]
                #[encode_as_type(crate_path = ":: subxt :: ext :: scale_encode")]
                pub struct WhitelistChain {
                    pub chain_id: runtime_types::webb_proposals::header::TypedChainId,
                }
                impl ::subxt::blocks::StaticExtrinsic for WhitelistChain {
                    const PALLET: &'static str = "DKGProposals";
                    const CALL: &'static str = "whitelist_chain";
                }
                #[derive(
                    ::subxt::ext::codec::Decode,
                    ::subxt::ext::codec::Encode,
                    ::subxt::ext::scale_decode::DecodeAsType,
                    ::subxt::ext::scale_encode::EncodeAsType,
                    Clone,
                    Debug,
                    Eq,
                    PartialEq
                )]
                #[codec(crate = ::subxt::ext::codec)]
                #[decode_as_type(crate_path = ":: subxt :: ext :: scale_decode")]
                #[encode_as_type(crate_path = ":: subxt :: ext :: scale_encode")]
                pub struct AcknowledgeProposal {
                    pub prop: runtime_types::webb_proposals::proposal::Proposal<
                        runtime_types::dkg_runtime_primitives::CustomU32Getter,
                    >,
                }
                impl ::subxt::blocks::StaticExtrinsic for AcknowledgeProposal {
                    const PALLET: &'static str = "DKGProposals";
                    const CALL: &'static str = "acknowledge_proposal";
                }
                #[derive(
                    ::subxt::ext::codec::Decode,
                    ::subxt::ext::codec::Encode,
                    ::subxt::ext::scale_decode::DecodeAsType,
                    ::subxt::ext::scale_encode::EncodeAsType,
                    Clone,
                    Debug,
                    Eq,
                    PartialEq
                )]
                #[codec(crate = ::subxt::ext::codec)]
                #[decode_as_type(crate_path = ":: subxt :: ext :: scale_decode")]
                #[encode_as_type(crate_path = ":: subxt :: ext :: scale_encode")]
                pub struct RejectProposal {
                    pub prop: runtime_types::webb_proposals::proposal::Proposal<
                        runtime_types::dkg_runtime_primitives::CustomU32Getter,
                    >,
                }
                impl ::subxt::blocks::StaticExtrinsic for RejectProposal {
                    const PALLET: &'static str = "DKGProposals";
                    const CALL: &'static str = "reject_proposal";
                }
                #[derive(
                    ::subxt::ext::codec::Decode,
                    ::subxt::ext::codec::Encode,
                    ::subxt::ext::scale_decode::DecodeAsType,
                    ::subxt::ext::scale_encode::EncodeAsType,
                    Clone,
                    Debug,
                    Eq,
                    PartialEq
                )]
                #[codec(crate = ::subxt::ext::codec)]
                #[decode_as_type(crate_path = ":: subxt :: ext :: scale_decode")]
                #[encode_as_type(crate_path = ":: subxt :: ext :: scale_encode")]
                pub struct EvalVoteState {
                    pub nonce: runtime_types::webb_proposals::nonce::Nonce,
                    pub src_chain_id: runtime_types::webb_proposals::header::TypedChainId,
                    pub prop: runtime_types::webb_proposals::proposal::Proposal<
                        runtime_types::dkg_runtime_primitives::CustomU32Getter,
                    >,
                }
                impl ::subxt::blocks::StaticExtrinsic for EvalVoteState {
                    const PALLET: &'static str = "DKGProposals";
                    const CALL: &'static str = "eval_vote_state";
                }
            }
            pub struct TransactionApi;
            impl TransactionApi {
                ///Sets the vote threshold for proposals.
                ///
                ///This threshold is used to determine how many votes are required
                ///before a proposal is executed.
                ///
                ///# <weight>
                ///- O(1) lookup and insert
                ///# </weight>
                pub fn set_threshold(
                    &self,
                    threshold: ::core::primitive::u32,
                ) -> ::subxt::tx::Payload<types::SetThreshold> {
                    ::subxt::tx::Payload::new_static(
                        "DKGProposals",
                        "set_threshold",
                        types::SetThreshold { threshold },
                        [
                            3u8,
                            99u8,
                            76u8,
                            8u8,
                            152u8,
                            104u8,
                            97u8,
                            44u8,
                            34u8,
                            46u8,
                            161u8,
                            95u8,
                            83u8,
                            31u8,
                            211u8,
                            198u8,
                            25u8,
                            125u8,
                            172u8,
                            145u8,
                            204u8,
                            14u8,
                            255u8,
                            156u8,
                            17u8,
                            148u8,
                            40u8,
                            245u8,
                            42u8,
                            190u8,
                            118u8,
                            201u8,
                        ],
                    )
                }
                ///Stores a method name on chain under an associated resource ID.
                ///
                ///# <weight>
                ///- O(1) write
                ///# </weight>
                pub fn set_resource(
                    &self,
                    id: runtime_types::webb_proposals::header::ResourceId,
                    method: ::std::vec::Vec<::core::primitive::u8>,
                ) -> ::subxt::tx::Payload<types::SetResource> {
                    ::subxt::tx::Payload::new_static(
                        "DKGProposals",
                        "set_resource",
                        types::SetResource { id, method },
                        [
                            65u8,
                            156u8,
                            116u8,
                            182u8,
                            233u8,
                            133u8,
                            248u8,
                            67u8,
                            71u8,
                            37u8,
                            11u8,
                            97u8,
                            246u8,
                            25u8,
                            147u8,
                            5u8,
                            59u8,
                            115u8,
                            144u8,
                            165u8,
                            51u8,
                            58u8,
                            66u8,
                            85u8,
                            161u8,
                            2u8,
                            95u8,
                            239u8,
                            192u8,
                            229u8,
                            24u8,
                            163u8,
                        ],
                    )
                }
                ///Removes a resource ID from the resource mapping.
                ///
                ///After this call, bridge transfers with the associated resource ID
                ///will be rejected.
                ///
                ///# <weight>
                ///- O(1) removal
                ///# </weight>
                pub fn remove_resource(
                    &self,
                    id: runtime_types::webb_proposals::header::ResourceId,
                ) -> ::subxt::tx::Payload<types::RemoveResource> {
                    ::subxt::tx::Payload::new_static(
                        "DKGProposals",
                        "remove_resource",
                        types::RemoveResource { id },
                        [
                            175u8,
                            147u8,
                            87u8,
                            144u8,
                            238u8,
                            31u8,
                            153u8,
                            244u8,
                            63u8,
                            101u8,
                            21u8,
                            12u8,
                            236u8,
                            204u8,
                            0u8,
                            22u8,
                            27u8,
                            80u8,
                            209u8,
                            148u8,
                            118u8,
                            224u8,
                            115u8,
                            31u8,
                            104u8,
                            222u8,
                            190u8,
                            29u8,
                            40u8,
                            143u8,
                            214u8,
                            25u8,
                        ],
                    )
                }
                ///Enables a chain ID as a source or destination for a bridge transfer.
                ///
                ///# <weight>
                ///- O(1) lookup and insert
                ///# </weight>
                pub fn whitelist_chain(
                    &self,
                    chain_id: runtime_types::webb_proposals::header::TypedChainId,
                ) -> ::subxt::tx::Payload<types::WhitelistChain> {
                    ::subxt::tx::Payload::new_static(
                        "DKGProposals",
                        "whitelist_chain",
                        types::WhitelistChain { chain_id },
                        [
                            81u8,
                            87u8,
                            223u8,
                            191u8,
                            41u8,
                            122u8,
                            91u8,
                            107u8,
                            77u8,
                            174u8,
                            33u8,
                            141u8,
                            163u8,
                            249u8,
                            111u8,
                            187u8,
                            135u8,
                            171u8,
                            46u8,
                            75u8,
                            40u8,
                            38u8,
                            242u8,
                            172u8,
                            206u8,
                            137u8,
                            108u8,
                            21u8,
                            125u8,
                            53u8,
                            116u8,
                            13u8,
                        ],
                    )
                }
                ///Commits a vote in favour of the provided proposal.
                ///
                ///If a proposal with the given nonce and source chain ID does not
                ///already exist, it will be created with an initial vote in favour
                ///from the caller.
                ///
                ///# <weight>
                ///- weight of proposed call, regardless of whether execution is performed
                ///# </weight>
                pub fn acknowledge_proposal(
                    &self,
                    prop: runtime_types::webb_proposals::proposal::Proposal<
                        runtime_types::dkg_runtime_primitives::CustomU32Getter,
                    >,
                ) -> ::subxt::tx::Payload<types::AcknowledgeProposal> {
                    ::subxt::tx::Payload::new_static(
                        "DKGProposals",
                        "acknowledge_proposal",
                        types::AcknowledgeProposal { prop },
                        [
                            177u8,
                            189u8,
                            221u8,
                            170u8,
                            224u8,
                            166u8,
                            51u8,
                            38u8,
                            102u8,
                            207u8,
                            55u8,
                            128u8,
                            251u8,
                            208u8,
                            51u8,
                            201u8,
                            91u8,
                            162u8,
                            247u8,
                            30u8,
                            187u8,
                            143u8,
                            157u8,
                            32u8,
                            13u8,
                            21u8,
                            44u8,
                            102u8,
                            45u8,
                            16u8,
                            186u8,
                            31u8,
                        ],
                    )
                }
                ///Commits a vote against a provided proposal.
                ///
                ///# <weight>
                ///- Fixed, since execution of proposal should not be included
                ///# </weight>
                pub fn reject_proposal(
                    &self,
                    prop: runtime_types::webb_proposals::proposal::Proposal<
                        runtime_types::dkg_runtime_primitives::CustomU32Getter,
                    >,
                ) -> ::subxt::tx::Payload<types::RejectProposal> {
                    ::subxt::tx::Payload::new_static(
                        "DKGProposals",
                        "reject_proposal",
                        types::RejectProposal { prop },
                        [
                            70u8,
                            156u8,
                            249u8,
                            170u8,
                            69u8,
                            63u8,
                            60u8,
                            9u8,
                            72u8,
                            201u8,
                            154u8,
                            169u8,
                            97u8,
                            81u8,
                            9u8,
                            100u8,
                            115u8,
                            59u8,
                            236u8,
                            153u8,
                            50u8,
                            73u8,
                            150u8,
                            100u8,
                            234u8,
                            202u8,
                            148u8,
                            95u8,
                            8u8,
                            149u8,
                            177u8,
                            101u8,
                        ],
                    )
                }
                ///Evaluate the state of a proposal given the current vote threshold.
                ///
                ///A proposal with enough votes will be either executed or cancelled,
                ///and the status will be updated accordingly.
                ///
                ///# <weight>
                ///- weight of proposed call, regardless of whether execution is performed
                ///# </weight>
                pub fn eval_vote_state(
                    &self,
                    nonce: runtime_types::webb_proposals::nonce::Nonce,
                    src_chain_id: runtime_types::webb_proposals::header::TypedChainId,
                    prop: runtime_types::webb_proposals::proposal::Proposal<
                        runtime_types::dkg_runtime_primitives::CustomU32Getter,
                    >,
                ) -> ::subxt::tx::Payload<types::EvalVoteState> {
                    ::subxt::tx::Payload::new_static(
                        "DKGProposals",
                        "eval_vote_state",
                        types::EvalVoteState {
                            nonce,
                            src_chain_id,
                            prop,
                        },
                        [
                            91u8,
                            62u8,
                            156u8,
                            111u8,
                            253u8,
                            57u8,
                            11u8,
                            146u8,
                            193u8,
                            220u8,
                            214u8,
                            215u8,
                            129u8,
                            246u8,
                            31u8,
                            14u8,
                            66u8,
                            85u8,
                            240u8,
                            225u8,
                            33u8,
                            238u8,
                            187u8,
                            182u8,
                            236u8,
                            171u8,
                            211u8,
                            68u8,
                            159u8,
                            139u8,
                            88u8,
                            253u8,
                        ],
                    )
                }
            }
        }
        /**
			The [event](https://docs.substrate.io/main-docs/build/events-errors/) emitted
			by this pallet.
			*/
        pub type Event = runtime_types::pallet_dkg_proposals::pallet::Event;
        pub mod events {
            use super::runtime_types;
            #[derive(
                ::subxt::ext::codec::CompactAs,
                ::subxt::ext::codec::Decode,
                ::subxt::ext::codec::Encode,
                ::subxt::ext::scale_decode::DecodeAsType,
                ::subxt::ext::scale_encode::EncodeAsType,
                Clone,
                Debug,
                Eq,
                PartialEq
            )]
            #[codec(crate = ::subxt::ext::codec)]
            #[decode_as_type(crate_path = ":: subxt :: ext :: scale_decode")]
            #[encode_as_type(crate_path = ":: subxt :: ext :: scale_encode")]
            ///Vote threshold has changed (new_threshold)
            pub struct ProposerThresholdChanged {
                pub new_threshold: ::core::primitive::u32,
            }
            impl ::subxt::events::StaticEvent for ProposerThresholdChanged {
                const PALLET: &'static str = "DKGProposals";
                const EVENT: &'static str = "ProposerThresholdChanged";
            }
            #[derive(
                ::subxt::ext::codec::Decode,
                ::subxt::ext::codec::Encode,
                ::subxt::ext::scale_decode::DecodeAsType,
                ::subxt::ext::scale_encode::EncodeAsType,
                Clone,
                Debug,
                Eq,
                PartialEq
            )]
            #[codec(crate = ::subxt::ext::codec)]
            #[decode_as_type(crate_path = ":: subxt :: ext :: scale_decode")]
            #[encode_as_type(crate_path = ":: subxt :: ext :: scale_encode")]
            ///Chain now available for transfers (chain_id)
            pub struct ChainWhitelisted {
                pub chain_id: runtime_types::webb_proposals::header::TypedChainId,
            }
            impl ::subxt::events::StaticEvent for ChainWhitelisted {
                const PALLET: &'static str = "DKGProposals";
                const EVENT: &'static str = "ChainWhitelisted";
            }
            #[derive(
                ::subxt::ext::codec::Decode,
                ::subxt::ext::codec::Encode,
                ::subxt::ext::scale_decode::DecodeAsType,
                ::subxt::ext::scale_encode::EncodeAsType,
                Clone,
                Debug,
                Eq,
                PartialEq
            )]
            #[codec(crate = ::subxt::ext::codec)]
            #[decode_as_type(crate_path = ":: subxt :: ext :: scale_decode")]
            #[encode_as_type(crate_path = ":: subxt :: ext :: scale_encode")]
            ///Vote submitted in favour of proposal
            pub struct VoteFor {
                pub kind: runtime_types::webb_proposals::proposal::ProposalKind,
                pub src_chain_id: runtime_types::webb_proposals::header::TypedChainId,
                pub proposal_nonce: runtime_types::webb_proposals::nonce::Nonce,
                pub who: ::subxt::utils::AccountId32,
            }
            impl ::subxt::events::StaticEvent for VoteFor {
                const PALLET: &'static str = "DKGProposals";
                const EVENT: &'static str = "VoteFor";
            }
            #[derive(
                ::subxt::ext::codec::Decode,
                ::subxt::ext::codec::Encode,
                ::subxt::ext::scale_decode::DecodeAsType,
                ::subxt::ext::scale_encode::EncodeAsType,
                Clone,
                Debug,
                Eq,
                PartialEq
            )]
            #[codec(crate = ::subxt::ext::codec)]
            #[decode_as_type(crate_path = ":: subxt :: ext :: scale_decode")]
            #[encode_as_type(crate_path = ":: subxt :: ext :: scale_encode")]
            ///Vot submitted against proposal
            pub struct VoteAgainst {
                pub kind: runtime_types::webb_proposals::proposal::ProposalKind,
                pub src_chain_id: runtime_types::webb_proposals::header::TypedChainId,
                pub proposal_nonce: runtime_types::webb_proposals::nonce::Nonce,
                pub who: ::subxt::utils::AccountId32,
            }
            impl ::subxt::events::StaticEvent for VoteAgainst {
                const PALLET: &'static str = "DKGProposals";
                const EVENT: &'static str = "VoteAgainst";
            }
            #[derive(
                ::subxt::ext::codec::Decode,
                ::subxt::ext::codec::Encode,
                ::subxt::ext::scale_decode::DecodeAsType,
                ::subxt::ext::scale_encode::EncodeAsType,
                Clone,
                Debug,
                Eq,
                PartialEq
            )]
            #[codec(crate = ::subxt::ext::codec)]
            #[decode_as_type(crate_path = ":: subxt :: ext :: scale_decode")]
            #[encode_as_type(crate_path = ":: subxt :: ext :: scale_encode")]
            ///Voting successful for a proposal
            pub struct ProposalApproved {
                pub kind: runtime_types::webb_proposals::proposal::ProposalKind,
                pub src_chain_id: runtime_types::webb_proposals::header::TypedChainId,
                pub proposal_nonce: runtime_types::webb_proposals::nonce::Nonce,
            }
            impl ::subxt::events::StaticEvent for ProposalApproved {
                const PALLET: &'static str = "DKGProposals";
                const EVENT: &'static str = "ProposalApproved";
            }
            #[derive(
                ::subxt::ext::codec::Decode,
                ::subxt::ext::codec::Encode,
                ::subxt::ext::scale_decode::DecodeAsType,
                ::subxt::ext::scale_encode::EncodeAsType,
                Clone,
                Debug,
                Eq,
                PartialEq
            )]
            #[codec(crate = ::subxt::ext::codec)]
            #[decode_as_type(crate_path = ":: subxt :: ext :: scale_decode")]
            #[encode_as_type(crate_path = ":: subxt :: ext :: scale_encode")]
            ///Voting rejected a proposal
            pub struct ProposalRejected {
                pub kind: runtime_types::webb_proposals::proposal::ProposalKind,
                pub src_chain_id: runtime_types::webb_proposals::header::TypedChainId,
                pub proposal_nonce: runtime_types::webb_proposals::nonce::Nonce,
            }
            impl ::subxt::events::StaticEvent for ProposalRejected {
                const PALLET: &'static str = "DKGProposals";
                const EVENT: &'static str = "ProposalRejected";
            }
            #[derive(
                ::subxt::ext::codec::Decode,
                ::subxt::ext::codec::Encode,
                ::subxt::ext::scale_decode::DecodeAsType,
                ::subxt::ext::scale_encode::EncodeAsType,
                Clone,
                Debug,
                Eq,
                PartialEq
            )]
            #[codec(crate = ::subxt::ext::codec)]
            #[decode_as_type(crate_path = ":: subxt :: ext :: scale_decode")]
            #[encode_as_type(crate_path = ":: subxt :: ext :: scale_encode")]
            ///Execution of call succeeded
            pub struct ProposalSucceeded {
                pub kind: runtime_types::webb_proposals::proposal::ProposalKind,
                pub src_chain_id: runtime_types::webb_proposals::header::TypedChainId,
                pub proposal_nonce: runtime_types::webb_proposals::nonce::Nonce,
            }
            impl ::subxt::events::StaticEvent for ProposalSucceeded {
                const PALLET: &'static str = "DKGProposals";
                const EVENT: &'static str = "ProposalSucceeded";
            }
            #[derive(
                ::subxt::ext::codec::Decode,
                ::subxt::ext::codec::Encode,
                ::subxt::ext::scale_decode::DecodeAsType,
                ::subxt::ext::scale_encode::EncodeAsType,
                Clone,
                Debug,
                Eq,
                PartialEq
            )]
            #[codec(crate = ::subxt::ext::codec)]
            #[decode_as_type(crate_path = ":: subxt :: ext :: scale_decode")]
            #[encode_as_type(crate_path = ":: subxt :: ext :: scale_encode")]
            ///Execution of call failed
            pub struct ProposalFailed {
                pub kind: runtime_types::webb_proposals::proposal::ProposalKind,
                pub src_chain_id: runtime_types::webb_proposals::header::TypedChainId,
                pub proposal_nonce: runtime_types::webb_proposals::nonce::Nonce,
            }
            impl ::subxt::events::StaticEvent for ProposalFailed {
                const PALLET: &'static str = "DKGProposals";
                const EVENT: &'static str = "ProposalFailed";
            }
            #[derive(
                ::subxt::ext::codec::Decode,
                ::subxt::ext::codec::Encode,
                ::subxt::ext::scale_decode::DecodeAsType,
                ::subxt::ext::scale_encode::EncodeAsType,
                Clone,
                Debug,
                Eq,
                PartialEq
            )]
            #[codec(crate = ::subxt::ext::codec)]
            #[decode_as_type(crate_path = ":: subxt :: ext :: scale_decode")]
            #[encode_as_type(crate_path = ":: subxt :: ext :: scale_encode")]
            ///Proposers have been reset
            pub struct ProposersReset {
                pub proposers: ::std::vec::Vec<::subxt::utils::AccountId32>,
            }
            impl ::subxt::events::StaticEvent for ProposersReset {
                const PALLET: &'static str = "DKGProposals";
                const EVENT: &'static str = "ProposersReset";
            }
        }
        pub mod storage {
            use super::runtime_types;
            pub struct StorageApi;
            impl StorageApi {
                /// All whitelisted chains and their respective transaction counts
                pub fn chain_nonces(
                    &self,
                    _0: impl ::std::borrow::Borrow<
                        runtime_types::webb_proposals::header::TypedChainId,
                    >,
                ) -> ::subxt::storage::address::Address<
                    ::subxt::storage::address::StaticStorageMapKey,
                    runtime_types::webb_proposals::nonce::Nonce,
                    ::subxt::storage::address::Yes,
                    (),
                    ::subxt::storage::address::Yes,
                > {
                    ::subxt::storage::address::Address::new_static(
                        "DKGProposals",
                        "ChainNonces",
                        vec![
                            ::subxt::storage::address::make_static_storage_map_key(_0
                            .borrow())
                        ],
                        [
                            35u8,
                            181u8,
                            95u8,
                            135u8,
                            21u8,
                            65u8,
                            211u8,
                            8u8,
                            244u8,
                            34u8,
                            10u8,
                            76u8,
                            117u8,
                            71u8,
                            68u8,
                            2u8,
                            87u8,
                            127u8,
                            66u8,
                            128u8,
                            186u8,
                            223u8,
                            248u8,
                            182u8,
                            58u8,
                            38u8,
                            96u8,
                            81u8,
                            46u8,
                            103u8,
                            33u8,
                            141u8,
                        ],
                    )
                }
                /// All whitelisted chains and their respective transaction counts
                pub fn chain_nonces_root(
                    &self,
                ) -> ::subxt::storage::address::Address<
                    ::subxt::storage::address::StaticStorageMapKey,
                    runtime_types::webb_proposals::nonce::Nonce,
                    (),
                    (),
                    ::subxt::storage::address::Yes,
                > {
                    ::subxt::storage::address::Address::new_static(
                        "DKGProposals",
                        "ChainNonces",
                        Vec::new(),
                        [
                            35u8,
                            181u8,
                            95u8,
                            135u8,
                            21u8,
                            65u8,
                            211u8,
                            8u8,
                            244u8,
                            34u8,
                            10u8,
                            76u8,
                            117u8,
                            71u8,
                            68u8,
                            2u8,
                            87u8,
                            127u8,
                            66u8,
                            128u8,
                            186u8,
                            223u8,
                            248u8,
                            182u8,
                            58u8,
                            38u8,
                            96u8,
                            81u8,
                            46u8,
                            103u8,
                            33u8,
                            141u8,
                        ],
                    )
                }
                /// Number of votes required for a proposal to execute
                pub fn proposer_threshold(
                    &self,
                ) -> ::subxt::storage::address::Address<
                    ::subxt::storage::address::StaticStorageMapKey,
                    ::core::primitive::u32,
                    ::subxt::storage::address::Yes,
                    ::subxt::storage::address::Yes,
                    (),
                > {
                    ::subxt::storage::address::Address::new_static(
                        "DKGProposals",
                        "ProposerThreshold",
                        vec![],
                        [
                            156u8,
                            50u8,
                            115u8,
                            111u8,
                            127u8,
                            120u8,
                            1u8,
                            129u8,
                            135u8,
                            45u8,
                            132u8,
                            136u8,
                            134u8,
                            187u8,
                            35u8,
                            225u8,
                            37u8,
                            193u8,
                            139u8,
                            178u8,
                            219u8,
                            55u8,
                            146u8,
                            228u8,
                            141u8,
                            162u8,
                            241u8,
                            172u8,
                            76u8,
                            31u8,
                            45u8,
                            194u8,
                        ],
                    )
                }
                /// Tracks current proposer set
                pub fn proposers(
                    &self,
                ) -> ::subxt::storage::address::Address<
                    ::subxt::storage::address::StaticStorageMapKey,
                    runtime_types::bounded_collections::bounded_vec::BoundedVec<
                        ::subxt::utils::AccountId32,
                    >,
                    ::subxt::storage::address::Yes,
                    ::subxt::storage::address::Yes,
                    (),
                > {
                    ::subxt::storage::address::Address::new_static(
                        "DKGProposals",
                        "Proposers",
                        vec![],
                        [
                            106u8,
                            178u8,
                            183u8,
                            98u8,
                            217u8,
                            88u8,
                            111u8,
                            104u8,
                            13u8,
                            246u8,
                            117u8,
                            239u8,
                            39u8,
                            245u8,
                            46u8,
                            118u8,
                            71u8,
                            185u8,
                            251u8,
                            92u8,
                            178u8,
                            214u8,
                            247u8,
                            37u8,
                            117u8,
                            216u8,
                            170u8,
                            158u8,
                            248u8,
                            223u8,
                            130u8,
                            76u8,
                        ],
                    )
                }
                pub fn voting_keys(
                    &self,
                ) -> ::subxt::storage::address::Address<
                    ::subxt::storage::address::StaticStorageMapKey,
                    runtime_types::bounded_collections::bounded_vec::BoundedVec<
                        (
                            ::subxt::utils::AccountId32,
                            runtime_types::bounded_collections::bounded_vec::BoundedVec<
                                ::core::primitive::u8,
                            >,
                        ),
                    >,
                    ::subxt::storage::address::Yes,
                    ::subxt::storage::address::Yes,
                    (),
                > {
                    ::subxt::storage::address::Address::new_static(
                        "DKGProposals",
                        "VotingKeys",
                        vec![],
                        [
                            210u8,
                            161u8,
                            163u8,
                            23u8,
                            110u8,
                            72u8,
                            202u8,
                            80u8,
                            204u8,
                            78u8,
                            120u8,
                            129u8,
                            15u8,
                            12u8,
                            226u8,
                            193u8,
                            61u8,
                            82u8,
                            240u8,
                            60u8,
                            154u8,
                            70u8,
                            83u8,
                            197u8,
                            132u8,
                            115u8,
                            70u8,
                            106u8,
                            255u8,
                            141u8,
                            76u8,
                            7u8,
                        ],
                    )
                }
                /// Number of proposers in set
                pub fn proposer_count(
                    &self,
                ) -> ::subxt::storage::address::Address<
                    ::subxt::storage::address::StaticStorageMapKey,
                    ::core::primitive::u32,
                    ::subxt::storage::address::Yes,
                    ::subxt::storage::address::Yes,
                    (),
                > {
                    ::subxt::storage::address::Address::new_static(
                        "DKGProposals",
                        "ProposerCount",
                        vec![],
                        [
                            228u8,
                            191u8,
                            78u8,
                            109u8,
                            95u8,
                            206u8,
                            190u8,
                            107u8,
                            239u8,
                            133u8,
                            38u8,
                            233u8,
                            220u8,
                            107u8,
                            57u8,
                            61u8,
                            212u8,
                            85u8,
                            30u8,
                            5u8,
                            50u8,
                            82u8,
                            123u8,
                            235u8,
                            44u8,
                            5u8,
                            11u8,
                            58u8,
                            249u8,
                            179u8,
                            232u8,
                            75u8,
                        ],
                    )
                }
                /// All known proposals.
                /// The key is the hash of the call and the deposit ID, to ensure it's
                /// unique.
                pub fn votes(
                    &self,
                    _0: impl ::std::borrow::Borrow<
                        runtime_types::webb_proposals::header::TypedChainId,
                    >,
                    _1: impl ::std::borrow::Borrow<
                        (
                            runtime_types::webb_proposals::nonce::Nonce,
                            runtime_types::webb_proposals::proposal::Proposal<
                                runtime_types::dkg_runtime_primitives::CustomU32Getter,
                            >,
                        ),
                    >,
                ) -> ::subxt::storage::address::Address<
                    ::subxt::storage::address::StaticStorageMapKey,
                    runtime_types::pallet_dkg_proposals::types::ProposalVotes<
                        ::subxt::utils::AccountId32,
                        ::core::primitive::u32,
                        runtime_types::tangle_standalone_runtime::MaxVotes,
                    >,
                    ::subxt::storage::address::Yes,
                    (),
                    ::subxt::storage::address::Yes,
                > {
                    ::subxt::storage::address::Address::new_static(
                        "DKGProposals",
                        "Votes",
                        vec![
                            ::subxt::storage::address::make_static_storage_map_key(_0
                            .borrow()),
                            ::subxt::storage::address::make_static_storage_map_key(_1
                            .borrow())
                        ],
                        [
                            91u8,
                            171u8,
                            212u8,
                            42u8,
                            109u8,
                            160u8,
                            115u8,
                            10u8,
                            21u8,
                            29u8,
                            178u8,
                            213u8,
                            244u8,
                            185u8,
                            44u8,
                            7u8,
                            238u8,
                            46u8,
                            183u8,
                            226u8,
                            27u8,
                            141u8,
                            177u8,
                            28u8,
                            232u8,
                            215u8,
                            104u8,
                            4u8,
                            100u8,
                            173u8,
                            22u8,
                            77u8,
                        ],
                    )
                }
                /// All known proposals.
                /// The key is the hash of the call and the deposit ID, to ensure it's
                /// unique.
                pub fn votes_root(
                    &self,
                ) -> ::subxt::storage::address::Address<
                    ::subxt::storage::address::StaticStorageMapKey,
                    runtime_types::pallet_dkg_proposals::types::ProposalVotes<
                        ::subxt::utils::AccountId32,
                        ::core::primitive::u32,
                        runtime_types::tangle_standalone_runtime::MaxVotes,
                    >,
                    (),
                    (),
                    ::subxt::storage::address::Yes,
                > {
                    ::subxt::storage::address::Address::new_static(
                        "DKGProposals",
                        "Votes",
                        Vec::new(),
                        [
                            91u8,
                            171u8,
                            212u8,
                            42u8,
                            109u8,
                            160u8,
                            115u8,
                            10u8,
                            21u8,
                            29u8,
                            178u8,
                            213u8,
                            244u8,
                            185u8,
                            44u8,
                            7u8,
                            238u8,
                            46u8,
                            183u8,
                            226u8,
                            27u8,
                            141u8,
                            177u8,
                            28u8,
                            232u8,
                            215u8,
                            104u8,
                            4u8,
                            100u8,
                            173u8,
                            22u8,
                            77u8,
                        ],
                    )
                }
                /// Utilized by the bridge software to map resource IDs to actual methods
                pub fn resources(
                    &self,
                    _0: impl ::std::borrow::Borrow<
                        runtime_types::webb_proposals::header::ResourceId,
                    >,
                ) -> ::subxt::storage::address::Address<
                    ::subxt::storage::address::StaticStorageMapKey,
                    runtime_types::bounded_collections::bounded_vec::BoundedVec<
                        ::core::primitive::u8,
                    >,
                    ::subxt::storage::address::Yes,
                    (),
                    ::subxt::storage::address::Yes,
                > {
                    ::subxt::storage::address::Address::new_static(
                        "DKGProposals",
                        "Resources",
                        vec![
                            ::subxt::storage::address::make_static_storage_map_key(_0
                            .borrow())
                        ],
                        [
                            49u8,
                            255u8,
                            169u8,
                            11u8,
                            165u8,
                            236u8,
                            190u8,
                            20u8,
                            111u8,
                            111u8,
                            241u8,
                            242u8,
                            11u8,
                            146u8,
                            53u8,
                            140u8,
                            231u8,
                            169u8,
                            63u8,
                            97u8,
                            107u8,
                            25u8,
                            50u8,
                            200u8,
                            157u8,
                            5u8,
                            179u8,
                            22u8,
                            44u8,
                            18u8,
                            73u8,
                            56u8,
                        ],
                    )
                }
                /// Utilized by the bridge software to map resource IDs to actual methods
                pub fn resources_root(
                    &self,
                ) -> ::subxt::storage::address::Address<
                    ::subxt::storage::address::StaticStorageMapKey,
                    runtime_types::bounded_collections::bounded_vec::BoundedVec<
                        ::core::primitive::u8,
                    >,
                    (),
                    (),
                    ::subxt::storage::address::Yes,
                > {
                    ::subxt::storage::address::Address::new_static(
                        "DKGProposals",
                        "Resources",
                        Vec::new(),
                        [
                            49u8,
                            255u8,
                            169u8,
                            11u8,
                            165u8,
                            236u8,
                            190u8,
                            20u8,
                            111u8,
                            111u8,
                            241u8,
                            242u8,
                            11u8,
                            146u8,
                            53u8,
                            140u8,
                            231u8,
                            169u8,
                            63u8,
                            97u8,
                            107u8,
                            25u8,
                            50u8,
                            200u8,
                            157u8,
                            5u8,
                            179u8,
                            22u8,
                            44u8,
                            18u8,
                            73u8,
                            56u8,
                        ],
                    )
                }
            }
        }
        pub mod constants {
            use super::runtime_types;
            pub struct ConstantsApi;
            impl ConstantsApi {
                /// The identifier for this chain.
                /// This must be unique and must not collide with existing IDs within a
                /// set of bridged chains.
                pub fn chain_identifier(
                    &self,
                ) -> ::subxt::constants::Address<
                    runtime_types::webb_proposals::header::TypedChainId,
                > {
                    ::subxt::constants::Address::new_static(
                        "DKGProposals",
                        "ChainIdentifier",
                        [
                            49u8,
                            214u8,
                            85u8,
                            221u8,
                            155u8,
                            69u8,
                            78u8,
                            182u8,
                            94u8,
                            184u8,
                            153u8,
                            110u8,
                            168u8,
                            59u8,
                            69u8,
                            231u8,
                            245u8,
                            129u8,
                            115u8,
                            187u8,
                            150u8,
                            79u8,
                            147u8,
                            92u8,
                            117u8,
                            226u8,
                            210u8,
                            255u8,
                            231u8,
                            131u8,
                            229u8,
                            115u8,
                        ],
                    )
                }
                pub fn proposal_lifetime(
                    &self,
                ) -> ::subxt::constants::Address<::core::primitive::u32> {
                    ::subxt::constants::Address::new_static(
                        "DKGProposals",
                        "ProposalLifetime",
                        [
                            98u8,
                            252u8,
                            116u8,
                            72u8,
                            26u8,
                            180u8,
                            225u8,
                            83u8,
                            200u8,
                            157u8,
                            125u8,
                            151u8,
                            53u8,
                            76u8,
                            168u8,
                            26u8,
                            10u8,
                            9u8,
                            98u8,
                            68u8,
                            9u8,
                            178u8,
                            197u8,
                            113u8,
                            31u8,
                            79u8,
                            200u8,
                            90u8,
                            203u8,
                            100u8,
                            41u8,
                            145u8,
                        ],
                    )
                }
                /// The session period
                pub fn period(
                    &self,
                ) -> ::subxt::constants::Address<::core::primitive::u32> {
                    ::subxt::constants::Address::new_static(
                        "DKGProposals",
                        "Period",
                        [
                            98u8,
                            252u8,
                            116u8,
                            72u8,
                            26u8,
                            180u8,
                            225u8,
                            83u8,
                            200u8,
                            157u8,
                            125u8,
                            151u8,
                            53u8,
                            76u8,
                            168u8,
                            26u8,
                            10u8,
                            9u8,
                            98u8,
                            68u8,
                            9u8,
                            178u8,
                            197u8,
                            113u8,
                            31u8,
                            79u8,
                            200u8,
                            90u8,
                            203u8,
                            100u8,
                            41u8,
                            145u8,
                        ],
                    )
                }
                /// The max votes to store for for and against
                pub fn max_votes(
                    &self,
                ) -> ::subxt::constants::Address<::core::primitive::u32> {
                    ::subxt::constants::Address::new_static(
                        "DKGProposals",
                        "MaxVotes",
                        [
                            98u8,
                            252u8,
                            116u8,
                            72u8,
                            26u8,
                            180u8,
                            225u8,
                            83u8,
                            200u8,
                            157u8,
                            125u8,
                            151u8,
                            53u8,
                            76u8,
                            168u8,
                            26u8,
                            10u8,
                            9u8,
                            98u8,
                            68u8,
                            9u8,
                            178u8,
                            197u8,
                            113u8,
                            31u8,
                            79u8,
                            200u8,
                            90u8,
                            203u8,
                            100u8,
                            41u8,
                            145u8,
                        ],
                    )
                }
                /// The max resources that can be stored in storage
                pub fn max_resources(
                    &self,
                ) -> ::subxt::constants::Address<::core::primitive::u32> {
                    ::subxt::constants::Address::new_static(
                        "DKGProposals",
                        "MaxResources",
                        [
                            98u8,
                            252u8,
                            116u8,
                            72u8,
                            26u8,
                            180u8,
                            225u8,
                            83u8,
                            200u8,
                            157u8,
                            125u8,
                            151u8,
                            53u8,
                            76u8,
                            168u8,
                            26u8,
                            10u8,
                            9u8,
                            98u8,
                            68u8,
                            9u8,
                            178u8,
                            197u8,
                            113u8,
                            31u8,
                            79u8,
                            200u8,
                            90u8,
                            203u8,
                            100u8,
                            41u8,
                            145u8,
                        ],
                    )
                }
                /// The max proposers that can be stored in storage
                pub fn max_proposers(
                    &self,
                ) -> ::subxt::constants::Address<::core::primitive::u32> {
                    ::subxt::constants::Address::new_static(
                        "DKGProposals",
                        "MaxProposers",
                        [
                            98u8,
                            252u8,
                            116u8,
                            72u8,
                            26u8,
                            180u8,
                            225u8,
                            83u8,
                            200u8,
                            157u8,
                            125u8,
                            151u8,
                            53u8,
                            76u8,
                            168u8,
                            26u8,
                            10u8,
                            9u8,
                            98u8,
                            68u8,
                            9u8,
                            178u8,
                            197u8,
                            113u8,
                            31u8,
                            79u8,
                            200u8,
                            90u8,
                            203u8,
                            100u8,
                            41u8,
                            145u8,
                        ],
                    )
                }
                /// The size of an external proposer account (i.e. 64-byte Ethereum public key)
                pub fn voting_key_size(
                    &self,
                ) -> ::subxt::constants::Address<::core::primitive::u32> {
                    ::subxt::constants::Address::new_static(
                        "DKGProposals",
                        "VotingKeySize",
                        [
                            98u8,
                            252u8,
                            116u8,
                            72u8,
                            26u8,
                            180u8,
                            225u8,
                            83u8,
                            200u8,
                            157u8,
                            125u8,
                            151u8,
                            53u8,
                            76u8,
                            168u8,
                            26u8,
                            10u8,
                            9u8,
                            98u8,
                            68u8,
                            9u8,
                            178u8,
                            197u8,
                            113u8,
                            31u8,
                            79u8,
                            200u8,
                            90u8,
                            203u8,
                            100u8,
                            41u8,
                            145u8,
                        ],
                    )
                }
                /// Max length of a proposal
                pub fn max_proposal_length(
                    &self,
                ) -> ::subxt::constants::Address<::core::primitive::u32> {
                    ::subxt::constants::Address::new_static(
                        "DKGProposals",
                        "MaxProposalLength",
                        [
                            98u8,
                            252u8,
                            116u8,
                            72u8,
                            26u8,
                            180u8,
                            225u8,
                            83u8,
                            200u8,
                            157u8,
                            125u8,
                            151u8,
                            53u8,
                            76u8,
                            168u8,
                            26u8,
                            10u8,
                            9u8,
                            98u8,
                            68u8,
                            9u8,
                            178u8,
                            197u8,
                            113u8,
                            31u8,
                            79u8,
                            200u8,
                            90u8,
                            203u8,
                            100u8,
                            41u8,
                            145u8,
                        ],
                    )
                }
            }
        }
    }
    pub mod dkg_proposal_handler {
        use super::root_mod;
        use super::runtime_types;
        /**
			Custom [dispatch errors](https://docs.substrate.io/main-docs/build/events-errors/)
			of this pallet.
			*/
        pub type Error = runtime_types::pallet_dkg_proposal_handler::pallet::Error;
        ///Contains one variant per dispatchable that can be called by an extrinsic.
        pub type Call = runtime_types::pallet_dkg_proposal_handler::pallet::Call;
        pub mod calls {
            use super::root_mod;
            use super::runtime_types;
            type DispatchError = runtime_types::sp_runtime::DispatchError;
            pub mod types {
                use super::runtime_types;
                #[derive(
                    ::subxt::ext::codec::Decode,
                    ::subxt::ext::codec::Encode,
                    ::subxt::ext::scale_decode::DecodeAsType,
                    ::subxt::ext::scale_encode::EncodeAsType,
                    Clone,
                    Debug,
                    Eq,
                    PartialEq
                )]
                #[codec(crate = ::subxt::ext::codec)]
                #[decode_as_type(crate_path = ":: subxt :: ext :: scale_decode")]
                #[encode_as_type(crate_path = ":: subxt :: ext :: scale_encode")]
                pub struct SubmitSignedProposals {
                    pub props: ::std::vec::Vec<
                        runtime_types::dkg_runtime_primitives::proposal::SignedProposalBatch<
                            ::core::primitive::u32,
                            runtime_types::dkg_runtime_primitives::CustomU32Getter,
                            runtime_types::dkg_runtime_primitives::CustomU32Getter2,
                            runtime_types::dkg_runtime_primitives::CustomU32Getter3,
                        >,
                    >,
                }
                impl ::subxt::blocks::StaticExtrinsic for SubmitSignedProposals {
                    const PALLET: &'static str = "DKGProposalHandler";
                    const CALL: &'static str = "submit_signed_proposals";
                }
                #[derive(
                    ::subxt::ext::codec::Decode,
                    ::subxt::ext::codec::Encode,
                    ::subxt::ext::scale_decode::DecodeAsType,
                    ::subxt::ext::scale_encode::EncodeAsType,
                    Clone,
                    Debug,
                    Eq,
                    PartialEq
                )]
                #[codec(crate = ::subxt::ext::codec)]
                #[decode_as_type(crate_path = ":: subxt :: ext :: scale_decode")]
                #[encode_as_type(crate_path = ":: subxt :: ext :: scale_encode")]
                pub struct ForceSubmitUnsignedProposal {
                    pub prop: runtime_types::webb_proposals::proposal::Proposal<
                        runtime_types::dkg_runtime_primitives::CustomU32Getter,
                    >,
                }
                impl ::subxt::blocks::StaticExtrinsic for ForceSubmitUnsignedProposal {
                    const PALLET: &'static str = "DKGProposalHandler";
                    const CALL: &'static str = "force_submit_unsigned_proposal";
                }
            }
            pub struct TransactionApi;
            impl TransactionApi {
                pub fn submit_signed_proposals(
                    &self,
                    props: ::std::vec::Vec<
                        runtime_types::dkg_runtime_primitives::proposal::SignedProposalBatch<
                            ::core::primitive::u32,
                            runtime_types::dkg_runtime_primitives::CustomU32Getter,
                            runtime_types::dkg_runtime_primitives::CustomU32Getter2,
                            runtime_types::dkg_runtime_primitives::CustomU32Getter3,
                        >,
                    >,
                ) -> ::subxt::tx::Payload<types::SubmitSignedProposals> {
                    ::subxt::tx::Payload::new_static(
                        "DKGProposalHandler",
                        "submit_signed_proposals",
                        types::SubmitSignedProposals {
                            props,
                        },
                        [
                            147u8,
                            155u8,
                            98u8,
                            133u8,
                            252u8,
                            28u8,
                            100u8,
                            153u8,
                            205u8,
                            199u8,
                            244u8,
                            199u8,
                            200u8,
                            253u8,
                            132u8,
                            104u8,
                            0u8,
                            241u8,
                            199u8,
                            173u8,
                            48u8,
                            231u8,
                            42u8,
                            123u8,
                            156u8,
                            83u8,
                            193u8,
                            54u8,
                            95u8,
                            199u8,
                            51u8,
                            10u8,
                        ],
                    )
                }
                ///Force submit an unsigned proposal to the DKG
                ///
                ///There are certain proposals we'd like to be proposable only
                ///through root actions. The currently supported proposals are
                ///	1. Updating
                pub fn force_submit_unsigned_proposal(
                    &self,
                    prop: runtime_types::webb_proposals::proposal::Proposal<
                        runtime_types::dkg_runtime_primitives::CustomU32Getter,
                    >,
                ) -> ::subxt::tx::Payload<types::ForceSubmitUnsignedProposal> {
                    ::subxt::tx::Payload::new_static(
                        "DKGProposalHandler",
                        "force_submit_unsigned_proposal",
                        types::ForceSubmitUnsignedProposal {
                            prop,
                        },
                        [
                            1u8,
                            152u8,
                            199u8,
                            7u8,
                            172u8,
                            51u8,
                            230u8,
                            233u8,
                            2u8,
                            238u8,
                            215u8,
                            77u8,
                            170u8,
                            227u8,
                            230u8,
                            194u8,
                            143u8,
                            44u8,
                            105u8,
                            172u8,
                            94u8,
                            15u8,
                            207u8,
                            87u8,
                            10u8,
                            221u8,
                            254u8,
                            5u8,
                            126u8,
                            81u8,
                            110u8,
                            134u8,
                        ],
                    )
                }
            }
        }
        /**
			The [event](https://docs.substrate.io/main-docs/build/events-errors/) emitted
			by this pallet.
			*/
        pub type Event = runtime_types::pallet_dkg_proposal_handler::pallet::Event;
        pub mod events {
            use super::runtime_types;
            #[derive(
                ::subxt::ext::codec::Decode,
                ::subxt::ext::codec::Encode,
                ::subxt::ext::scale_decode::DecodeAsType,
                ::subxt::ext::scale_encode::EncodeAsType,
                Clone,
                Debug,
                Eq,
                PartialEq
            )]
            #[codec(crate = ::subxt::ext::codec)]
            #[decode_as_type(crate_path = ":: subxt :: ext :: scale_decode")]
            #[encode_as_type(crate_path = ":: subxt :: ext :: scale_encode")]
            ///RuntimeEvent Emitted when we encounter a Proposal with invalid Signature.
            pub struct InvalidProposalBatchSignature {
                pub proposals: runtime_types::dkg_runtime_primitives::proposal::SignedProposalBatch<
                    ::core::primitive::u32,
                    runtime_types::dkg_runtime_primitives::CustomU32Getter,
                    runtime_types::dkg_runtime_primitives::CustomU32Getter2,
                    runtime_types::dkg_runtime_primitives::CustomU32Getter3,
                >,
                pub data: ::std::vec::Vec<::core::primitive::u8>,
                pub invalid_signature: ::std::vec::Vec<::core::primitive::u8>,
                pub expected_public_key: ::core::option::Option<
                    ::std::vec::Vec<::core::primitive::u8>,
                >,
                pub actual_public_key: ::core::option::Option<
                    ::std::vec::Vec<::core::primitive::u8>,
                >,
            }
            impl ::subxt::events::StaticEvent for InvalidProposalBatchSignature {
                const PALLET: &'static str = "DKGProposalHandler";
                const EVENT: &'static str = "InvalidProposalBatchSignature";
            }
            #[derive(
                ::subxt::ext::codec::Decode,
                ::subxt::ext::codec::Encode,
                ::subxt::ext::scale_decode::DecodeAsType,
                ::subxt::ext::scale_encode::EncodeAsType,
                Clone,
                Debug,
                Eq,
                PartialEq
            )]
            #[codec(crate = ::subxt::ext::codec)]
            #[decode_as_type(crate_path = ":: subxt :: ext :: scale_decode")]
            #[encode_as_type(crate_path = ":: subxt :: ext :: scale_encode")]
            ///RuntimeEvent When a Proposal is added to UnsignedProposalQueue.
            pub struct ProposalAdded {
                pub key: runtime_types::dkg_runtime_primitives::proposal::DKGPayloadKey,
                pub target_chain: runtime_types::webb_proposals::header::TypedChainId,
                pub data: ::std::vec::Vec<::core::primitive::u8>,
            }
            impl ::subxt::events::StaticEvent for ProposalAdded {
                const PALLET: &'static str = "DKGProposalHandler";
                const EVENT: &'static str = "ProposalAdded";
            }
            #[derive(
                ::subxt::ext::codec::Decode,
                ::subxt::ext::codec::Encode,
                ::subxt::ext::scale_decode::DecodeAsType,
                ::subxt::ext::scale_encode::EncodeAsType,
                Clone,
                Debug,
                Eq,
                PartialEq
            )]
            #[codec(crate = ::subxt::ext::codec)]
            #[decode_as_type(crate_path = ":: subxt :: ext :: scale_decode")]
            #[encode_as_type(crate_path = ":: subxt :: ext :: scale_encode")]
            ///RuntimeEvent When a Proposal is removed from UnsignedProposalQueue.
            pub struct ProposalRemoved {
                pub key: runtime_types::dkg_runtime_primitives::proposal::DKGPayloadKey,
                pub target_chain: runtime_types::webb_proposals::header::TypedChainId,
                pub expired: ::core::primitive::bool,
            }
            impl ::subxt::events::StaticEvent for ProposalRemoved {
                const PALLET: &'static str = "DKGProposalHandler";
                const EVENT: &'static str = "ProposalRemoved";
            }
            #[derive(
                ::subxt::ext::codec::Decode,
                ::subxt::ext::codec::Encode,
                ::subxt::ext::scale_decode::DecodeAsType,
                ::subxt::ext::scale_encode::EncodeAsType,
                Clone,
                Debug,
                Eq,
                PartialEq
            )]
            #[codec(crate = ::subxt::ext::codec)]
            #[decode_as_type(crate_path = ":: subxt :: ext :: scale_decode")]
            #[encode_as_type(crate_path = ":: subxt :: ext :: scale_encode")]
            ///RuntimeEvent When a Proposal Gets Signed by DKG.
            pub struct ProposalBatchSigned {
                pub target_chain: runtime_types::webb_proposals::header::TypedChainId,
                pub batch_id: ::core::primitive::u32,
                pub proposals: ::std::vec::Vec<
                    runtime_types::pallet_dkg_proposal_handler::pallet::SignedProposalEventData,
                >,
                pub signature: ::std::vec::Vec<::core::primitive::u8>,
            }
            impl ::subxt::events::StaticEvent for ProposalBatchSigned {
                const PALLET: &'static str = "DKGProposalHandler";
                const EVENT: &'static str = "ProposalBatchSigned";
            }
        }
        pub mod storage {
            use super::runtime_types;
            pub struct StorageApi;
            impl StorageApi {
                /// All unsigned proposals.
                pub fn unsigned_proposal_queue(
                    &self,
                    _0: impl ::std::borrow::Borrow<
                        runtime_types::webb_proposals::header::TypedChainId,
                    >,
                    _1: impl ::std::borrow::Borrow<::core::primitive::u32>,
                ) -> ::subxt::storage::address::Address<
                    ::subxt::storage::address::StaticStorageMapKey,
                    runtime_types::dkg_runtime_primitives::proposal::StoredUnsignedProposalBatch<
                        ::core::primitive::u32,
                        runtime_types::dkg_runtime_primitives::CustomU32Getter,
                        runtime_types::dkg_runtime_primitives::CustomU32Getter2,
                        ::core::primitive::u32,
                    >,
                    ::subxt::storage::address::Yes,
                    (),
                    ::subxt::storage::address::Yes,
                > {
                    ::subxt::storage::address::Address::new_static(
                        "DKGProposalHandler",
                        "UnsignedProposalQueue",
                        vec![
                            ::subxt::storage::address::make_static_storage_map_key(_0
                            .borrow()),
                            ::subxt::storage::address::make_static_storage_map_key(_1
                            .borrow())
                        ],
                        [
                            188u8,
                            198u8,
                            43u8,
                            215u8,
                            205u8,
                            171u8,
                            107u8,
                            32u8,
                            154u8,
                            127u8,
                            229u8,
                            220u8,
                            187u8,
                            112u8,
                            224u8,
                            168u8,
                            187u8,
                            246u8,
                            145u8,
                            101u8,
                            147u8,
                            241u8,
                            142u8,
                            63u8,
                            116u8,
                            149u8,
                            168u8,
                            12u8,
                            114u8,
                            183u8,
                            166u8,
                            176u8,
                        ],
                    )
                }
                /// All unsigned proposals.
                pub fn unsigned_proposal_queue_root(
                    &self,
                ) -> ::subxt::storage::address::Address<
                    ::subxt::storage::address::StaticStorageMapKey,
                    runtime_types::dkg_runtime_primitives::proposal::StoredUnsignedProposalBatch<
                        ::core::primitive::u32,
                        runtime_types::dkg_runtime_primitives::CustomU32Getter,
                        runtime_types::dkg_runtime_primitives::CustomU32Getter2,
                        ::core::primitive::u32,
                    >,
                    (),
                    (),
                    ::subxt::storage::address::Yes,
                > {
                    ::subxt::storage::address::Address::new_static(
                        "DKGProposalHandler",
                        "UnsignedProposalQueue",
                        Vec::new(),
                        [
                            188u8,
                            198u8,
                            43u8,
                            215u8,
                            205u8,
                            171u8,
                            107u8,
                            32u8,
                            154u8,
                            127u8,
                            229u8,
                            220u8,
                            187u8,
                            112u8,
                            224u8,
                            168u8,
                            187u8,
                            246u8,
                            145u8,
                            101u8,
                            147u8,
                            241u8,
                            142u8,
                            63u8,
                            116u8,
                            149u8,
                            168u8,
                            12u8,
                            114u8,
                            183u8,
                            166u8,
                            176u8,
                        ],
                    )
                }
                /// Defines the next batch id available
                pub fn next_batch_id(
                    &self,
                ) -> ::subxt::storage::address::Address<
                    ::subxt::storage::address::StaticStorageMapKey,
                    ::core::primitive::u32,
                    ::subxt::storage::address::Yes,
                    ::subxt::storage::address::Yes,
                    (),
                > {
                    ::subxt::storage::address::Address::new_static(
                        "DKGProposalHandler",
                        "NextBatchId",
                        vec![],
                        [
                            194u8,
                            36u8,
                            199u8,
                            34u8,
                            76u8,
                            252u8,
                            109u8,
                            61u8,
                            79u8,
                            109u8,
                            152u8,
                            67u8,
                            74u8,
                            153u8,
                            11u8,
                            128u8,
                            158u8,
                            145u8,
                            53u8,
                            226u8,
                            57u8,
                            228u8,
                            106u8,
                            111u8,
                            99u8,
                            241u8,
                            96u8,
                            78u8,
                            164u8,
                            66u8,
                            253u8,
                            16u8,
                        ],
                    )
                }
                /// Staging queue for unsigned proposals
                pub fn unsigned_proposals(
                    &self,
                    _0: impl ::std::borrow::Borrow<
                        runtime_types::webb_proposals::header::TypedChainId,
                    >,
                ) -> ::subxt::storage::address::Address<
                    ::subxt::storage::address::StaticStorageMapKey,
                    runtime_types::bounded_collections::bounded_vec::BoundedVec<
                        runtime_types::dkg_runtime_primitives::UnsignedProposal<
                            runtime_types::dkg_runtime_primitives::CustomU32Getter,
                        >,
                    >,
                    ::subxt::storage::address::Yes,
                    (),
                    ::subxt::storage::address::Yes,
                > {
                    ::subxt::storage::address::Address::new_static(
                        "DKGProposalHandler",
                        "UnsignedProposals",
                        vec![
                            ::subxt::storage::address::make_static_storage_map_key(_0
                            .borrow())
                        ],
                        [
                            227u8,
                            51u8,
                            214u8,
                            126u8,
                            13u8,
                            13u8,
                            237u8,
                            74u8,
                            157u8,
                            254u8,
                            156u8,
                            151u8,
                            146u8,
                            237u8,
                            173u8,
                            101u8,
                            95u8,
                            222u8,
                            154u8,
                            158u8,
                            217u8,
                            109u8,
                            183u8,
                            255u8,
                            56u8,
                            67u8,
                            84u8,
                            95u8,
                            109u8,
                            67u8,
                            61u8,
                            142u8,
                        ],
                    )
                }
                /// Staging queue for unsigned proposals
                pub fn unsigned_proposals_root(
                    &self,
                ) -> ::subxt::storage::address::Address<
                    ::subxt::storage::address::StaticStorageMapKey,
                    runtime_types::bounded_collections::bounded_vec::BoundedVec<
                        runtime_types::dkg_runtime_primitives::UnsignedProposal<
                            runtime_types::dkg_runtime_primitives::CustomU32Getter,
                        >,
                    >,
                    (),
                    (),
                    ::subxt::storage::address::Yes,
                > {
                    ::subxt::storage::address::Address::new_static(
                        "DKGProposalHandler",
                        "UnsignedProposals",
                        Vec::new(),
                        [
                            227u8,
                            51u8,
                            214u8,
                            126u8,
                            13u8,
                            13u8,
                            237u8,
                            74u8,
                            157u8,
                            254u8,
                            156u8,
                            151u8,
                            146u8,
                            237u8,
                            173u8,
                            101u8,
                            95u8,
                            222u8,
                            154u8,
                            158u8,
                            217u8,
                            109u8,
                            183u8,
                            255u8,
                            56u8,
                            67u8,
                            84u8,
                            95u8,
                            109u8,
                            67u8,
                            61u8,
                            142u8,
                        ],
                    )
                }
                /// All signed proposals.
                pub fn signed_proposals(
                    &self,
                    _0: impl ::std::borrow::Borrow<
                        runtime_types::webb_proposals::header::TypedChainId,
                    >,
                    _1: impl ::std::borrow::Borrow<::core::primitive::u32>,
                ) -> ::subxt::storage::address::Address<
                    ::subxt::storage::address::StaticStorageMapKey,
                    runtime_types::dkg_runtime_primitives::proposal::SignedProposalBatch<
                        ::core::primitive::u32,
                        runtime_types::dkg_runtime_primitives::CustomU32Getter,
                        runtime_types::dkg_runtime_primitives::CustomU32Getter2,
                        runtime_types::dkg_runtime_primitives::CustomU32Getter3,
                    >,
                    ::subxt::storage::address::Yes,
                    (),
                    ::subxt::storage::address::Yes,
                > {
                    ::subxt::storage::address::Address::new_static(
                        "DKGProposalHandler",
                        "SignedProposals",
                        vec![
                            ::subxt::storage::address::make_static_storage_map_key(_0
                            .borrow()),
                            ::subxt::storage::address::make_static_storage_map_key(_1
                            .borrow())
                        ],
                        [
                            1u8,
                            250u8,
                            224u8,
                            184u8,
                            208u8,
                            2u8,
                            38u8,
                            243u8,
                            21u8,
                            33u8,
                            46u8,
                            14u8,
                            190u8,
                            205u8,
                            144u8,
                            41u8,
                            175u8,
                            253u8,
                            106u8,
                            165u8,
                            2u8,
                            161u8,
                            33u8,
                            208u8,
                            86u8,
                            64u8,
                            237u8,
                            220u8,
                            203u8,
                            83u8,
                            205u8,
                            98u8,
                        ],
                    )
                }
                /// All signed proposals.
                pub fn signed_proposals_root(
                    &self,
                ) -> ::subxt::storage::address::Address<
                    ::subxt::storage::address::StaticStorageMapKey,
                    runtime_types::dkg_runtime_primitives::proposal::SignedProposalBatch<
                        ::core::primitive::u32,
                        runtime_types::dkg_runtime_primitives::CustomU32Getter,
                        runtime_types::dkg_runtime_primitives::CustomU32Getter2,
                        runtime_types::dkg_runtime_primitives::CustomU32Getter3,
                    >,
                    (),
                    (),
                    ::subxt::storage::address::Yes,
                > {
                    ::subxt::storage::address::Address::new_static(
                        "DKGProposalHandler",
                        "SignedProposals",
                        Vec::new(),
                        [
                            1u8,
                            250u8,
                            224u8,
                            184u8,
                            208u8,
                            2u8,
                            38u8,
                            243u8,
                            21u8,
                            33u8,
                            46u8,
                            14u8,
                            190u8,
                            205u8,
                            144u8,
                            41u8,
                            175u8,
                            253u8,
                            106u8,
                            165u8,
                            2u8,
                            161u8,
                            33u8,
                            208u8,
                            86u8,
                            64u8,
                            237u8,
                            220u8,
                            203u8,
                            83u8,
                            205u8,
                            98u8,
                        ],
                    )
                }
            }
        }
        pub mod constants {
            use super::runtime_types;
            pub struct ConstantsApi;
            impl ConstantsApi {
                /// Max number of signed proposal submissions per batch;
                pub fn max_proposals_per_batch(
                    &self,
                ) -> ::subxt::constants::Address<::core::primitive::u32> {
                    ::subxt::constants::Address::new_static(
                        "DKGProposalHandler",
                        "MaxProposalsPerBatch",
                        [
                            98u8,
                            252u8,
                            116u8,
                            72u8,
                            26u8,
                            180u8,
                            225u8,
                            83u8,
                            200u8,
                            157u8,
                            125u8,
                            151u8,
                            53u8,
                            76u8,
                            168u8,
                            26u8,
                            10u8,
                            9u8,
                            98u8,
                            68u8,
                            9u8,
                            178u8,
                            197u8,
                            113u8,
                            31u8,
                            79u8,
                            200u8,
                            90u8,
                            203u8,
                            100u8,
                            41u8,
                            145u8,
                        ],
                    )
                }
                /// Max blocks to store an unsigned proposal
                pub fn unsigned_proposal_expiry(
                    &self,
                ) -> ::subxt::constants::Address<::core::primitive::u32> {
                    ::subxt::constants::Address::new_static(
                        "DKGProposalHandler",
                        "UnsignedProposalExpiry",
                        [
                            98u8,
                            252u8,
                            116u8,
                            72u8,
                            26u8,
                            180u8,
                            225u8,
                            83u8,
                            200u8,
                            157u8,
                            125u8,
                            151u8,
                            53u8,
                            76u8,
                            168u8,
                            26u8,
                            10u8,
                            9u8,
                            98u8,
                            68u8,
                            9u8,
                            178u8,
                            197u8,
                            113u8,
                            31u8,
                            79u8,
                            200u8,
                            90u8,
                            203u8,
                            100u8,
                            41u8,
                            145u8,
                        ],
                    )
                }
            }
        }
    }
    pub mod bridge_registry {
        use super::root_mod;
        use super::runtime_types;
        /**
			Custom [dispatch errors](https://docs.substrate.io/main-docs/build/events-errors/)
			of this pallet.
			*/
        pub type Error = runtime_types::pallet_bridge_registry::pallet::Error;
        ///Contains one variant per dispatchable that can be called by an extrinsic.
        pub type Call = runtime_types::pallet_bridge_registry::pallet::Call;
        pub mod calls {
            use super::root_mod;
            use super::runtime_types;
            type DispatchError = runtime_types::sp_runtime::DispatchError;
            pub mod types {
                use super::runtime_types;
                #[derive(
                    ::subxt::ext::codec::Decode,
                    ::subxt::ext::codec::Encode,
                    ::subxt::ext::scale_decode::DecodeAsType,
                    ::subxt::ext::scale_encode::EncodeAsType,
                    Clone,
                    Debug,
                    Eq,
                    PartialEq
                )]
                #[codec(crate = ::subxt::ext::codec)]
                #[decode_as_type(crate_path = ":: subxt :: ext :: scale_decode")]
                #[encode_as_type(crate_path = ":: subxt :: ext :: scale_encode")]
                pub struct SetMetadata {
                    pub bridge_index: ::core::primitive::u32,
                    pub info: runtime_types::pallet_bridge_registry::types::BridgeInfo,
                }
                impl ::subxt::blocks::StaticExtrinsic for SetMetadata {
                    const PALLET: &'static str = "BridgeRegistry";
                    const CALL: &'static str = "set_metadata";
                }
                #[derive(
                    ::subxt::ext::codec::Decode,
                    ::subxt::ext::codec::Encode,
                    ::subxt::ext::scale_decode::DecodeAsType,
                    ::subxt::ext::scale_encode::EncodeAsType,
                    Clone,
                    Debug,
                    Eq,
                    PartialEq
                )]
                #[codec(crate = ::subxt::ext::codec)]
                #[decode_as_type(crate_path = ":: subxt :: ext :: scale_decode")]
                #[encode_as_type(crate_path = ":: subxt :: ext :: scale_encode")]
                pub struct ForceResetIndices {
                    pub resource_ids: ::std::vec::Vec<
                        runtime_types::webb_proposals::header::ResourceId,
                    >,
                    pub bridge_index: ::core::primitive::u32,
                }
                impl ::subxt::blocks::StaticExtrinsic for ForceResetIndices {
                    const PALLET: &'static str = "BridgeRegistry";
                    const CALL: &'static str = "force_reset_indices";
                }
            }
            pub struct TransactionApi;
            impl TransactionApi {
                ///Set an account's identity information and reserve the appropriate deposit.
                ///
                ///If the account already has identity information, the deposit is taken as part payment
                ///for the new deposit.
                ///
                ///The dispatch origin for this call must be _Signed_.
                ///
                ///- `info`: The identity information.
                ///
                ///Emits `ResourceSet` if successful.
                pub fn set_metadata(
                    &self,
                    bridge_index: ::core::primitive::u32,
                    info: runtime_types::pallet_bridge_registry::types::BridgeInfo,
                ) -> ::subxt::tx::Payload<types::SetMetadata> {
                    ::subxt::tx::Payload::new_static(
                        "BridgeRegistry",
                        "set_metadata",
                        types::SetMetadata {
                            bridge_index,
                            info,
                        },
                        [
                            52u8,
                            157u8,
                            92u8,
                            170u8,
                            237u8,
                            144u8,
                            192u8,
                            94u8,
                            52u8,
                            117u8,
                            2u8,
                            17u8,
                            142u8,
                            151u8,
                            223u8,
                            251u8,
                            209u8,
                            2u8,
                            92u8,
                            53u8,
                            80u8,
                            110u8,
                            119u8,
                            98u8,
                            20u8,
                            118u8,
                            219u8,
                            126u8,
                            27u8,
                            59u8,
                            17u8,
                            167u8,
                        ],
                    )
                }
                pub fn force_reset_indices(
                    &self,
                    resource_ids: ::std::vec::Vec<
                        runtime_types::webb_proposals::header::ResourceId,
                    >,
                    bridge_index: ::core::primitive::u32,
                ) -> ::subxt::tx::Payload<types::ForceResetIndices> {
                    ::subxt::tx::Payload::new_static(
                        "BridgeRegistry",
                        "force_reset_indices",
                        types::ForceResetIndices {
                            resource_ids,
                            bridge_index,
                        },
                        [
                            108u8,
                            188u8,
                            179u8,
                            241u8,
                            6u8,
                            58u8,
                            104u8,
                            156u8,
                            227u8,
                            12u8,
                            44u8,
                            246u8,
                            191u8,
                            22u8,
                            185u8,
                            49u8,
                            173u8,
                            180u8,
                            213u8,
                            177u8,
                            21u8,
                            128u8,
                            44u8,
                            194u8,
                            72u8,
                            242u8,
                            102u8,
                            105u8,
                            41u8,
                            25u8,
                            160u8,
                            161u8,
                        ],
                    )
                }
            }
        }
        /**
			The [event](https://docs.substrate.io/main-docs/build/events-errors/) emitted
			by this pallet.
			*/
        pub type Event = runtime_types::pallet_bridge_registry::pallet::Event;
        pub mod events {
            use super::runtime_types;
        }
        pub mod storage {
            use super::runtime_types;
            pub struct StorageApi;
            impl StorageApi {
                /// Storage for next bridge index
                pub fn next_bridge_index(
                    &self,
                ) -> ::subxt::storage::address::Address<
                    ::subxt::storage::address::StaticStorageMapKey,
                    ::core::primitive::u32,
                    ::subxt::storage::address::Yes,
                    ::subxt::storage::address::Yes,
                    (),
                > {
                    ::subxt::storage::address::Address::new_static(
                        "BridgeRegistry",
                        "NextBridgeIndex",
                        vec![],
                        [
                            98u8,
                            62u8,
                            155u8,
                            139u8,
                            234u8,
                            185u8,
                            141u8,
                            174u8,
                            92u8,
                            88u8,
                            57u8,
                            86u8,
                            195u8,
                            176u8,
                            37u8,
                            168u8,
                            184u8,
                            127u8,
                            211u8,
                            196u8,
                            174u8,
                            224u8,
                            133u8,
                            99u8,
                            252u8,
                            145u8,
                            44u8,
                            102u8,
                            3u8,
                            149u8,
                            71u8,
                            56u8,
                        ],
                    )
                }
                /// Storage for map of all bridges
                pub fn bridges(
                    &self,
                    _0: impl ::std::borrow::Borrow<::core::primitive::u32>,
                ) -> ::subxt::storage::address::Address<
                    ::subxt::storage::address::StaticStorageMapKey,
                    runtime_types::pallet_bridge_registry::types::BridgeMetadata,
                    ::subxt::storage::address::Yes,
                    (),
                    ::subxt::storage::address::Yes,
                > {
                    ::subxt::storage::address::Address::new_static(
                        "BridgeRegistry",
                        "Bridges",
                        vec![
                            ::subxt::storage::address::make_static_storage_map_key(_0
                            .borrow())
                        ],
                        [
                            49u8,
                            116u8,
                            113u8,
                            163u8,
                            244u8,
                            101u8,
                            236u8,
                            196u8,
                            32u8,
                            69u8,
                            87u8,
                            227u8,
                            237u8,
                            165u8,
                            45u8,
                            197u8,
                            34u8,
                            166u8,
                            68u8,
                            172u8,
                            171u8,
                            49u8,
                            190u8,
                            229u8,
                            73u8,
                            114u8,
                            238u8,
                            183u8,
                            20u8,
                            106u8,
                            230u8,
                            8u8,
                        ],
                    )
                }
                /// Storage for map of all bridges
                pub fn bridges_root(
                    &self,
                ) -> ::subxt::storage::address::Address<
                    ::subxt::storage::address::StaticStorageMapKey,
                    runtime_types::pallet_bridge_registry::types::BridgeMetadata,
                    (),
                    (),
                    ::subxt::storage::address::Yes,
                > {
                    ::subxt::storage::address::Address::new_static(
                        "BridgeRegistry",
                        "Bridges",
                        Vec::new(),
                        [
                            49u8,
                            116u8,
                            113u8,
                            163u8,
                            244u8,
                            101u8,
                            236u8,
                            196u8,
                            32u8,
                            69u8,
                            87u8,
                            227u8,
                            237u8,
                            165u8,
                            45u8,
                            197u8,
                            34u8,
                            166u8,
                            68u8,
                            172u8,
                            171u8,
                            49u8,
                            190u8,
                            229u8,
                            73u8,
                            114u8,
                            238u8,
                            183u8,
                            20u8,
                            106u8,
                            230u8,
                            8u8,
                        ],
                    )
                }
                /// Mapping of resource to bridge index
                pub fn resource_to_bridge_index(
                    &self,
                    _0: impl ::std::borrow::Borrow<
                        runtime_types::webb_proposals::header::ResourceId,
                    >,
                ) -> ::subxt::storage::address::Address<
                    ::subxt::storage::address::StaticStorageMapKey,
                    ::core::primitive::u32,
                    ::subxt::storage::address::Yes,
                    (),
                    ::subxt::storage::address::Yes,
                > {
                    ::subxt::storage::address::Address::new_static(
                        "BridgeRegistry",
                        "ResourceToBridgeIndex",
                        vec![
                            ::subxt::storage::address::make_static_storage_map_key(_0
                            .borrow())
                        ],
                        [
                            167u8,
                            106u8,
                            30u8,
                            98u8,
                            141u8,
                            167u8,
                            182u8,
                            35u8,
                            117u8,
                            140u8,
                            186u8,
                            93u8,
                            154u8,
                            201u8,
                            19u8,
                            33u8,
                            18u8,
                            27u8,
                            56u8,
                            247u8,
                            206u8,
                            238u8,
                            139u8,
                            53u8,
                            6u8,
                            232u8,
                            103u8,
                            19u8,
                            82u8,
                            149u8,
                            19u8,
                            196u8,
                        ],
                    )
                }
                /// Mapping of resource to bridge index
                pub fn resource_to_bridge_index_root(
                    &self,
                ) -> ::subxt::storage::address::Address<
                    ::subxt::storage::address::StaticStorageMapKey,
                    ::core::primitive::u32,
                    (),
                    (),
                    ::subxt::storage::address::Yes,
                > {
                    ::subxt::storage::address::Address::new_static(
                        "BridgeRegistry",
                        "ResourceToBridgeIndex",
                        Vec::new(),
                        [
                            167u8,
                            106u8,
                            30u8,
                            98u8,
                            141u8,
                            167u8,
                            182u8,
                            35u8,
                            117u8,
                            140u8,
                            186u8,
                            93u8,
                            154u8,
                            201u8,
                            19u8,
                            33u8,
                            18u8,
                            27u8,
                            56u8,
                            247u8,
                            206u8,
                            238u8,
                            139u8,
                            53u8,
                            6u8,
                            232u8,
                            103u8,
                            19u8,
                            82u8,
                            149u8,
                            19u8,
                            196u8,
                        ],
                    )
                }
            }
        }
        pub mod constants {
            use super::runtime_types;
            pub struct ConstantsApi;
            impl ConstantsApi {
                /// Maximum number of additional fields that may be stored in a bridge's metadata. Needed to
                /// bound the I/O required to access an identity, but can be pretty high.
                pub fn max_additional_fields(
                    &self,
                ) -> ::subxt::constants::Address<::core::primitive::u32> {
                    ::subxt::constants::Address::new_static(
                        "BridgeRegistry",
                        "MaxAdditionalFields",
                        [
                            98u8,
                            252u8,
                            116u8,
                            72u8,
                            26u8,
                            180u8,
                            225u8,
                            83u8,
                            200u8,
                            157u8,
                            125u8,
                            151u8,
                            53u8,
                            76u8,
                            168u8,
                            26u8,
                            10u8,
                            9u8,
                            98u8,
                            68u8,
                            9u8,
                            178u8,
                            197u8,
                            113u8,
                            31u8,
                            79u8,
                            200u8,
                            90u8,
                            203u8,
                            100u8,
                            41u8,
                            145u8,
                        ],
                    )
                }
                /// Maximum number of resources that may be stored in a bridge. This is not to be confused
                /// with the actual maximum supported by the bridge. Needed to bound the I/O
                /// required to access a metadata object, but can be pretty high.
                pub fn max_resources(
                    &self,
                ) -> ::subxt::constants::Address<::core::primitive::u32> {
                    ::subxt::constants::Address::new_static(
                        "BridgeRegistry",
                        "MaxResources",
                        [
                            98u8,
                            252u8,
                            116u8,
                            72u8,
                            26u8,
                            180u8,
                            225u8,
                            83u8,
                            200u8,
                            157u8,
                            125u8,
                            151u8,
                            53u8,
                            76u8,
                            168u8,
                            26u8,
                            10u8,
                            9u8,
                            98u8,
                            68u8,
                            9u8,
                            178u8,
                            197u8,
                            113u8,
                            31u8,
                            79u8,
                            200u8,
                            90u8,
                            203u8,
                            100u8,
                            41u8,
                            145u8,
                        ],
                    )
                }
                /// Max length of a proposal
                pub fn max_proposal_length(
                    &self,
                ) -> ::subxt::constants::Address<::core::primitive::u32> {
                    ::subxt::constants::Address::new_static(
                        "BridgeRegistry",
                        "MaxProposalLength",
                        [
                            98u8,
                            252u8,
                            116u8,
                            72u8,
                            26u8,
                            180u8,
                            225u8,
                            83u8,
                            200u8,
                            157u8,
                            125u8,
                            151u8,
                            53u8,
                            76u8,
                            168u8,
                            26u8,
                            10u8,
                            9u8,
                            98u8,
                            68u8,
                            9u8,
                            178u8,
                            197u8,
                            113u8,
                            31u8,
                            79u8,
                            200u8,
                            90u8,
                            203u8,
                            100u8,
                            41u8,
                            145u8,
                        ],
                    )
                }
            }
        }
    }
    pub mod indices {
        use super::root_mod;
        use super::runtime_types;
        /**
			Custom [dispatch errors](https://docs.substrate.io/main-docs/build/events-errors/)
			of this pallet.
			*/
        pub type Error = runtime_types::pallet_indices::pallet::Error;
        ///Contains one variant per dispatchable that can be called by an extrinsic.
        pub type Call = runtime_types::pallet_indices::pallet::Call;
        pub mod calls {
            use super::root_mod;
            use super::runtime_types;
            type DispatchError = runtime_types::sp_runtime::DispatchError;
            pub mod types {
                use super::runtime_types;
                #[derive(
                    ::subxt::ext::codec::CompactAs,
                    ::subxt::ext::codec::Decode,
                    ::subxt::ext::codec::Encode,
                    ::subxt::ext::scale_decode::DecodeAsType,
                    ::subxt::ext::scale_encode::EncodeAsType,
                    Clone,
                    Debug,
                    Eq,
                    PartialEq
                )]
                #[codec(crate = ::subxt::ext::codec)]
                #[decode_as_type(crate_path = ":: subxt :: ext :: scale_decode")]
                #[encode_as_type(crate_path = ":: subxt :: ext :: scale_encode")]
                pub struct Claim {
                    pub index: ::core::primitive::u32,
                }
                impl ::subxt::blocks::StaticExtrinsic for Claim {
                    const PALLET: &'static str = "Indices";
                    const CALL: &'static str = "claim";
                }
                #[derive(
                    ::subxt::ext::codec::Decode,
                    ::subxt::ext::codec::Encode,
                    ::subxt::ext::scale_decode::DecodeAsType,
                    ::subxt::ext::scale_encode::EncodeAsType,
                    Clone,
                    Debug,
                    Eq,
                    PartialEq
                )]
                #[codec(crate = ::subxt::ext::codec)]
                #[decode_as_type(crate_path = ":: subxt :: ext :: scale_decode")]
                #[encode_as_type(crate_path = ":: subxt :: ext :: scale_encode")]
                pub struct Transfer {
                    pub new: ::subxt::utils::MultiAddress<
                        ::subxt::utils::AccountId32,
                        ::core::primitive::u32,
                    >,
                    pub index: ::core::primitive::u32,
                }
                impl ::subxt::blocks::StaticExtrinsic for Transfer {
                    const PALLET: &'static str = "Indices";
                    const CALL: &'static str = "transfer";
                }
                #[derive(
                    ::subxt::ext::codec::CompactAs,
                    ::subxt::ext::codec::Decode,
                    ::subxt::ext::codec::Encode,
                    ::subxt::ext::scale_decode::DecodeAsType,
                    ::subxt::ext::scale_encode::EncodeAsType,
                    Clone,
                    Debug,
                    Eq,
                    PartialEq
                )]
                #[codec(crate = ::subxt::ext::codec)]
                #[decode_as_type(crate_path = ":: subxt :: ext :: scale_decode")]
                #[encode_as_type(crate_path = ":: subxt :: ext :: scale_encode")]
                pub struct Free {
                    pub index: ::core::primitive::u32,
                }
                impl ::subxt::blocks::StaticExtrinsic for Free {
                    const PALLET: &'static str = "Indices";
                    const CALL: &'static str = "free";
                }
                #[derive(
                    ::subxt::ext::codec::Decode,
                    ::subxt::ext::codec::Encode,
                    ::subxt::ext::scale_decode::DecodeAsType,
                    ::subxt::ext::scale_encode::EncodeAsType,
                    Clone,
                    Debug,
                    Eq,
                    PartialEq
                )]
                #[codec(crate = ::subxt::ext::codec)]
                #[decode_as_type(crate_path = ":: subxt :: ext :: scale_decode")]
                #[encode_as_type(crate_path = ":: subxt :: ext :: scale_encode")]
                pub struct ForceTransfer {
                    pub new: ::subxt::utils::MultiAddress<
                        ::subxt::utils::AccountId32,
                        ::core::primitive::u32,
                    >,
                    pub index: ::core::primitive::u32,
                    pub freeze: ::core::primitive::bool,
                }
                impl ::subxt::blocks::StaticExtrinsic for ForceTransfer {
                    const PALLET: &'static str = "Indices";
                    const CALL: &'static str = "force_transfer";
                }
                #[derive(
                    ::subxt::ext::codec::CompactAs,
                    ::subxt::ext::codec::Decode,
                    ::subxt::ext::codec::Encode,
                    ::subxt::ext::scale_decode::DecodeAsType,
                    ::subxt::ext::scale_encode::EncodeAsType,
                    Clone,
                    Debug,
                    Eq,
                    PartialEq
                )]
                #[codec(crate = ::subxt::ext::codec)]
                #[decode_as_type(crate_path = ":: subxt :: ext :: scale_decode")]
                #[encode_as_type(crate_path = ":: subxt :: ext :: scale_encode")]
                pub struct Freeze {
                    pub index: ::core::primitive::u32,
                }
                impl ::subxt::blocks::StaticExtrinsic for Freeze {
                    const PALLET: &'static str = "Indices";
                    const CALL: &'static str = "freeze";
                }
            }
            pub struct TransactionApi;
            impl TransactionApi {
                ///Assign an previously unassigned index.
                ///
                ///Payment: `Deposit` is reserved from the sender account.
                ///
                ///The dispatch origin for this call must be _Signed_.
                ///
                ///- `index`: the index to be claimed. This must not be in use.
                ///
                ///Emits `IndexAssigned` if successful.
                ///
                ///## Complexity
                ///- `O(1)`.
                pub fn claim(
                    &self,
                    index: ::core::primitive::u32,
                ) -> ::subxt::tx::Payload<types::Claim> {
                    ::subxt::tx::Payload::new_static(
                        "Indices",
                        "claim",
                        types::Claim { index },
                        [
                            146u8,
                            58u8,
                            246u8,
                            135u8,
                            59u8,
                            90u8,
                            3u8,
                            5u8,
                            140u8,
                            169u8,
                            232u8,
                            195u8,
                            11u8,
                            107u8,
                            36u8,
                            141u8,
                            118u8,
                            174u8,
                            160u8,
                            160u8,
                            19u8,
                            205u8,
                            177u8,
                            193u8,
                            18u8,
                            102u8,
                            115u8,
                            31u8,
                            72u8,
                            29u8,
                            91u8,
                            235u8,
                        ],
                    )
                }
                ///Assign an index already owned by the sender to another account. The balance reservation
                ///is effectively transferred to the new account.
                ///
                ///The dispatch origin for this call must be _Signed_.
                ///
                ///- `index`: the index to be re-assigned. This must be owned by the sender.
                ///- `new`: the new owner of the index. This function is a no-op if it is equal to sender.
                ///
                ///Emits `IndexAssigned` if successful.
                ///
                ///## Complexity
                ///- `O(1)`.
                pub fn transfer(
                    &self,
                    new: ::subxt::utils::MultiAddress<
                        ::subxt::utils::AccountId32,
                        ::core::primitive::u32,
                    >,
                    index: ::core::primitive::u32,
                ) -> ::subxt::tx::Payload<types::Transfer> {
                    ::subxt::tx::Payload::new_static(
                        "Indices",
                        "transfer",
                        types::Transfer { new, index },
                        [
                            139u8,
                            89u8,
                            163u8,
                            53u8,
                            141u8,
                            131u8,
                            135u8,
                            107u8,
                            0u8,
                            131u8,
                            53u8,
                            202u8,
                            117u8,
                            99u8,
                            239u8,
                            205u8,
                            101u8,
                            97u8,
                            251u8,
                            247u8,
                            116u8,
                            128u8,
                            220u8,
                            186u8,
                            151u8,
                            203u8,
                            82u8,
                            222u8,
                            199u8,
                            137u8,
                            41u8,
                            199u8,
                        ],
                    )
                }
                ///Free up an index owned by the sender.
                ///
                ///Payment: Any previous deposit placed for the index is unreserved in the sender account.
                ///
                ///The dispatch origin for this call must be _Signed_ and the sender must own the index.
                ///
                ///- `index`: the index to be freed. This must be owned by the sender.
                ///
                ///Emits `IndexFreed` if successful.
                ///
                ///## Complexity
                ///- `O(1)`.
                pub fn free(
                    &self,
                    index: ::core::primitive::u32,
                ) -> ::subxt::tx::Payload<types::Free> {
                    ::subxt::tx::Payload::new_static(
                        "Indices",
                        "free",
                        types::Free { index },
                        [
                            241u8,
                            211u8,
                            234u8,
                            102u8,
                            189u8,
                            22u8,
                            209u8,
                            27u8,
                            8u8,
                            229u8,
                            80u8,
                            227u8,
                            138u8,
                            252u8,
                            222u8,
                            111u8,
                            77u8,
                            201u8,
                            235u8,
                            51u8,
                            163u8,
                            247u8,
                            13u8,
                            126u8,
                            216u8,
                            136u8,
                            57u8,
                            222u8,
                            56u8,
                            66u8,
                            215u8,
                            244u8,
                        ],
                    )
                }
                ///Force an index to an account. This doesn't require a deposit. If the index is already
                ///held, then any deposit is reimbursed to its current owner.
                ///
                ///The dispatch origin for this call must be _Root_.
                ///
                ///- `index`: the index to be (re-)assigned.
                ///- `new`: the new owner of the index. This function is a no-op if it is equal to sender.
                ///- `freeze`: if set to `true`, will freeze the index so it cannot be transferred.
                ///
                ///Emits `IndexAssigned` if successful.
                ///
                ///## Complexity
                ///- `O(1)`.
                pub fn force_transfer(
                    &self,
                    new: ::subxt::utils::MultiAddress<
                        ::subxt::utils::AccountId32,
                        ::core::primitive::u32,
                    >,
                    index: ::core::primitive::u32,
                    freeze: ::core::primitive::bool,
                ) -> ::subxt::tx::Payload<types::ForceTransfer> {
                    ::subxt::tx::Payload::new_static(
                        "Indices",
                        "force_transfer",
                        types::ForceTransfer {
                            new,
                            index,
                            freeze,
                        },
                        [
                            160u8,
                            55u8,
                            190u8,
                            50u8,
                            35u8,
                            79u8,
                            28u8,
                            117u8,
                            9u8,
                            2u8,
                            34u8,
                            99u8,
                            247u8,
                            50u8,
                            77u8,
                            158u8,
                            156u8,
                            101u8,
                            90u8,
                            246u8,
                            129u8,
                            106u8,
                            23u8,
                            142u8,
                            213u8,
                            88u8,
                            191u8,
                            232u8,
                            99u8,
                            139u8,
                            61u8,
                            125u8,
                        ],
                    )
                }
                ///Freeze an index so it will always point to the sender account. This consumes the
                ///deposit.
                ///
                ///The dispatch origin for this call must be _Signed_ and the signing account must have a
                ///non-frozen account `index`.
                ///
                ///- `index`: the index to be frozen in place.
                ///
                ///Emits `IndexFrozen` if successful.
                ///
                ///## Complexity
                ///- `O(1)`.
                pub fn freeze(
                    &self,
                    index: ::core::primitive::u32,
                ) -> ::subxt::tx::Payload<types::Freeze> {
                    ::subxt::tx::Payload::new_static(
                        "Indices",
                        "freeze",
                        types::Freeze { index },
                        [
                            238u8,
                            215u8,
                            108u8,
                            156u8,
                            84u8,
                            240u8,
                            130u8,
                            229u8,
                            27u8,
                            132u8,
                            93u8,
                            78u8,
                            2u8,
                            251u8,
                            43u8,
                            203u8,
                            2u8,
                            142u8,
                            147u8,
                            48u8,
                            92u8,
                            101u8,
                            207u8,
                            24u8,
                            51u8,
                            16u8,
                            36u8,
                            229u8,
                            188u8,
                            129u8,
                            160u8,
                            117u8,
                        ],
                    )
                }
            }
        }
        /**
			The [event](https://docs.substrate.io/main-docs/build/events-errors/) emitted
			by this pallet.
			*/
        pub type Event = runtime_types::pallet_indices::pallet::Event;
        pub mod events {
            use super::runtime_types;
            #[derive(
                ::subxt::ext::codec::Decode,
                ::subxt::ext::codec::Encode,
                ::subxt::ext::scale_decode::DecodeAsType,
                ::subxt::ext::scale_encode::EncodeAsType,
                Clone,
                Debug,
                Eq,
                PartialEq
            )]
            #[codec(crate = ::subxt::ext::codec)]
            #[decode_as_type(crate_path = ":: subxt :: ext :: scale_decode")]
            #[encode_as_type(crate_path = ":: subxt :: ext :: scale_encode")]
            ///A account index was assigned.
            pub struct IndexAssigned {
                pub who: ::subxt::utils::AccountId32,
                pub index: ::core::primitive::u32,
            }
            impl ::subxt::events::StaticEvent for IndexAssigned {
                const PALLET: &'static str = "Indices";
                const EVENT: &'static str = "IndexAssigned";
            }
            #[derive(
                ::subxt::ext::codec::CompactAs,
                ::subxt::ext::codec::Decode,
                ::subxt::ext::codec::Encode,
                ::subxt::ext::scale_decode::DecodeAsType,
                ::subxt::ext::scale_encode::EncodeAsType,
                Clone,
                Debug,
                Eq,
                PartialEq
            )]
            #[codec(crate = ::subxt::ext::codec)]
            #[decode_as_type(crate_path = ":: subxt :: ext :: scale_decode")]
            #[encode_as_type(crate_path = ":: subxt :: ext :: scale_encode")]
            ///A account index has been freed up (unassigned).
            pub struct IndexFreed {
                pub index: ::core::primitive::u32,
            }
            impl ::subxt::events::StaticEvent for IndexFreed {
                const PALLET: &'static str = "Indices";
                const EVENT: &'static str = "IndexFreed";
            }
            #[derive(
                ::subxt::ext::codec::Decode,
                ::subxt::ext::codec::Encode,
                ::subxt::ext::scale_decode::DecodeAsType,
                ::subxt::ext::scale_encode::EncodeAsType,
                Clone,
                Debug,
                Eq,
                PartialEq
            )]
            #[codec(crate = ::subxt::ext::codec)]
            #[decode_as_type(crate_path = ":: subxt :: ext :: scale_decode")]
            #[encode_as_type(crate_path = ":: subxt :: ext :: scale_encode")]
            ///A account index has been frozen to its current account ID.
            pub struct IndexFrozen {
                pub index: ::core::primitive::u32,
                pub who: ::subxt::utils::AccountId32,
            }
            impl ::subxt::events::StaticEvent for IndexFrozen {
                const PALLET: &'static str = "Indices";
                const EVENT: &'static str = "IndexFrozen";
            }
        }
        pub mod storage {
            use super::runtime_types;
            pub struct StorageApi;
            impl StorageApi {
                /// The lookup from index to account.
                pub fn accounts(
                    &self,
                    _0: impl ::std::borrow::Borrow<::core::primitive::u32>,
                ) -> ::subxt::storage::address::Address<
                    ::subxt::storage::address::StaticStorageMapKey,
                    (
                        ::subxt::utils::AccountId32,
                        ::core::primitive::u128,
                        ::core::primitive::bool,
                    ),
                    ::subxt::storage::address::Yes,
                    (),
                    ::subxt::storage::address::Yes,
                > {
                    ::subxt::storage::address::Address::new_static(
                        "Indices",
                        "Accounts",
                        vec![
                            ::subxt::storage::address::make_static_storage_map_key(_0
                            .borrow())
                        ],
                        [
                            48u8,
                            189u8,
                            43u8,
                            119u8,
                            32u8,
                            168u8,
                            28u8,
                            12u8,
                            245u8,
                            81u8,
                            119u8,
                            182u8,
                            23u8,
                            201u8,
                            33u8,
                            147u8,
                            128u8,
                            171u8,
                            155u8,
                            134u8,
                            71u8,
                            87u8,
                            100u8,
                            248u8,
                            107u8,
                            129u8,
                            36u8,
                            197u8,
                            220u8,
                            90u8,
                            11u8,
                            238u8,
                        ],
                    )
                }
                /// The lookup from index to account.
                pub fn accounts_root(
                    &self,
                ) -> ::subxt::storage::address::Address<
                    ::subxt::storage::address::StaticStorageMapKey,
                    (
                        ::subxt::utils::AccountId32,
                        ::core::primitive::u128,
                        ::core::primitive::bool,
                    ),
                    (),
                    (),
                    ::subxt::storage::address::Yes,
                > {
                    ::subxt::storage::address::Address::new_static(
                        "Indices",
                        "Accounts",
                        Vec::new(),
                        [
                            48u8,
                            189u8,
                            43u8,
                            119u8,
                            32u8,
                            168u8,
                            28u8,
                            12u8,
                            245u8,
                            81u8,
                            119u8,
                            182u8,
                            23u8,
                            201u8,
                            33u8,
                            147u8,
                            128u8,
                            171u8,
                            155u8,
                            134u8,
                            71u8,
                            87u8,
                            100u8,
                            248u8,
                            107u8,
                            129u8,
                            36u8,
                            197u8,
                            220u8,
                            90u8,
                            11u8,
                            238u8,
                        ],
                    )
                }
            }
        }
        pub mod constants {
            use super::runtime_types;
            pub struct ConstantsApi;
            impl ConstantsApi {
                /// The deposit needed for reserving an index.
                pub fn deposit(
                    &self,
                ) -> ::subxt::constants::Address<::core::primitive::u128> {
                    ::subxt::constants::Address::new_static(
                        "Indices",
                        "Deposit",
                        [
                            84u8,
                            157u8,
                            140u8,
                            4u8,
                            93u8,
                            57u8,
                            29u8,
                            133u8,
                            105u8,
                            200u8,
                            214u8,
                            27u8,
                            144u8,
                            208u8,
                            218u8,
                            160u8,
                            130u8,
                            109u8,
                            101u8,
                            54u8,
                            210u8,
                            136u8,
                            71u8,
                            63u8,
                            49u8,
                            237u8,
                            234u8,
                            15u8,
                            178u8,
                            98u8,
                            148u8,
                            156u8,
                        ],
                    )
                }
            }
        }
    }
    pub mod democracy {
        use super::root_mod;
        use super::runtime_types;
        /**
			Custom [dispatch errors](https://docs.substrate.io/main-docs/build/events-errors/)
			of this pallet.
			*/
        pub type Error = runtime_types::pallet_democracy::pallet::Error;
        ///Contains one variant per dispatchable that can be called by an extrinsic.
        pub type Call = runtime_types::pallet_democracy::pallet::Call;
        pub mod calls {
            use super::root_mod;
            use super::runtime_types;
            type DispatchError = runtime_types::sp_runtime::DispatchError;
            pub mod types {
                use super::runtime_types;
                #[derive(
                    ::subxt::ext::codec::Decode,
                    ::subxt::ext::codec::Encode,
                    ::subxt::ext::scale_decode::DecodeAsType,
                    ::subxt::ext::scale_encode::EncodeAsType,
                    Clone,
                    Debug,
                    Eq,
                    PartialEq
                )]
                #[codec(crate = ::subxt::ext::codec)]
                #[decode_as_type(crate_path = ":: subxt :: ext :: scale_decode")]
                #[encode_as_type(crate_path = ":: subxt :: ext :: scale_encode")]
                pub struct Propose {
                    pub proposal: runtime_types::frame_support::traits::preimages::Bounded<
                        runtime_types::tangle_standalone_runtime::RuntimeCall,
                    >,
                    #[codec(compact)]
                    pub value: ::core::primitive::u128,
                }
                impl ::subxt::blocks::StaticExtrinsic for Propose {
                    const PALLET: &'static str = "Democracy";
                    const CALL: &'static str = "propose";
                }
                #[derive(
                    ::subxt::ext::codec::Decode,
                    ::subxt::ext::codec::Encode,
                    ::subxt::ext::scale_decode::DecodeAsType,
                    ::subxt::ext::scale_encode::EncodeAsType,
                    Clone,
                    Debug,
                    Eq,
                    PartialEq
                )]
                #[codec(crate = ::subxt::ext::codec)]
                #[decode_as_type(crate_path = ":: subxt :: ext :: scale_decode")]
                #[encode_as_type(crate_path = ":: subxt :: ext :: scale_encode")]
                pub struct Second {
                    #[codec(compact)]
                    pub proposal: ::core::primitive::u32,
                }
                impl ::subxt::blocks::StaticExtrinsic for Second {
                    const PALLET: &'static str = "Democracy";
                    const CALL: &'static str = "second";
                }
                #[derive(
                    ::subxt::ext::codec::Decode,
                    ::subxt::ext::codec::Encode,
                    ::subxt::ext::scale_decode::DecodeAsType,
                    ::subxt::ext::scale_encode::EncodeAsType,
                    Clone,
                    Debug,
                    Eq,
                    PartialEq
                )]
                #[codec(crate = ::subxt::ext::codec)]
                #[decode_as_type(crate_path = ":: subxt :: ext :: scale_decode")]
                #[encode_as_type(crate_path = ":: subxt :: ext :: scale_encode")]
                pub struct Vote {
                    #[codec(compact)]
                    pub ref_index: ::core::primitive::u32,
                    pub vote: runtime_types::pallet_democracy::vote::AccountVote<
                        ::core::primitive::u128,
                    >,
                }
                impl ::subxt::blocks::StaticExtrinsic for Vote {
                    const PALLET: &'static str = "Democracy";
                    const CALL: &'static str = "vote";
                }
                #[derive(
                    ::subxt::ext::codec::CompactAs,
                    ::subxt::ext::codec::Decode,
                    ::subxt::ext::codec::Encode,
                    ::subxt::ext::scale_decode::DecodeAsType,
                    ::subxt::ext::scale_encode::EncodeAsType,
                    Clone,
                    Debug,
                    Eq,
                    PartialEq
                )]
                #[codec(crate = ::subxt::ext::codec)]
                #[decode_as_type(crate_path = ":: subxt :: ext :: scale_decode")]
                #[encode_as_type(crate_path = ":: subxt :: ext :: scale_encode")]
                pub struct EmergencyCancel {
                    pub ref_index: ::core::primitive::u32,
                }
                impl ::subxt::blocks::StaticExtrinsic for EmergencyCancel {
                    const PALLET: &'static str = "Democracy";
                    const CALL: &'static str = "emergency_cancel";
                }
                #[derive(
                    ::subxt::ext::codec::Decode,
                    ::subxt::ext::codec::Encode,
                    ::subxt::ext::scale_decode::DecodeAsType,
                    ::subxt::ext::scale_encode::EncodeAsType,
                    Clone,
                    Debug,
                    Eq,
                    PartialEq
                )]
                #[codec(crate = ::subxt::ext::codec)]
                #[decode_as_type(crate_path = ":: subxt :: ext :: scale_decode")]
                #[encode_as_type(crate_path = ":: subxt :: ext :: scale_encode")]
                pub struct ExternalPropose {
                    pub proposal: runtime_types::frame_support::traits::preimages::Bounded<
                        runtime_types::tangle_standalone_runtime::RuntimeCall,
                    >,
                }
                impl ::subxt::blocks::StaticExtrinsic for ExternalPropose {
                    const PALLET: &'static str = "Democracy";
                    const CALL: &'static str = "external_propose";
                }
                #[derive(
                    ::subxt::ext::codec::Decode,
                    ::subxt::ext::codec::Encode,
                    ::subxt::ext::scale_decode::DecodeAsType,
                    ::subxt::ext::scale_encode::EncodeAsType,
                    Clone,
                    Debug,
                    Eq,
                    PartialEq
                )]
                #[codec(crate = ::subxt::ext::codec)]
                #[decode_as_type(crate_path = ":: subxt :: ext :: scale_decode")]
                #[encode_as_type(crate_path = ":: subxt :: ext :: scale_encode")]
                pub struct ExternalProposeMajority {
                    pub proposal: runtime_types::frame_support::traits::preimages::Bounded<
                        runtime_types::tangle_standalone_runtime::RuntimeCall,
                    >,
                }
                impl ::subxt::blocks::StaticExtrinsic for ExternalProposeMajority {
                    const PALLET: &'static str = "Democracy";
                    const CALL: &'static str = "external_propose_majority";
                }
                #[derive(
                    ::subxt::ext::codec::Decode,
                    ::subxt::ext::codec::Encode,
                    ::subxt::ext::scale_decode::DecodeAsType,
                    ::subxt::ext::scale_encode::EncodeAsType,
                    Clone,
                    Debug,
                    Eq,
                    PartialEq
                )]
                #[codec(crate = ::subxt::ext::codec)]
                #[decode_as_type(crate_path = ":: subxt :: ext :: scale_decode")]
                #[encode_as_type(crate_path = ":: subxt :: ext :: scale_encode")]
                pub struct ExternalProposeDefault {
                    pub proposal: runtime_types::frame_support::traits::preimages::Bounded<
                        runtime_types::tangle_standalone_runtime::RuntimeCall,
                    >,
                }
                impl ::subxt::blocks::StaticExtrinsic for ExternalProposeDefault {
                    const PALLET: &'static str = "Democracy";
                    const CALL: &'static str = "external_propose_default";
                }
                #[derive(
                    ::subxt::ext::codec::Decode,
                    ::subxt::ext::codec::Encode,
                    ::subxt::ext::scale_decode::DecodeAsType,
                    ::subxt::ext::scale_encode::EncodeAsType,
                    Clone,
                    Debug,
                    Eq,
                    PartialEq
                )]
                #[codec(crate = ::subxt::ext::codec)]
                #[decode_as_type(crate_path = ":: subxt :: ext :: scale_decode")]
                #[encode_as_type(crate_path = ":: subxt :: ext :: scale_encode")]
                pub struct FastTrack {
                    pub proposal_hash: ::subxt::utils::H256,
                    pub voting_period: ::core::primitive::u32,
                    pub delay: ::core::primitive::u32,
                }
                impl ::subxt::blocks::StaticExtrinsic for FastTrack {
                    const PALLET: &'static str = "Democracy";
                    const CALL: &'static str = "fast_track";
                }
                #[derive(
                    ::subxt::ext::codec::Decode,
                    ::subxt::ext::codec::Encode,
                    ::subxt::ext::scale_decode::DecodeAsType,
                    ::subxt::ext::scale_encode::EncodeAsType,
                    Clone,
                    Debug,
                    Eq,
                    PartialEq
                )]
                #[codec(crate = ::subxt::ext::codec)]
                #[decode_as_type(crate_path = ":: subxt :: ext :: scale_decode")]
                #[encode_as_type(crate_path = ":: subxt :: ext :: scale_encode")]
                pub struct VetoExternal {
                    pub proposal_hash: ::subxt::utils::H256,
                }
                impl ::subxt::blocks::StaticExtrinsic for VetoExternal {
                    const PALLET: &'static str = "Democracy";
                    const CALL: &'static str = "veto_external";
                }
                #[derive(
                    ::subxt::ext::codec::Decode,
                    ::subxt::ext::codec::Encode,
                    ::subxt::ext::scale_decode::DecodeAsType,
                    ::subxt::ext::scale_encode::EncodeAsType,
                    Clone,
                    Debug,
                    Eq,
                    PartialEq
                )]
                #[codec(crate = ::subxt::ext::codec)]
                #[decode_as_type(crate_path = ":: subxt :: ext :: scale_decode")]
                #[encode_as_type(crate_path = ":: subxt :: ext :: scale_encode")]
                pub struct CancelReferendum {
                    #[codec(compact)]
                    pub ref_index: ::core::primitive::u32,
                }
                impl ::subxt::blocks::StaticExtrinsic for CancelReferendum {
                    const PALLET: &'static str = "Democracy";
                    const CALL: &'static str = "cancel_referendum";
                }
                #[derive(
                    ::subxt::ext::codec::Decode,
                    ::subxt::ext::codec::Encode,
                    ::subxt::ext::scale_decode::DecodeAsType,
                    ::subxt::ext::scale_encode::EncodeAsType,
                    Clone,
                    Debug,
                    Eq,
                    PartialEq
                )]
                #[codec(crate = ::subxt::ext::codec)]
                #[decode_as_type(crate_path = ":: subxt :: ext :: scale_decode")]
                #[encode_as_type(crate_path = ":: subxt :: ext :: scale_encode")]
                pub struct Delegate {
                    pub to: ::subxt::utils::MultiAddress<
                        ::subxt::utils::AccountId32,
                        ::core::primitive::u32,
                    >,
                    pub conviction: runtime_types::pallet_democracy::conviction::Conviction,
                    pub balance: ::core::primitive::u128,
                }
                impl ::subxt::blocks::StaticExtrinsic for Delegate {
                    const PALLET: &'static str = "Democracy";
                    const CALL: &'static str = "delegate";
                }
                #[derive(
                    ::subxt::ext::codec::Decode,
                    ::subxt::ext::codec::Encode,
                    ::subxt::ext::scale_decode::DecodeAsType,
                    ::subxt::ext::scale_encode::EncodeAsType,
                    Clone,
                    Debug,
                    Eq,
                    PartialEq
                )]
                #[codec(crate = ::subxt::ext::codec)]
                #[decode_as_type(crate_path = ":: subxt :: ext :: scale_decode")]
                #[encode_as_type(crate_path = ":: subxt :: ext :: scale_encode")]
                pub struct Undelegate;
                impl ::subxt::blocks::StaticExtrinsic for Undelegate {
                    const PALLET: &'static str = "Democracy";
                    const CALL: &'static str = "undelegate";
                }
                #[derive(
                    ::subxt::ext::codec::Decode,
                    ::subxt::ext::codec::Encode,
                    ::subxt::ext::scale_decode::DecodeAsType,
                    ::subxt::ext::scale_encode::EncodeAsType,
                    Clone,
                    Debug,
                    Eq,
                    PartialEq
                )]
                #[codec(crate = ::subxt::ext::codec)]
                #[decode_as_type(crate_path = ":: subxt :: ext :: scale_decode")]
                #[encode_as_type(crate_path = ":: subxt :: ext :: scale_encode")]
                pub struct ClearPublicProposals;
                impl ::subxt::blocks::StaticExtrinsic for ClearPublicProposals {
                    const PALLET: &'static str = "Democracy";
                    const CALL: &'static str = "clear_public_proposals";
                }
                #[derive(
                    ::subxt::ext::codec::Decode,
                    ::subxt::ext::codec::Encode,
                    ::subxt::ext::scale_decode::DecodeAsType,
                    ::subxt::ext::scale_encode::EncodeAsType,
                    Clone,
                    Debug,
                    Eq,
                    PartialEq
                )]
                #[codec(crate = ::subxt::ext::codec)]
                #[decode_as_type(crate_path = ":: subxt :: ext :: scale_decode")]
                #[encode_as_type(crate_path = ":: subxt :: ext :: scale_encode")]
                pub struct Unlock {
                    pub target: ::subxt::utils::MultiAddress<
                        ::subxt::utils::AccountId32,
                        ::core::primitive::u32,
                    >,
                }
                impl ::subxt::blocks::StaticExtrinsic for Unlock {
                    const PALLET: &'static str = "Democracy";
                    const CALL: &'static str = "unlock";
                }
                #[derive(
                    ::subxt::ext::codec::CompactAs,
                    ::subxt::ext::codec::Decode,
                    ::subxt::ext::codec::Encode,
                    ::subxt::ext::scale_decode::DecodeAsType,
                    ::subxt::ext::scale_encode::EncodeAsType,
                    Clone,
                    Debug,
                    Eq,
                    PartialEq
                )]
                #[codec(crate = ::subxt::ext::codec)]
                #[decode_as_type(crate_path = ":: subxt :: ext :: scale_decode")]
                #[encode_as_type(crate_path = ":: subxt :: ext :: scale_encode")]
                pub struct RemoveVote {
                    pub index: ::core::primitive::u32,
                }
                impl ::subxt::blocks::StaticExtrinsic for RemoveVote {
                    const PALLET: &'static str = "Democracy";
                    const CALL: &'static str = "remove_vote";
                }
                #[derive(
                    ::subxt::ext::codec::Decode,
                    ::subxt::ext::codec::Encode,
                    ::subxt::ext::scale_decode::DecodeAsType,
                    ::subxt::ext::scale_encode::EncodeAsType,
                    Clone,
                    Debug,
                    Eq,
                    PartialEq
                )]
                #[codec(crate = ::subxt::ext::codec)]
                #[decode_as_type(crate_path = ":: subxt :: ext :: scale_decode")]
                #[encode_as_type(crate_path = ":: subxt :: ext :: scale_encode")]
                pub struct RemoveOtherVote {
                    pub target: ::subxt::utils::MultiAddress<
                        ::subxt::utils::AccountId32,
                        ::core::primitive::u32,
                    >,
                    pub index: ::core::primitive::u32,
                }
                impl ::subxt::blocks::StaticExtrinsic for RemoveOtherVote {
                    const PALLET: &'static str = "Democracy";
                    const CALL: &'static str = "remove_other_vote";
                }
                #[derive(
                    ::subxt::ext::codec::Decode,
                    ::subxt::ext::codec::Encode,
                    ::subxt::ext::scale_decode::DecodeAsType,
                    ::subxt::ext::scale_encode::EncodeAsType,
                    Clone,
                    Debug,
                    Eq,
                    PartialEq
                )]
                #[codec(crate = ::subxt::ext::codec)]
                #[decode_as_type(crate_path = ":: subxt :: ext :: scale_decode")]
                #[encode_as_type(crate_path = ":: subxt :: ext :: scale_encode")]
                pub struct Blacklist {
                    pub proposal_hash: ::subxt::utils::H256,
                    pub maybe_ref_index: ::core::option::Option<::core::primitive::u32>,
                }
                impl ::subxt::blocks::StaticExtrinsic for Blacklist {
                    const PALLET: &'static str = "Democracy";
                    const CALL: &'static str = "blacklist";
                }
                #[derive(
                    ::subxt::ext::codec::Decode,
                    ::subxt::ext::codec::Encode,
                    ::subxt::ext::scale_decode::DecodeAsType,
                    ::subxt::ext::scale_encode::EncodeAsType,
                    Clone,
                    Debug,
                    Eq,
                    PartialEq
                )]
                #[codec(crate = ::subxt::ext::codec)]
                #[decode_as_type(crate_path = ":: subxt :: ext :: scale_decode")]
                #[encode_as_type(crate_path = ":: subxt :: ext :: scale_encode")]
                pub struct CancelProposal {
                    #[codec(compact)]
                    pub prop_index: ::core::primitive::u32,
                }
                impl ::subxt::blocks::StaticExtrinsic for CancelProposal {
                    const PALLET: &'static str = "Democracy";
                    const CALL: &'static str = "cancel_proposal";
                }
                #[derive(
                    ::subxt::ext::codec::Decode,
                    ::subxt::ext::codec::Encode,
                    ::subxt::ext::scale_decode::DecodeAsType,
                    ::subxt::ext::scale_encode::EncodeAsType,
                    Clone,
                    Debug,
                    Eq,
                    PartialEq
                )]
                #[codec(crate = ::subxt::ext::codec)]
                #[decode_as_type(crate_path = ":: subxt :: ext :: scale_decode")]
                #[encode_as_type(crate_path = ":: subxt :: ext :: scale_encode")]
                pub struct SetMetadata {
                    pub owner: runtime_types::pallet_democracy::types::MetadataOwner,
                    pub maybe_hash: ::core::option::Option<::subxt::utils::H256>,
                }
                impl ::subxt::blocks::StaticExtrinsic for SetMetadata {
                    const PALLET: &'static str = "Democracy";
                    const CALL: &'static str = "set_metadata";
                }
            }
            pub struct TransactionApi;
            impl TransactionApi {
                ///Propose a sensitive action to be taken.
                ///
                ///The dispatch origin of this call must be _Signed_ and the sender must
                ///have funds to cover the deposit.
                ///
                ///- `proposal_hash`: The hash of the proposal preimage.
                ///- `value`: The amount of deposit (must be at least `MinimumDeposit`).
                ///
                ///Emits `Proposed`.
                pub fn propose(
                    &self,
                    proposal: runtime_types::frame_support::traits::preimages::Bounded<
                        runtime_types::tangle_standalone_runtime::RuntimeCall,
                    >,
                    value: ::core::primitive::u128,
                ) -> ::subxt::tx::Payload<types::Propose> {
                    ::subxt::tx::Payload::new_static(
                        "Democracy",
                        "propose",
                        types::Propose { proposal, value },
                        [
                            230u8,
                            248u8,
                            57u8,
                            131u8,
                            96u8,
                            178u8,
                            225u8,
                            150u8,
                            97u8,
                            77u8,
                            246u8,
                            143u8,
                            151u8,
                            204u8,
                            201u8,
                            252u8,
                            133u8,
                            53u8,
                            34u8,
                            27u8,
                            156u8,
                            2u8,
                            242u8,
                            170u8,
                            198u8,
                            157u8,
                            166u8,
                            84u8,
                            246u8,
                            86u8,
                            78u8,
                            128u8,
                        ],
                    )
                }
                ///Signals agreement with a particular proposal.
                ///
                ///The dispatch origin of this call must be _Signed_ and the sender
                ///must have funds to cover the deposit, equal to the original deposit.
                ///
                ///- `proposal`: The index of the proposal to second.
                pub fn second(
                    &self,
                    proposal: ::core::primitive::u32,
                ) -> ::subxt::tx::Payload<types::Second> {
                    ::subxt::tx::Payload::new_static(
                        "Democracy",
                        "second",
                        types::Second { proposal },
                        [
                            195u8,
                            55u8,
                            178u8,
                            55u8,
                            129u8,
                            64u8,
                            10u8,
                            131u8,
                            217u8,
                            79u8,
                            1u8,
                            187u8,
                            73u8,
                            126u8,
                            191u8,
                            221u8,
                            110u8,
                            10u8,
                            13u8,
                            65u8,
                            190u8,
                            107u8,
                            21u8,
                            236u8,
                            175u8,
                            130u8,
                            227u8,
                            179u8,
                            173u8,
                            39u8,
                            32u8,
                            147u8,
                        ],
                    )
                }
                ///Vote in a referendum. If `vote.is_aye()`, the vote is to enact the proposal;
                ///otherwise it is a vote to keep the status quo.
                ///
                ///The dispatch origin of this call must be _Signed_.
                ///
                ///- `ref_index`: The index of the referendum to vote for.
                ///- `vote`: The vote configuration.
                pub fn vote(
                    &self,
                    ref_index: ::core::primitive::u32,
                    vote: runtime_types::pallet_democracy::vote::AccountVote<
                        ::core::primitive::u128,
                    >,
                ) -> ::subxt::tx::Payload<types::Vote> {
                    ::subxt::tx::Payload::new_static(
                        "Democracy",
                        "vote",
                        types::Vote { ref_index, vote },
                        [
                            39u8,
                            113u8,
                            23u8,
                            175u8,
                            197u8,
                            225u8,
                            225u8,
                            129u8,
                            66u8,
                            50u8,
                            236u8,
                            220u8,
                            50u8,
                            49u8,
                            98u8,
                            163u8,
                            176u8,
                            96u8,
                            17u8,
                            91u8,
                            28u8,
                            187u8,
                            139u8,
                            148u8,
                            108u8,
                            110u8,
                            78u8,
                            253u8,
                            229u8,
                            3u8,
                            244u8,
                            126u8,
                        ],
                    )
                }
                ///Schedule an emergency cancellation of a referendum. Cannot happen twice to the same
                ///referendum.
                ///
                ///The dispatch origin of this call must be `CancellationOrigin`.
                ///
                ///-`ref_index`: The index of the referendum to cancel.
                ///
                ///Weight: `O(1)`.
                pub fn emergency_cancel(
                    &self,
                    ref_index: ::core::primitive::u32,
                ) -> ::subxt::tx::Payload<types::EmergencyCancel> {
                    ::subxt::tx::Payload::new_static(
                        "Democracy",
                        "emergency_cancel",
                        types::EmergencyCancel {
                            ref_index,
                        },
                        [
                            82u8,
                            232u8,
                            19u8,
                            158u8,
                            88u8,
                            69u8,
                            96u8,
                            225u8,
                            106u8,
                            253u8,
                            6u8,
                            136u8,
                            87u8,
                            0u8,
                            68u8,
                            128u8,
                            122u8,
                            16u8,
                            107u8,
                            76u8,
                            209u8,
                            14u8,
                            230u8,
                            49u8,
                            228u8,
                            100u8,
                            187u8,
                            10u8,
                            76u8,
                            71u8,
                            197u8,
                            72u8,
                        ],
                    )
                }
                ///Schedule a referendum to be tabled once it is legal to schedule an external
                ///referendum.
                ///
                ///The dispatch origin of this call must be `ExternalOrigin`.
                ///
                ///- `proposal_hash`: The preimage hash of the proposal.
                pub fn external_propose(
                    &self,
                    proposal: runtime_types::frame_support::traits::preimages::Bounded<
                        runtime_types::tangle_standalone_runtime::RuntimeCall,
                    >,
                ) -> ::subxt::tx::Payload<types::ExternalPropose> {
                    ::subxt::tx::Payload::new_static(
                        "Democracy",
                        "external_propose",
                        types::ExternalPropose { proposal },
                        [
                            247u8,
                            47u8,
                            180u8,
                            40u8,
                            205u8,
                            53u8,
                            99u8,
                            158u8,
                            4u8,
                            45u8,
                            157u8,
                            247u8,
                            32u8,
                            117u8,
                            153u8,
                            170u8,
                            226u8,
                            250u8,
                            142u8,
                            38u8,
                            237u8,
                            238u8,
                            75u8,
                            245u8,
                            184u8,
                            27u8,
                            157u8,
                            255u8,
                            213u8,
                            163u8,
                            92u8,
                            251u8,
                        ],
                    )
                }
                ///Schedule a majority-carries referendum to be tabled next once it is legal to schedule
                ///an external referendum.
                ///
                ///The dispatch of this call must be `ExternalMajorityOrigin`.
                ///
                ///- `proposal_hash`: The preimage hash of the proposal.
                ///
                ///Unlike `external_propose`, blacklisting has no effect on this and it may replace a
                ///pre-scheduled `external_propose` call.
                ///
                ///Weight: `O(1)`
                pub fn external_propose_majority(
                    &self,
                    proposal: runtime_types::frame_support::traits::preimages::Bounded<
                        runtime_types::tangle_standalone_runtime::RuntimeCall,
                    >,
                ) -> ::subxt::tx::Payload<types::ExternalProposeMajority> {
                    ::subxt::tx::Payload::new_static(
                        "Democracy",
                        "external_propose_majority",
                        types::ExternalProposeMajority {
                            proposal,
                        },
                        [
                            107u8,
                            81u8,
                            160u8,
                            130u8,
                            242u8,
                            208u8,
                            22u8,
                            70u8,
                            237u8,
                            235u8,
                            236u8,
                            60u8,
                            206u8,
                            172u8,
                            251u8,
                            138u8,
                            168u8,
                            124u8,
                            136u8,
                            95u8,
                            3u8,
                            184u8,
                            12u8,
                            55u8,
                            125u8,
                            233u8,
                            20u8,
                            148u8,
                            36u8,
                            189u8,
                            16u8,
                            245u8,
                        ],
                    )
                }
                ///Schedule a negative-turnout-bias referendum to be tabled next once it is legal to
                ///schedule an external referendum.
                ///
                ///The dispatch of this call must be `ExternalDefaultOrigin`.
                ///
                ///- `proposal_hash`: The preimage hash of the proposal.
                ///
                ///Unlike `external_propose`, blacklisting has no effect on this and it may replace a
                ///pre-scheduled `external_propose` call.
                ///
                ///Weight: `O(1)`
                pub fn external_propose_default(
                    &self,
                    proposal: runtime_types::frame_support::traits::preimages::Bounded<
                        runtime_types::tangle_standalone_runtime::RuntimeCall,
                    >,
                ) -> ::subxt::tx::Payload<types::ExternalProposeDefault> {
                    ::subxt::tx::Payload::new_static(
                        "Democracy",
                        "external_propose_default",
                        types::ExternalProposeDefault {
                            proposal,
                        },
                        [
                            238u8,
                            247u8,
                            252u8,
                            35u8,
                            78u8,
                            158u8,
                            221u8,
                            87u8,
                            252u8,
                            98u8,
                            67u8,
                            44u8,
                            200u8,
                            206u8,
                            28u8,
                            19u8,
                            204u8,
                            13u8,
                            253u8,
                            133u8,
                            229u8,
                            195u8,
                            166u8,
                            218u8,
                            114u8,
                            69u8,
                            23u8,
                            169u8,
                            67u8,
                            168u8,
                            46u8,
                            176u8,
                        ],
                    )
                }
                ///Schedule the currently externally-proposed majority-carries referendum to be tabled
                ///immediately. If there is no externally-proposed referendum currently, or if there is one
                ///but it is not a majority-carries referendum then it fails.
                ///
                ///The dispatch of this call must be `FastTrackOrigin`.
                ///
                ///- `proposal_hash`: The hash of the current external proposal.
                ///- `voting_period`: The period that is allowed for voting on this proposal. Increased to
                ///	Must be always greater than zero.
                ///	For `FastTrackOrigin` must be equal or greater than `FastTrackVotingPeriod`.
                ///- `delay`: The number of block after voting has ended in approval and this should be
                ///  enacted. This doesn't have a minimum amount.
                ///
                ///Emits `Started`.
                ///
                ///Weight: `O(1)`
                pub fn fast_track(
                    &self,
                    proposal_hash: ::subxt::utils::H256,
                    voting_period: ::core::primitive::u32,
                    delay: ::core::primitive::u32,
                ) -> ::subxt::tx::Payload<types::FastTrack> {
                    ::subxt::tx::Payload::new_static(
                        "Democracy",
                        "fast_track",
                        types::FastTrack {
                            proposal_hash,
                            voting_period,
                            delay,
                        },
                        [
                            147u8,
                            226u8,
                            166u8,
                            105u8,
                            149u8,
                            171u8,
                            86u8,
                            165u8,
                            168u8,
                            78u8,
                            233u8,
                            182u8,
                            118u8,
                            36u8,
                            82u8,
                            155u8,
                            209u8,
                            55u8,
                            153u8,
                            141u8,
                            120u8,
                            223u8,
                            46u8,
                            170u8,
                            48u8,
                            94u8,
                            32u8,
                            144u8,
                            84u8,
                            203u8,
                            68u8,
                            62u8,
                        ],
                    )
                }
                ///Veto and blacklist the external proposal hash.
                ///
                ///The dispatch origin of this call must be `VetoOrigin`.
                ///
                ///- `proposal_hash`: The preimage hash of the proposal to veto and blacklist.
                ///
                ///Emits `Vetoed`.
                ///
                ///Weight: `O(V + log(V))` where V is number of `existing vetoers`
                pub fn veto_external(
                    &self,
                    proposal_hash: ::subxt::utils::H256,
                ) -> ::subxt::tx::Payload<types::VetoExternal> {
                    ::subxt::tx::Payload::new_static(
                        "Democracy",
                        "veto_external",
                        types::VetoExternal {
                            proposal_hash,
                        },
                        [
                            121u8,
                            217u8,
                            249u8,
                            134u8,
                            45u8,
                            19u8,
                            126u8,
                            166u8,
                            218u8,
                            223u8,
                            165u8,
                            124u8,
                            162u8,
                            59u8,
                            56u8,
                            200u8,
                            227u8,
                            125u8,
                            23u8,
                            133u8,
                            196u8,
                            93u8,
                            210u8,
                            15u8,
                            39u8,
                            26u8,
                            58u8,
                            236u8,
                            9u8,
                            101u8,
                            202u8,
                            168u8,
                        ],
                    )
                }
                ///Remove a referendum.
                ///
                ///The dispatch origin of this call must be _Root_.
                ///
                ///- `ref_index`: The index of the referendum to cancel.
                ///
                ///# Weight: `O(1)`.
                pub fn cancel_referendum(
                    &self,
                    ref_index: ::core::primitive::u32,
                ) -> ::subxt::tx::Payload<types::CancelReferendum> {
                    ::subxt::tx::Payload::new_static(
                        "Democracy",
                        "cancel_referendum",
                        types::CancelReferendum {
                            ref_index,
                        },
                        [
                            149u8,
                            120u8,
                            70u8,
                            20u8,
                            126u8,
                            21u8,
                            30u8,
                            33u8,
                            82u8,
                            124u8,
                            229u8,
                            179u8,
                            169u8,
                            243u8,
                            173u8,
                            146u8,
                            140u8,
                            22u8,
                            124u8,
                            154u8,
                            228u8,
                            117u8,
                            109u8,
                            88u8,
                            11u8,
                            100u8,
                            235u8,
                            243u8,
                            118u8,
                            99u8,
                            250u8,
                            140u8,
                        ],
                    )
                }
                ///Delegate the voting power (with some given conviction) of the sending account.
                ///
                ///The balance delegated is locked for as long as it's delegated, and thereafter for the
                ///time appropriate for the conviction's lock period.
                ///
                ///The dispatch origin of this call must be _Signed_, and the signing account must either:
                ///  - be delegating already; or
                ///  - have no voting activity (if there is, then it will need to be removed/consolidated
                ///    through `reap_vote` or `unvote`).
                ///
                ///- `to`: The account whose voting the `target` account's voting power will follow.
                ///- `conviction`: The conviction that will be attached to the delegated votes. When the
                ///  account is undelegated, the funds will be locked for the corresponding period.
                ///- `balance`: The amount of the account's balance to be used in delegating. This must not
                ///  be more than the account's current balance.
                ///
                ///Emits `Delegated`.
                ///
                ///Weight: `O(R)` where R is the number of referendums the voter delegating to has
                ///  voted on. Weight is charged as if maximum votes.
                pub fn delegate(
                    &self,
                    to: ::subxt::utils::MultiAddress<
                        ::subxt::utils::AccountId32,
                        ::core::primitive::u32,
                    >,
                    conviction: runtime_types::pallet_democracy::conviction::Conviction,
                    balance: ::core::primitive::u128,
                ) -> ::subxt::tx::Payload<types::Delegate> {
                    ::subxt::tx::Payload::new_static(
                        "Democracy",
                        "delegate",
                        types::Delegate {
                            to,
                            conviction,
                            balance,
                        },
                        [
                            252u8,
                            37u8,
                            255u8,
                            84u8,
                            153u8,
                            112u8,
                            84u8,
                            10u8,
                            131u8,
                            85u8,
                            6u8,
                            204u8,
                            85u8,
                            241u8,
                            104u8,
                            155u8,
                            219u8,
                            222u8,
                            30u8,
                            7u8,
                            245u8,
                            12u8,
                            101u8,
                            120u8,
                            9u8,
                            156u8,
                            65u8,
                            218u8,
                            110u8,
                            244u8,
                            24u8,
                            251u8,
                        ],
                    )
                }
                ///Undelegate the voting power of the sending account.
                ///
                ///Tokens may be unlocked following once an amount of time consistent with the lock period
                ///of the conviction with which the delegation was issued.
                ///
                ///The dispatch origin of this call must be _Signed_ and the signing account must be
                ///currently delegating.
                ///
                ///Emits `Undelegated`.
                ///
                ///Weight: `O(R)` where R is the number of referendums the voter delegating to has
                ///  voted on. Weight is charged as if maximum votes.
                pub fn undelegate(&self) -> ::subxt::tx::Payload<types::Undelegate> {
                    ::subxt::tx::Payload::new_static(
                        "Democracy",
                        "undelegate",
                        types::Undelegate {},
                        [
                            225u8,
                            156u8,
                            102u8,
                            1u8,
                            172u8,
                            145u8,
                            88u8,
                            12u8,
                            89u8,
                            32u8,
                            51u8,
                            83u8,
                            25u8,
                            149u8,
                            132u8,
                            203u8,
                            246u8,
                            98u8,
                            155u8,
                            36u8,
                            165u8,
                            206u8,
                            233u8,
                            169u8,
                            91u8,
                            85u8,
                            105u8,
                            67u8,
                            46u8,
                            134u8,
                            244u8,
                            250u8,
                        ],
                    )
                }
                ///Clears all public proposals.
                ///
                ///The dispatch origin of this call must be _Root_.
                ///
                ///Weight: `O(1)`.
                pub fn clear_public_proposals(
                    &self,
                ) -> ::subxt::tx::Payload<types::ClearPublicProposals> {
                    ::subxt::tx::Payload::new_static(
                        "Democracy",
                        "clear_public_proposals",
                        types::ClearPublicProposals {},
                        [
                            116u8,
                            160u8,
                            246u8,
                            216u8,
                            23u8,
                            188u8,
                            144u8,
                            63u8,
                            97u8,
                            198u8,
                            11u8,
                            243u8,
                            165u8,
                            84u8,
                            159u8,
                            153u8,
                            235u8,
                            169u8,
                            166u8,
                            15u8,
                            23u8,
                            116u8,
                            30u8,
                            56u8,
                            133u8,
                            31u8,
                            158u8,
                            114u8,
                            158u8,
                            86u8,
                            106u8,
                            93u8,
                        ],
                    )
                }
                ///Unlock tokens that have an expired lock.
                ///
                ///The dispatch origin of this call must be _Signed_.
                ///
                ///- `target`: The account to remove the lock on.
                ///
                ///Weight: `O(R)` with R number of vote of target.
                pub fn unlock(
                    &self,
                    target: ::subxt::utils::MultiAddress<
                        ::subxt::utils::AccountId32,
                        ::core::primitive::u32,
                    >,
                ) -> ::subxt::tx::Payload<types::Unlock> {
                    ::subxt::tx::Payload::new_static(
                        "Democracy",
                        "unlock",
                        types::Unlock { target },
                        [
                            134u8,
                            220u8,
                            108u8,
                            243u8,
                            205u8,
                            162u8,
                            111u8,
                            77u8,
                            224u8,
                            62u8,
                            27u8,
                            214u8,
                            97u8,
                            83u8,
                            212u8,
                            96u8,
                            68u8,
                            123u8,
                            160u8,
                            70u8,
                            127u8,
                            255u8,
                            94u8,
                            57u8,
                            224u8,
                            165u8,
                            250u8,
                            65u8,
                            13u8,
                            122u8,
                            101u8,
                            56u8,
                        ],
                    )
                }
                ///Remove a vote for a referendum.
                ///
                ///If:
                ///- the referendum was cancelled, or
                ///- the referendum is ongoing, or
                ///- the referendum has ended such that
                ///  - the vote of the account was in opposition to the result; or
                ///  - there was no conviction to the account's vote; or
                ///  - the account made a split vote
                ///...then the vote is removed cleanly and a following call to `unlock` may result in more
                ///funds being available.
                ///
                ///If, however, the referendum has ended and:
                ///- it finished corresponding to the vote of the account, and
                ///- the account made a standard vote with conviction, and
                ///- the lock period of the conviction is not over
                ///...then the lock will be aggregated into the overall account's lock, which may involve
                ///*overlocking* (where the two locks are combined into a single lock that is the maximum
                ///of both the amount locked and the time is it locked for).
                ///
                ///The dispatch origin of this call must be _Signed_, and the signer must have a vote
                ///registered for referendum `index`.
                ///
                ///- `index`: The index of referendum of the vote to be removed.
                ///
                ///Weight: `O(R + log R)` where R is the number of referenda that `target` has voted on.
                ///  Weight is calculated for the maximum number of vote.
                pub fn remove_vote(
                    &self,
                    index: ::core::primitive::u32,
                ) -> ::subxt::tx::Payload<types::RemoveVote> {
                    ::subxt::tx::Payload::new_static(
                        "Democracy",
                        "remove_vote",
                        types::RemoveVote { index },
                        [
                            98u8,
                            146u8,
                            215u8,
                            63u8,
                            222u8,
                            70u8,
                            61u8,
                            186u8,
                            90u8,
                            34u8,
                            63u8,
                            25u8,
                            195u8,
                            119u8,
                            228u8,
                            189u8,
                            38u8,
                            163u8,
                            58u8,
                            210u8,
                            216u8,
                            156u8,
                            20u8,
                            204u8,
                            136u8,
                            192u8,
                            33u8,
                            210u8,
                            124u8,
                            65u8,
                            153u8,
                            105u8,
                        ],
                    )
                }
                ///Remove a vote for a referendum.
                ///
                ///If the `target` is equal to the signer, then this function is exactly equivalent to
                ///`remove_vote`. If not equal to the signer, then the vote must have expired,
                ///either because the referendum was cancelled, because the voter lost the referendum or
                ///because the conviction period is over.
                ///
                ///The dispatch origin of this call must be _Signed_.
                ///
                ///- `target`: The account of the vote to be removed; this account must have voted for
                ///  referendum `index`.
                ///- `index`: The index of referendum of the vote to be removed.
                ///
                ///Weight: `O(R + log R)` where R is the number of referenda that `target` has voted on.
                ///  Weight is calculated for the maximum number of vote.
                pub fn remove_other_vote(
                    &self,
                    target: ::subxt::utils::MultiAddress<
                        ::subxt::utils::AccountId32,
                        ::core::primitive::u32,
                    >,
                    index: ::core::primitive::u32,
                ) -> ::subxt::tx::Payload<types::RemoveOtherVote> {
                    ::subxt::tx::Payload::new_static(
                        "Democracy",
                        "remove_other_vote",
                        types::RemoveOtherVote {
                            target,
                            index,
                        },
                        [
                            92u8,
                            152u8,
                            49u8,
                            134u8,
                            235u8,
                            186u8,
                            109u8,
                            234u8,
                            16u8,
                            129u8,
                            255u8,
                            88u8,
                            231u8,
                            177u8,
                            197u8,
                            125u8,
                            105u8,
                            228u8,
                            69u8,
                            38u8,
                            231u8,
                            178u8,
                            75u8,
                            197u8,
                            113u8,
                            213u8,
                            157u8,
                            5u8,
                            68u8,
                            75u8,
                            155u8,
                            47u8,
                        ],
                    )
                }
                ///Permanently place a proposal into the blacklist. This prevents it from ever being
                ///proposed again.
                ///
                ///If called on a queued public or external proposal, then this will result in it being
                ///removed. If the `ref_index` supplied is an active referendum with the proposal hash,
                ///then it will be cancelled.
                ///
                ///The dispatch origin of this call must be `BlacklistOrigin`.
                ///
                ///- `proposal_hash`: The proposal hash to blacklist permanently.
                ///- `ref_index`: An ongoing referendum whose hash is `proposal_hash`, which will be
                ///cancelled.
                ///
                ///Weight: `O(p)` (though as this is an high-privilege dispatch, we assume it has a
                ///  reasonable value).
                pub fn blacklist(
                    &self,
                    proposal_hash: ::subxt::utils::H256,
                    maybe_ref_index: ::core::option::Option<::core::primitive::u32>,
                ) -> ::subxt::tx::Payload<types::Blacklist> {
                    ::subxt::tx::Payload::new_static(
                        "Democracy",
                        "blacklist",
                        types::Blacklist {
                            proposal_hash,
                            maybe_ref_index,
                        },
                        [
                            227u8,
                            200u8,
                            88u8,
                            154u8,
                            134u8,
                            121u8,
                            131u8,
                            177u8,
                            94u8,
                            119u8,
                            12u8,
                            129u8,
                            150u8,
                            59u8,
                            108u8,
                            103u8,
                            109u8,
                            55u8,
                            220u8,
                            211u8,
                            250u8,
                            103u8,
                            160u8,
                            170u8,
                            63u8,
                            142u8,
                            112u8,
                            244u8,
                            29u8,
                            238u8,
                            101u8,
                            24u8,
                        ],
                    )
                }
                ///Remove a proposal.
                ///
                ///The dispatch origin of this call must be `CancelProposalOrigin`.
                ///
                ///- `prop_index`: The index of the proposal to cancel.
                ///
                ///Weight: `O(p)` where `p = PublicProps::<T>::decode_len()`
                pub fn cancel_proposal(
                    &self,
                    prop_index: ::core::primitive::u32,
                ) -> ::subxt::tx::Payload<types::CancelProposal> {
                    ::subxt::tx::Payload::new_static(
                        "Democracy",
                        "cancel_proposal",
                        types::CancelProposal {
                            prop_index,
                        },
                        [
                            213u8,
                            5u8,
                            215u8,
                            209u8,
                            71u8,
                            229u8,
                            66u8,
                            38u8,
                            171u8,
                            38u8,
                            14u8,
                            103u8,
                            248u8,
                            176u8,
                            217u8,
                            143u8,
                            234u8,
                            89u8,
                            110u8,
                            250u8,
                            3u8,
                            190u8,
                            151u8,
                            74u8,
                            55u8,
                            58u8,
                            249u8,
                            138u8,
                            25u8,
                            191u8,
                            55u8,
                            142u8,
                        ],
                    )
                }
                ///Set or clear a metadata of a proposal or a referendum.
                ///
                ///Parameters:
                ///- `origin`: Must correspond to the `MetadataOwner`.
                ///    - `ExternalOrigin` for an external proposal with the `SuperMajorityApprove`
                ///      threshold.
                ///    - `ExternalDefaultOrigin` for an external proposal with the `SuperMajorityAgainst`
                ///      threshold.
                ///    - `ExternalMajorityOrigin` for an external proposal with the `SimpleMajority`
                ///      threshold.
                ///    - `Signed` by a creator for a public proposal.
                ///    - `Signed` to clear a metadata for a finished referendum.
                ///    - `Root` to set a metadata for an ongoing referendum.
                ///- `owner`: an identifier of a metadata owner.
                ///- `maybe_hash`: The hash of an on-chain stored preimage. `None` to clear a metadata.
                pub fn set_metadata(
                    &self,
                    owner: runtime_types::pallet_democracy::types::MetadataOwner,
                    maybe_hash: ::core::option::Option<::subxt::utils::H256>,
                ) -> ::subxt::tx::Payload<types::SetMetadata> {
                    ::subxt::tx::Payload::new_static(
                        "Democracy",
                        "set_metadata",
                        types::SetMetadata {
                            owner,
                            maybe_hash,
                        },
                        [
                            192u8,
                            174u8,
                            122u8,
                            229u8,
                            149u8,
                            49u8,
                            155u8,
                            209u8,
                            226u8,
                            255u8,
                            46u8,
                            43u8,
                            77u8,
                            164u8,
                            226u8,
                            254u8,
                            207u8,
                            110u8,
                            222u8,
                            131u8,
                            220u8,
                            53u8,
                            95u8,
                            170u8,
                            128u8,
                            212u8,
                            236u8,
                            168u8,
                            156u8,
                            29u8,
                            151u8,
                            40u8,
                        ],
                    )
                }
            }
        }
        /**
			The [event](https://docs.substrate.io/main-docs/build/events-errors/) emitted
			by this pallet.
			*/
        pub type Event = runtime_types::pallet_democracy::pallet::Event;
        pub mod events {
            use super::runtime_types;
            #[derive(
                ::subxt::ext::codec::Decode,
                ::subxt::ext::codec::Encode,
                ::subxt::ext::scale_decode::DecodeAsType,
                ::subxt::ext::scale_encode::EncodeAsType,
                Clone,
                Debug,
                Eq,
                PartialEq
            )]
            #[codec(crate = ::subxt::ext::codec)]
            #[decode_as_type(crate_path = ":: subxt :: ext :: scale_decode")]
            #[encode_as_type(crate_path = ":: subxt :: ext :: scale_encode")]
            ///A motion has been proposed by a public account.
            pub struct Proposed {
                pub proposal_index: ::core::primitive::u32,
                pub deposit: ::core::primitive::u128,
            }
            impl ::subxt::events::StaticEvent for Proposed {
                const PALLET: &'static str = "Democracy";
                const EVENT: &'static str = "Proposed";
            }
            #[derive(
                ::subxt::ext::codec::Decode,
                ::subxt::ext::codec::Encode,
                ::subxt::ext::scale_decode::DecodeAsType,
                ::subxt::ext::scale_encode::EncodeAsType,
                Clone,
                Debug,
                Eq,
                PartialEq
            )]
            #[codec(crate = ::subxt::ext::codec)]
            #[decode_as_type(crate_path = ":: subxt :: ext :: scale_decode")]
            #[encode_as_type(crate_path = ":: subxt :: ext :: scale_encode")]
            ///A public proposal has been tabled for referendum vote.
            pub struct Tabled {
                pub proposal_index: ::core::primitive::u32,
                pub deposit: ::core::primitive::u128,
            }
            impl ::subxt::events::StaticEvent for Tabled {
                const PALLET: &'static str = "Democracy";
                const EVENT: &'static str = "Tabled";
            }
            #[derive(
                ::subxt::ext::codec::Decode,
                ::subxt::ext::codec::Encode,
                ::subxt::ext::scale_decode::DecodeAsType,
                ::subxt::ext::scale_encode::EncodeAsType,
                Clone,
                Debug,
                Eq,
                PartialEq
            )]
            #[codec(crate = ::subxt::ext::codec)]
            #[decode_as_type(crate_path = ":: subxt :: ext :: scale_decode")]
            #[encode_as_type(crate_path = ":: subxt :: ext :: scale_encode")]
            ///An external proposal has been tabled.
            pub struct ExternalTabled;
            impl ::subxt::events::StaticEvent for ExternalTabled {
                const PALLET: &'static str = "Democracy";
                const EVENT: &'static str = "ExternalTabled";
            }
            #[derive(
                ::subxt::ext::codec::Decode,
                ::subxt::ext::codec::Encode,
                ::subxt::ext::scale_decode::DecodeAsType,
                ::subxt::ext::scale_encode::EncodeAsType,
                Clone,
                Debug,
                Eq,
                PartialEq
            )]
            #[codec(crate = ::subxt::ext::codec)]
            #[decode_as_type(crate_path = ":: subxt :: ext :: scale_decode")]
            #[encode_as_type(crate_path = ":: subxt :: ext :: scale_encode")]
            ///A referendum has begun.
            pub struct Started {
                pub ref_index: ::core::primitive::u32,
                pub threshold: runtime_types::pallet_democracy::vote_threshold::VoteThreshold,
            }
            impl ::subxt::events::StaticEvent for Started {
                const PALLET: &'static str = "Democracy";
                const EVENT: &'static str = "Started";
            }
            #[derive(
                ::subxt::ext::codec::CompactAs,
                ::subxt::ext::codec::Decode,
                ::subxt::ext::codec::Encode,
                ::subxt::ext::scale_decode::DecodeAsType,
                ::subxt::ext::scale_encode::EncodeAsType,
                Clone,
                Debug,
                Eq,
                PartialEq
            )]
            #[codec(crate = ::subxt::ext::codec)]
            #[decode_as_type(crate_path = ":: subxt :: ext :: scale_decode")]
            #[encode_as_type(crate_path = ":: subxt :: ext :: scale_encode")]
            ///A proposal has been approved by referendum.
            pub struct Passed {
                pub ref_index: ::core::primitive::u32,
            }
            impl ::subxt::events::StaticEvent for Passed {
                const PALLET: &'static str = "Democracy";
                const EVENT: &'static str = "Passed";
            }
            #[derive(
                ::subxt::ext::codec::CompactAs,
                ::subxt::ext::codec::Decode,
                ::subxt::ext::codec::Encode,
                ::subxt::ext::scale_decode::DecodeAsType,
                ::subxt::ext::scale_encode::EncodeAsType,
                Clone,
                Debug,
                Eq,
                PartialEq
            )]
            #[codec(crate = ::subxt::ext::codec)]
            #[decode_as_type(crate_path = ":: subxt :: ext :: scale_decode")]
            #[encode_as_type(crate_path = ":: subxt :: ext :: scale_encode")]
            ///A proposal has been rejected by referendum.
            pub struct NotPassed {
                pub ref_index: ::core::primitive::u32,
            }
            impl ::subxt::events::StaticEvent for NotPassed {
                const PALLET: &'static str = "Democracy";
                const EVENT: &'static str = "NotPassed";
            }
            #[derive(
                ::subxt::ext::codec::CompactAs,
                ::subxt::ext::codec::Decode,
                ::subxt::ext::codec::Encode,
                ::subxt::ext::scale_decode::DecodeAsType,
                ::subxt::ext::scale_encode::EncodeAsType,
                Clone,
                Debug,
                Eq,
                PartialEq
            )]
            #[codec(crate = ::subxt::ext::codec)]
            #[decode_as_type(crate_path = ":: subxt :: ext :: scale_decode")]
            #[encode_as_type(crate_path = ":: subxt :: ext :: scale_encode")]
            ///A referendum has been cancelled.
            pub struct Cancelled {
                pub ref_index: ::core::primitive::u32,
            }
            impl ::subxt::events::StaticEvent for Cancelled {
                const PALLET: &'static str = "Democracy";
                const EVENT: &'static str = "Cancelled";
            }
            #[derive(
                ::subxt::ext::codec::Decode,
                ::subxt::ext::codec::Encode,
                ::subxt::ext::scale_decode::DecodeAsType,
                ::subxt::ext::scale_encode::EncodeAsType,
                Clone,
                Debug,
                Eq,
                PartialEq
            )]
            #[codec(crate = ::subxt::ext::codec)]
            #[decode_as_type(crate_path = ":: subxt :: ext :: scale_decode")]
            #[encode_as_type(crate_path = ":: subxt :: ext :: scale_encode")]
            ///An account has delegated their vote to another account.
            pub struct Delegated {
                pub who: ::subxt::utils::AccountId32,
                pub target: ::subxt::utils::AccountId32,
            }
            impl ::subxt::events::StaticEvent for Delegated {
                const PALLET: &'static str = "Democracy";
                const EVENT: &'static str = "Delegated";
            }
            #[derive(
                ::subxt::ext::codec::Decode,
                ::subxt::ext::codec::Encode,
                ::subxt::ext::scale_decode::DecodeAsType,
                ::subxt::ext::scale_encode::EncodeAsType,
                Clone,
                Debug,
                Eq,
                PartialEq
            )]
            #[codec(crate = ::subxt::ext::codec)]
            #[decode_as_type(crate_path = ":: subxt :: ext :: scale_decode")]
            #[encode_as_type(crate_path = ":: subxt :: ext :: scale_encode")]
            ///An account has cancelled a previous delegation operation.
            pub struct Undelegated {
                pub account: ::subxt::utils::AccountId32,
            }
            impl ::subxt::events::StaticEvent for Undelegated {
                const PALLET: &'static str = "Democracy";
                const EVENT: &'static str = "Undelegated";
            }
            #[derive(
                ::subxt::ext::codec::Decode,
                ::subxt::ext::codec::Encode,
                ::subxt::ext::scale_decode::DecodeAsType,
                ::subxt::ext::scale_encode::EncodeAsType,
                Clone,
                Debug,
                Eq,
                PartialEq
            )]
            #[codec(crate = ::subxt::ext::codec)]
            #[decode_as_type(crate_path = ":: subxt :: ext :: scale_decode")]
            #[encode_as_type(crate_path = ":: subxt :: ext :: scale_encode")]
            ///An external proposal has been vetoed.
            pub struct Vetoed {
                pub who: ::subxt::utils::AccountId32,
                pub proposal_hash: ::subxt::utils::H256,
                pub until: ::core::primitive::u32,
            }
            impl ::subxt::events::StaticEvent for Vetoed {
                const PALLET: &'static str = "Democracy";
                const EVENT: &'static str = "Vetoed";
            }
            #[derive(
                ::subxt::ext::codec::Decode,
                ::subxt::ext::codec::Encode,
                ::subxt::ext::scale_decode::DecodeAsType,
                ::subxt::ext::scale_encode::EncodeAsType,
                Clone,
                Debug,
                Eq,
                PartialEq
            )]
            #[codec(crate = ::subxt::ext::codec)]
            #[decode_as_type(crate_path = ":: subxt :: ext :: scale_decode")]
            #[encode_as_type(crate_path = ":: subxt :: ext :: scale_encode")]
            ///A proposal_hash has been blacklisted permanently.
            pub struct Blacklisted {
                pub proposal_hash: ::subxt::utils::H256,
            }
            impl ::subxt::events::StaticEvent for Blacklisted {
                const PALLET: &'static str = "Democracy";
                const EVENT: &'static str = "Blacklisted";
            }
            #[derive(
                ::subxt::ext::codec::Decode,
                ::subxt::ext::codec::Encode,
                ::subxt::ext::scale_decode::DecodeAsType,
                ::subxt::ext::scale_encode::EncodeAsType,
                Clone,
                Debug,
                Eq,
                PartialEq
            )]
            #[codec(crate = ::subxt::ext::codec)]
            #[decode_as_type(crate_path = ":: subxt :: ext :: scale_decode")]
            #[encode_as_type(crate_path = ":: subxt :: ext :: scale_encode")]
            ///An account has voted in a referendum
            pub struct Voted {
                pub voter: ::subxt::utils::AccountId32,
                pub ref_index: ::core::primitive::u32,
                pub vote: runtime_types::pallet_democracy::vote::AccountVote<
                    ::core::primitive::u128,
                >,
            }
            impl ::subxt::events::StaticEvent for Voted {
                const PALLET: &'static str = "Democracy";
                const EVENT: &'static str = "Voted";
            }
            #[derive(
                ::subxt::ext::codec::Decode,
                ::subxt::ext::codec::Encode,
                ::subxt::ext::scale_decode::DecodeAsType,
                ::subxt::ext::scale_encode::EncodeAsType,
                Clone,
                Debug,
                Eq,
                PartialEq
            )]
            #[codec(crate = ::subxt::ext::codec)]
            #[decode_as_type(crate_path = ":: subxt :: ext :: scale_decode")]
            #[encode_as_type(crate_path = ":: subxt :: ext :: scale_encode")]
            ///An account has secconded a proposal
            pub struct Seconded {
                pub seconder: ::subxt::utils::AccountId32,
                pub prop_index: ::core::primitive::u32,
            }
            impl ::subxt::events::StaticEvent for Seconded {
                const PALLET: &'static str = "Democracy";
                const EVENT: &'static str = "Seconded";
            }
            #[derive(
                ::subxt::ext::codec::CompactAs,
                ::subxt::ext::codec::Decode,
                ::subxt::ext::codec::Encode,
                ::subxt::ext::scale_decode::DecodeAsType,
                ::subxt::ext::scale_encode::EncodeAsType,
                Clone,
                Debug,
                Eq,
                PartialEq
            )]
            #[codec(crate = ::subxt::ext::codec)]
            #[decode_as_type(crate_path = ":: subxt :: ext :: scale_decode")]
            #[encode_as_type(crate_path = ":: subxt :: ext :: scale_encode")]
            ///A proposal got canceled.
            pub struct ProposalCanceled {
                pub prop_index: ::core::primitive::u32,
            }
            impl ::subxt::events::StaticEvent for ProposalCanceled {
                const PALLET: &'static str = "Democracy";
                const EVENT: &'static str = "ProposalCanceled";
            }
            #[derive(
                ::subxt::ext::codec::Decode,
                ::subxt::ext::codec::Encode,
                ::subxt::ext::scale_decode::DecodeAsType,
                ::subxt::ext::scale_encode::EncodeAsType,
                Clone,
                Debug,
                Eq,
                PartialEq
            )]
            #[codec(crate = ::subxt::ext::codec)]
            #[decode_as_type(crate_path = ":: subxt :: ext :: scale_decode")]
            #[encode_as_type(crate_path = ":: subxt :: ext :: scale_encode")]
            ///Metadata for a proposal or a referendum has been set.
            pub struct MetadataSet {
                pub owner: runtime_types::pallet_democracy::types::MetadataOwner,
                pub hash: ::subxt::utils::H256,
            }
            impl ::subxt::events::StaticEvent for MetadataSet {
                const PALLET: &'static str = "Democracy";
                const EVENT: &'static str = "MetadataSet";
            }
            #[derive(
                ::subxt::ext::codec::Decode,
                ::subxt::ext::codec::Encode,
                ::subxt::ext::scale_decode::DecodeAsType,
                ::subxt::ext::scale_encode::EncodeAsType,
                Clone,
                Debug,
                Eq,
                PartialEq
            )]
            #[codec(crate = ::subxt::ext::codec)]
            #[decode_as_type(crate_path = ":: subxt :: ext :: scale_decode")]
            #[encode_as_type(crate_path = ":: subxt :: ext :: scale_encode")]
            ///Metadata for a proposal or a referendum has been cleared.
            pub struct MetadataCleared {
                pub owner: runtime_types::pallet_democracy::types::MetadataOwner,
                pub hash: ::subxt::utils::H256,
            }
            impl ::subxt::events::StaticEvent for MetadataCleared {
                const PALLET: &'static str = "Democracy";
                const EVENT: &'static str = "MetadataCleared";
            }
            #[derive(
                ::subxt::ext::codec::Decode,
                ::subxt::ext::codec::Encode,
                ::subxt::ext::scale_decode::DecodeAsType,
                ::subxt::ext::scale_encode::EncodeAsType,
                Clone,
                Debug,
                Eq,
                PartialEq
            )]
            #[codec(crate = ::subxt::ext::codec)]
            #[decode_as_type(crate_path = ":: subxt :: ext :: scale_decode")]
            #[encode_as_type(crate_path = ":: subxt :: ext :: scale_encode")]
            ///Metadata has been transferred to new owner.
            pub struct MetadataTransferred {
                pub prev_owner: runtime_types::pallet_democracy::types::MetadataOwner,
                pub owner: runtime_types::pallet_democracy::types::MetadataOwner,
                pub hash: ::subxt::utils::H256,
            }
            impl ::subxt::events::StaticEvent for MetadataTransferred {
                const PALLET: &'static str = "Democracy";
                const EVENT: &'static str = "MetadataTransferred";
            }
        }
        pub mod storage {
            use super::runtime_types;
            pub struct StorageApi;
            impl StorageApi {
                /// The number of (public) proposals that have been made so far.
                pub fn public_prop_count(
                    &self,
                ) -> ::subxt::storage::address::Address<
                    ::subxt::storage::address::StaticStorageMapKey,
                    ::core::primitive::u32,
                    ::subxt::storage::address::Yes,
                    ::subxt::storage::address::Yes,
                    (),
                > {
                    ::subxt::storage::address::Address::new_static(
                        "Democracy",
                        "PublicPropCount",
                        vec![],
                        [
                            51u8,
                            175u8,
                            184u8,
                            94u8,
                            91u8,
                            212u8,
                            100u8,
                            108u8,
                            127u8,
                            162u8,
                            233u8,
                            137u8,
                            12u8,
                            209u8,
                            29u8,
                            130u8,
                            125u8,
                            179u8,
                            208u8,
                            160u8,
                            173u8,
                            149u8,
                            12u8,
                            111u8,
                            1u8,
                            82u8,
                            196u8,
                            137u8,
                            51u8,
                            204u8,
                            153u8,
                            198u8,
                        ],
                    )
                }
                /// The public proposals. Unsorted. The second item is the proposal.
                pub fn public_props(
                    &self,
                ) -> ::subxt::storage::address::Address<
                    ::subxt::storage::address::StaticStorageMapKey,
                    runtime_types::bounded_collections::bounded_vec::BoundedVec<
                        (
                            ::core::primitive::u32,
                            runtime_types::frame_support::traits::preimages::Bounded<
                                runtime_types::tangle_standalone_runtime::RuntimeCall,
                            >,
                            ::subxt::utils::AccountId32,
                        ),
                    >,
                    ::subxt::storage::address::Yes,
                    ::subxt::storage::address::Yes,
                    (),
                > {
                    ::subxt::storage::address::Address::new_static(
                        "Democracy",
                        "PublicProps",
                        vec![],
                        [
                            156u8,
                            21u8,
                            84u8,
                            229u8,
                            193u8,
                            34u8,
                            28u8,
                            230u8,
                            11u8,
                            108u8,
                            2u8,
                            84u8,
                            188u8,
                            11u8,
                            25u8,
                            55u8,
                            130u8,
                            80u8,
                            164u8,
                            239u8,
                            150u8,
                            77u8,
                            4u8,
                            246u8,
                            174u8,
                            16u8,
                            232u8,
                            23u8,
                            9u8,
                            194u8,
                            177u8,
                            73u8,
                        ],
                    )
                }
                /// Those who have locked a deposit.
                ///
                /// TWOX-NOTE: Safe, as increasing integer keys are safe.
                pub fn deposit_of(
                    &self,
                    _0: impl ::std::borrow::Borrow<::core::primitive::u32>,
                ) -> ::subxt::storage::address::Address<
                    ::subxt::storage::address::StaticStorageMapKey,
                    (
                        runtime_types::bounded_collections::bounded_vec::BoundedVec<
                            ::subxt::utils::AccountId32,
                        >,
                        ::core::primitive::u128,
                    ),
                    ::subxt::storage::address::Yes,
                    (),
                    ::subxt::storage::address::Yes,
                > {
                    ::subxt::storage::address::Address::new_static(
                        "Democracy",
                        "DepositOf",
                        vec![
                            ::subxt::storage::address::make_static_storage_map_key(_0
                            .borrow())
                        ],
                        [
                            115u8,
                            12u8,
                            250u8,
                            191u8,
                            201u8,
                            165u8,
                            90u8,
                            140u8,
                            101u8,
                            47u8,
                            46u8,
                            3u8,
                            78u8,
                            30u8,
                            180u8,
                            22u8,
                            28u8,
                            154u8,
                            36u8,
                            99u8,
                            255u8,
                            84u8,
                            33u8,
                            21u8,
                            65u8,
                            110u8,
                            52u8,
                            245u8,
                            19u8,
                            6u8,
                            104u8,
                            167u8,
                        ],
                    )
                }
                /// Those who have locked a deposit.
                ///
                /// TWOX-NOTE: Safe, as increasing integer keys are safe.
                pub fn deposit_of_root(
                    &self,
                ) -> ::subxt::storage::address::Address<
                    ::subxt::storage::address::StaticStorageMapKey,
                    (
                        runtime_types::bounded_collections::bounded_vec::BoundedVec<
                            ::subxt::utils::AccountId32,
                        >,
                        ::core::primitive::u128,
                    ),
                    (),
                    (),
                    ::subxt::storage::address::Yes,
                > {
                    ::subxt::storage::address::Address::new_static(
                        "Democracy",
                        "DepositOf",
                        Vec::new(),
                        [
                            115u8,
                            12u8,
                            250u8,
                            191u8,
                            201u8,
                            165u8,
                            90u8,
                            140u8,
                            101u8,
                            47u8,
                            46u8,
                            3u8,
                            78u8,
                            30u8,
                            180u8,
                            22u8,
                            28u8,
                            154u8,
                            36u8,
                            99u8,
                            255u8,
                            84u8,
                            33u8,
                            21u8,
                            65u8,
                            110u8,
                            52u8,
                            245u8,
                            19u8,
                            6u8,
                            104u8,
                            167u8,
                        ],
                    )
                }
                /// The next free referendum index, aka the number of referenda started so far.
                pub fn referendum_count(
                    &self,
                ) -> ::subxt::storage::address::Address<
                    ::subxt::storage::address::StaticStorageMapKey,
                    ::core::primitive::u32,
                    ::subxt::storage::address::Yes,
                    ::subxt::storage::address::Yes,
                    (),
                > {
                    ::subxt::storage::address::Address::new_static(
                        "Democracy",
                        "ReferendumCount",
                        vec![],
                        [
                            64u8,
                            145u8,
                            232u8,
                            153u8,
                            121u8,
                            87u8,
                            128u8,
                            253u8,
                            170u8,
                            192u8,
                            139u8,
                            18u8,
                            0u8,
                            33u8,
                            243u8,
                            11u8,
                            238u8,
                            222u8,
                            244u8,
                            5u8,
                            247u8,
                            198u8,
                            149u8,
                            31u8,
                            122u8,
                            208u8,
                            86u8,
                            179u8,
                            166u8,
                            167u8,
                            93u8,
                            67u8,
                        ],
                    )
                }
                /// The lowest referendum index representing an unbaked referendum. Equal to
                /// `ReferendumCount` if there isn't a unbaked referendum.
                pub fn lowest_unbaked(
                    &self,
                ) -> ::subxt::storage::address::Address<
                    ::subxt::storage::address::StaticStorageMapKey,
                    ::core::primitive::u32,
                    ::subxt::storage::address::Yes,
                    ::subxt::storage::address::Yes,
                    (),
                > {
                    ::subxt::storage::address::Address::new_static(
                        "Democracy",
                        "LowestUnbaked",
                        vec![],
                        [
                            237u8,
                            222u8,
                            144u8,
                            214u8,
                            0u8,
                            186u8,
                            81u8,
                            176u8,
                            51u8,
                            14u8,
                            204u8,
                            184u8,
                            147u8,
                            97u8,
                            187u8,
                            84u8,
                            40u8,
                            8u8,
                            86u8,
                            241u8,
                            16u8,
                            157u8,
                            202u8,
                            44u8,
                            185u8,
                            111u8,
                            70u8,
                            114u8,
                            40u8,
                            135u8,
                            1u8,
                            155u8,
                        ],
                    )
                }
                /// Information concerning any given referendum.
                ///
                /// TWOX-NOTE: SAFE as indexes are not under an attackers control.
                pub fn referendum_info_of(
                    &self,
                    _0: impl ::std::borrow::Borrow<::core::primitive::u32>,
                ) -> ::subxt::storage::address::Address<
                    ::subxt::storage::address::StaticStorageMapKey,
                    runtime_types::pallet_democracy::types::ReferendumInfo<
                        ::core::primitive::u32,
                        runtime_types::frame_support::traits::preimages::Bounded<
                            runtime_types::tangle_standalone_runtime::RuntimeCall,
                        >,
                        ::core::primitive::u128,
                    >,
                    ::subxt::storage::address::Yes,
                    (),
                    ::subxt::storage::address::Yes,
                > {
                    ::subxt::storage::address::Address::new_static(
                        "Democracy",
                        "ReferendumInfoOf",
                        vec![
                            ::subxt::storage::address::make_static_storage_map_key(_0
                            .borrow())
                        ],
                        [
                            250u8,
                            201u8,
                            144u8,
                            220u8,
                            13u8,
                            14u8,
                            69u8,
                            171u8,
                            240u8,
                            119u8,
                            158u8,
                            200u8,
                            86u8,
                            77u8,
                            115u8,
                            156u8,
                            156u8,
                            101u8,
                            215u8,
                            233u8,
                            165u8,
                            96u8,
                            62u8,
                            201u8,
                            83u8,
                            203u8,
                            58u8,
                            67u8,
                            49u8,
                            174u8,
                            86u8,
                            242u8,
                        ],
                    )
                }
                /// Information concerning any given referendum.
                ///
                /// TWOX-NOTE: SAFE as indexes are not under an attackers control.
                pub fn referendum_info_of_root(
                    &self,
                ) -> ::subxt::storage::address::Address<
                    ::subxt::storage::address::StaticStorageMapKey,
                    runtime_types::pallet_democracy::types::ReferendumInfo<
                        ::core::primitive::u32,
                        runtime_types::frame_support::traits::preimages::Bounded<
                            runtime_types::tangle_standalone_runtime::RuntimeCall,
                        >,
                        ::core::primitive::u128,
                    >,
                    (),
                    (),
                    ::subxt::storage::address::Yes,
                > {
                    ::subxt::storage::address::Address::new_static(
                        "Democracy",
                        "ReferendumInfoOf",
                        Vec::new(),
                        [
                            250u8,
                            201u8,
                            144u8,
                            220u8,
                            13u8,
                            14u8,
                            69u8,
                            171u8,
                            240u8,
                            119u8,
                            158u8,
                            200u8,
                            86u8,
                            77u8,
                            115u8,
                            156u8,
                            156u8,
                            101u8,
                            215u8,
                            233u8,
                            165u8,
                            96u8,
                            62u8,
                            201u8,
                            83u8,
                            203u8,
                            58u8,
                            67u8,
                            49u8,
                            174u8,
                            86u8,
                            242u8,
                        ],
                    )
                }
                /// All votes for a particular voter. We store the balance for the number of votes that we
                /// have recorded. The second item is the total amount of delegations, that will be added.
                ///
                /// TWOX-NOTE: SAFE as `AccountId`s are crypto hashes anyway.
                pub fn voting_of(
                    &self,
                    _0: impl ::std::borrow::Borrow<::subxt::utils::AccountId32>,
                ) -> ::subxt::storage::address::Address<
                    ::subxt::storage::address::StaticStorageMapKey,
                    runtime_types::pallet_democracy::vote::Voting<
                        ::core::primitive::u128,
                        ::subxt::utils::AccountId32,
                        ::core::primitive::u32,
                    >,
                    ::subxt::storage::address::Yes,
                    ::subxt::storage::address::Yes,
                    ::subxt::storage::address::Yes,
                > {
                    ::subxt::storage::address::Address::new_static(
                        "Democracy",
                        "VotingOf",
                        vec![
                            ::subxt::storage::address::make_static_storage_map_key(_0
                            .borrow())
                        ],
                        [
                            170u8,
                            234u8,
                            179u8,
                            190u8,
                            153u8,
                            172u8,
                            83u8,
                            105u8,
                            57u8,
                            88u8,
                            183u8,
                            54u8,
                            172u8,
                            149u8,
                            222u8,
                            240u8,
                            128u8,
                            46u8,
                            25u8,
                            10u8,
                            205u8,
                            69u8,
                            164u8,
                            173u8,
                            55u8,
                            188u8,
                            196u8,
                            51u8,
                            129u8,
                            206u8,
                            87u8,
                            249u8,
                        ],
                    )
                }
                /// All votes for a particular voter. We store the balance for the number of votes that we
                /// have recorded. The second item is the total amount of delegations, that will be added.
                ///
                /// TWOX-NOTE: SAFE as `AccountId`s are crypto hashes anyway.
                pub fn voting_of_root(
                    &self,
                ) -> ::subxt::storage::address::Address<
                    ::subxt::storage::address::StaticStorageMapKey,
                    runtime_types::pallet_democracy::vote::Voting<
                        ::core::primitive::u128,
                        ::subxt::utils::AccountId32,
                        ::core::primitive::u32,
                    >,
                    (),
                    ::subxt::storage::address::Yes,
                    ::subxt::storage::address::Yes,
                > {
                    ::subxt::storage::address::Address::new_static(
                        "Democracy",
                        "VotingOf",
                        Vec::new(),
                        [
                            170u8,
                            234u8,
                            179u8,
                            190u8,
                            153u8,
                            172u8,
                            83u8,
                            105u8,
                            57u8,
                            88u8,
                            183u8,
                            54u8,
                            172u8,
                            149u8,
                            222u8,
                            240u8,
                            128u8,
                            46u8,
                            25u8,
                            10u8,
                            205u8,
                            69u8,
                            164u8,
                            173u8,
                            55u8,
                            188u8,
                            196u8,
                            51u8,
                            129u8,
                            206u8,
                            87u8,
                            249u8,
                        ],
                    )
                }
                /// True if the last referendum tabled was submitted externally. False if it was a public
                /// proposal.
                pub fn last_tabled_was_external(
                    &self,
                ) -> ::subxt::storage::address::Address<
                    ::subxt::storage::address::StaticStorageMapKey,
                    ::core::primitive::bool,
                    ::subxt::storage::address::Yes,
                    ::subxt::storage::address::Yes,
                    (),
                > {
                    ::subxt::storage::address::Address::new_static(
                        "Democracy",
                        "LastTabledWasExternal",
                        vec![],
                        [
                            162u8,
                            201u8,
                            72u8,
                            9u8,
                            78u8,
                            49u8,
                            72u8,
                            62u8,
                            240u8,
                            69u8,
                            20u8,
                            135u8,
                            26u8,
                            59u8,
                            71u8,
                            46u8,
                            19u8,
                            25u8,
                            195u8,
                            11u8,
                            99u8,
                            31u8,
                            104u8,
                            4u8,
                            24u8,
                            129u8,
                            47u8,
                            69u8,
                            219u8,
                            178u8,
                            104u8,
                            190u8,
                        ],
                    )
                }
                /// The referendum to be tabled whenever it would be valid to table an external proposal.
                /// This happens when a referendum needs to be tabled and one of two conditions are met:
                /// - `LastTabledWasExternal` is `false`; or
                /// - `PublicProps` is empty.
                pub fn next_external(
                    &self,
                ) -> ::subxt::storage::address::Address<
                    ::subxt::storage::address::StaticStorageMapKey,
                    (
                        runtime_types::frame_support::traits::preimages::Bounded<
                            runtime_types::tangle_standalone_runtime::RuntimeCall,
                        >,
                        runtime_types::pallet_democracy::vote_threshold::VoteThreshold,
                    ),
                    ::subxt::storage::address::Yes,
                    (),
                    (),
                > {
                    ::subxt::storage::address::Address::new_static(
                        "Democracy",
                        "NextExternal",
                        vec![],
                        [
                            130u8,
                            253u8,
                            139u8,
                            228u8,
                            253u8,
                            181u8,
                            172u8,
                            14u8,
                            214u8,
                            128u8,
                            17u8,
                            195u8,
                            104u8,
                            64u8,
                            64u8,
                            132u8,
                            40u8,
                            212u8,
                            80u8,
                            47u8,
                            225u8,
                            224u8,
                            9u8,
                            186u8,
                            80u8,
                            118u8,
                            120u8,
                            174u8,
                            174u8,
                            20u8,
                            150u8,
                            13u8,
                        ],
                    )
                }
                /// A record of who vetoed what. Maps proposal hash to a possible existent block number
                /// (until when it may not be resubmitted) and who vetoed it.
                pub fn blacklist(
                    &self,
                    _0: impl ::std::borrow::Borrow<::subxt::utils::H256>,
                ) -> ::subxt::storage::address::Address<
                    ::subxt::storage::address::StaticStorageMapKey,
                    (
                        ::core::primitive::u32,
                        runtime_types::bounded_collections::bounded_vec::BoundedVec<
                            ::subxt::utils::AccountId32,
                        >,
                    ),
                    ::subxt::storage::address::Yes,
                    (),
                    ::subxt::storage::address::Yes,
                > {
                    ::subxt::storage::address::Address::new_static(
                        "Democracy",
                        "Blacklist",
                        vec![
                            ::subxt::storage::address::make_static_storage_map_key(_0
                            .borrow())
                        ],
                        [
                            238u8,
                            119u8,
                            98u8,
                            220u8,
                            11u8,
                            209u8,
                            90u8,
                            9u8,
                            69u8,
                            51u8,
                            59u8,
                            177u8,
                            169u8,
                            113u8,
                            138u8,
                            13u8,
                            134u8,
                            14u8,
                            184u8,
                            6u8,
                            80u8,
                            182u8,
                            154u8,
                            10u8,
                            100u8,
                            71u8,
                            117u8,
                            2u8,
                            150u8,
                            170u8,
                            154u8,
                            255u8,
                        ],
                    )
                }
                /// A record of who vetoed what. Maps proposal hash to a possible existent block number
                /// (until when it may not be resubmitted) and who vetoed it.
                pub fn blacklist_root(
                    &self,
                ) -> ::subxt::storage::address::Address<
                    ::subxt::storage::address::StaticStorageMapKey,
                    (
                        ::core::primitive::u32,
                        runtime_types::bounded_collections::bounded_vec::BoundedVec<
                            ::subxt::utils::AccountId32,
                        >,
                    ),
                    (),
                    (),
                    ::subxt::storage::address::Yes,
                > {
                    ::subxt::storage::address::Address::new_static(
                        "Democracy",
                        "Blacklist",
                        Vec::new(),
                        [
                            238u8,
                            119u8,
                            98u8,
                            220u8,
                            11u8,
                            209u8,
                            90u8,
                            9u8,
                            69u8,
                            51u8,
                            59u8,
                            177u8,
                            169u8,
                            113u8,
                            138u8,
                            13u8,
                            134u8,
                            14u8,
                            184u8,
                            6u8,
                            80u8,
                            182u8,
                            154u8,
                            10u8,
                            100u8,
                            71u8,
                            117u8,
                            2u8,
                            150u8,
                            170u8,
                            154u8,
                            255u8,
                        ],
                    )
                }
                /// Record of all proposals that have been subject to emergency cancellation.
                pub fn cancellations(
                    &self,
                    _0: impl ::std::borrow::Borrow<::subxt::utils::H256>,
                ) -> ::subxt::storage::address::Address<
                    ::subxt::storage::address::StaticStorageMapKey,
                    ::core::primitive::bool,
                    ::subxt::storage::address::Yes,
                    ::subxt::storage::address::Yes,
                    ::subxt::storage::address::Yes,
                > {
                    ::subxt::storage::address::Address::new_static(
                        "Democracy",
                        "Cancellations",
                        vec![
                            ::subxt::storage::address::make_static_storage_map_key(_0
                            .borrow())
                        ],
                        [
                            80u8,
                            190u8,
                            98u8,
                            105u8,
                            129u8,
                            25u8,
                            167u8,
                            180u8,
                            74u8,
                            128u8,
                            232u8,
                            29u8,
                            193u8,
                            209u8,
                            185u8,
                            60u8,
                            18u8,
                            180u8,
                            59u8,
                            192u8,
                            149u8,
                            13u8,
                            123u8,
                            232u8,
                            34u8,
                            208u8,
                            48u8,
                            104u8,
                            35u8,
                            181u8,
                            186u8,
                            244u8,
                        ],
                    )
                }
                /// Record of all proposals that have been subject to emergency cancellation.
                pub fn cancellations_root(
                    &self,
                ) -> ::subxt::storage::address::Address<
                    ::subxt::storage::address::StaticStorageMapKey,
                    ::core::primitive::bool,
                    (),
                    ::subxt::storage::address::Yes,
                    ::subxt::storage::address::Yes,
                > {
                    ::subxt::storage::address::Address::new_static(
                        "Democracy",
                        "Cancellations",
                        Vec::new(),
                        [
                            80u8,
                            190u8,
                            98u8,
                            105u8,
                            129u8,
                            25u8,
                            167u8,
                            180u8,
                            74u8,
                            128u8,
                            232u8,
                            29u8,
                            193u8,
                            209u8,
                            185u8,
                            60u8,
                            18u8,
                            180u8,
                            59u8,
                            192u8,
                            149u8,
                            13u8,
                            123u8,
                            232u8,
                            34u8,
                            208u8,
                            48u8,
                            104u8,
                            35u8,
                            181u8,
                            186u8,
                            244u8,
                        ],
                    )
                }
                /// General information concerning any proposal or referendum.
                /// The `PreimageHash` refers to the preimage of the `Preimages` provider which can be a JSON
                /// dump or IPFS hash of a JSON file.
                ///
                /// Consider a garbage collection for a metadata of finished referendums to `unrequest` (remove)
                /// large preimages.
                pub fn metadata_of(
                    &self,
                    _0: impl ::std::borrow::Borrow<
                        runtime_types::pallet_democracy::types::MetadataOwner,
                    >,
                ) -> ::subxt::storage::address::Address<
                    ::subxt::storage::address::StaticStorageMapKey,
                    ::subxt::utils::H256,
                    ::subxt::storage::address::Yes,
                    (),
                    ::subxt::storage::address::Yes,
                > {
                    ::subxt::storage::address::Address::new_static(
                        "Democracy",
                        "MetadataOf",
                        vec![
                            ::subxt::storage::address::make_static_storage_map_key(_0
                            .borrow())
                        ],
                        [
                            241u8,
                            106u8,
                            118u8,
                            66u8,
                            219u8,
                            192u8,
                            185u8,
                            117u8,
                            144u8,
                            174u8,
                            171u8,
                            207u8,
                            181u8,
                            32u8,
                            133u8,
                            127u8,
                            160u8,
                            218u8,
                            113u8,
                            153u8,
                            160u8,
                            7u8,
                            72u8,
                            58u8,
                            187u8,
                            96u8,
                            51u8,
                            236u8,
                            64u8,
                            80u8,
                            123u8,
                            254u8,
                        ],
                    )
                }
                /// General information concerning any proposal or referendum.
                /// The `PreimageHash` refers to the preimage of the `Preimages` provider which can be a JSON
                /// dump or IPFS hash of a JSON file.
                ///
                /// Consider a garbage collection for a metadata of finished referendums to `unrequest` (remove)
                /// large preimages.
                pub fn metadata_of_root(
                    &self,
                ) -> ::subxt::storage::address::Address<
                    ::subxt::storage::address::StaticStorageMapKey,
                    ::subxt::utils::H256,
                    (),
                    (),
                    ::subxt::storage::address::Yes,
                > {
                    ::subxt::storage::address::Address::new_static(
                        "Democracy",
                        "MetadataOf",
                        Vec::new(),
                        [
                            241u8,
                            106u8,
                            118u8,
                            66u8,
                            219u8,
                            192u8,
                            185u8,
                            117u8,
                            144u8,
                            174u8,
                            171u8,
                            207u8,
                            181u8,
                            32u8,
                            133u8,
                            127u8,
                            160u8,
                            218u8,
                            113u8,
                            153u8,
                            160u8,
                            7u8,
                            72u8,
                            58u8,
                            187u8,
                            96u8,
                            51u8,
                            236u8,
                            64u8,
                            80u8,
                            123u8,
                            254u8,
                        ],
                    )
                }
            }
        }
        pub mod constants {
            use super::runtime_types;
            pub struct ConstantsApi;
            impl ConstantsApi {
                /// The period between a proposal being approved and enacted.
                ///
                /// It should generally be a little more than the unstake period to ensure that
                /// voting stakers have an opportunity to remove themselves from the system in the case
                /// where they are on the losing side of a vote.
                pub fn enactment_period(
                    &self,
                ) -> ::subxt::constants::Address<::core::primitive::u32> {
                    ::subxt::constants::Address::new_static(
                        "Democracy",
                        "EnactmentPeriod",
                        [
                            98u8,
                            252u8,
                            116u8,
                            72u8,
                            26u8,
                            180u8,
                            225u8,
                            83u8,
                            200u8,
                            157u8,
                            125u8,
                            151u8,
                            53u8,
                            76u8,
                            168u8,
                            26u8,
                            10u8,
                            9u8,
                            98u8,
                            68u8,
                            9u8,
                            178u8,
                            197u8,
                            113u8,
                            31u8,
                            79u8,
                            200u8,
                            90u8,
                            203u8,
                            100u8,
                            41u8,
                            145u8,
                        ],
                    )
                }
                /// How often (in blocks) new public referenda are launched.
                pub fn launch_period(
                    &self,
                ) -> ::subxt::constants::Address<::core::primitive::u32> {
                    ::subxt::constants::Address::new_static(
                        "Democracy",
                        "LaunchPeriod",
                        [
                            98u8,
                            252u8,
                            116u8,
                            72u8,
                            26u8,
                            180u8,
                            225u8,
                            83u8,
                            200u8,
                            157u8,
                            125u8,
                            151u8,
                            53u8,
                            76u8,
                            168u8,
                            26u8,
                            10u8,
                            9u8,
                            98u8,
                            68u8,
                            9u8,
                            178u8,
                            197u8,
                            113u8,
                            31u8,
                            79u8,
                            200u8,
                            90u8,
                            203u8,
                            100u8,
                            41u8,
                            145u8,
                        ],
                    )
                }
                /// How often (in blocks) to check for new votes.
                pub fn voting_period(
                    &self,
                ) -> ::subxt::constants::Address<::core::primitive::u32> {
                    ::subxt::constants::Address::new_static(
                        "Democracy",
                        "VotingPeriod",
                        [
                            98u8,
                            252u8,
                            116u8,
                            72u8,
                            26u8,
                            180u8,
                            225u8,
                            83u8,
                            200u8,
                            157u8,
                            125u8,
                            151u8,
                            53u8,
                            76u8,
                            168u8,
                            26u8,
                            10u8,
                            9u8,
                            98u8,
                            68u8,
                            9u8,
                            178u8,
                            197u8,
                            113u8,
                            31u8,
                            79u8,
                            200u8,
                            90u8,
                            203u8,
                            100u8,
                            41u8,
                            145u8,
                        ],
                    )
                }
                /// The minimum period of vote locking.
                ///
                /// It should be no shorter than enactment period to ensure that in the case of an approval,
                /// those successful voters are locked into the consequences that their votes entail.
                pub fn vote_locking_period(
                    &self,
                ) -> ::subxt::constants::Address<::core::primitive::u32> {
                    ::subxt::constants::Address::new_static(
                        "Democracy",
                        "VoteLockingPeriod",
                        [
                            98u8,
                            252u8,
                            116u8,
                            72u8,
                            26u8,
                            180u8,
                            225u8,
                            83u8,
                            200u8,
                            157u8,
                            125u8,
                            151u8,
                            53u8,
                            76u8,
                            168u8,
                            26u8,
                            10u8,
                            9u8,
                            98u8,
                            68u8,
                            9u8,
                            178u8,
                            197u8,
                            113u8,
                            31u8,
                            79u8,
                            200u8,
                            90u8,
                            203u8,
                            100u8,
                            41u8,
                            145u8,
                        ],
                    )
                }
                /// The minimum amount to be used as a deposit for a public referendum proposal.
                pub fn minimum_deposit(
                    &self,
                ) -> ::subxt::constants::Address<::core::primitive::u128> {
                    ::subxt::constants::Address::new_static(
                        "Democracy",
                        "MinimumDeposit",
                        [
                            84u8,
                            157u8,
                            140u8,
                            4u8,
                            93u8,
                            57u8,
                            29u8,
                            133u8,
                            105u8,
                            200u8,
                            214u8,
                            27u8,
                            144u8,
                            208u8,
                            218u8,
                            160u8,
                            130u8,
                            109u8,
                            101u8,
                            54u8,
                            210u8,
                            136u8,
                            71u8,
                            63u8,
                            49u8,
                            237u8,
                            234u8,
                            15u8,
                            178u8,
                            98u8,
                            148u8,
                            156u8,
                        ],
                    )
                }
                /// Indicator for whether an emergency origin is even allowed to happen. Some chains may
                /// want to set this permanently to `false`, others may want to condition it on things such
                /// as an upgrade having happened recently.
                pub fn instant_allowed(
                    &self,
                ) -> ::subxt::constants::Address<::core::primitive::bool> {
                    ::subxt::constants::Address::new_static(
                        "Democracy",
                        "InstantAllowed",
                        [
                            165u8,
                            28u8,
                            112u8,
                            190u8,
                            18u8,
                            129u8,
                            182u8,
                            206u8,
                            237u8,
                            1u8,
                            68u8,
                            252u8,
                            125u8,
                            234u8,
                            185u8,
                            50u8,
                            149u8,
                            164u8,
                            47u8,
                            126u8,
                            134u8,
                            100u8,
                            14u8,
                            86u8,
                            209u8,
                            39u8,
                            20u8,
                            4u8,
                            233u8,
                            115u8,
                            102u8,
                            131u8,
                        ],
                    )
                }
                /// Minimum voting period allowed for a fast-track referendum.
                pub fn fast_track_voting_period(
                    &self,
                ) -> ::subxt::constants::Address<::core::primitive::u32> {
                    ::subxt::constants::Address::new_static(
                        "Democracy",
                        "FastTrackVotingPeriod",
                        [
                            98u8,
                            252u8,
                            116u8,
                            72u8,
                            26u8,
                            180u8,
                            225u8,
                            83u8,
                            200u8,
                            157u8,
                            125u8,
                            151u8,
                            53u8,
                            76u8,
                            168u8,
                            26u8,
                            10u8,
                            9u8,
                            98u8,
                            68u8,
                            9u8,
                            178u8,
                            197u8,
                            113u8,
                            31u8,
                            79u8,
                            200u8,
                            90u8,
                            203u8,
                            100u8,
                            41u8,
                            145u8,
                        ],
                    )
                }
                /// Period in blocks where an external proposal may not be re-submitted after being vetoed.
                pub fn cooloff_period(
                    &self,
                ) -> ::subxt::constants::Address<::core::primitive::u32> {
                    ::subxt::constants::Address::new_static(
                        "Democracy",
                        "CooloffPeriod",
                        [
                            98u8,
                            252u8,
                            116u8,
                            72u8,
                            26u8,
                            180u8,
                            225u8,
                            83u8,
                            200u8,
                            157u8,
                            125u8,
                            151u8,
                            53u8,
                            76u8,
                            168u8,
                            26u8,
                            10u8,
                            9u8,
                            98u8,
                            68u8,
                            9u8,
                            178u8,
                            197u8,
                            113u8,
                            31u8,
                            79u8,
                            200u8,
                            90u8,
                            203u8,
                            100u8,
                            41u8,
                            145u8,
                        ],
                    )
                }
                /// The maximum number of votes for an account.
                ///
                /// Also used to compute weight, an overly big value can
                /// lead to extrinsic with very big weight: see `delegate` for instance.
                pub fn max_votes(
                    &self,
                ) -> ::subxt::constants::Address<::core::primitive::u32> {
                    ::subxt::constants::Address::new_static(
                        "Democracy",
                        "MaxVotes",
                        [
                            98u8,
                            252u8,
                            116u8,
                            72u8,
                            26u8,
                            180u8,
                            225u8,
                            83u8,
                            200u8,
                            157u8,
                            125u8,
                            151u8,
                            53u8,
                            76u8,
                            168u8,
                            26u8,
                            10u8,
                            9u8,
                            98u8,
                            68u8,
                            9u8,
                            178u8,
                            197u8,
                            113u8,
                            31u8,
                            79u8,
                            200u8,
                            90u8,
                            203u8,
                            100u8,
                            41u8,
                            145u8,
                        ],
                    )
                }
                /// The maximum number of public proposals that can exist at any time.
                pub fn max_proposals(
                    &self,
                ) -> ::subxt::constants::Address<::core::primitive::u32> {
                    ::subxt::constants::Address::new_static(
                        "Democracy",
                        "MaxProposals",
                        [
                            98u8,
                            252u8,
                            116u8,
                            72u8,
                            26u8,
                            180u8,
                            225u8,
                            83u8,
                            200u8,
                            157u8,
                            125u8,
                            151u8,
                            53u8,
                            76u8,
                            168u8,
                            26u8,
                            10u8,
                            9u8,
                            98u8,
                            68u8,
                            9u8,
                            178u8,
                            197u8,
                            113u8,
                            31u8,
                            79u8,
                            200u8,
                            90u8,
                            203u8,
                            100u8,
                            41u8,
                            145u8,
                        ],
                    )
                }
                /// The maximum number of deposits a public proposal may have at any time.
                pub fn max_deposits(
                    &self,
                ) -> ::subxt::constants::Address<::core::primitive::u32> {
                    ::subxt::constants::Address::new_static(
                        "Democracy",
                        "MaxDeposits",
                        [
                            98u8,
                            252u8,
                            116u8,
                            72u8,
                            26u8,
                            180u8,
                            225u8,
                            83u8,
                            200u8,
                            157u8,
                            125u8,
                            151u8,
                            53u8,
                            76u8,
                            168u8,
                            26u8,
                            10u8,
                            9u8,
                            98u8,
                            68u8,
                            9u8,
                            178u8,
                            197u8,
                            113u8,
                            31u8,
                            79u8,
                            200u8,
                            90u8,
                            203u8,
                            100u8,
                            41u8,
                            145u8,
                        ],
                    )
                }
                /// The maximum number of items which can be blacklisted.
                pub fn max_blacklisted(
                    &self,
                ) -> ::subxt::constants::Address<::core::primitive::u32> {
                    ::subxt::constants::Address::new_static(
                        "Democracy",
                        "MaxBlacklisted",
                        [
                            98u8,
                            252u8,
                            116u8,
                            72u8,
                            26u8,
                            180u8,
                            225u8,
                            83u8,
                            200u8,
                            157u8,
                            125u8,
                            151u8,
                            53u8,
                            76u8,
                            168u8,
                            26u8,
                            10u8,
                            9u8,
                            98u8,
                            68u8,
                            9u8,
                            178u8,
                            197u8,
                            113u8,
                            31u8,
                            79u8,
                            200u8,
                            90u8,
                            203u8,
                            100u8,
                            41u8,
                            145u8,
                        ],
                    )
                }
            }
        }
    }
    pub mod council {
        use super::root_mod;
        use super::runtime_types;
        /**
			Custom [dispatch errors](https://docs.substrate.io/main-docs/build/events-errors/)
			of this pallet.
			*/
        pub type Error = runtime_types::pallet_collective::pallet::Error;
        ///Contains one variant per dispatchable that can be called by an extrinsic.
        pub type Call = runtime_types::pallet_collective::pallet::Call;
        pub mod calls {
            use super::root_mod;
            use super::runtime_types;
            type DispatchError = runtime_types::sp_runtime::DispatchError;
            pub mod types {
                use super::runtime_types;
                #[derive(
                    ::subxt::ext::codec::Decode,
                    ::subxt::ext::codec::Encode,
                    ::subxt::ext::scale_decode::DecodeAsType,
                    ::subxt::ext::scale_encode::EncodeAsType,
                    Clone,
                    Debug,
                    Eq,
                    PartialEq
                )]
                #[codec(crate = ::subxt::ext::codec)]
                #[decode_as_type(crate_path = ":: subxt :: ext :: scale_decode")]
                #[encode_as_type(crate_path = ":: subxt :: ext :: scale_encode")]
                pub struct SetMembers {
                    pub new_members: ::std::vec::Vec<::subxt::utils::AccountId32>,
                    pub prime: ::core::option::Option<::subxt::utils::AccountId32>,
                    pub old_count: ::core::primitive::u32,
                }
                impl ::subxt::blocks::StaticExtrinsic for SetMembers {
                    const PALLET: &'static str = "Council";
                    const CALL: &'static str = "set_members";
                }
                #[derive(
                    ::subxt::ext::codec::Decode,
                    ::subxt::ext::codec::Encode,
                    ::subxt::ext::scale_decode::DecodeAsType,
                    ::subxt::ext::scale_encode::EncodeAsType,
                    Clone,
                    Debug,
                    Eq,
                    PartialEq
                )]
                #[codec(crate = ::subxt::ext::codec)]
                #[decode_as_type(crate_path = ":: subxt :: ext :: scale_decode")]
                #[encode_as_type(crate_path = ":: subxt :: ext :: scale_encode")]
                pub struct Execute {
                    pub proposal: ::std::boxed::Box<
                        runtime_types::tangle_standalone_runtime::RuntimeCall,
                    >,
                    #[codec(compact)]
                    pub length_bound: ::core::primitive::u32,
                }
                impl ::subxt::blocks::StaticExtrinsic for Execute {
                    const PALLET: &'static str = "Council";
                    const CALL: &'static str = "execute";
                }
                #[derive(
                    ::subxt::ext::codec::Decode,
                    ::subxt::ext::codec::Encode,
                    ::subxt::ext::scale_decode::DecodeAsType,
                    ::subxt::ext::scale_encode::EncodeAsType,
                    Clone,
                    Debug,
                    Eq,
                    PartialEq
                )]
                #[codec(crate = ::subxt::ext::codec)]
                #[decode_as_type(crate_path = ":: subxt :: ext :: scale_decode")]
                #[encode_as_type(crate_path = ":: subxt :: ext :: scale_encode")]
                pub struct Propose {
                    #[codec(compact)]
                    pub threshold: ::core::primitive::u32,
                    pub proposal: ::std::boxed::Box<
                        runtime_types::tangle_standalone_runtime::RuntimeCall,
                    >,
                    #[codec(compact)]
                    pub length_bound: ::core::primitive::u32,
                }
                impl ::subxt::blocks::StaticExtrinsic for Propose {
                    const PALLET: &'static str = "Council";
                    const CALL: &'static str = "propose";
                }
                #[derive(
                    ::subxt::ext::codec::Decode,
                    ::subxt::ext::codec::Encode,
                    ::subxt::ext::scale_decode::DecodeAsType,
                    ::subxt::ext::scale_encode::EncodeAsType,
                    Clone,
                    Debug,
                    Eq,
                    PartialEq
                )]
                #[codec(crate = ::subxt::ext::codec)]
                #[decode_as_type(crate_path = ":: subxt :: ext :: scale_decode")]
                #[encode_as_type(crate_path = ":: subxt :: ext :: scale_encode")]
                pub struct Vote {
                    pub proposal: ::subxt::utils::H256,
                    #[codec(compact)]
                    pub index: ::core::primitive::u32,
                    pub approve: ::core::primitive::bool,
                }
                impl ::subxt::blocks::StaticExtrinsic for Vote {
                    const PALLET: &'static str = "Council";
                    const CALL: &'static str = "vote";
                }
                #[derive(
                    ::subxt::ext::codec::Decode,
                    ::subxt::ext::codec::Encode,
                    ::subxt::ext::scale_decode::DecodeAsType,
                    ::subxt::ext::scale_encode::EncodeAsType,
                    Clone,
                    Debug,
                    Eq,
                    PartialEq
                )]
                #[codec(crate = ::subxt::ext::codec)]
                #[decode_as_type(crate_path = ":: subxt :: ext :: scale_decode")]
                #[encode_as_type(crate_path = ":: subxt :: ext :: scale_encode")]
                pub struct DisapproveProposal {
                    pub proposal_hash: ::subxt::utils::H256,
                }
                impl ::subxt::blocks::StaticExtrinsic for DisapproveProposal {
                    const PALLET: &'static str = "Council";
                    const CALL: &'static str = "disapprove_proposal";
                }
                #[derive(
                    ::subxt::ext::codec::Decode,
                    ::subxt::ext::codec::Encode,
                    ::subxt::ext::scale_decode::DecodeAsType,
                    ::subxt::ext::scale_encode::EncodeAsType,
                    Clone,
                    Debug,
                    Eq,
                    PartialEq
                )]
                #[codec(crate = ::subxt::ext::codec)]
                #[decode_as_type(crate_path = ":: subxt :: ext :: scale_decode")]
                #[encode_as_type(crate_path = ":: subxt :: ext :: scale_encode")]
                pub struct Close {
                    pub proposal_hash: ::subxt::utils::H256,
                    #[codec(compact)]
                    pub index: ::core::primitive::u32,
                    pub proposal_weight_bound: runtime_types::sp_weights::weight_v2::Weight,
                    #[codec(compact)]
                    pub length_bound: ::core::primitive::u32,
                }
                impl ::subxt::blocks::StaticExtrinsic for Close {
                    const PALLET: &'static str = "Council";
                    const CALL: &'static str = "close";
                }
            }
            pub struct TransactionApi;
            impl TransactionApi {
                ///Set the collective's membership.
                ///
                ///- `new_members`: The new member list. Be nice to the chain and provide it sorted.
                ///- `prime`: The prime member whose vote sets the default.
                ///- `old_count`: The upper bound for the previous number of members in storage. Used for
                ///  weight estimation.
                ///
                ///The dispatch of this call must be `SetMembersOrigin`.
                ///
                ///NOTE: Does not enforce the expected `MaxMembers` limit on the amount of members, but
                ///      the weight estimations rely on it to estimate dispatchable weight.
                ///
                ///# WARNING:
                ///
                ///The `pallet-collective` can also be managed by logic outside of the pallet through the
                ///implementation of the trait [`ChangeMembers`].
                ///Any call to `set_members` must be careful that the member set doesn't get out of sync
                ///with other logic managing the member set.
                ///
                ///## Complexity:
                ///- `O(MP + N)` where:
                ///  - `M` old-members-count (code- and governance-bounded)
                ///  - `N` new-members-count (code- and governance-bounded)
                ///  - `P` proposals-count (code-bounded)
                pub fn set_members(
                    &self,
                    new_members: ::std::vec::Vec<::subxt::utils::AccountId32>,
                    prime: ::core::option::Option<::subxt::utils::AccountId32>,
                    old_count: ::core::primitive::u32,
                ) -> ::subxt::tx::Payload<types::SetMembers> {
                    ::subxt::tx::Payload::new_static(
                        "Council",
                        "set_members",
                        types::SetMembers {
                            new_members,
                            prime,
                            old_count,
                        },
                        [
                            141u8,
                            113u8,
                            137u8,
                            46u8,
                            75u8,
                            22u8,
                            143u8,
                            204u8,
                            50u8,
                            24u8,
                            137u8,
                            25u8,
                            226u8,
                            166u8,
                            121u8,
                            161u8,
                            54u8,
                            144u8,
                            12u8,
                            145u8,
                            157u8,
                            153u8,
                            47u8,
                            144u8,
                            94u8,
                            34u8,
                            217u8,
                            115u8,
                            125u8,
                            152u8,
                            110u8,
                            28u8,
                        ],
                    )
                }
                ///Dispatch a proposal from a member using the `Member` origin.
                ///
                ///Origin must be a member of the collective.
                ///
                ///## Complexity:
                ///- `O(B + M + P)` where:
                ///- `B` is `proposal` size in bytes (length-fee-bounded)
                ///- `M` members-count (code-bounded)
                ///- `P` complexity of dispatching `proposal`
                pub fn execute(
                    &self,
                    proposal: runtime_types::tangle_standalone_runtime::RuntimeCall,
                    length_bound: ::core::primitive::u32,
                ) -> ::subxt::tx::Payload<types::Execute> {
                    ::subxt::tx::Payload::new_static(
                        "Council",
                        "execute",
                        types::Execute {
                            proposal: ::std::boxed::Box::new(proposal),
                            length_bound,
                        },
                        [
                            106u8,
                            30u8,
                            217u8,
                            144u8,
                            246u8,
                            60u8,
                            62u8,
                            44u8,
                            41u8,
                            154u8,
                            127u8,
                            196u8,
                            0u8,
                            113u8,
                            179u8,
                            190u8,
                            112u8,
                            95u8,
                            211u8,
                            187u8,
                            33u8,
                            205u8,
                            99u8,
                            94u8,
                            143u8,
                            45u8,
                            9u8,
                            66u8,
                            228u8,
                            3u8,
                            202u8,
                            180u8,
                        ],
                    )
                }
                ///Add a new proposal to either be voted on or executed directly.
                ///
                ///Requires the sender to be member.
                ///
                ///`threshold` determines whether `proposal` is executed directly (`threshold < 2`)
                ///or put up for voting.
                ///
                ///## Complexity
                ///- `O(B + M + P1)` or `O(B + M + P2)` where:
                ///  - `B` is `proposal` size in bytes (length-fee-bounded)
                ///  - `M` is members-count (code- and governance-bounded)
                ///  - branching is influenced by `threshold` where:
                ///    - `P1` is proposal execution complexity (`threshold < 2`)
                ///    - `P2` is proposals-count (code-bounded) (`threshold >= 2`)
                pub fn propose(
                    &self,
                    threshold: ::core::primitive::u32,
                    proposal: runtime_types::tangle_standalone_runtime::RuntimeCall,
                    length_bound: ::core::primitive::u32,
                ) -> ::subxt::tx::Payload<types::Propose> {
                    ::subxt::tx::Payload::new_static(
                        "Council",
                        "propose",
                        types::Propose {
                            threshold,
                            proposal: ::std::boxed::Box::new(proposal),
                            length_bound,
                        },
                        [
                            25u8,
                            107u8,
                            142u8,
                            100u8,
                            87u8,
                            244u8,
                            101u8,
                            88u8,
                            144u8,
                            93u8,
                            193u8,
                            115u8,
                            50u8,
                            230u8,
                            236u8,
                            13u8,
                            66u8,
                            110u8,
                            223u8,
                            88u8,
                            73u8,
                            104u8,
                            1u8,
                            251u8,
                            210u8,
                            183u8,
                            13u8,
                            228u8,
                            100u8,
                            72u8,
                            217u8,
                            85u8,
                        ],
                    )
                }
                ///Add an aye or nay vote for the sender to the given proposal.
                ///
                ///Requires the sender to be a member.
                ///
                ///Transaction fees will be waived if the member is voting on any particular proposal
                ///for the first time and the call is successful. Subsequent vote changes will charge a
                ///fee.
                ///## Complexity
                ///- `O(M)` where `M` is members-count (code- and governance-bounded)
                pub fn vote(
                    &self,
                    proposal: ::subxt::utils::H256,
                    index: ::core::primitive::u32,
                    approve: ::core::primitive::bool,
                ) -> ::subxt::tx::Payload<types::Vote> {
                    ::subxt::tx::Payload::new_static(
                        "Council",
                        "vote",
                        types::Vote {
                            proposal,
                            index,
                            approve,
                        },
                        [
                            110u8,
                            141u8,
                            24u8,
                            33u8,
                            91u8,
                            7u8,
                            89u8,
                            198u8,
                            54u8,
                            10u8,
                            76u8,
                            129u8,
                            45u8,
                            20u8,
                            216u8,
                            104u8,
                            231u8,
                            246u8,
                            174u8,
                            205u8,
                            190u8,
                            176u8,
                            171u8,
                            113u8,
                            33u8,
                            37u8,
                            155u8,
                            203u8,
                            251u8,
                            34u8,
                            25u8,
                            120u8,
                        ],
                    )
                }
                ///Disapprove a proposal, close, and remove it from the system, regardless of its current
                ///state.
                ///
                ///Must be called by the Root origin.
                ///
                ///Parameters:
                ///* `proposal_hash`: The hash of the proposal that should be disapproved.
                ///
                ///## Complexity
                ///O(P) where P is the number of max proposals
                pub fn disapprove_proposal(
                    &self,
                    proposal_hash: ::subxt::utils::H256,
                ) -> ::subxt::tx::Payload<types::DisapproveProposal> {
                    ::subxt::tx::Payload::new_static(
                        "Council",
                        "disapprove_proposal",
                        types::DisapproveProposal {
                            proposal_hash,
                        },
                        [
                            26u8,
                            140u8,
                            111u8,
                            193u8,
                            229u8,
                            59u8,
                            53u8,
                            196u8,
                            230u8,
                            60u8,
                            7u8,
                            155u8,
                            168u8,
                            7u8,
                            201u8,
                            177u8,
                            70u8,
                            103u8,
                            190u8,
                            57u8,
                            244u8,
                            156u8,
                            67u8,
                            101u8,
                            228u8,
                            6u8,
                            213u8,
                            83u8,
                            225u8,
                            95u8,
                            148u8,
                            96u8,
                        ],
                    )
                }
                ///Close a vote that is either approved, disapproved or whose voting period has ended.
                ///
                ///May be called by any signed account in order to finish voting and close the proposal.
                ///
                ///If called before the end of the voting period it will only close the vote if it is
                ///has enough votes to be approved or disapproved.
                ///
                ///If called after the end of the voting period abstentions are counted as rejections
                ///unless there is a prime member set and the prime member cast an approval.
                ///
                ///If the close operation completes successfully with disapproval, the transaction fee will
                ///be waived. Otherwise execution of the approved operation will be charged to the caller.
                ///
                ///+ `proposal_weight_bound`: The maximum amount of weight consumed by executing the closed
                ///proposal.
                ///+ `length_bound`: The upper bound for the length of the proposal in storage. Checked via
                ///`storage::read` so it is `size_of::<u32>() == 4` larger than the pure length.
                ///
                ///## Complexity
                ///- `O(B + M + P1 + P2)` where:
                ///  - `B` is `proposal` size in bytes (length-fee-bounded)
                ///  - `M` is members-count (code- and governance-bounded)
                ///  - `P1` is the complexity of `proposal` preimage.
                ///  - `P2` is proposal-count (code-bounded)
                pub fn close(
                    &self,
                    proposal_hash: ::subxt::utils::H256,
                    index: ::core::primitive::u32,
                    proposal_weight_bound: runtime_types::sp_weights::weight_v2::Weight,
                    length_bound: ::core::primitive::u32,
                ) -> ::subxt::tx::Payload<types::Close> {
                    ::subxt::tx::Payload::new_static(
                        "Council",
                        "close",
                        types::Close {
                            proposal_hash,
                            index,
                            proposal_weight_bound,
                            length_bound,
                        },
                        [
                            189u8,
                            149u8,
                            125u8,
                            63u8,
                            39u8,
                            201u8,
                            247u8,
                            4u8,
                            220u8,
                            74u8,
                            78u8,
                            14u8,
                            113u8,
                            163u8,
                            1u8,
                            159u8,
                            81u8,
                            248u8,
                            141u8,
                            111u8,
                            34u8,
                            243u8,
                            67u8,
                            70u8,
                            60u8,
                            92u8,
                            47u8,
                            70u8,
                            66u8,
                            246u8,
                            236u8,
                            153u8,
                        ],
                    )
                }
            }
        }
        /**
			The [event](https://docs.substrate.io/main-docs/build/events-errors/) emitted
			by this pallet.
			*/
        pub type Event = runtime_types::pallet_collective::pallet::Event;
        pub mod events {
            use super::runtime_types;
            #[derive(
                ::subxt::ext::codec::Decode,
                ::subxt::ext::codec::Encode,
                ::subxt::ext::scale_decode::DecodeAsType,
                ::subxt::ext::scale_encode::EncodeAsType,
                Clone,
                Debug,
                Eq,
                PartialEq
            )]
            #[codec(crate = ::subxt::ext::codec)]
            #[decode_as_type(crate_path = ":: subxt :: ext :: scale_decode")]
            #[encode_as_type(crate_path = ":: subxt :: ext :: scale_encode")]
            ///A motion (given hash) has been proposed (by given account) with a threshold (given
            ///`MemberCount`).
            pub struct Proposed {
                pub account: ::subxt::utils::AccountId32,
                pub proposal_index: ::core::primitive::u32,
                pub proposal_hash: ::subxt::utils::H256,
                pub threshold: ::core::primitive::u32,
            }
            impl ::subxt::events::StaticEvent for Proposed {
                const PALLET: &'static str = "Council";
                const EVENT: &'static str = "Proposed";
            }
            #[derive(
                ::subxt::ext::codec::Decode,
                ::subxt::ext::codec::Encode,
                ::subxt::ext::scale_decode::DecodeAsType,
                ::subxt::ext::scale_encode::EncodeAsType,
                Clone,
                Debug,
                Eq,
                PartialEq
            )]
            #[codec(crate = ::subxt::ext::codec)]
            #[decode_as_type(crate_path = ":: subxt :: ext :: scale_decode")]
            #[encode_as_type(crate_path = ":: subxt :: ext :: scale_encode")]
            ///A motion (given hash) has been voted on by given account, leaving
            ///a tally (yes votes and no votes given respectively as `MemberCount`).
            pub struct Voted {
                pub account: ::subxt::utils::AccountId32,
                pub proposal_hash: ::subxt::utils::H256,
                pub voted: ::core::primitive::bool,
                pub yes: ::core::primitive::u32,
                pub no: ::core::primitive::u32,
            }
            impl ::subxt::events::StaticEvent for Voted {
                const PALLET: &'static str = "Council";
                const EVENT: &'static str = "Voted";
            }
            #[derive(
                ::subxt::ext::codec::Decode,
                ::subxt::ext::codec::Encode,
                ::subxt::ext::scale_decode::DecodeAsType,
                ::subxt::ext::scale_encode::EncodeAsType,
                Clone,
                Debug,
                Eq,
                PartialEq
            )]
            #[codec(crate = ::subxt::ext::codec)]
            #[decode_as_type(crate_path = ":: subxt :: ext :: scale_decode")]
            #[encode_as_type(crate_path = ":: subxt :: ext :: scale_encode")]
            ///A motion was approved by the required threshold.
            pub struct Approved {
                pub proposal_hash: ::subxt::utils::H256,
            }
            impl ::subxt::events::StaticEvent for Approved {
                const PALLET: &'static str = "Council";
                const EVENT: &'static str = "Approved";
            }
            #[derive(
                ::subxt::ext::codec::Decode,
                ::subxt::ext::codec::Encode,
                ::subxt::ext::scale_decode::DecodeAsType,
                ::subxt::ext::scale_encode::EncodeAsType,
                Clone,
                Debug,
                Eq,
                PartialEq
            )]
            #[codec(crate = ::subxt::ext::codec)]
            #[decode_as_type(crate_path = ":: subxt :: ext :: scale_decode")]
            #[encode_as_type(crate_path = ":: subxt :: ext :: scale_encode")]
            ///A motion was not approved by the required threshold.
            pub struct Disapproved {
                pub proposal_hash: ::subxt::utils::H256,
            }
            impl ::subxt::events::StaticEvent for Disapproved {
                const PALLET: &'static str = "Council";
                const EVENT: &'static str = "Disapproved";
            }
            #[derive(
                ::subxt::ext::codec::Decode,
                ::subxt::ext::codec::Encode,
                ::subxt::ext::scale_decode::DecodeAsType,
                ::subxt::ext::scale_encode::EncodeAsType,
                Clone,
                Debug,
                Eq,
                PartialEq
            )]
            #[codec(crate = ::subxt::ext::codec)]
            #[decode_as_type(crate_path = ":: subxt :: ext :: scale_decode")]
            #[encode_as_type(crate_path = ":: subxt :: ext :: scale_encode")]
            ///A motion was executed; result will be `Ok` if it returned without error.
            pub struct Executed {
                pub proposal_hash: ::subxt::utils::H256,
                pub result: ::core::result::Result<
                    (),
                    runtime_types::sp_runtime::DispatchError,
                >,
            }
            impl ::subxt::events::StaticEvent for Executed {
                const PALLET: &'static str = "Council";
                const EVENT: &'static str = "Executed";
            }
            #[derive(
                ::subxt::ext::codec::Decode,
                ::subxt::ext::codec::Encode,
                ::subxt::ext::scale_decode::DecodeAsType,
                ::subxt::ext::scale_encode::EncodeAsType,
                Clone,
                Debug,
                Eq,
                PartialEq
            )]
            #[codec(crate = ::subxt::ext::codec)]
            #[decode_as_type(crate_path = ":: subxt :: ext :: scale_decode")]
            #[encode_as_type(crate_path = ":: subxt :: ext :: scale_encode")]
            ///A single member did some action; result will be `Ok` if it returned without error.
            pub struct MemberExecuted {
                pub proposal_hash: ::subxt::utils::H256,
                pub result: ::core::result::Result<
                    (),
                    runtime_types::sp_runtime::DispatchError,
                >,
            }
            impl ::subxt::events::StaticEvent for MemberExecuted {
                const PALLET: &'static str = "Council";
                const EVENT: &'static str = "MemberExecuted";
            }
            #[derive(
                ::subxt::ext::codec::Decode,
                ::subxt::ext::codec::Encode,
                ::subxt::ext::scale_decode::DecodeAsType,
                ::subxt::ext::scale_encode::EncodeAsType,
                Clone,
                Debug,
                Eq,
                PartialEq
            )]
            #[codec(crate = ::subxt::ext::codec)]
            #[decode_as_type(crate_path = ":: subxt :: ext :: scale_decode")]
            #[encode_as_type(crate_path = ":: subxt :: ext :: scale_encode")]
            ///A proposal was closed because its threshold was reached or after its duration was up.
            pub struct Closed {
                pub proposal_hash: ::subxt::utils::H256,
                pub yes: ::core::primitive::u32,
                pub no: ::core::primitive::u32,
            }
            impl ::subxt::events::StaticEvent for Closed {
                const PALLET: &'static str = "Council";
                const EVENT: &'static str = "Closed";
            }
        }
        pub mod storage {
            use super::runtime_types;
            pub struct StorageApi;
            impl StorageApi {
                /// The hashes of the active proposals.
                pub fn proposals(
                    &self,
                ) -> ::subxt::storage::address::Address<
                    ::subxt::storage::address::StaticStorageMapKey,
                    runtime_types::bounded_collections::bounded_vec::BoundedVec<
                        ::subxt::utils::H256,
                    >,
                    ::subxt::storage::address::Yes,
                    ::subxt::storage::address::Yes,
                    (),
                > {
                    ::subxt::storage::address::Address::new_static(
                        "Council",
                        "Proposals",
                        vec![],
                        [
                            210u8,
                            234u8,
                            7u8,
                            29u8,
                            231u8,
                            80u8,
                            17u8,
                            36u8,
                            189u8,
                            34u8,
                            175u8,
                            147u8,
                            56u8,
                            92u8,
                            201u8,
                            104u8,
                            207u8,
                            150u8,
                            58u8,
                            110u8,
                            90u8,
                            28u8,
                            198u8,
                            79u8,
                            236u8,
                            245u8,
                            19u8,
                            38u8,
                            68u8,
                            59u8,
                            215u8,
                            74u8,
                        ],
                    )
                }
                /// Actual proposal for a given hash, if it's current.
                pub fn proposal_of(
                    &self,
                    _0: impl ::std::borrow::Borrow<::subxt::utils::H256>,
                ) -> ::subxt::storage::address::Address<
                    ::subxt::storage::address::StaticStorageMapKey,
                    runtime_types::tangle_standalone_runtime::RuntimeCall,
                    ::subxt::storage::address::Yes,
                    (),
                    ::subxt::storage::address::Yes,
                > {
                    ::subxt::storage::address::Address::new_static(
                        "Council",
                        "ProposalOf",
                        vec![
                            ::subxt::storage::address::make_static_storage_map_key(_0
                            .borrow())
                        ],
                        [
                            20u8,
                            149u8,
                            181u8,
                            18u8,
                            142u8,
                            218u8,
                            244u8,
                            38u8,
                            65u8,
                            204u8,
                            60u8,
                            107u8,
                            226u8,
                            233u8,
                            0u8,
                            39u8,
                            137u8,
                            167u8,
                            83u8,
                            33u8,
                            25u8,
                            92u8,
                            87u8,
                            168u8,
                            151u8,
                            60u8,
                            230u8,
                            221u8,
                            48u8,
                            155u8,
                            135u8,
                            66u8,
                        ],
                    )
                }
                /// Actual proposal for a given hash, if it's current.
                pub fn proposal_of_root(
                    &self,
                ) -> ::subxt::storage::address::Address<
                    ::subxt::storage::address::StaticStorageMapKey,
                    runtime_types::tangle_standalone_runtime::RuntimeCall,
                    (),
                    (),
                    ::subxt::storage::address::Yes,
                > {
                    ::subxt::storage::address::Address::new_static(
                        "Council",
                        "ProposalOf",
                        Vec::new(),
                        [
                            20u8,
                            149u8,
                            181u8,
                            18u8,
                            142u8,
                            218u8,
                            244u8,
                            38u8,
                            65u8,
                            204u8,
                            60u8,
                            107u8,
                            226u8,
                            233u8,
                            0u8,
                            39u8,
                            137u8,
                            167u8,
                            83u8,
                            33u8,
                            25u8,
                            92u8,
                            87u8,
                            168u8,
                            151u8,
                            60u8,
                            230u8,
                            221u8,
                            48u8,
                            155u8,
                            135u8,
                            66u8,
                        ],
                    )
                }
                /// Votes on a given proposal, if it is ongoing.
                pub fn voting(
                    &self,
                    _0: impl ::std::borrow::Borrow<::subxt::utils::H256>,
                ) -> ::subxt::storage::address::Address<
                    ::subxt::storage::address::StaticStorageMapKey,
                    runtime_types::pallet_collective::Votes<
                        ::subxt::utils::AccountId32,
                        ::core::primitive::u32,
                    >,
                    ::subxt::storage::address::Yes,
                    (),
                    ::subxt::storage::address::Yes,
                > {
                    ::subxt::storage::address::Address::new_static(
                        "Council",
                        "Voting",
                        vec![
                            ::subxt::storage::address::make_static_storage_map_key(_0
                            .borrow())
                        ],
                        [
                            56u8,
                            192u8,
                            111u8,
                            180u8,
                            253u8,
                            5u8,
                            232u8,
                            126u8,
                            177u8,
                            48u8,
                            135u8,
                            39u8,
                            89u8,
                            71u8,
                            62u8,
                            239u8,
                            216u8,
                            17u8,
                            64u8,
                            82u8,
                            130u8,
                            236u8,
                            96u8,
                            89u8,
                            167u8,
                            2u8,
                            118u8,
                            113u8,
                            63u8,
                            176u8,
                            124u8,
                            73u8,
                        ],
                    )
                }
                /// Votes on a given proposal, if it is ongoing.
                pub fn voting_root(
                    &self,
                ) -> ::subxt::storage::address::Address<
                    ::subxt::storage::address::StaticStorageMapKey,
                    runtime_types::pallet_collective::Votes<
                        ::subxt::utils::AccountId32,
                        ::core::primitive::u32,
                    >,
                    (),
                    (),
                    ::subxt::storage::address::Yes,
                > {
                    ::subxt::storage::address::Address::new_static(
                        "Council",
                        "Voting",
                        Vec::new(),
                        [
                            56u8,
                            192u8,
                            111u8,
                            180u8,
                            253u8,
                            5u8,
                            232u8,
                            126u8,
                            177u8,
                            48u8,
                            135u8,
                            39u8,
                            89u8,
                            71u8,
                            62u8,
                            239u8,
                            216u8,
                            17u8,
                            64u8,
                            82u8,
                            130u8,
                            236u8,
                            96u8,
                            89u8,
                            167u8,
                            2u8,
                            118u8,
                            113u8,
                            63u8,
                            176u8,
                            124u8,
                            73u8,
                        ],
                    )
                }
                /// Proposals so far.
                pub fn proposal_count(
                    &self,
                ) -> ::subxt::storage::address::Address<
                    ::subxt::storage::address::StaticStorageMapKey,
                    ::core::primitive::u32,
                    ::subxt::storage::address::Yes,
                    ::subxt::storage::address::Yes,
                    (),
                > {
                    ::subxt::storage::address::Address::new_static(
                        "Council",
                        "ProposalCount",
                        vec![],
                        [
                            91u8,
                            238u8,
                            246u8,
                            106u8,
                            95u8,
                            66u8,
                            83u8,
                            134u8,
                            1u8,
                            225u8,
                            164u8,
                            216u8,
                            113u8,
                            101u8,
                            203u8,
                            200u8,
                            113u8,
                            97u8,
                            246u8,
                            228u8,
                            140u8,
                            29u8,
                            29u8,
                            48u8,
                            176u8,
                            137u8,
                            93u8,
                            230u8,
                            56u8,
                            75u8,
                            51u8,
                            149u8,
                        ],
                    )
                }
                /// The current members of the collective. This is stored sorted (just by value).
                pub fn members(
                    &self,
                ) -> ::subxt::storage::address::Address<
                    ::subxt::storage::address::StaticStorageMapKey,
                    ::std::vec::Vec<::subxt::utils::AccountId32>,
                    ::subxt::storage::address::Yes,
                    ::subxt::storage::address::Yes,
                    (),
                > {
                    ::subxt::storage::address::Address::new_static(
                        "Council",
                        "Members",
                        vec![],
                        [
                            16u8,
                            29u8,
                            32u8,
                            222u8,
                            175u8,
                            136u8,
                            111u8,
                            101u8,
                            43u8,
                            74u8,
                            209u8,
                            81u8,
                            47u8,
                            97u8,
                            129u8,
                            39u8,
                            225u8,
                            243u8,
                            110u8,
                            229u8,
                            237u8,
                            21u8,
                            90u8,
                            127u8,
                            80u8,
                            239u8,
                            156u8,
                            32u8,
                            90u8,
                            109u8,
                            179u8,
                            0u8,
                        ],
                    )
                }
                /// The prime member that helps determine the default vote behavior in case of absentations.
                pub fn prime(
                    &self,
                ) -> ::subxt::storage::address::Address<
                    ::subxt::storage::address::StaticStorageMapKey,
                    ::subxt::utils::AccountId32,
                    ::subxt::storage::address::Yes,
                    (),
                    (),
                > {
                    ::subxt::storage::address::Address::new_static(
                        "Council",
                        "Prime",
                        vec![],
                        [
                            72u8,
                            128u8,
                            214u8,
                            72u8,
                            78u8,
                            80u8,
                            100u8,
                            198u8,
                            114u8,
                            215u8,
                            59u8,
                            3u8,
                            103u8,
                            14u8,
                            152u8,
                            202u8,
                            12u8,
                            165u8,
                            224u8,
                            10u8,
                            41u8,
                            154u8,
                            77u8,
                            95u8,
                            116u8,
                            143u8,
                            250u8,
                            250u8,
                            176u8,
                            92u8,
                            238u8,
                            154u8,
                        ],
                    )
                }
            }
        }
        pub mod constants {
            use super::runtime_types;
            pub struct ConstantsApi;
            impl ConstantsApi {
                /// The maximum weight of a dispatch call that can be proposed and executed.
                pub fn max_proposal_weight(
                    &self,
                ) -> ::subxt::constants::Address<
                    runtime_types::sp_weights::weight_v2::Weight,
                > {
                    ::subxt::constants::Address::new_static(
                        "Council",
                        "MaxProposalWeight",
                        [
                            222u8,
                            183u8,
                            203u8,
                            169u8,
                            31u8,
                            134u8,
                            28u8,
                            12u8,
                            47u8,
                            140u8,
                            71u8,
                            74u8,
                            61u8,
                            55u8,
                            71u8,
                            236u8,
                            215u8,
                            83u8,
                            28u8,
                            70u8,
                            45u8,
                            128u8,
                            184u8,
                            57u8,
                            101u8,
                            83u8,
                            42u8,
                            165u8,
                            34u8,
                            155u8,
                            64u8,
                            145u8,
                        ],
                    )
                }
            }
        }
    }
    pub mod vesting {
        use super::root_mod;
        use super::runtime_types;
        ///Error for the vesting pallet.
        pub type Error = runtime_types::pallet_vesting::pallet::Error;
        ///Contains one variant per dispatchable that can be called by an extrinsic.
        pub type Call = runtime_types::pallet_vesting::pallet::Call;
        pub mod calls {
            use super::root_mod;
            use super::runtime_types;
            type DispatchError = runtime_types::sp_runtime::DispatchError;
            pub mod types {
                use super::runtime_types;
                #[derive(
                    ::subxt::ext::codec::Decode,
                    ::subxt::ext::codec::Encode,
                    ::subxt::ext::scale_decode::DecodeAsType,
                    ::subxt::ext::scale_encode::EncodeAsType,
                    Clone,
                    Debug,
                    Eq,
                    PartialEq
                )]
                #[codec(crate = ::subxt::ext::codec)]
                #[decode_as_type(crate_path = ":: subxt :: ext :: scale_decode")]
                #[encode_as_type(crate_path = ":: subxt :: ext :: scale_encode")]
                pub struct Vest;
                impl ::subxt::blocks::StaticExtrinsic for Vest {
                    const PALLET: &'static str = "Vesting";
                    const CALL: &'static str = "vest";
                }
                #[derive(
                    ::subxt::ext::codec::Decode,
                    ::subxt::ext::codec::Encode,
                    ::subxt::ext::scale_decode::DecodeAsType,
                    ::subxt::ext::scale_encode::EncodeAsType,
                    Clone,
                    Debug,
                    Eq,
                    PartialEq
                )]
                #[codec(crate = ::subxt::ext::codec)]
                #[decode_as_type(crate_path = ":: subxt :: ext :: scale_decode")]
                #[encode_as_type(crate_path = ":: subxt :: ext :: scale_encode")]
                pub struct VestOther {
                    pub target: ::subxt::utils::MultiAddress<
                        ::subxt::utils::AccountId32,
                        ::core::primitive::u32,
                    >,
                }
                impl ::subxt::blocks::StaticExtrinsic for VestOther {
                    const PALLET: &'static str = "Vesting";
                    const CALL: &'static str = "vest_other";
                }
                #[derive(
                    ::subxt::ext::codec::Decode,
                    ::subxt::ext::codec::Encode,
                    ::subxt::ext::scale_decode::DecodeAsType,
                    ::subxt::ext::scale_encode::EncodeAsType,
                    Clone,
                    Debug,
                    Eq,
                    PartialEq
                )]
                #[codec(crate = ::subxt::ext::codec)]
                #[decode_as_type(crate_path = ":: subxt :: ext :: scale_decode")]
                #[encode_as_type(crate_path = ":: subxt :: ext :: scale_encode")]
                pub struct VestedTransfer {
                    pub target: ::subxt::utils::MultiAddress<
                        ::subxt::utils::AccountId32,
                        ::core::primitive::u32,
                    >,
                    pub schedule: runtime_types::pallet_vesting::vesting_info::VestingInfo<
                        ::core::primitive::u128,
                        ::core::primitive::u32,
                    >,
                }
                impl ::subxt::blocks::StaticExtrinsic for VestedTransfer {
                    const PALLET: &'static str = "Vesting";
                    const CALL: &'static str = "vested_transfer";
                }
                #[derive(
                    ::subxt::ext::codec::Decode,
                    ::subxt::ext::codec::Encode,
                    ::subxt::ext::scale_decode::DecodeAsType,
                    ::subxt::ext::scale_encode::EncodeAsType,
                    Clone,
                    Debug,
                    Eq,
                    PartialEq
                )]
                #[codec(crate = ::subxt::ext::codec)]
                #[decode_as_type(crate_path = ":: subxt :: ext :: scale_decode")]
                #[encode_as_type(crate_path = ":: subxt :: ext :: scale_encode")]
                pub struct ForceVestedTransfer {
                    pub source: ::subxt::utils::MultiAddress<
                        ::subxt::utils::AccountId32,
                        ::core::primitive::u32,
                    >,
                    pub target: ::subxt::utils::MultiAddress<
                        ::subxt::utils::AccountId32,
                        ::core::primitive::u32,
                    >,
                    pub schedule: runtime_types::pallet_vesting::vesting_info::VestingInfo<
                        ::core::primitive::u128,
                        ::core::primitive::u32,
                    >,
                }
                impl ::subxt::blocks::StaticExtrinsic for ForceVestedTransfer {
                    const PALLET: &'static str = "Vesting";
                    const CALL: &'static str = "force_vested_transfer";
                }
                #[derive(
                    ::subxt::ext::codec::Decode,
                    ::subxt::ext::codec::Encode,
                    ::subxt::ext::scale_decode::DecodeAsType,
                    ::subxt::ext::scale_encode::EncodeAsType,
                    Clone,
                    Debug,
                    Eq,
                    PartialEq
                )]
                #[codec(crate = ::subxt::ext::codec)]
                #[decode_as_type(crate_path = ":: subxt :: ext :: scale_decode")]
                #[encode_as_type(crate_path = ":: subxt :: ext :: scale_encode")]
                pub struct MergeSchedules {
                    pub schedule1_index: ::core::primitive::u32,
                    pub schedule2_index: ::core::primitive::u32,
                }
                impl ::subxt::blocks::StaticExtrinsic for MergeSchedules {
                    const PALLET: &'static str = "Vesting";
                    const CALL: &'static str = "merge_schedules";
                }
            }
            pub struct TransactionApi;
            impl TransactionApi {
                ///Unlock any vested funds of the sender account.
                ///
                ///The dispatch origin for this call must be _Signed_ and the sender must have funds still
                ///locked under this pallet.
                ///
                ///Emits either `VestingCompleted` or `VestingUpdated`.
                ///
                ///## Complexity
                ///- `O(1)`.
                pub fn vest(&self) -> ::subxt::tx::Payload<types::Vest> {
                    ::subxt::tx::Payload::new_static(
                        "Vesting",
                        "vest",
                        types::Vest {},
                        [
                            149u8,
                            89u8,
                            178u8,
                            148u8,
                            127u8,
                            127u8,
                            155u8,
                            60u8,
                            114u8,
                            126u8,
                            204u8,
                            123u8,
                            166u8,
                            70u8,
                            104u8,
                            208u8,
                            186u8,
                            69u8,
                            139u8,
                            181u8,
                            151u8,
                            154u8,
                            235u8,
                            161u8,
                            191u8,
                            35u8,
                            111u8,
                            60u8,
                            21u8,
                            165u8,
                            44u8,
                            122u8,
                        ],
                    )
                }
                ///Unlock any vested funds of a `target` account.
                ///
                ///The dispatch origin for this call must be _Signed_.
                ///
                ///- `target`: The account whose vested funds should be unlocked. Must have funds still
                ///locked under this pallet.
                ///
                ///Emits either `VestingCompleted` or `VestingUpdated`.
                ///
                ///## Complexity
                ///- `O(1)`.
                pub fn vest_other(
                    &self,
                    target: ::subxt::utils::MultiAddress<
                        ::subxt::utils::AccountId32,
                        ::core::primitive::u32,
                    >,
                ) -> ::subxt::tx::Payload<types::VestOther> {
                    ::subxt::tx::Payload::new_static(
                        "Vesting",
                        "vest_other",
                        types::VestOther { target },
                        [
                            237u8,
                            98u8,
                            131u8,
                            246u8,
                            166u8,
                            177u8,
                            74u8,
                            207u8,
                            136u8,
                            120u8,
                            117u8,
                            252u8,
                            197u8,
                            226u8,
                            72u8,
                            233u8,
                            141u8,
                            180u8,
                            220u8,
                            163u8,
                            64u8,
                            66u8,
                            95u8,
                            114u8,
                            143u8,
                            102u8,
                            158u8,
                            225u8,
                            44u8,
                            99u8,
                            75u8,
                            117u8,
                        ],
                    )
                }
                ///Create a vested transfer.
                ///
                ///The dispatch origin for this call must be _Signed_.
                ///
                ///- `target`: The account receiving the vested funds.
                ///- `schedule`: The vesting schedule attached to the transfer.
                ///
                ///Emits `VestingCreated`.
                ///
                ///NOTE: This will unlock all schedules through the current block.
                ///
                ///## Complexity
                ///- `O(1)`.
                pub fn vested_transfer(
                    &self,
                    target: ::subxt::utils::MultiAddress<
                        ::subxt::utils::AccountId32,
                        ::core::primitive::u32,
                    >,
                    schedule: runtime_types::pallet_vesting::vesting_info::VestingInfo<
                        ::core::primitive::u128,
                        ::core::primitive::u32,
                    >,
                ) -> ::subxt::tx::Payload<types::VestedTransfer> {
                    ::subxt::tx::Payload::new_static(
                        "Vesting",
                        "vested_transfer",
                        types::VestedTransfer {
                            target,
                            schedule,
                        },
                        [
                            208u8,
                            95u8,
                            120u8,
                            179u8,
                            8u8,
                            246u8,
                            213u8,
                            174u8,
                            133u8,
                            234u8,
                            117u8,
                            13u8,
                            25u8,
                            32u8,
                            245u8,
                            101u8,
                            168u8,
                            94u8,
                            255u8,
                            193u8,
                            236u8,
                            177u8,
                            164u8,
                            62u8,
                            113u8,
                            181u8,
                            105u8,
                            49u8,
                            133u8,
                            9u8,
                            133u8,
                            244u8,
                        ],
                    )
                }
                ///Force a vested transfer.
                ///
                ///The dispatch origin for this call must be _Root_.
                ///
                ///- `source`: The account whose funds should be transferred.
                ///- `target`: The account that should be transferred the vested funds.
                ///- `schedule`: The vesting schedule attached to the transfer.
                ///
                ///Emits `VestingCreated`.
                ///
                ///NOTE: This will unlock all schedules through the current block.
                ///
                ///## Complexity
                ///- `O(1)`.
                pub fn force_vested_transfer(
                    &self,
                    source: ::subxt::utils::MultiAddress<
                        ::subxt::utils::AccountId32,
                        ::core::primitive::u32,
                    >,
                    target: ::subxt::utils::MultiAddress<
                        ::subxt::utils::AccountId32,
                        ::core::primitive::u32,
                    >,
                    schedule: runtime_types::pallet_vesting::vesting_info::VestingInfo<
                        ::core::primitive::u128,
                        ::core::primitive::u32,
                    >,
                ) -> ::subxt::tx::Payload<types::ForceVestedTransfer> {
                    ::subxt::tx::Payload::new_static(
                        "Vesting",
                        "force_vested_transfer",
                        types::ForceVestedTransfer {
                            source,
                            target,
                            schedule,
                        },
                        [
                            204u8,
                            15u8,
                            117u8,
                            96u8,
                            62u8,
                            131u8,
                            170u8,
                            139u8,
                            226u8,
                            58u8,
                            240u8,
                            170u8,
                            130u8,
                            15u8,
                            106u8,
                            168u8,
                            109u8,
                            93u8,
                            22u8,
                            185u8,
                            93u8,
                            211u8,
                            7u8,
                            234u8,
                            204u8,
                            30u8,
                            18u8,
                            239u8,
                            106u8,
                            196u8,
                            90u8,
                            240u8,
                        ],
                    )
                }
                ///Merge two vesting schedules together, creating a new vesting schedule that unlocks over
                ///the highest possible start and end blocks. If both schedules have already started the
                ///current block will be used as the schedule start; with the caveat that if one schedule
                ///is finished by the current block, the other will be treated as the new merged schedule,
                ///unmodified.
                ///
                ///NOTE: If `schedule1_index == schedule2_index` this is a no-op.
                ///NOTE: This will unlock all schedules through the current block prior to merging.
                ///NOTE: If both schedules have ended by the current block, no new schedule will be created
                ///and both will be removed.
                ///
                ///Merged schedule attributes:
                ///- `starting_block`: `MAX(schedule1.starting_block, scheduled2.starting_block,
                ///  current_block)`.
                ///- `ending_block`: `MAX(schedule1.ending_block, schedule2.ending_block)`.
                ///- `locked`: `schedule1.locked_at(current_block) + schedule2.locked_at(current_block)`.
                ///
                ///The dispatch origin for this call must be _Signed_.
                ///
                ///- `schedule1_index`: index of the first schedule to merge.
                ///- `schedule2_index`: index of the second schedule to merge.
                pub fn merge_schedules(
                    &self,
                    schedule1_index: ::core::primitive::u32,
                    schedule2_index: ::core::primitive::u32,
                ) -> ::subxt::tx::Payload<types::MergeSchedules> {
                    ::subxt::tx::Payload::new_static(
                        "Vesting",
                        "merge_schedules",
                        types::MergeSchedules {
                            schedule1_index,
                            schedule2_index,
                        },
                        [
                            135u8,
                            49u8,
                            137u8,
                            222u8,
                            134u8,
                            94u8,
                            197u8,
                            182u8,
                            171u8,
                            57u8,
                            161u8,
                            6u8,
                            185u8,
                            130u8,
                            45u8,
                            30u8,
                            79u8,
                            77u8,
                            157u8,
                            118u8,
                            35u8,
                            249u8,
                            39u8,
                            10u8,
                            103u8,
                            160u8,
                            198u8,
                            75u8,
                            26u8,
                            50u8,
                            64u8,
                            26u8,
                        ],
                    )
                }
            }
        }
        /**
			The [event](https://docs.substrate.io/main-docs/build/events-errors/) emitted
			by this pallet.
			*/
        pub type Event = runtime_types::pallet_vesting::pallet::Event;
        pub mod events {
            use super::runtime_types;
            #[derive(
                ::subxt::ext::codec::Decode,
                ::subxt::ext::codec::Encode,
                ::subxt::ext::scale_decode::DecodeAsType,
                ::subxt::ext::scale_encode::EncodeAsType,
                Clone,
                Debug,
                Eq,
                PartialEq
            )]
            #[codec(crate = ::subxt::ext::codec)]
            #[decode_as_type(crate_path = ":: subxt :: ext :: scale_decode")]
            #[encode_as_type(crate_path = ":: subxt :: ext :: scale_encode")]
            ///The amount vested has been updated. This could indicate a change in funds available.
            ///The balance given is the amount which is left unvested (and thus locked).
            pub struct VestingUpdated {
                pub account: ::subxt::utils::AccountId32,
                pub unvested: ::core::primitive::u128,
            }
            impl ::subxt::events::StaticEvent for VestingUpdated {
                const PALLET: &'static str = "Vesting";
                const EVENT: &'static str = "VestingUpdated";
            }
            #[derive(
                ::subxt::ext::codec::Decode,
                ::subxt::ext::codec::Encode,
                ::subxt::ext::scale_decode::DecodeAsType,
                ::subxt::ext::scale_encode::EncodeAsType,
                Clone,
                Debug,
                Eq,
                PartialEq
            )]
            #[codec(crate = ::subxt::ext::codec)]
            #[decode_as_type(crate_path = ":: subxt :: ext :: scale_decode")]
            #[encode_as_type(crate_path = ":: subxt :: ext :: scale_encode")]
            ///An \[account\] has become fully vested.
            pub struct VestingCompleted {
                pub account: ::subxt::utils::AccountId32,
            }
            impl ::subxt::events::StaticEvent for VestingCompleted {
                const PALLET: &'static str = "Vesting";
                const EVENT: &'static str = "VestingCompleted";
            }
        }
        pub mod storage {
            use super::runtime_types;
            pub struct StorageApi;
            impl StorageApi {
                /// Information regarding the vesting of a given account.
                pub fn vesting(
                    &self,
                    _0: impl ::std::borrow::Borrow<::subxt::utils::AccountId32>,
                ) -> ::subxt::storage::address::Address<
                    ::subxt::storage::address::StaticStorageMapKey,
                    runtime_types::bounded_collections::bounded_vec::BoundedVec<
                        runtime_types::pallet_vesting::vesting_info::VestingInfo<
                            ::core::primitive::u128,
                            ::core::primitive::u32,
                        >,
                    >,
                    ::subxt::storage::address::Yes,
                    (),
                    ::subxt::storage::address::Yes,
                > {
                    ::subxt::storage::address::Address::new_static(
                        "Vesting",
                        "Vesting",
                        vec![
                            ::subxt::storage::address::make_static_storage_map_key(_0
                            .borrow())
                        ],
                        [
                            10u8,
                            98u8,
                            73u8,
                            242u8,
                            215u8,
                            4u8,
                            45u8,
                            227u8,
                            73u8,
                            203u8,
                            33u8,
                            105u8,
                            228u8,
                            247u8,
                            125u8,
                            99u8,
                            98u8,
                            38u8,
                            176u8,
                            123u8,
                            233u8,
                            219u8,
                            174u8,
                            118u8,
                            49u8,
                            172u8,
                            58u8,
                            162u8,
                            186u8,
                            110u8,
                            147u8,
                            122u8,
                        ],
                    )
                }
                /// Information regarding the vesting of a given account.
                pub fn vesting_root(
                    &self,
                ) -> ::subxt::storage::address::Address<
                    ::subxt::storage::address::StaticStorageMapKey,
                    runtime_types::bounded_collections::bounded_vec::BoundedVec<
                        runtime_types::pallet_vesting::vesting_info::VestingInfo<
                            ::core::primitive::u128,
                            ::core::primitive::u32,
                        >,
                    >,
                    (),
                    (),
                    ::subxt::storage::address::Yes,
                > {
                    ::subxt::storage::address::Address::new_static(
                        "Vesting",
                        "Vesting",
                        Vec::new(),
                        [
                            10u8,
                            98u8,
                            73u8,
                            242u8,
                            215u8,
                            4u8,
                            45u8,
                            227u8,
                            73u8,
                            203u8,
                            33u8,
                            105u8,
                            228u8,
                            247u8,
                            125u8,
                            99u8,
                            98u8,
                            38u8,
                            176u8,
                            123u8,
                            233u8,
                            219u8,
                            174u8,
                            118u8,
                            49u8,
                            172u8,
                            58u8,
                            162u8,
                            186u8,
                            110u8,
                            147u8,
                            122u8,
                        ],
                    )
                }
                /// Storage version of the pallet.
                ///
                /// New networks start with latest version, as determined by the genesis build.
                pub fn storage_version(
                    &self,
                ) -> ::subxt::storage::address::Address<
                    ::subxt::storage::address::StaticStorageMapKey,
                    runtime_types::pallet_vesting::Releases,
                    ::subxt::storage::address::Yes,
                    ::subxt::storage::address::Yes,
                    (),
                > {
                    ::subxt::storage::address::Address::new_static(
                        "Vesting",
                        "StorageVersion",
                        vec![],
                        [
                            230u8,
                            137u8,
                            180u8,
                            133u8,
                            142u8,
                            124u8,
                            231u8,
                            234u8,
                            223u8,
                            10u8,
                            154u8,
                            98u8,
                            158u8,
                            253u8,
                            228u8,
                            80u8,
                            5u8,
                            9u8,
                            91u8,
                            210u8,
                            252u8,
                            9u8,
                            13u8,
                            195u8,
                            193u8,
                            164u8,
                            129u8,
                            113u8,
                            128u8,
                            218u8,
                            8u8,
                            40u8,
                        ],
                    )
                }
            }
        }
        pub mod constants {
            use super::runtime_types;
            pub struct ConstantsApi;
            impl ConstantsApi {
                /// The minimum amount transferred to call `vested_transfer`.
                pub fn min_vested_transfer(
                    &self,
                ) -> ::subxt::constants::Address<::core::primitive::u128> {
                    ::subxt::constants::Address::new_static(
                        "Vesting",
                        "MinVestedTransfer",
                        [
                            84u8,
                            157u8,
                            140u8,
                            4u8,
                            93u8,
                            57u8,
                            29u8,
                            133u8,
                            105u8,
                            200u8,
                            214u8,
                            27u8,
                            144u8,
                            208u8,
                            218u8,
                            160u8,
                            130u8,
                            109u8,
                            101u8,
                            54u8,
                            210u8,
                            136u8,
                            71u8,
                            63u8,
                            49u8,
                            237u8,
                            234u8,
                            15u8,
                            178u8,
                            98u8,
                            148u8,
                            156u8,
                        ],
                    )
                }
                pub fn max_vesting_schedules(
                    &self,
                ) -> ::subxt::constants::Address<::core::primitive::u32> {
                    ::subxt::constants::Address::new_static(
                        "Vesting",
                        "MaxVestingSchedules",
                        [
                            98u8,
                            252u8,
                            116u8,
                            72u8,
                            26u8,
                            180u8,
                            225u8,
                            83u8,
                            200u8,
                            157u8,
                            125u8,
                            151u8,
                            53u8,
                            76u8,
                            168u8,
                            26u8,
                            10u8,
                            9u8,
                            98u8,
                            68u8,
                            9u8,
                            178u8,
                            197u8,
                            113u8,
                            31u8,
                            79u8,
                            200u8,
                            90u8,
                            203u8,
                            100u8,
                            41u8,
                            145u8,
                        ],
                    )
                }
            }
        }
    }
    pub mod claims {
        use super::root_mod;
        use super::runtime_types;
        /**
			Custom [dispatch errors](https://docs.substrate.io/main-docs/build/events-errors/)
			of this pallet.
			*/
        pub type Error = runtime_types::pallet_ecdsa_claims::pallet::Error;
        ///Contains one variant per dispatchable that can be called by an extrinsic.
        pub type Call = runtime_types::pallet_ecdsa_claims::pallet::Call;
        pub mod calls {
            use super::root_mod;
            use super::runtime_types;
            type DispatchError = runtime_types::sp_runtime::DispatchError;
            pub mod types {
                use super::runtime_types;
                #[derive(
                    ::subxt::ext::codec::Decode,
                    ::subxt::ext::codec::Encode,
                    ::subxt::ext::scale_decode::DecodeAsType,
                    ::subxt::ext::scale_encode::EncodeAsType,
                    Clone,
                    Debug,
                    Eq,
                    PartialEq
                )]
                #[codec(crate = ::subxt::ext::codec)]
                #[decode_as_type(crate_path = ":: subxt :: ext :: scale_decode")]
                #[encode_as_type(crate_path = ":: subxt :: ext :: scale_encode")]
                pub struct Claim {
                    pub dest: ::subxt::utils::AccountId32,
                    pub ethereum_signature: runtime_types::pallet_ecdsa_claims::EcdsaSignature,
                }
                impl ::subxt::blocks::StaticExtrinsic for Claim {
                    const PALLET: &'static str = "Claims";
                    const CALL: &'static str = "claim";
                }
                #[derive(
                    ::subxt::ext::codec::Decode,
                    ::subxt::ext::codec::Encode,
                    ::subxt::ext::scale_decode::DecodeAsType,
                    ::subxt::ext::scale_encode::EncodeAsType,
                    Clone,
                    Debug,
                    Eq,
                    PartialEq
                )]
                #[codec(crate = ::subxt::ext::codec)]
                #[decode_as_type(crate_path = ":: subxt :: ext :: scale_decode")]
                #[encode_as_type(crate_path = ":: subxt :: ext :: scale_encode")]
                pub struct MintClaim {
                    pub who: runtime_types::pallet_ecdsa_claims::EthereumAddress,
                    pub value: ::core::primitive::u128,
                    pub vesting_schedule: ::core::option::Option<
                        (
                            ::core::primitive::u128,
                            ::core::primitive::u128,
                            ::core::primitive::u32,
                        ),
                    >,
                    pub statement: ::core::option::Option<
                        runtime_types::pallet_ecdsa_claims::StatementKind,
                    >,
                }
                impl ::subxt::blocks::StaticExtrinsic for MintClaim {
                    const PALLET: &'static str = "Claims";
                    const CALL: &'static str = "mint_claim";
                }
                #[derive(
                    ::subxt::ext::codec::Decode,
                    ::subxt::ext::codec::Encode,
                    ::subxt::ext::scale_decode::DecodeAsType,
                    ::subxt::ext::scale_encode::EncodeAsType,
                    Clone,
                    Debug,
                    Eq,
                    PartialEq
                )]
                #[codec(crate = ::subxt::ext::codec)]
                #[decode_as_type(crate_path = ":: subxt :: ext :: scale_decode")]
                #[encode_as_type(crate_path = ":: subxt :: ext :: scale_encode")]
                pub struct ClaimAttest {
                    pub dest: ::subxt::utils::AccountId32,
                    pub ethereum_signature: runtime_types::pallet_ecdsa_claims::EcdsaSignature,
                    pub statement: ::std::vec::Vec<::core::primitive::u8>,
                }
                impl ::subxt::blocks::StaticExtrinsic for ClaimAttest {
                    const PALLET: &'static str = "Claims";
                    const CALL: &'static str = "claim_attest";
                }
                #[derive(
                    ::subxt::ext::codec::Decode,
                    ::subxt::ext::codec::Encode,
                    ::subxt::ext::scale_decode::DecodeAsType,
                    ::subxt::ext::scale_encode::EncodeAsType,
                    Clone,
                    Debug,
                    Eq,
                    PartialEq
                )]
                #[codec(crate = ::subxt::ext::codec)]
                #[decode_as_type(crate_path = ":: subxt :: ext :: scale_decode")]
                #[encode_as_type(crate_path = ":: subxt :: ext :: scale_encode")]
                pub struct Attest {
                    pub statement: ::std::vec::Vec<::core::primitive::u8>,
                }
                impl ::subxt::blocks::StaticExtrinsic for Attest {
                    const PALLET: &'static str = "Claims";
                    const CALL: &'static str = "attest";
                }
                #[derive(
                    ::subxt::ext::codec::Decode,
                    ::subxt::ext::codec::Encode,
                    ::subxt::ext::scale_decode::DecodeAsType,
                    ::subxt::ext::scale_encode::EncodeAsType,
                    Clone,
                    Debug,
                    Eq,
                    PartialEq
                )]
                #[codec(crate = ::subxt::ext::codec)]
                #[decode_as_type(crate_path = ":: subxt :: ext :: scale_decode")]
                #[encode_as_type(crate_path = ":: subxt :: ext :: scale_encode")]
                pub struct MoveClaim {
                    pub old: runtime_types::pallet_ecdsa_claims::EthereumAddress,
                    pub new: runtime_types::pallet_ecdsa_claims::EthereumAddress,
                    pub maybe_preclaim: ::core::option::Option<
                        ::subxt::utils::AccountId32,
                    >,
                }
                impl ::subxt::blocks::StaticExtrinsic for MoveClaim {
                    const PALLET: &'static str = "Claims";
                    const CALL: &'static str = "move_claim";
                }
                #[derive(
                    ::subxt::ext::codec::Decode,
                    ::subxt::ext::codec::Encode,
                    ::subxt::ext::scale_decode::DecodeAsType,
                    ::subxt::ext::scale_encode::EncodeAsType,
                    Clone,
                    Debug,
                    Eq,
                    PartialEq
                )]
                #[codec(crate = ::subxt::ext::codec)]
                #[decode_as_type(crate_path = ":: subxt :: ext :: scale_decode")]
                #[encode_as_type(crate_path = ":: subxt :: ext :: scale_encode")]
                pub struct ForceSetExpiryConfig {
                    pub expiry_block: ::core::primitive::u32,
                    pub dest: ::subxt::utils::AccountId32,
                }
                impl ::subxt::blocks::StaticExtrinsic for ForceSetExpiryConfig {
                    const PALLET: &'static str = "Claims";
                    const CALL: &'static str = "force_set_expiry_config";
                }
            }
            pub struct TransactionApi;
            impl TransactionApi {
                ///Make a claim to collect your WEBBs.
                ///
                ///The dispatch origin for this call must be _None_.
                ///
                ///Unsigned Validation:
                ///A call to claim is deemed valid if the signature provided matches
                ///the expected signed message of:
                ///
                ///> Ethereum Signed Message:
                ///> (configured prefix string)(address)
                ///
                ///and `address` matches the `dest` account.
                ///
                ///Parameters:
                ///- `dest`: The destination account to payout the claim.
                ///- `ethereum_signature`: The signature of an ethereum signed message matching the format
                ///  described above.
                ///
                ///<weight>
                ///The weight of this call is invariant over the input parameters.
                ///Weight includes logic to validate unsigned `claim` call.
                ///
                ///Total Complexity: O(1)
                ///</weight>
                pub fn claim(
                    &self,
                    dest: ::subxt::utils::AccountId32,
                    ethereum_signature: runtime_types::pallet_ecdsa_claims::EcdsaSignature,
                ) -> ::subxt::tx::Payload<types::Claim> {
                    ::subxt::tx::Payload::new_static(
                        "Claims",
                        "claim",
                        types::Claim {
                            dest,
                            ethereum_signature,
                        },
                        [
                            83u8,
                            166u8,
                            82u8,
                            164u8,
                            185u8,
                            116u8,
                            35u8,
                            29u8,
                            60u8,
                            10u8,
                            92u8,
                            61u8,
                            212u8,
                            63u8,
                            236u8,
                            107u8,
                            19u8,
                            110u8,
                            100u8,
                            58u8,
                            154u8,
                            143u8,
                            188u8,
                            153u8,
                            34u8,
                            237u8,
                            60u8,
                            140u8,
                            194u8,
                            135u8,
                            227u8,
                            8u8,
                        ],
                    )
                }
                ///Mint a new claim to collect WEBBs.
                ///
                ///The dispatch origin for this call must be _Root_.
                ///
                ///Parameters:
                ///- `who`: The Ethereum address allowed to collect this claim.
                ///- `value`: The number of WEBBs that will be claimed.
                ///- `vesting_schedule`: An optional vesting schedule for these WEBBs.
                ///
                ///<weight>
                ///The weight of this call is invariant over the input parameters.
                ///We assume worst case that both vesting and statement is being inserted.
                ///
                ///Total Complexity: O(1)
                ///</weight>
                pub fn mint_claim(
                    &self,
                    who: runtime_types::pallet_ecdsa_claims::EthereumAddress,
                    value: ::core::primitive::u128,
                    vesting_schedule: ::core::option::Option<
                        (
                            ::core::primitive::u128,
                            ::core::primitive::u128,
                            ::core::primitive::u32,
                        ),
                    >,
                    statement: ::core::option::Option<
                        runtime_types::pallet_ecdsa_claims::StatementKind,
                    >,
                ) -> ::subxt::tx::Payload<types::MintClaim> {
                    ::subxt::tx::Payload::new_static(
                        "Claims",
                        "mint_claim",
                        types::MintClaim {
                            who,
                            value,
                            vesting_schedule,
                            statement,
                        },
                        [
                            254u8,
                            174u8,
                            70u8,
                            0u8,
                            70u8,
                            79u8,
                            195u8,
                            176u8,
                            196u8,
                            52u8,
                            204u8,
                            219u8,
                            158u8,
                            73u8,
                            158u8,
                            126u8,
                            14u8,
                            37u8,
                            45u8,
                            29u8,
                            249u8,
                            246u8,
                            3u8,
                            40u8,
                            72u8,
                            111u8,
                            213u8,
                            180u8,
                            201u8,
                            139u8,
                            175u8,
                            194u8,
                        ],
                    )
                }
                ///Make a claim to collect your WEBBs by signing a statement.
                ///
                ///The dispatch origin for this call must be _None_.
                ///
                ///Unsigned Validation:
                ///A call to `claim_attest` is deemed valid if the signature provided matches
                ///the expected signed message of:
                ///
                ///> Ethereum Signed Message:
                ///> (configured prefix string)(address)(statement)
                ///
                ///and `address` matches the `dest` account; the `statement` must match that which is
                ///expected according to your purchase arrangement.
                ///
                ///Parameters:
                ///- `dest`: The destination account to payout the claim.
                ///- `ethereum_signature`: The signature of an ethereum signed message matching the format
                ///  described above.
                ///- `statement`: The identity of the statement which is being attested to in the
                ///  signature.
                ///
                ///<weight>
                ///The weight of this call is invariant over the input parameters.
                ///Weight includes logic to validate unsigned `claim_attest` call.
                ///
                ///Total Complexity: O(1)
                ///</weight>
                pub fn claim_attest(
                    &self,
                    dest: ::subxt::utils::AccountId32,
                    ethereum_signature: runtime_types::pallet_ecdsa_claims::EcdsaSignature,
                    statement: ::std::vec::Vec<::core::primitive::u8>,
                ) -> ::subxt::tx::Payload<types::ClaimAttest> {
                    ::subxt::tx::Payload::new_static(
                        "Claims",
                        "claim_attest",
                        types::ClaimAttest {
                            dest,
                            ethereum_signature,
                            statement,
                        },
                        [
                            18u8,
                            79u8,
                            43u8,
                            28u8,
                            88u8,
                            151u8,
                            46u8,
                            15u8,
                            28u8,
                            146u8,
                            210u8,
                            235u8,
                            158u8,
                            64u8,
                            236u8,
                            204u8,
                            89u8,
                            174u8,
                            250u8,
                            114u8,
                            45u8,
                            3u8,
                            17u8,
                            129u8,
                            147u8,
                            69u8,
                            232u8,
                            181u8,
                            71u8,
                            98u8,
                            5u8,
                            244u8,
                        ],
                    )
                }
                ///Attest to a statement, needed to finalize the claims process.
                ///
                ///WARNING: Insecure unless your chain includes `PrevalidateAttests` as a
                ///`SignedExtension`.
                ///
                ///Unsigned Validation:
                ///A call to attest is deemed valid if the sender has a `Preclaim` registered
                ///and provides a `statement` which is expected for the account.
                ///
                ///Parameters:
                ///- `statement`: The identity of the statement which is being attested to in the
                ///  signature.
                ///
                ///<weight>
                ///The weight of this call is invariant over the input parameters.
                ///Weight includes logic to do pre-validation on `attest` call.
                ///
                ///Total Complexity: O(1)
                ///</weight>
                pub fn attest(
                    &self,
                    statement: ::std::vec::Vec<::core::primitive::u8>,
                ) -> ::subxt::tx::Payload<types::Attest> {
                    ::subxt::tx::Payload::new_static(
                        "Claims",
                        "attest",
                        types::Attest { statement },
                        [
                            254u8,
                            56u8,
                            140u8,
                            129u8,
                            227u8,
                            155u8,
                            161u8,
                            107u8,
                            167u8,
                            148u8,
                            167u8,
                            104u8,
                            139u8,
                            174u8,
                            204u8,
                            124u8,
                            126u8,
                            198u8,
                            165u8,
                            61u8,
                            83u8,
                            197u8,
                            242u8,
                            13u8,
                            70u8,
                            153u8,
                            14u8,
                            62u8,
                            214u8,
                            129u8,
                            64u8,
                            93u8,
                        ],
                    )
                }
                pub fn move_claim(
                    &self,
                    old: runtime_types::pallet_ecdsa_claims::EthereumAddress,
                    new: runtime_types::pallet_ecdsa_claims::EthereumAddress,
                    maybe_preclaim: ::core::option::Option<::subxt::utils::AccountId32>,
                ) -> ::subxt::tx::Payload<types::MoveClaim> {
                    ::subxt::tx::Payload::new_static(
                        "Claims",
                        "move_claim",
                        types::MoveClaim {
                            old,
                            new,
                            maybe_preclaim,
                        },
                        [
                            82u8,
                            63u8,
                            8u8,
                            178u8,
                            205u8,
                            16u8,
                            182u8,
                            216u8,
                            80u8,
                            254u8,
                            48u8,
                            10u8,
                            52u8,
                            159u8,
                            198u8,
                            116u8,
                            164u8,
                            108u8,
                            209u8,
                            193u8,
                            60u8,
                            139u8,
                            241u8,
                            135u8,
                            92u8,
                            103u8,
                            241u8,
                            52u8,
                            103u8,
                            52u8,
                            243u8,
                            0u8,
                        ],
                    )
                }
                ///Set the value for expiryconfig
                ///Can only be called by ForceOrigin
                pub fn force_set_expiry_config(
                    &self,
                    expiry_block: ::core::primitive::u32,
                    dest: ::subxt::utils::AccountId32,
                ) -> ::subxt::tx::Payload<types::ForceSetExpiryConfig> {
                    ::subxt::tx::Payload::new_static(
                        "Claims",
                        "force_set_expiry_config",
                        types::ForceSetExpiryConfig {
                            expiry_block,
                            dest,
                        },
                        [
                            162u8,
                            211u8,
                            180u8,
                            76u8,
                            192u8,
                            117u8,
                            104u8,
                            228u8,
                            230u8,
                            243u8,
                            227u8,
                            47u8,
                            177u8,
                            101u8,
                            35u8,
                            41u8,
                            44u8,
                            255u8,
                            249u8,
                            172u8,
                            247u8,
                            248u8,
                            21u8,
                            219u8,
                            125u8,
                            252u8,
                            13u8,
                            7u8,
                            146u8,
                            60u8,
                            57u8,
                            186u8,
                        ],
                    )
                }
            }
        }
        /**
			The [event](https://docs.substrate.io/main-docs/build/events-errors/) emitted
			by this pallet.
			*/
        pub type Event = runtime_types::pallet_ecdsa_claims::pallet::Event;
        pub mod events {
            use super::runtime_types;
            #[derive(
                ::subxt::ext::codec::Decode,
                ::subxt::ext::codec::Encode,
                ::subxt::ext::scale_decode::DecodeAsType,
                ::subxt::ext::scale_encode::EncodeAsType,
                Clone,
                Debug,
                Eq,
                PartialEq
            )]
            #[codec(crate = ::subxt::ext::codec)]
            #[decode_as_type(crate_path = ":: subxt :: ext :: scale_decode")]
            #[encode_as_type(crate_path = ":: subxt :: ext :: scale_encode")]
            ///Someone claimed some WEBBs.
            pub struct Claimed {
                pub who: ::subxt::utils::AccountId32,
                pub ethereum_address: runtime_types::pallet_ecdsa_claims::EthereumAddress,
                pub amount: ::core::primitive::u128,
            }
            impl ::subxt::events::StaticEvent for Claimed {
                const PALLET: &'static str = "Claims";
                const EVENT: &'static str = "Claimed";
            }
        }
        pub mod storage {
            use super::runtime_types;
            pub struct StorageApi;
            impl StorageApi {
                pub fn claims(
                    &self,
                    _0: impl ::std::borrow::Borrow<
                        runtime_types::pallet_ecdsa_claims::EthereumAddress,
                    >,
                ) -> ::subxt::storage::address::Address<
                    ::subxt::storage::address::StaticStorageMapKey,
                    ::core::primitive::u128,
                    ::subxt::storage::address::Yes,
                    (),
                    ::subxt::storage::address::Yes,
                > {
                    ::subxt::storage::address::Address::new_static(
                        "Claims",
                        "Claims",
                        vec![
                            ::subxt::storage::address::make_static_storage_map_key(_0
                            .borrow())
                        ],
                        [
                            148u8,
                            115u8,
                            159u8,
                            169u8,
                            36u8,
                            116u8,
                            15u8,
                            108u8,
                            57u8,
                            195u8,
                            226u8,
                            180u8,
                            187u8,
                            112u8,
                            114u8,
                            63u8,
                            3u8,
                            205u8,
                            113u8,
                            141u8,
                            149u8,
                            149u8,
                            118u8,
                            246u8,
                            45u8,
                            245u8,
                            148u8,
                            108u8,
                            22u8,
                            184u8,
                            152u8,
                            132u8,
                        ],
                    )
                }
                pub fn claims_root(
                    &self,
                ) -> ::subxt::storage::address::Address<
                    ::subxt::storage::address::StaticStorageMapKey,
                    ::core::primitive::u128,
                    (),
                    (),
                    ::subxt::storage::address::Yes,
                > {
                    ::subxt::storage::address::Address::new_static(
                        "Claims",
                        "Claims",
                        Vec::new(),
                        [
                            148u8,
                            115u8,
                            159u8,
                            169u8,
                            36u8,
                            116u8,
                            15u8,
                            108u8,
                            57u8,
                            195u8,
                            226u8,
                            180u8,
                            187u8,
                            112u8,
                            114u8,
                            63u8,
                            3u8,
                            205u8,
                            113u8,
                            141u8,
                            149u8,
                            149u8,
                            118u8,
                            246u8,
                            45u8,
                            245u8,
                            148u8,
                            108u8,
                            22u8,
                            184u8,
                            152u8,
                            132u8,
                        ],
                    )
                }
                pub fn total(
                    &self,
                ) -> ::subxt::storage::address::Address<
                    ::subxt::storage::address::StaticStorageMapKey,
                    ::core::primitive::u128,
                    ::subxt::storage::address::Yes,
                    ::subxt::storage::address::Yes,
                    (),
                > {
                    ::subxt::storage::address::Address::new_static(
                        "Claims",
                        "Total",
                        vec![],
                        [
                            188u8,
                            31u8,
                            219u8,
                            189u8,
                            49u8,
                            213u8,
                            203u8,
                            89u8,
                            125u8,
                            58u8,
                            232u8,
                            159u8,
                            131u8,
                            155u8,
                            166u8,
                            113u8,
                            99u8,
                            24u8,
                            40u8,
                            242u8,
                            118u8,
                            183u8,
                            108u8,
                            230u8,
                            135u8,
                            150u8,
                            84u8,
                            86u8,
                            118u8,
                            91u8,
                            168u8,
                            62u8,
                        ],
                    )
                }
                /// Expiry block and account to deposit expired funds
                pub fn expiry_config(
                    &self,
                ) -> ::subxt::storage::address::Address<
                    ::subxt::storage::address::StaticStorageMapKey,
                    (::core::primitive::u32, ::subxt::utils::AccountId32),
                    ::subxt::storage::address::Yes,
                    (),
                    (),
                > {
                    ::subxt::storage::address::Address::new_static(
                        "Claims",
                        "ExpiryConfig",
                        vec![],
                        [
                            80u8,
                            129u8,
                            105u8,
                            115u8,
                            6u8,
                            95u8,
                            124u8,
                            125u8,
                            23u8,
                            145u8,
                            239u8,
                            227u8,
                            228u8,
                            53u8,
                            219u8,
                            20u8,
                            27u8,
                            234u8,
                            85u8,
                            92u8,
                            10u8,
                            11u8,
                            205u8,
                            159u8,
                            54u8,
                            106u8,
                            18u8,
                            240u8,
                            20u8,
                            142u8,
                            199u8,
                            167u8,
                        ],
                    )
                }
                /// Vesting schedule for a claim.
                /// First balance is the total amount that should be held for vesting.
                /// Second balance is how much should be unlocked per block.
                /// The block number is when the vesting should start.
                pub fn vesting(
                    &self,
                    _0: impl ::std::borrow::Borrow<
                        runtime_types::pallet_ecdsa_claims::EthereumAddress,
                    >,
                ) -> ::subxt::storage::address::Address<
                    ::subxt::storage::address::StaticStorageMapKey,
                    (
                        ::core::primitive::u128,
                        ::core::primitive::u128,
                        ::core::primitive::u32,
                    ),
                    ::subxt::storage::address::Yes,
                    (),
                    ::subxt::storage::address::Yes,
                > {
                    ::subxt::storage::address::Address::new_static(
                        "Claims",
                        "Vesting",
                        vec![
                            ::subxt::storage::address::make_static_storage_map_key(_0
                            .borrow())
                        ],
                        [
                            16u8,
                            107u8,
                            69u8,
                            162u8,
                            210u8,
                            200u8,
                            188u8,
                            185u8,
                            69u8,
                            90u8,
                            209u8,
                            238u8,
                            167u8,
                            173u8,
                            193u8,
                            118u8,
                            58u8,
                            17u8,
                            68u8,
                            136u8,
                            163u8,
                            207u8,
                            34u8,
                            226u8,
                            174u8,
                            199u8,
                            127u8,
                            4u8,
                            225u8,
                            198u8,
                            143u8,
                            180u8,
                        ],
                    )
                }
                /// Vesting schedule for a claim.
                /// First balance is the total amount that should be held for vesting.
                /// Second balance is how much should be unlocked per block.
                /// The block number is when the vesting should start.
                pub fn vesting_root(
                    &self,
                ) -> ::subxt::storage::address::Address<
                    ::subxt::storage::address::StaticStorageMapKey,
                    (
                        ::core::primitive::u128,
                        ::core::primitive::u128,
                        ::core::primitive::u32,
                    ),
                    (),
                    (),
                    ::subxt::storage::address::Yes,
                > {
                    ::subxt::storage::address::Address::new_static(
                        "Claims",
                        "Vesting",
                        Vec::new(),
                        [
                            16u8,
                            107u8,
                            69u8,
                            162u8,
                            210u8,
                            200u8,
                            188u8,
                            185u8,
                            69u8,
                            90u8,
                            209u8,
                            238u8,
                            167u8,
                            173u8,
                            193u8,
                            118u8,
                            58u8,
                            17u8,
                            68u8,
                            136u8,
                            163u8,
                            207u8,
                            34u8,
                            226u8,
                            174u8,
                            199u8,
                            127u8,
                            4u8,
                            225u8,
                            198u8,
                            143u8,
                            180u8,
                        ],
                    )
                }
                /// The statement kind that must be signed, if any.
                pub fn signing(
                    &self,
                    _0: impl ::std::borrow::Borrow<
                        runtime_types::pallet_ecdsa_claims::EthereumAddress,
                    >,
                ) -> ::subxt::storage::address::Address<
                    ::subxt::storage::address::StaticStorageMapKey,
                    runtime_types::pallet_ecdsa_claims::StatementKind,
                    ::subxt::storage::address::Yes,
                    (),
                    ::subxt::storage::address::Yes,
                > {
                    ::subxt::storage::address::Address::new_static(
                        "Claims",
                        "Signing",
                        vec![
                            ::subxt::storage::address::make_static_storage_map_key(_0
                            .borrow())
                        ],
                        [
                            111u8,
                            90u8,
                            178u8,
                            121u8,
                            241u8,
                            28u8,
                            169u8,
                            231u8,
                            61u8,
                            189u8,
                            113u8,
                            207u8,
                            26u8,
                            153u8,
                            189u8,
                            15u8,
                            192u8,
                            25u8,
                            22u8,
                            22u8,
                            124u8,
                            26u8,
                            191u8,
                            39u8,
                            130u8,
                            164u8,
                            34u8,
                            4u8,
                            44u8,
                            91u8,
                            82u8,
                            186u8,
                        ],
                    )
                }
                /// The statement kind that must be signed, if any.
                pub fn signing_root(
                    &self,
                ) -> ::subxt::storage::address::Address<
                    ::subxt::storage::address::StaticStorageMapKey,
                    runtime_types::pallet_ecdsa_claims::StatementKind,
                    (),
                    (),
                    ::subxt::storage::address::Yes,
                > {
                    ::subxt::storage::address::Address::new_static(
                        "Claims",
                        "Signing",
                        Vec::new(),
                        [
                            111u8,
                            90u8,
                            178u8,
                            121u8,
                            241u8,
                            28u8,
                            169u8,
                            231u8,
                            61u8,
                            189u8,
                            113u8,
                            207u8,
                            26u8,
                            153u8,
                            189u8,
                            15u8,
                            192u8,
                            25u8,
                            22u8,
                            22u8,
                            124u8,
                            26u8,
                            191u8,
                            39u8,
                            130u8,
                            164u8,
                            34u8,
                            4u8,
                            44u8,
                            91u8,
                            82u8,
                            186u8,
                        ],
                    )
                }
                /// Pre-claimed Ethereum accounts, by the Account ID that they are claimed to.
                pub fn preclaims(
                    &self,
                    _0: impl ::std::borrow::Borrow<::subxt::utils::AccountId32>,
                ) -> ::subxt::storage::address::Address<
                    ::subxt::storage::address::StaticStorageMapKey,
                    runtime_types::pallet_ecdsa_claims::EthereumAddress,
                    ::subxt::storage::address::Yes,
                    (),
                    ::subxt::storage::address::Yes,
                > {
                    ::subxt::storage::address::Address::new_static(
                        "Claims",
                        "Preclaims",
                        vec![
                            ::subxt::storage::address::make_static_storage_map_key(_0
                            .borrow())
                        ],
                        [
                            154u8,
                            182u8,
                            178u8,
                            76u8,
                            81u8,
                            63u8,
                            87u8,
                            179u8,
                            243u8,
                            104u8,
                            206u8,
                            75u8,
                            114u8,
                            83u8,
                            16u8,
                            233u8,
                            22u8,
                            132u8,
                            207u8,
                            36u8,
                            151u8,
                            179u8,
                            94u8,
                            208u8,
                            210u8,
                            202u8,
                            149u8,
                            248u8,
                            9u8,
                            49u8,
                            140u8,
                            94u8,
                        ],
                    )
                }
                /// Pre-claimed Ethereum accounts, by the Account ID that they are claimed to.
                pub fn preclaims_root(
                    &self,
                ) -> ::subxt::storage::address::Address<
                    ::subxt::storage::address::StaticStorageMapKey,
                    runtime_types::pallet_ecdsa_claims::EthereumAddress,
                    (),
                    (),
                    ::subxt::storage::address::Yes,
                > {
                    ::subxt::storage::address::Address::new_static(
                        "Claims",
                        "Preclaims",
                        Vec::new(),
                        [
                            154u8,
                            182u8,
                            178u8,
                            76u8,
                            81u8,
                            63u8,
                            87u8,
                            179u8,
                            243u8,
                            104u8,
                            206u8,
                            75u8,
                            114u8,
                            83u8,
                            16u8,
                            233u8,
                            22u8,
                            132u8,
                            207u8,
                            36u8,
                            151u8,
                            179u8,
                            94u8,
                            208u8,
                            210u8,
                            202u8,
                            149u8,
                            248u8,
                            9u8,
                            49u8,
                            140u8,
                            94u8,
                        ],
                    )
                }
            }
        }
        pub mod constants {
            use super::runtime_types;
            pub struct ConstantsApi;
            impl ConstantsApi {
                pub fn prefix(
                    &self,
                ) -> ::subxt::constants::Address<
                    ::std::vec::Vec<::core::primitive::u8>,
                > {
                    ::subxt::constants::Address::new_static(
                        "Claims",
                        "Prefix",
                        [
                            64u8,
                            190u8,
                            244u8,
                            122u8,
                            87u8,
                            182u8,
                            217u8,
                            16u8,
                            55u8,
                            223u8,
                            128u8,
                            6u8,
                            112u8,
                            30u8,
                            236u8,
                            222u8,
                            153u8,
                            53u8,
                            247u8,
                            102u8,
                            196u8,
                            31u8,
                            6u8,
                            186u8,
                            251u8,
                            209u8,
                            114u8,
                            125u8,
                            213u8,
                            222u8,
                            240u8,
                            8u8,
                        ],
                    )
                }
            }
        }
    }
    pub mod elections {
        use super::root_mod;
        use super::runtime_types;
        /**
			Custom [dispatch errors](https://docs.substrate.io/main-docs/build/events-errors/)
			of this pallet.
			*/
        pub type Error = runtime_types::pallet_elections_phragmen::pallet::Error;
        ///Contains one variant per dispatchable that can be called by an extrinsic.
        pub type Call = runtime_types::pallet_elections_phragmen::pallet::Call;
        pub mod calls {
            use super::root_mod;
            use super::runtime_types;
            type DispatchError = runtime_types::sp_runtime::DispatchError;
            pub mod types {
                use super::runtime_types;
                #[derive(
                    ::subxt::ext::codec::Decode,
                    ::subxt::ext::codec::Encode,
                    ::subxt::ext::scale_decode::DecodeAsType,
                    ::subxt::ext::scale_encode::EncodeAsType,
                    Clone,
                    Debug,
                    Eq,
                    PartialEq
                )]
                #[codec(crate = ::subxt::ext::codec)]
                #[decode_as_type(crate_path = ":: subxt :: ext :: scale_decode")]
                #[encode_as_type(crate_path = ":: subxt :: ext :: scale_encode")]
                pub struct Vote {
                    pub votes: ::std::vec::Vec<::subxt::utils::AccountId32>,
                    #[codec(compact)]
                    pub value: ::core::primitive::u128,
                }
                impl ::subxt::blocks::StaticExtrinsic for Vote {
                    const PALLET: &'static str = "Elections";
                    const CALL: &'static str = "vote";
                }
                #[derive(
                    ::subxt::ext::codec::Decode,
                    ::subxt::ext::codec::Encode,
                    ::subxt::ext::scale_decode::DecodeAsType,
                    ::subxt::ext::scale_encode::EncodeAsType,
                    Clone,
                    Debug,
                    Eq,
                    PartialEq
                )]
                #[codec(crate = ::subxt::ext::codec)]
                #[decode_as_type(crate_path = ":: subxt :: ext :: scale_decode")]
                #[encode_as_type(crate_path = ":: subxt :: ext :: scale_encode")]
                pub struct RemoveVoter;
                impl ::subxt::blocks::StaticExtrinsic for RemoveVoter {
                    const PALLET: &'static str = "Elections";
                    const CALL: &'static str = "remove_voter";
                }
                #[derive(
                    ::subxt::ext::codec::Decode,
                    ::subxt::ext::codec::Encode,
                    ::subxt::ext::scale_decode::DecodeAsType,
                    ::subxt::ext::scale_encode::EncodeAsType,
                    Clone,
                    Debug,
                    Eq,
                    PartialEq
                )]
                #[codec(crate = ::subxt::ext::codec)]
                #[decode_as_type(crate_path = ":: subxt :: ext :: scale_decode")]
                #[encode_as_type(crate_path = ":: subxt :: ext :: scale_encode")]
                pub struct SubmitCandidacy {
                    #[codec(compact)]
                    pub candidate_count: ::core::primitive::u32,
                }
                impl ::subxt::blocks::StaticExtrinsic for SubmitCandidacy {
                    const PALLET: &'static str = "Elections";
                    const CALL: &'static str = "submit_candidacy";
                }
                #[derive(
                    ::subxt::ext::codec::Decode,
                    ::subxt::ext::codec::Encode,
                    ::subxt::ext::scale_decode::DecodeAsType,
                    ::subxt::ext::scale_encode::EncodeAsType,
                    Clone,
                    Debug,
                    Eq,
                    PartialEq
                )]
                #[codec(crate = ::subxt::ext::codec)]
                #[decode_as_type(crate_path = ":: subxt :: ext :: scale_decode")]
                #[encode_as_type(crate_path = ":: subxt :: ext :: scale_encode")]
                pub struct RenounceCandidacy {
                    pub renouncing: runtime_types::pallet_elections_phragmen::Renouncing,
                }
                impl ::subxt::blocks::StaticExtrinsic for RenounceCandidacy {
                    const PALLET: &'static str = "Elections";
                    const CALL: &'static str = "renounce_candidacy";
                }
                #[derive(
                    ::subxt::ext::codec::Decode,
                    ::subxt::ext::codec::Encode,
                    ::subxt::ext::scale_decode::DecodeAsType,
                    ::subxt::ext::scale_encode::EncodeAsType,
                    Clone,
                    Debug,
                    Eq,
                    PartialEq
                )]
                #[codec(crate = ::subxt::ext::codec)]
                #[decode_as_type(crate_path = ":: subxt :: ext :: scale_decode")]
                #[encode_as_type(crate_path = ":: subxt :: ext :: scale_encode")]
                pub struct RemoveMember {
                    pub who: ::subxt::utils::MultiAddress<
                        ::subxt::utils::AccountId32,
                        ::core::primitive::u32,
                    >,
                    pub slash_bond: ::core::primitive::bool,
                    pub rerun_election: ::core::primitive::bool,
                }
                impl ::subxt::blocks::StaticExtrinsic for RemoveMember {
                    const PALLET: &'static str = "Elections";
                    const CALL: &'static str = "remove_member";
                }
                #[derive(
                    ::subxt::ext::codec::Decode,
                    ::subxt::ext::codec::Encode,
                    ::subxt::ext::scale_decode::DecodeAsType,
                    ::subxt::ext::scale_encode::EncodeAsType,
                    Clone,
                    Debug,
                    Eq,
                    PartialEq
                )]
                #[codec(crate = ::subxt::ext::codec)]
                #[decode_as_type(crate_path = ":: subxt :: ext :: scale_decode")]
                #[encode_as_type(crate_path = ":: subxt :: ext :: scale_encode")]
                pub struct CleanDefunctVoters {
                    pub num_voters: ::core::primitive::u32,
                    pub num_defunct: ::core::primitive::u32,
                }
                impl ::subxt::blocks::StaticExtrinsic for CleanDefunctVoters {
                    const PALLET: &'static str = "Elections";
                    const CALL: &'static str = "clean_defunct_voters";
                }
            }
            pub struct TransactionApi;
            impl TransactionApi {
                ///Vote for a set of candidates for the upcoming round of election. This can be called to
                ///set the initial votes, or update already existing votes.
                ///
                ///Upon initial voting, `value` units of `who`'s balance is locked and a deposit amount is
                ///reserved. The deposit is based on the number of votes and can be updated over time.
                ///
                ///The `votes` should:
                ///  - not be empty.
                ///  - be less than the number of possible candidates. Note that all current members and
                ///    runners-up are also automatically candidates for the next round.
                ///
                ///If `value` is more than `who`'s free balance, then the maximum of the two is used.
                ///
                ///The dispatch origin of this call must be signed.
                ///
                ///### Warning
                ///
                ///It is the responsibility of the caller to **NOT** place all of their balance into the
                ///lock and keep some for further operations.
                pub fn vote(
                    &self,
                    votes: ::std::vec::Vec<::subxt::utils::AccountId32>,
                    value: ::core::primitive::u128,
                ) -> ::subxt::tx::Payload<types::Vote> {
                    ::subxt::tx::Payload::new_static(
                        "Elections",
                        "vote",
                        types::Vote { votes, value },
                        [
                            229u8,
                            163u8,
                            1u8,
                            49u8,
                            26u8,
                            130u8,
                            7u8,
                            228u8,
                            34u8,
                            80u8,
                            17u8,
                            125u8,
                            32u8,
                            180u8,
                            174u8,
                            69u8,
                            17u8,
                            171u8,
                            163u8,
                            54u8,
                            42u8,
                            139u8,
                            201u8,
                            205u8,
                            196u8,
                            18u8,
                            16u8,
                            211u8,
                            252u8,
                            64u8,
                            73u8,
                            5u8,
                        ],
                    )
                }
                ///Remove `origin` as a voter.
                ///
                ///This removes the lock and returns the deposit.
                ///
                ///The dispatch origin of this call must be signed and be a voter.
                pub fn remove_voter(&self) -> ::subxt::tx::Payload<types::RemoveVoter> {
                    ::subxt::tx::Payload::new_static(
                        "Elections",
                        "remove_voter",
                        types::RemoveVoter {},
                        [
                            89u8,
                            43u8,
                            70u8,
                            117u8,
                            76u8,
                            84u8,
                            230u8,
                            114u8,
                            229u8,
                            91u8,
                            75u8,
                            213u8,
                            47u8,
                            143u8,
                            233u8,
                            47u8,
                            108u8,
                            120u8,
                            171u8,
                            167u8,
                            14u8,
                            62u8,
                            52u8,
                            20u8,
                            227u8,
                            106u8,
                            249u8,
                            239u8,
                            33u8,
                            115u8,
                            155u8,
                            106u8,
                        ],
                    )
                }
                ///Submit oneself for candidacy. A fixed amount of deposit is recorded.
                ///
                ///All candidates are wiped at the end of the term. They either become a member/runner-up,
                ///or leave the system while their deposit is slashed.
                ///
                ///The dispatch origin of this call must be signed.
                ///
                ///### Warning
                ///
                ///Even if a candidate ends up being a member, they must call [`Call::renounce_candidacy`]
                ///to get their deposit back. Losing the spot in an election will always lead to a slash.
                ///
                ///The number of current candidates must be provided as witness data.
                ///## Complexity
                ///O(C + log(C)) where C is candidate_count.
                pub fn submit_candidacy(
                    &self,
                    candidate_count: ::core::primitive::u32,
                ) -> ::subxt::tx::Payload<types::SubmitCandidacy> {
                    ::subxt::tx::Payload::new_static(
                        "Elections",
                        "submit_candidacy",
                        types::SubmitCandidacy {
                            candidate_count,
                        },
                        [
                            229u8,
                            169u8,
                            247u8,
                            102u8,
                            33u8,
                            7u8,
                            9u8,
                            125u8,
                            190u8,
                            179u8,
                            241u8,
                            220u8,
                            205u8,
                            242u8,
                            168u8,
                            112u8,
                            197u8,
                            169u8,
                            135u8,
                            133u8,
                            102u8,
                            173u8,
                            168u8,
                            203u8,
                            17u8,
                            135u8,
                            224u8,
                            145u8,
                            101u8,
                            204u8,
                            253u8,
                            4u8,
                        ],
                    )
                }
                ///Renounce one's intention to be a candidate for the next election round. 3 potential
                ///outcomes exist:
                ///
                ///- `origin` is a candidate and not elected in any set. In this case, the deposit is
                ///  unreserved, returned and origin is removed as a candidate.
                ///- `origin` is a current runner-up. In this case, the deposit is unreserved, returned and
                ///  origin is removed as a runner-up.
                ///- `origin` is a current member. In this case, the deposit is unreserved and origin is
                ///  removed as a member, consequently not being a candidate for the next round anymore.
                ///  Similar to [`remove_member`](Self::remove_member), if replacement runners exists, they
                ///  are immediately used. If the prime is renouncing, then no prime will exist until the
                ///  next round.
                ///
                ///The dispatch origin of this call must be signed, and have one of the above roles.
                ///The type of renouncing must be provided as witness data.
                ///
                ///## Complexity
                ///  - Renouncing::Candidate(count): O(count + log(count))
                ///  - Renouncing::Member: O(1)
                ///  - Renouncing::RunnerUp: O(1)
                pub fn renounce_candidacy(
                    &self,
                    renouncing: runtime_types::pallet_elections_phragmen::Renouncing,
                ) -> ::subxt::tx::Payload<types::RenounceCandidacy> {
                    ::subxt::tx::Payload::new_static(
                        "Elections",
                        "renounce_candidacy",
                        types::RenounceCandidacy {
                            renouncing,
                        },
                        [
                            230u8,
                            140u8,
                            205u8,
                            240u8,
                            110u8,
                            247u8,
                            242u8,
                            185u8,
                            228u8,
                            135u8,
                            243u8,
                            73u8,
                            71u8,
                            200u8,
                            88u8,
                            134u8,
                            132u8,
                            174u8,
                            190u8,
                            251u8,
                            81u8,
                            85u8,
                            174u8,
                            230u8,
                            94u8,
                            97u8,
                            96u8,
                            230u8,
                            15u8,
                            204u8,
                            247u8,
                            214u8,
                        ],
                    )
                }
                ///Remove a particular member from the set. This is effective immediately and the bond of
                ///the outgoing member is slashed.
                ///
                ///If a runner-up is available, then the best runner-up will be removed and replaces the
                ///outgoing member. Otherwise, if `rerun_election` is `true`, a new phragmen election is
                ///started, else, nothing happens.
                ///
                ///If `slash_bond` is set to true, the bond of the member being removed is slashed. Else,
                ///it is returned.
                ///
                ///The dispatch origin of this call must be root.
                ///
                ///Note that this does not affect the designated block number of the next election.
                ///
                ///## Complexity
                ///- Check details of remove_and_replace_member() and do_phragmen().
                pub fn remove_member(
                    &self,
                    who: ::subxt::utils::MultiAddress<
                        ::subxt::utils::AccountId32,
                        ::core::primitive::u32,
                    >,
                    slash_bond: ::core::primitive::bool,
                    rerun_election: ::core::primitive::bool,
                ) -> ::subxt::tx::Payload<types::RemoveMember> {
                    ::subxt::tx::Payload::new_static(
                        "Elections",
                        "remove_member",
                        types::RemoveMember {
                            who,
                            slash_bond,
                            rerun_election,
                        },
                        [
                            121u8,
                            189u8,
                            213u8,
                            154u8,
                            126u8,
                            196u8,
                            140u8,
                            208u8,
                            152u8,
                            191u8,
                            224u8,
                            160u8,
                            42u8,
                            2u8,
                            243u8,
                            37u8,
                            120u8,
                            73u8,
                            160u8,
                            5u8,
                            243u8,
                            110u8,
                            167u8,
                            242u8,
                            22u8,
                            100u8,
                            93u8,
                            197u8,
                            209u8,
                            85u8,
                            201u8,
                            153u8,
                        ],
                    )
                }
                ///Clean all voters who are defunct (i.e. they do not serve any purpose at all). The
                ///deposit of the removed voters are returned.
                ///
                ///This is an root function to be used only for cleaning the state.
                ///
                ///The dispatch origin of this call must be root.
                ///
                ///## Complexity
                ///- Check is_defunct_voter() details.
                pub fn clean_defunct_voters(
                    &self,
                    num_voters: ::core::primitive::u32,
                    num_defunct: ::core::primitive::u32,
                ) -> ::subxt::tx::Payload<types::CleanDefunctVoters> {
                    ::subxt::tx::Payload::new_static(
                        "Elections",
                        "clean_defunct_voters",
                        types::CleanDefunctVoters {
                            num_voters,
                            num_defunct,
                        },
                        [
                            103u8,
                            241u8,
                            66u8,
                            156u8,
                            118u8,
                            36u8,
                            101u8,
                            148u8,
                            76u8,
                            162u8,
                            240u8,
                            31u8,
                            114u8,
                            10u8,
                            247u8,
                            68u8,
                            163u8,
                            187u8,
                            117u8,
                            47u8,
                            14u8,
                            16u8,
                            103u8,
                            211u8,
                            243u8,
                            44u8,
                            235u8,
                            200u8,
                            127u8,
                            113u8,
                            98u8,
                            83u8,
                        ],
                    )
                }
            }
        }
        /**
			The [event](https://docs.substrate.io/main-docs/build/events-errors/) emitted
			by this pallet.
			*/
        pub type Event = runtime_types::pallet_elections_phragmen::pallet::Event;
        pub mod events {
            use super::runtime_types;
            #[derive(
                ::subxt::ext::codec::Decode,
                ::subxt::ext::codec::Encode,
                ::subxt::ext::scale_decode::DecodeAsType,
                ::subxt::ext::scale_encode::EncodeAsType,
                Clone,
                Debug,
                Eq,
                PartialEq
            )]
            #[codec(crate = ::subxt::ext::codec)]
            #[decode_as_type(crate_path = ":: subxt :: ext :: scale_decode")]
            #[encode_as_type(crate_path = ":: subxt :: ext :: scale_encode")]
            ///A new term with new_members. This indicates that enough candidates existed to run
            ///the election, not that enough have has been elected. The inner value must be examined
            ///for this purpose. A `NewTerm(\[\])` indicates that some candidates got their bond
            ///slashed and none were elected, whilst `EmptyTerm` means that no candidates existed to
            ///begin with.
            pub struct NewTerm {
                pub new_members: ::std::vec::Vec<
                    (::subxt::utils::AccountId32, ::core::primitive::u128),
                >,
            }
            impl ::subxt::events::StaticEvent for NewTerm {
                const PALLET: &'static str = "Elections";
                const EVENT: &'static str = "NewTerm";
            }
            #[derive(
                ::subxt::ext::codec::Decode,
                ::subxt::ext::codec::Encode,
                ::subxt::ext::scale_decode::DecodeAsType,
                ::subxt::ext::scale_encode::EncodeAsType,
                Clone,
                Debug,
                Eq,
                PartialEq
            )]
            #[codec(crate = ::subxt::ext::codec)]
            #[decode_as_type(crate_path = ":: subxt :: ext :: scale_decode")]
            #[encode_as_type(crate_path = ":: subxt :: ext :: scale_encode")]
            ///No (or not enough) candidates existed for this round. This is different from
            ///`NewTerm(\[\])`. See the description of `NewTerm`.
            pub struct EmptyTerm;
            impl ::subxt::events::StaticEvent for EmptyTerm {
                const PALLET: &'static str = "Elections";
                const EVENT: &'static str = "EmptyTerm";
            }
            #[derive(
                ::subxt::ext::codec::Decode,
                ::subxt::ext::codec::Encode,
                ::subxt::ext::scale_decode::DecodeAsType,
                ::subxt::ext::scale_encode::EncodeAsType,
                Clone,
                Debug,
                Eq,
                PartialEq
            )]
            #[codec(crate = ::subxt::ext::codec)]
            #[decode_as_type(crate_path = ":: subxt :: ext :: scale_decode")]
            #[encode_as_type(crate_path = ":: subxt :: ext :: scale_encode")]
            ///Internal error happened while trying to perform election.
            pub struct ElectionError;
            impl ::subxt::events::StaticEvent for ElectionError {
                const PALLET: &'static str = "Elections";
                const EVENT: &'static str = "ElectionError";
            }
            #[derive(
                ::subxt::ext::codec::Decode,
                ::subxt::ext::codec::Encode,
                ::subxt::ext::scale_decode::DecodeAsType,
                ::subxt::ext::scale_encode::EncodeAsType,
                Clone,
                Debug,
                Eq,
                PartialEq
            )]
            #[codec(crate = ::subxt::ext::codec)]
            #[decode_as_type(crate_path = ":: subxt :: ext :: scale_decode")]
            #[encode_as_type(crate_path = ":: subxt :: ext :: scale_encode")]
            ///A member has been removed. This should always be followed by either `NewTerm` or
            ///`EmptyTerm`.
            pub struct MemberKicked {
                pub member: ::subxt::utils::AccountId32,
            }
            impl ::subxt::events::StaticEvent for MemberKicked {
                const PALLET: &'static str = "Elections";
                const EVENT: &'static str = "MemberKicked";
            }
            #[derive(
                ::subxt::ext::codec::Decode,
                ::subxt::ext::codec::Encode,
                ::subxt::ext::scale_decode::DecodeAsType,
                ::subxt::ext::scale_encode::EncodeAsType,
                Clone,
                Debug,
                Eq,
                PartialEq
            )]
            #[codec(crate = ::subxt::ext::codec)]
            #[decode_as_type(crate_path = ":: subxt :: ext :: scale_decode")]
            #[encode_as_type(crate_path = ":: subxt :: ext :: scale_encode")]
            ///Someone has renounced their candidacy.
            pub struct Renounced {
                pub candidate: ::subxt::utils::AccountId32,
            }
            impl ::subxt::events::StaticEvent for Renounced {
                const PALLET: &'static str = "Elections";
                const EVENT: &'static str = "Renounced";
            }
            #[derive(
                ::subxt::ext::codec::Decode,
                ::subxt::ext::codec::Encode,
                ::subxt::ext::scale_decode::DecodeAsType,
                ::subxt::ext::scale_encode::EncodeAsType,
                Clone,
                Debug,
                Eq,
                PartialEq
            )]
            #[codec(crate = ::subxt::ext::codec)]
            #[decode_as_type(crate_path = ":: subxt :: ext :: scale_decode")]
            #[encode_as_type(crate_path = ":: subxt :: ext :: scale_encode")]
            ///A candidate was slashed by amount due to failing to obtain a seat as member or
            ///runner-up.
            ///
            ///Note that old members and runners-up are also candidates.
            pub struct CandidateSlashed {
                pub candidate: ::subxt::utils::AccountId32,
                pub amount: ::core::primitive::u128,
            }
            impl ::subxt::events::StaticEvent for CandidateSlashed {
                const PALLET: &'static str = "Elections";
                const EVENT: &'static str = "CandidateSlashed";
            }
            #[derive(
                ::subxt::ext::codec::Decode,
                ::subxt::ext::codec::Encode,
                ::subxt::ext::scale_decode::DecodeAsType,
                ::subxt::ext::scale_encode::EncodeAsType,
                Clone,
                Debug,
                Eq,
                PartialEq
            )]
            #[codec(crate = ::subxt::ext::codec)]
            #[decode_as_type(crate_path = ":: subxt :: ext :: scale_decode")]
            #[encode_as_type(crate_path = ":: subxt :: ext :: scale_encode")]
            ///A seat holder was slashed by amount by being forcefully removed from the set.
            pub struct SeatHolderSlashed {
                pub seat_holder: ::subxt::utils::AccountId32,
                pub amount: ::core::primitive::u128,
            }
            impl ::subxt::events::StaticEvent for SeatHolderSlashed {
                const PALLET: &'static str = "Elections";
                const EVENT: &'static str = "SeatHolderSlashed";
            }
        }
        pub mod storage {
            use super::runtime_types;
            pub struct StorageApi;
            impl StorageApi {
                /// The current elected members.
                ///
                /// Invariant: Always sorted based on account id.
                pub fn members(
                    &self,
                ) -> ::subxt::storage::address::Address<
                    ::subxt::storage::address::StaticStorageMapKey,
                    ::std::vec::Vec<
                        runtime_types::pallet_elections_phragmen::SeatHolder<
                            ::subxt::utils::AccountId32,
                            ::core::primitive::u128,
                        >,
                    >,
                    ::subxt::storage::address::Yes,
                    ::subxt::storage::address::Yes,
                    (),
                > {
                    ::subxt::storage::address::Address::new_static(
                        "Elections",
                        "Members",
                        vec![],
                        [
                            210u8,
                            86u8,
                            209u8,
                            114u8,
                            170u8,
                            238u8,
                            106u8,
                            102u8,
                            0u8,
                            140u8,
                            113u8,
                            238u8,
                            36u8,
                            115u8,
                            162u8,
                            167u8,
                            194u8,
                            3u8,
                            57u8,
                            171u8,
                            41u8,
                            219u8,
                            39u8,
                            120u8,
                            192u8,
                            208u8,
                            155u8,
                            163u8,
                            26u8,
                            209u8,
                            42u8,
                            73u8,
                        ],
                    )
                }
                /// The current reserved runners-up.
                ///
                /// Invariant: Always sorted based on rank (worse to best). Upon removal of a member, the
                /// last (i.e. _best_) runner-up will be replaced.
                pub fn runners_up(
                    &self,
                ) -> ::subxt::storage::address::Address<
                    ::subxt::storage::address::StaticStorageMapKey,
                    ::std::vec::Vec<
                        runtime_types::pallet_elections_phragmen::SeatHolder<
                            ::subxt::utils::AccountId32,
                            ::core::primitive::u128,
                        >,
                    >,
                    ::subxt::storage::address::Yes,
                    ::subxt::storage::address::Yes,
                    (),
                > {
                    ::subxt::storage::address::Address::new_static(
                        "Elections",
                        "RunnersUp",
                        vec![],
                        [
                            102u8,
                            255u8,
                            105u8,
                            141u8,
                            24u8,
                            140u8,
                            180u8,
                            249u8,
                            19u8,
                            52u8,
                            144u8,
                            157u8,
                            139u8,
                            156u8,
                            5u8,
                            30u8,
                            148u8,
                            36u8,
                            67u8,
                            25u8,
                            238u8,
                            196u8,
                            163u8,
                            165u8,
                            11u8,
                            1u8,
                            162u8,
                            131u8,
                            65u8,
                            207u8,
                            140u8,
                            171u8,
                        ],
                    )
                }
                /// The present candidate list. A current member or runner-up can never enter this vector
                /// and is always implicitly assumed to be a candidate.
                ///
                /// Second element is the deposit.
                ///
                /// Invariant: Always sorted based on account id.
                pub fn candidates(
                    &self,
                ) -> ::subxt::storage::address::Address<
                    ::subxt::storage::address::StaticStorageMapKey,
                    ::std::vec::Vec<
                        (::subxt::utils::AccountId32, ::core::primitive::u128),
                    >,
                    ::subxt::storage::address::Yes,
                    ::subxt::storage::address::Yes,
                    (),
                > {
                    ::subxt::storage::address::Address::new_static(
                        "Elections",
                        "Candidates",
                        vec![],
                        [
                            220u8,
                            219u8,
                            115u8,
                            204u8,
                            15u8,
                            0u8,
                            135u8,
                            72u8,
                            241u8,
                            89u8,
                            10u8,
                            105u8,
                            106u8,
                            93u8,
                            18u8,
                            63u8,
                            43u8,
                            117u8,
                            120u8,
                            73u8,
                            8u8,
                            143u8,
                            244u8,
                            144u8,
                            223u8,
                            155u8,
                            217u8,
                            132u8,
                            246u8,
                            228u8,
                            210u8,
                            53u8,
                        ],
                    )
                }
                /// The total number of vote rounds that have happened, excluding the upcoming one.
                pub fn election_rounds(
                    &self,
                ) -> ::subxt::storage::address::Address<
                    ::subxt::storage::address::StaticStorageMapKey,
                    ::core::primitive::u32,
                    ::subxt::storage::address::Yes,
                    ::subxt::storage::address::Yes,
                    (),
                > {
                    ::subxt::storage::address::Address::new_static(
                        "Elections",
                        "ElectionRounds",
                        vec![],
                        [
                            97u8,
                            151u8,
                            159u8,
                            133u8,
                            59u8,
                            215u8,
                            12u8,
                            178u8,
                            203u8,
                            24u8,
                            138u8,
                            36u8,
                            108u8,
                            134u8,
                            217u8,
                            137u8,
                            24u8,
                            6u8,
                            126u8,
                            87u8,
                            49u8,
                            90u8,
                            198u8,
                            16u8,
                            36u8,
                            109u8,
                            223u8,
                            190u8,
                            81u8,
                            7u8,
                            239u8,
                            243u8,
                        ],
                    )
                }
                /// Votes and locked stake of a particular voter.
                ///
                /// TWOX-NOTE: SAFE as `AccountId` is a crypto hash.
                pub fn voting(
                    &self,
                    _0: impl ::std::borrow::Borrow<::subxt::utils::AccountId32>,
                ) -> ::subxt::storage::address::Address<
                    ::subxt::storage::address::StaticStorageMapKey,
                    runtime_types::pallet_elections_phragmen::Voter<
                        ::subxt::utils::AccountId32,
                        ::core::primitive::u128,
                    >,
                    ::subxt::storage::address::Yes,
                    ::subxt::storage::address::Yes,
                    ::subxt::storage::address::Yes,
                > {
                    ::subxt::storage::address::Address::new_static(
                        "Elections",
                        "Voting",
                        vec![
                            ::subxt::storage::address::make_static_storage_map_key(_0
                            .borrow())
                        ],
                        [
                            18u8,
                            65u8,
                            68u8,
                            10u8,
                            123u8,
                            174u8,
                            185u8,
                            95u8,
                            75u8,
                            37u8,
                            201u8,
                            31u8,
                            93u8,
                            189u8,
                            184u8,
                            76u8,
                            199u8,
                            168u8,
                            74u8,
                            199u8,
                            75u8,
                            78u8,
                            55u8,
                            222u8,
                            234u8,
                            48u8,
                            81u8,
                            52u8,
                            187u8,
                            64u8,
                            41u8,
                            93u8,
                        ],
                    )
                }
                /// Votes and locked stake of a particular voter.
                ///
                /// TWOX-NOTE: SAFE as `AccountId` is a crypto hash.
                pub fn voting_root(
                    &self,
                ) -> ::subxt::storage::address::Address<
                    ::subxt::storage::address::StaticStorageMapKey,
                    runtime_types::pallet_elections_phragmen::Voter<
                        ::subxt::utils::AccountId32,
                        ::core::primitive::u128,
                    >,
                    (),
                    ::subxt::storage::address::Yes,
                    ::subxt::storage::address::Yes,
                > {
                    ::subxt::storage::address::Address::new_static(
                        "Elections",
                        "Voting",
                        Vec::new(),
                        [
                            18u8,
                            65u8,
                            68u8,
                            10u8,
                            123u8,
                            174u8,
                            185u8,
                            95u8,
                            75u8,
                            37u8,
                            201u8,
                            31u8,
                            93u8,
                            189u8,
                            184u8,
                            76u8,
                            199u8,
                            168u8,
                            74u8,
                            199u8,
                            75u8,
                            78u8,
                            55u8,
                            222u8,
                            234u8,
                            48u8,
                            81u8,
                            52u8,
                            187u8,
                            64u8,
                            41u8,
                            93u8,
                        ],
                    )
                }
            }
        }
        pub mod constants {
            use super::runtime_types;
            pub struct ConstantsApi;
            impl ConstantsApi {
                /// Identifier for the elections-phragmen pallet's lock
                pub fn pallet_id(
                    &self,
                ) -> ::subxt::constants::Address<[::core::primitive::u8; 8usize]> {
                    ::subxt::constants::Address::new_static(
                        "Elections",
                        "PalletId",
                        [
                            157u8,
                            118u8,
                            79u8,
                            88u8,
                            241u8,
                            22u8,
                            185u8,
                            37u8,
                            42u8,
                            20u8,
                            133u8,
                            240u8,
                            11u8,
                            25u8,
                            66u8,
                            154u8,
                            84u8,
                            163u8,
                            78u8,
                            92u8,
                            171u8,
                            82u8,
                            248u8,
                            76u8,
                            189u8,
                            70u8,
                            142u8,
                            249u8,
                            153u8,
                            84u8,
                            180u8,
                            60u8,
                        ],
                    )
                }
                /// How much should be locked up in order to submit one's candidacy.
                pub fn candidacy_bond(
                    &self,
                ) -> ::subxt::constants::Address<::core::primitive::u128> {
                    ::subxt::constants::Address::new_static(
                        "Elections",
                        "CandidacyBond",
                        [
                            84u8,
                            157u8,
                            140u8,
                            4u8,
                            93u8,
                            57u8,
                            29u8,
                            133u8,
                            105u8,
                            200u8,
                            214u8,
                            27u8,
                            144u8,
                            208u8,
                            218u8,
                            160u8,
                            130u8,
                            109u8,
                            101u8,
                            54u8,
                            210u8,
                            136u8,
                            71u8,
                            63u8,
                            49u8,
                            237u8,
                            234u8,
                            15u8,
                            178u8,
                            98u8,
                            148u8,
                            156u8,
                        ],
                    )
                }
                /// Base deposit associated with voting.
                ///
                /// This should be sensibly high to economically ensure the pallet cannot be attacked by
                /// creating a gigantic number of votes.
                pub fn voting_bond_base(
                    &self,
                ) -> ::subxt::constants::Address<::core::primitive::u128> {
                    ::subxt::constants::Address::new_static(
                        "Elections",
                        "VotingBondBase",
                        [
                            84u8,
                            157u8,
                            140u8,
                            4u8,
                            93u8,
                            57u8,
                            29u8,
                            133u8,
                            105u8,
                            200u8,
                            214u8,
                            27u8,
                            144u8,
                            208u8,
                            218u8,
                            160u8,
                            130u8,
                            109u8,
                            101u8,
                            54u8,
                            210u8,
                            136u8,
                            71u8,
                            63u8,
                            49u8,
                            237u8,
                            234u8,
                            15u8,
                            178u8,
                            98u8,
                            148u8,
                            156u8,
                        ],
                    )
                }
                /// The amount of bond that need to be locked for each vote (32 bytes).
                pub fn voting_bond_factor(
                    &self,
                ) -> ::subxt::constants::Address<::core::primitive::u128> {
                    ::subxt::constants::Address::new_static(
                        "Elections",
                        "VotingBondFactor",
                        [
                            84u8,
                            157u8,
                            140u8,
                            4u8,
                            93u8,
                            57u8,
                            29u8,
                            133u8,
                            105u8,
                            200u8,
                            214u8,
                            27u8,
                            144u8,
                            208u8,
                            218u8,
                            160u8,
                            130u8,
                            109u8,
                            101u8,
                            54u8,
                            210u8,
                            136u8,
                            71u8,
                            63u8,
                            49u8,
                            237u8,
                            234u8,
                            15u8,
                            178u8,
                            98u8,
                            148u8,
                            156u8,
                        ],
                    )
                }
                /// Number of members to elect.
                pub fn desired_members(
                    &self,
                ) -> ::subxt::constants::Address<::core::primitive::u32> {
                    ::subxt::constants::Address::new_static(
                        "Elections",
                        "DesiredMembers",
                        [
                            98u8,
                            252u8,
                            116u8,
                            72u8,
                            26u8,
                            180u8,
                            225u8,
                            83u8,
                            200u8,
                            157u8,
                            125u8,
                            151u8,
                            53u8,
                            76u8,
                            168u8,
                            26u8,
                            10u8,
                            9u8,
                            98u8,
                            68u8,
                            9u8,
                            178u8,
                            197u8,
                            113u8,
                            31u8,
                            79u8,
                            200u8,
                            90u8,
                            203u8,
                            100u8,
                            41u8,
                            145u8,
                        ],
                    )
                }
                /// Number of runners_up to keep.
                pub fn desired_runners_up(
                    &self,
                ) -> ::subxt::constants::Address<::core::primitive::u32> {
                    ::subxt::constants::Address::new_static(
                        "Elections",
                        "DesiredRunnersUp",
                        [
                            98u8,
                            252u8,
                            116u8,
                            72u8,
                            26u8,
                            180u8,
                            225u8,
                            83u8,
                            200u8,
                            157u8,
                            125u8,
                            151u8,
                            53u8,
                            76u8,
                            168u8,
                            26u8,
                            10u8,
                            9u8,
                            98u8,
                            68u8,
                            9u8,
                            178u8,
                            197u8,
                            113u8,
                            31u8,
                            79u8,
                            200u8,
                            90u8,
                            203u8,
                            100u8,
                            41u8,
                            145u8,
                        ],
                    )
                }
                /// How long each seat is kept. This defines the next block number at which an election
                /// round will happen. If set to zero, no elections are ever triggered and the module will
                /// be in passive mode.
                pub fn term_duration(
                    &self,
                ) -> ::subxt::constants::Address<::core::primitive::u32> {
                    ::subxt::constants::Address::new_static(
                        "Elections",
                        "TermDuration",
                        [
                            98u8,
                            252u8,
                            116u8,
                            72u8,
                            26u8,
                            180u8,
                            225u8,
                            83u8,
                            200u8,
                            157u8,
                            125u8,
                            151u8,
                            53u8,
                            76u8,
                            168u8,
                            26u8,
                            10u8,
                            9u8,
                            98u8,
                            68u8,
                            9u8,
                            178u8,
                            197u8,
                            113u8,
                            31u8,
                            79u8,
                            200u8,
                            90u8,
                            203u8,
                            100u8,
                            41u8,
                            145u8,
                        ],
                    )
                }
                /// The maximum number of candidates in a phragmen election.
                ///
                /// Warning: This impacts the size of the election which is run onchain. Chose wisely, and
                /// consider how it will impact `T::WeightInfo::election_phragmen`.
                ///
                /// When this limit is reached no more candidates are accepted in the election.
                pub fn max_candidates(
                    &self,
                ) -> ::subxt::constants::Address<::core::primitive::u32> {
                    ::subxt::constants::Address::new_static(
                        "Elections",
                        "MaxCandidates",
                        [
                            98u8,
                            252u8,
                            116u8,
                            72u8,
                            26u8,
                            180u8,
                            225u8,
                            83u8,
                            200u8,
                            157u8,
                            125u8,
                            151u8,
                            53u8,
                            76u8,
                            168u8,
                            26u8,
                            10u8,
                            9u8,
                            98u8,
                            68u8,
                            9u8,
                            178u8,
                            197u8,
                            113u8,
                            31u8,
                            79u8,
                            200u8,
                            90u8,
                            203u8,
                            100u8,
                            41u8,
                            145u8,
                        ],
                    )
                }
                /// The maximum number of voters to allow in a phragmen election.
                ///
                /// Warning: This impacts the size of the election which is run onchain. Chose wisely, and
                /// consider how it will impact `T::WeightInfo::election_phragmen`.
                ///
                /// When the limit is reached the new voters are ignored.
                pub fn max_voters(
                    &self,
                ) -> ::subxt::constants::Address<::core::primitive::u32> {
                    ::subxt::constants::Address::new_static(
                        "Elections",
                        "MaxVoters",
                        [
                            98u8,
                            252u8,
                            116u8,
                            72u8,
                            26u8,
                            180u8,
                            225u8,
                            83u8,
                            200u8,
                            157u8,
                            125u8,
                            151u8,
                            53u8,
                            76u8,
                            168u8,
                            26u8,
                            10u8,
                            9u8,
                            98u8,
                            68u8,
                            9u8,
                            178u8,
                            197u8,
                            113u8,
                            31u8,
                            79u8,
                            200u8,
                            90u8,
                            203u8,
                            100u8,
                            41u8,
                            145u8,
                        ],
                    )
                }
                /// Maximum numbers of votes per voter.
                ///
                /// Warning: This impacts the size of the election which is run onchain. Chose wisely, and
                /// consider how it will impact `T::WeightInfo::election_phragmen`.
                pub fn max_votes_per_voter(
                    &self,
                ) -> ::subxt::constants::Address<::core::primitive::u32> {
                    ::subxt::constants::Address::new_static(
                        "Elections",
                        "MaxVotesPerVoter",
                        [
                            98u8,
                            252u8,
                            116u8,
                            72u8,
                            26u8,
                            180u8,
                            225u8,
                            83u8,
                            200u8,
                            157u8,
                            125u8,
                            151u8,
                            53u8,
                            76u8,
                            168u8,
                            26u8,
                            10u8,
                            9u8,
                            98u8,
                            68u8,
                            9u8,
                            178u8,
                            197u8,
                            113u8,
                            31u8,
                            79u8,
                            200u8,
                            90u8,
                            203u8,
                            100u8,
                            41u8,
                            145u8,
                        ],
                    )
                }
            }
        }
    }
    pub mod election_provider_multi_phase {
        use super::root_mod;
        use super::runtime_types;
        ///Error of the pallet that can be returned in response to dispatches.
        pub type Error = runtime_types::pallet_election_provider_multi_phase::pallet::Error;
        ///Contains one variant per dispatchable that can be called by an extrinsic.
        pub type Call = runtime_types::pallet_election_provider_multi_phase::pallet::Call;
        pub mod calls {
            use super::root_mod;
            use super::runtime_types;
            type DispatchError = runtime_types::sp_runtime::DispatchError;
            pub mod types {
                use super::runtime_types;
                #[derive(
                    ::subxt::ext::codec::Decode,
                    ::subxt::ext::codec::Encode,
                    ::subxt::ext::scale_decode::DecodeAsType,
                    ::subxt::ext::scale_encode::EncodeAsType,
                    Clone,
                    Debug,
                    Eq,
                    PartialEq
                )]
                #[codec(crate = ::subxt::ext::codec)]
                #[decode_as_type(crate_path = ":: subxt :: ext :: scale_decode")]
                #[encode_as_type(crate_path = ":: subxt :: ext :: scale_encode")]
                pub struct SubmitUnsigned {
                    pub raw_solution: ::std::boxed::Box<
                        runtime_types::pallet_election_provider_multi_phase::RawSolution<
                            runtime_types::tangle_standalone_runtime::NposSolution16,
                        >,
                    >,
                    pub witness: runtime_types::pallet_election_provider_multi_phase::SolutionOrSnapshotSize,
                }
                impl ::subxt::blocks::StaticExtrinsic for SubmitUnsigned {
                    const PALLET: &'static str = "ElectionProviderMultiPhase";
                    const CALL: &'static str = "submit_unsigned";
                }
                #[derive(
                    ::subxt::ext::codec::Decode,
                    ::subxt::ext::codec::Encode,
                    ::subxt::ext::scale_decode::DecodeAsType,
                    ::subxt::ext::scale_encode::EncodeAsType,
                    Clone,
                    Debug,
                    Eq,
                    PartialEq
                )]
                #[codec(crate = ::subxt::ext::codec)]
                #[decode_as_type(crate_path = ":: subxt :: ext :: scale_decode")]
                #[encode_as_type(crate_path = ":: subxt :: ext :: scale_encode")]
                pub struct SetMinimumUntrustedScore {
                    pub maybe_next_score: ::core::option::Option<
                        runtime_types::sp_npos_elections::ElectionScore,
                    >,
                }
                impl ::subxt::blocks::StaticExtrinsic for SetMinimumUntrustedScore {
                    const PALLET: &'static str = "ElectionProviderMultiPhase";
                    const CALL: &'static str = "set_minimum_untrusted_score";
                }
                #[derive(
                    ::subxt::ext::codec::Decode,
                    ::subxt::ext::codec::Encode,
                    ::subxt::ext::scale_decode::DecodeAsType,
                    ::subxt::ext::scale_encode::EncodeAsType,
                    Clone,
                    Debug,
                    Eq,
                    PartialEq
                )]
                #[codec(crate = ::subxt::ext::codec)]
                #[decode_as_type(crate_path = ":: subxt :: ext :: scale_decode")]
                #[encode_as_type(crate_path = ":: subxt :: ext :: scale_encode")]
                pub struct SetEmergencyElectionResult {
                    pub supports: ::std::vec::Vec<
                        (
                            ::subxt::utils::AccountId32,
                            runtime_types::sp_npos_elections::Support<
                                ::subxt::utils::AccountId32,
                            >,
                        ),
                    >,
                }
                impl ::subxt::blocks::StaticExtrinsic for SetEmergencyElectionResult {
                    const PALLET: &'static str = "ElectionProviderMultiPhase";
                    const CALL: &'static str = "set_emergency_election_result";
                }
                #[derive(
                    ::subxt::ext::codec::Decode,
                    ::subxt::ext::codec::Encode,
                    ::subxt::ext::scale_decode::DecodeAsType,
                    ::subxt::ext::scale_encode::EncodeAsType,
                    Clone,
                    Debug,
                    Eq,
                    PartialEq
                )]
                #[codec(crate = ::subxt::ext::codec)]
                #[decode_as_type(crate_path = ":: subxt :: ext :: scale_decode")]
                #[encode_as_type(crate_path = ":: subxt :: ext :: scale_encode")]
                pub struct Submit {
                    pub raw_solution: ::std::boxed::Box<
                        runtime_types::pallet_election_provider_multi_phase::RawSolution<
                            runtime_types::tangle_standalone_runtime::NposSolution16,
                        >,
                    >,
                }
                impl ::subxt::blocks::StaticExtrinsic for Submit {
                    const PALLET: &'static str = "ElectionProviderMultiPhase";
                    const CALL: &'static str = "submit";
                }
                #[derive(
                    ::subxt::ext::codec::Decode,
                    ::subxt::ext::codec::Encode,
                    ::subxt::ext::scale_decode::DecodeAsType,
                    ::subxt::ext::scale_encode::EncodeAsType,
                    Clone,
                    Debug,
                    Eq,
                    PartialEq
                )]
                #[codec(crate = ::subxt::ext::codec)]
                #[decode_as_type(crate_path = ":: subxt :: ext :: scale_decode")]
                #[encode_as_type(crate_path = ":: subxt :: ext :: scale_encode")]
                pub struct GovernanceFallback {
                    pub maybe_max_voters: ::core::option::Option<::core::primitive::u32>,
                    pub maybe_max_targets: ::core::option::Option<
                        ::core::primitive::u32,
                    >,
                }
                impl ::subxt::blocks::StaticExtrinsic for GovernanceFallback {
                    const PALLET: &'static str = "ElectionProviderMultiPhase";
                    const CALL: &'static str = "governance_fallback";
                }
            }
            pub struct TransactionApi;
            impl TransactionApi {
                ///Submit a solution for the unsigned phase.
                ///
                ///The dispatch origin fo this call must be __none__.
                ///
                ///This submission is checked on the fly. Moreover, this unsigned solution is only
                ///validated when submitted to the pool from the **local** node. Effectively, this means
                ///that only active validators can submit this transaction when authoring a block (similar
                ///to an inherent).
                ///
                ///To prevent any incorrect solution (and thus wasted time/weight), this transaction will
                ///panic if the solution submitted by the validator is invalid in any way, effectively
                ///putting their authoring reward at risk.
                ///
                ///No deposit or reward is associated with this submission.
                pub fn submit_unsigned(
                    &self,
                    raw_solution: runtime_types::pallet_election_provider_multi_phase::RawSolution<
                        runtime_types::tangle_standalone_runtime::NposSolution16,
                    >,
                    witness: runtime_types::pallet_election_provider_multi_phase::SolutionOrSnapshotSize,
                ) -> ::subxt::tx::Payload<types::SubmitUnsigned> {
                    ::subxt::tx::Payload::new_static(
                        "ElectionProviderMultiPhase",
                        "submit_unsigned",
                        types::SubmitUnsigned {
                            raw_solution: ::std::boxed::Box::new(raw_solution),
                            witness,
                        },
                        [
                            34u8,
                            115u8,
                            43u8,
                            180u8,
                            202u8,
                            212u8,
                            42u8,
                            17u8,
                            187u8,
                            233u8,
                            54u8,
                            206u8,
                            238u8,
                            239u8,
                            35u8,
                            240u8,
                            136u8,
                            197u8,
                            117u8,
                            113u8,
                            213u8,
                            46u8,
                            94u8,
                            47u8,
                            84u8,
                            186u8,
                            177u8,
                            61u8,
                            3u8,
                            202u8,
                            2u8,
                            186u8,
                        ],
                    )
                }
                ///Set a new value for `MinimumUntrustedScore`.
                ///
                ///Dispatch origin must be aligned with `T::ForceOrigin`.
                ///
                ///This check can be turned off by setting the value to `None`.
                pub fn set_minimum_untrusted_score(
                    &self,
                    maybe_next_score: ::core::option::Option<
                        runtime_types::sp_npos_elections::ElectionScore,
                    >,
                ) -> ::subxt::tx::Payload<types::SetMinimumUntrustedScore> {
                    ::subxt::tx::Payload::new_static(
                        "ElectionProviderMultiPhase",
                        "set_minimum_untrusted_score",
                        types::SetMinimumUntrustedScore {
                            maybe_next_score,
                        },
                        [
                            36u8,
                            32u8,
                            197u8,
                            96u8,
                            189u8,
                            98u8,
                            96u8,
                            138u8,
                            84u8,
                            99u8,
                            235u8,
                            44u8,
                            103u8,
                            25u8,
                            118u8,
                            194u8,
                            166u8,
                            158u8,
                            212u8,
                            36u8,
                            243u8,
                            86u8,
                            202u8,
                            231u8,
                            189u8,
                            226u8,
                            21u8,
                            112u8,
                            20u8,
                            163u8,
                            229u8,
                            240u8,
                        ],
                    )
                }
                ///Set a solution in the queue, to be handed out to the client of this pallet in the next
                ///call to `ElectionProvider::elect`.
                ///
                ///This can only be set by `T::ForceOrigin`, and only when the phase is `Emergency`.
                ///
                ///The solution is not checked for any feasibility and is assumed to be trustworthy, as any
                ///feasibility check itself can in principle cause the election process to fail (due to
                ///memory/weight constrains).
                pub fn set_emergency_election_result(
                    &self,
                    supports: ::std::vec::Vec<
                        (
                            ::subxt::utils::AccountId32,
                            runtime_types::sp_npos_elections::Support<
                                ::subxt::utils::AccountId32,
                            >,
                        ),
                    >,
                ) -> ::subxt::tx::Payload<types::SetEmergencyElectionResult> {
                    ::subxt::tx::Payload::new_static(
                        "ElectionProviderMultiPhase",
                        "set_emergency_election_result",
                        types::SetEmergencyElectionResult {
                            supports,
                        },
                        [
                            158u8,
                            35u8,
                            6u8,
                            145u8,
                            37u8,
                            239u8,
                            101u8,
                            90u8,
                            121u8,
                            123u8,
                            240u8,
                            131u8,
                            154u8,
                            13u8,
                            111u8,
                            120u8,
                            146u8,
                            151u8,
                            203u8,
                            125u8,
                            115u8,
                            255u8,
                            58u8,
                            154u8,
                            177u8,
                            204u8,
                            140u8,
                            87u8,
                            9u8,
                            63u8,
                            146u8,
                            209u8,
                        ],
                    )
                }
                ///Submit a solution for the signed phase.
                ///
                ///The dispatch origin fo this call must be __signed__.
                ///
                ///The solution is potentially queued, based on the claimed score and processed at the end
                ///of the signed phase.
                ///
                ///A deposit is reserved and recorded for the solution. Based on the outcome, the solution
                ///might be rewarded, slashed, or get all or a part of the deposit back.
                pub fn submit(
                    &self,
                    raw_solution: runtime_types::pallet_election_provider_multi_phase::RawSolution<
                        runtime_types::tangle_standalone_runtime::NposSolution16,
                    >,
                ) -> ::subxt::tx::Payload<types::Submit> {
                    ::subxt::tx::Payload::new_static(
                        "ElectionProviderMultiPhase",
                        "submit",
                        types::Submit {
                            raw_solution: ::std::boxed::Box::new(raw_solution),
                        },
                        [
                            55u8,
                            153u8,
                            215u8,
                            21u8,
                            19u8,
                            192u8,
                            199u8,
                            19u8,
                            145u8,
                            27u8,
                            54u8,
                            128u8,
                            23u8,
                            3u8,
                            255u8,
                            87u8,
                            27u8,
                            75u8,
                            248u8,
                            145u8,
                            238u8,
                            75u8,
                            204u8,
                            173u8,
                            71u8,
                            252u8,
                            29u8,
                            71u8,
                            45u8,
                            143u8,
                            179u8,
                            154u8,
                        ],
                    )
                }
                ///Trigger the governance fallback.
                ///
                ///This can only be called when [`Phase::Emergency`] is enabled, as an alternative to
                ///calling [`Call::set_emergency_election_result`].
                pub fn governance_fallback(
                    &self,
                    maybe_max_voters: ::core::option::Option<::core::primitive::u32>,
                    maybe_max_targets: ::core::option::Option<::core::primitive::u32>,
                ) -> ::subxt::tx::Payload<types::GovernanceFallback> {
                    ::subxt::tx::Payload::new_static(
                        "ElectionProviderMultiPhase",
                        "governance_fallback",
                        types::GovernanceFallback {
                            maybe_max_voters,
                            maybe_max_targets,
                        },
                        [
                            168u8,
                            109u8,
                            243u8,
                            125u8,
                            188u8,
                            177u8,
                            251u8,
                            179u8,
                            158u8,
                            246u8,
                            179u8,
                            247u8,
                            87u8,
                            217u8,
                            190u8,
                            107u8,
                            207u8,
                            249u8,
                            204u8,
                            27u8,
                            166u8,
                            49u8,
                            135u8,
                            71u8,
                            88u8,
                            142u8,
                            58u8,
                            206u8,
                            137u8,
                            142u8,
                            75u8,
                            127u8,
                        ],
                    )
                }
            }
        }
        /**
			The [event](https://docs.substrate.io/main-docs/build/events-errors/) emitted
			by this pallet.
			*/
        pub type Event = runtime_types::pallet_election_provider_multi_phase::pallet::Event;
        pub mod events {
            use super::runtime_types;
            #[derive(
                ::subxt::ext::codec::Decode,
                ::subxt::ext::codec::Encode,
                ::subxt::ext::scale_decode::DecodeAsType,
                ::subxt::ext::scale_encode::EncodeAsType,
                Clone,
                Debug,
                Eq,
                PartialEq
            )]
            #[codec(crate = ::subxt::ext::codec)]
            #[decode_as_type(crate_path = ":: subxt :: ext :: scale_decode")]
            #[encode_as_type(crate_path = ":: subxt :: ext :: scale_encode")]
            ///A solution was stored with the given compute.
            ///
            ///The `origin` indicates the origin of the solution. If `origin` is `Some(AccountId)`,
            ///the stored solution was submited in the signed phase by a miner with the `AccountId`.
            ///Otherwise, the solution was stored either during the unsigned phase or by
            ///`T::ForceOrigin`. The `bool` is `true` when a previous solution was ejected to make
            ///room for this one.
            pub struct SolutionStored {
                pub compute: runtime_types::pallet_election_provider_multi_phase::ElectionCompute,
                pub origin: ::core::option::Option<::subxt::utils::AccountId32>,
                pub prev_ejected: ::core::primitive::bool,
            }
            impl ::subxt::events::StaticEvent for SolutionStored {
                const PALLET: &'static str = "ElectionProviderMultiPhase";
                const EVENT: &'static str = "SolutionStored";
            }
            #[derive(
                ::subxt::ext::codec::Decode,
                ::subxt::ext::codec::Encode,
                ::subxt::ext::scale_decode::DecodeAsType,
                ::subxt::ext::scale_encode::EncodeAsType,
                Clone,
                Debug,
                Eq,
                PartialEq
            )]
            #[codec(crate = ::subxt::ext::codec)]
            #[decode_as_type(crate_path = ":: subxt :: ext :: scale_decode")]
            #[encode_as_type(crate_path = ":: subxt :: ext :: scale_encode")]
            ///The election has been finalized, with the given computation and score.
            pub struct ElectionFinalized {
                pub compute: runtime_types::pallet_election_provider_multi_phase::ElectionCompute,
                pub score: runtime_types::sp_npos_elections::ElectionScore,
            }
            impl ::subxt::events::StaticEvent for ElectionFinalized {
                const PALLET: &'static str = "ElectionProviderMultiPhase";
                const EVENT: &'static str = "ElectionFinalized";
            }
            #[derive(
                ::subxt::ext::codec::Decode,
                ::subxt::ext::codec::Encode,
                ::subxt::ext::scale_decode::DecodeAsType,
                ::subxt::ext::scale_encode::EncodeAsType,
                Clone,
                Debug,
                Eq,
                PartialEq
            )]
            #[codec(crate = ::subxt::ext::codec)]
            #[decode_as_type(crate_path = ":: subxt :: ext :: scale_decode")]
            #[encode_as_type(crate_path = ":: subxt :: ext :: scale_encode")]
            ///An election failed.
            ///
            ///Not much can be said about which computes failed in the process.
            pub struct ElectionFailed;
            impl ::subxt::events::StaticEvent for ElectionFailed {
                const PALLET: &'static str = "ElectionProviderMultiPhase";
                const EVENT: &'static str = "ElectionFailed";
            }
            #[derive(
                ::subxt::ext::codec::Decode,
                ::subxt::ext::codec::Encode,
                ::subxt::ext::scale_decode::DecodeAsType,
                ::subxt::ext::scale_encode::EncodeAsType,
                Clone,
                Debug,
                Eq,
                PartialEq
            )]
            #[codec(crate = ::subxt::ext::codec)]
            #[decode_as_type(crate_path = ":: subxt :: ext :: scale_decode")]
            #[encode_as_type(crate_path = ":: subxt :: ext :: scale_encode")]
            ///An account has been rewarded for their signed submission being finalized.
            pub struct Rewarded {
                pub account: ::subxt::utils::AccountId32,
                pub value: ::core::primitive::u128,
            }
            impl ::subxt::events::StaticEvent for Rewarded {
                const PALLET: &'static str = "ElectionProviderMultiPhase";
                const EVENT: &'static str = "Rewarded";
            }
            #[derive(
                ::subxt::ext::codec::Decode,
                ::subxt::ext::codec::Encode,
                ::subxt::ext::scale_decode::DecodeAsType,
                ::subxt::ext::scale_encode::EncodeAsType,
                Clone,
                Debug,
                Eq,
                PartialEq
            )]
            #[codec(crate = ::subxt::ext::codec)]
            #[decode_as_type(crate_path = ":: subxt :: ext :: scale_decode")]
            #[encode_as_type(crate_path = ":: subxt :: ext :: scale_encode")]
            ///An account has been slashed for submitting an invalid signed submission.
            pub struct Slashed {
                pub account: ::subxt::utils::AccountId32,
                pub value: ::core::primitive::u128,
            }
            impl ::subxt::events::StaticEvent for Slashed {
                const PALLET: &'static str = "ElectionProviderMultiPhase";
                const EVENT: &'static str = "Slashed";
            }
            #[derive(
                ::subxt::ext::codec::Decode,
                ::subxt::ext::codec::Encode,
                ::subxt::ext::scale_decode::DecodeAsType,
                ::subxt::ext::scale_encode::EncodeAsType,
                Clone,
                Debug,
                Eq,
                PartialEq
            )]
            #[codec(crate = ::subxt::ext::codec)]
            #[decode_as_type(crate_path = ":: subxt :: ext :: scale_decode")]
            #[encode_as_type(crate_path = ":: subxt :: ext :: scale_encode")]
            ///There was a phase transition in a given round.
            pub struct PhaseTransitioned {
                pub from: runtime_types::pallet_election_provider_multi_phase::Phase<
                    ::core::primitive::u32,
                >,
                pub to: runtime_types::pallet_election_provider_multi_phase::Phase<
                    ::core::primitive::u32,
                >,
                pub round: ::core::primitive::u32,
            }
            impl ::subxt::events::StaticEvent for PhaseTransitioned {
                const PALLET: &'static str = "ElectionProviderMultiPhase";
                const EVENT: &'static str = "PhaseTransitioned";
            }
        }
        pub mod storage {
            use super::runtime_types;
            pub struct StorageApi;
            impl StorageApi {
                /// Internal counter for the number of rounds.
                ///
                /// This is useful for de-duplication of transactions submitted to the pool, and general
                /// diagnostics of the pallet.
                ///
                /// This is merely incremented once per every time that an upstream `elect` is called.
                pub fn round(
                    &self,
                ) -> ::subxt::storage::address::Address<
                    ::subxt::storage::address::StaticStorageMapKey,
                    ::core::primitive::u32,
                    ::subxt::storage::address::Yes,
                    ::subxt::storage::address::Yes,
                    (),
                > {
                    ::subxt::storage::address::Address::new_static(
                        "ElectionProviderMultiPhase",
                        "Round",
                        vec![],
                        [
                            37u8,
                            2u8,
                            47u8,
                            240u8,
                            18u8,
                            213u8,
                            214u8,
                            74u8,
                            57u8,
                            4u8,
                            103u8,
                            253u8,
                            45u8,
                            17u8,
                            123u8,
                            203u8,
                            173u8,
                            170u8,
                            234u8,
                            109u8,
                            139u8,
                            143u8,
                            216u8,
                            3u8,
                            161u8,
                            5u8,
                            0u8,
                            106u8,
                            181u8,
                            214u8,
                            170u8,
                            105u8,
                        ],
                    )
                }
                /// Current phase.
                pub fn current_phase(
                    &self,
                ) -> ::subxt::storage::address::Address<
                    ::subxt::storage::address::StaticStorageMapKey,
                    runtime_types::pallet_election_provider_multi_phase::Phase<
                        ::core::primitive::u32,
                    >,
                    ::subxt::storage::address::Yes,
                    ::subxt::storage::address::Yes,
                    (),
                > {
                    ::subxt::storage::address::Address::new_static(
                        "ElectionProviderMultiPhase",
                        "CurrentPhase",
                        vec![],
                        [
                            230u8,
                            7u8,
                            51u8,
                            158u8,
                            77u8,
                            36u8,
                            148u8,
                            175u8,
                            138u8,
                            205u8,
                            195u8,
                            236u8,
                            66u8,
                            148u8,
                            0u8,
                            77u8,
                            160u8,
                            249u8,
                            128u8,
                            58u8,
                            189u8,
                            48u8,
                            195u8,
                            198u8,
                            115u8,
                            251u8,
                            13u8,
                            206u8,
                            163u8,
                            180u8,
                            108u8,
                            10u8,
                        ],
                    )
                }
                /// Current best solution, signed or unsigned, queued to be returned upon `elect`.
                ///
                /// Always sorted by score.
                pub fn queued_solution(
                    &self,
                ) -> ::subxt::storage::address::Address<
                    ::subxt::storage::address::StaticStorageMapKey,
                    runtime_types::pallet_election_provider_multi_phase::ReadySolution,
                    ::subxt::storage::address::Yes,
                    (),
                    (),
                > {
                    ::subxt::storage::address::Address::new_static(
                        "ElectionProviderMultiPhase",
                        "QueuedSolution",
                        vec![],
                        [
                            64u8,
                            237u8,
                            221u8,
                            29u8,
                            144u8,
                            141u8,
                            147u8,
                            4u8,
                            46u8,
                            239u8,
                            34u8,
                            242u8,
                            164u8,
                            69u8,
                            108u8,
                            145u8,
                            95u8,
                            167u8,
                            34u8,
                            211u8,
                            103u8,
                            165u8,
                            183u8,
                            193u8,
                            245u8,
                            226u8,
                            140u8,
                            50u8,
                            176u8,
                            127u8,
                            108u8,
                            171u8,
                        ],
                    )
                }
                /// Snapshot data of the round.
                ///
                /// This is created at the beginning of the signed phase and cleared upon calling `elect`.
                pub fn snapshot(
                    &self,
                ) -> ::subxt::storage::address::Address<
                    ::subxt::storage::address::StaticStorageMapKey,
                    runtime_types::pallet_election_provider_multi_phase::RoundSnapshot<
                        ::subxt::utils::AccountId32,
                        (
                            ::subxt::utils::AccountId32,
                            ::core::primitive::u64,
                            runtime_types::bounded_collections::bounded_vec::BoundedVec<
                                ::subxt::utils::AccountId32,
                            >,
                        ),
                    >,
                    ::subxt::storage::address::Yes,
                    (),
                    (),
                > {
                    ::subxt::storage::address::Address::new_static(
                        "ElectionProviderMultiPhase",
                        "Snapshot",
                        vec![],
                        [
                            180u8,
                            77u8,
                            217u8,
                            249u8,
                            212u8,
                            99u8,
                            36u8,
                            26u8,
                            237u8,
                            4u8,
                            94u8,
                            80u8,
                            160u8,
                            6u8,
                            194u8,
                            98u8,
                            174u8,
                            153u8,
                            127u8,
                            124u8,
                            109u8,
                            188u8,
                            143u8,
                            151u8,
                            51u8,
                            200u8,
                            133u8,
                            66u8,
                            68u8,
                            226u8,
                            124u8,
                            158u8,
                        ],
                    )
                }
                /// Desired number of targets to elect for this round.
                ///
                /// Only exists when [`Snapshot`] is present.
                pub fn desired_targets(
                    &self,
                ) -> ::subxt::storage::address::Address<
                    ::subxt::storage::address::StaticStorageMapKey,
                    ::core::primitive::u32,
                    ::subxt::storage::address::Yes,
                    (),
                    (),
                > {
                    ::subxt::storage::address::Address::new_static(
                        "ElectionProviderMultiPhase",
                        "DesiredTargets",
                        vec![],
                        [
                            67u8,
                            241u8,
                            33u8,
                            113u8,
                            62u8,
                            173u8,
                            233u8,
                            76u8,
                            99u8,
                            12u8,
                            61u8,
                            237u8,
                            21u8,
                            252u8,
                            39u8,
                            37u8,
                            86u8,
                            167u8,
                            173u8,
                            53u8,
                            238u8,
                            172u8,
                            97u8,
                            59u8,
                            27u8,
                            164u8,
                            163u8,
                            76u8,
                            140u8,
                            37u8,
                            159u8,
                            250u8,
                        ],
                    )
                }
                /// The metadata of the [`RoundSnapshot`]
                ///
                /// Only exists when [`Snapshot`] is present.
                pub fn snapshot_metadata(
                    &self,
                ) -> ::subxt::storage::address::Address<
                    ::subxt::storage::address::StaticStorageMapKey,
                    runtime_types::pallet_election_provider_multi_phase::SolutionOrSnapshotSize,
                    ::subxt::storage::address::Yes,
                    (),
                    (),
                > {
                    ::subxt::storage::address::Address::new_static(
                        "ElectionProviderMultiPhase",
                        "SnapshotMetadata",
                        vec![],
                        [
                            14u8,
                            189u8,
                            135u8,
                            84u8,
                            238u8,
                            133u8,
                            76u8,
                            176u8,
                            181u8,
                            185u8,
                            111u8,
                            102u8,
                            181u8,
                            14u8,
                            172u8,
                            86u8,
                            188u8,
                            139u8,
                            73u8,
                            192u8,
                            203u8,
                            117u8,
                            39u8,
                            119u8,
                            108u8,
                            225u8,
                            163u8,
                            36u8,
                            91u8,
                            30u8,
                            0u8,
                            196u8,
                        ],
                    )
                }
                /// The next index to be assigned to an incoming signed submission.
                ///
                /// Every accepted submission is assigned a unique index; that index is bound to that particular
                /// submission for the duration of the election. On election finalization, the next index is
                /// reset to 0.
                ///
                /// We can't just use `SignedSubmissionIndices.len()`, because that's a bounded set; past its
                /// capacity, it will simply saturate. We can't just iterate over `SignedSubmissionsMap`,
                /// because iteration is slow. Instead, we store the value here.
                pub fn signed_submission_next_index(
                    &self,
                ) -> ::subxt::storage::address::Address<
                    ::subxt::storage::address::StaticStorageMapKey,
                    ::core::primitive::u32,
                    ::subxt::storage::address::Yes,
                    ::subxt::storage::address::Yes,
                    (),
                > {
                    ::subxt::storage::address::Address::new_static(
                        "ElectionProviderMultiPhase",
                        "SignedSubmissionNextIndex",
                        vec![],
                        [
                            188u8,
                            126u8,
                            77u8,
                            166u8,
                            42u8,
                            81u8,
                            12u8,
                            239u8,
                            195u8,
                            16u8,
                            132u8,
                            178u8,
                            217u8,
                            158u8,
                            28u8,
                            19u8,
                            201u8,
                            148u8,
                            47u8,
                            105u8,
                            178u8,
                            115u8,
                            17u8,
                            78u8,
                            71u8,
                            178u8,
                            205u8,
                            171u8,
                            71u8,
                            52u8,
                            194u8,
                            82u8,
                        ],
                    )
                }
                /// A sorted, bounded vector of `(score, block_number, index)`, where each `index` points to a
                /// value in `SignedSubmissions`.
                ///
                /// We never need to process more than a single signed submission at a time. Signed submissions
                /// can be quite large, so we're willing to pay the cost of multiple database accesses to access
                /// them one at a time instead of reading and decoding all of them at once.
                pub fn signed_submission_indices(
                    &self,
                ) -> ::subxt::storage::address::Address<
                    ::subxt::storage::address::StaticStorageMapKey,
                    runtime_types::bounded_collections::bounded_vec::BoundedVec<
                        (
                            runtime_types::sp_npos_elections::ElectionScore,
                            ::core::primitive::u32,
                            ::core::primitive::u32,
                        ),
                    >,
                    ::subxt::storage::address::Yes,
                    ::subxt::storage::address::Yes,
                    (),
                > {
                    ::subxt::storage::address::Address::new_static(
                        "ElectionProviderMultiPhase",
                        "SignedSubmissionIndices",
                        vec![],
                        [
                            203u8,
                            96u8,
                            121u8,
                            1u8,
                            24u8,
                            150u8,
                            185u8,
                            93u8,
                            129u8,
                            63u8,
                            52u8,
                            163u8,
                            67u8,
                            45u8,
                            100u8,
                            11u8,
                            254u8,
                            224u8,
                            18u8,
                            1u8,
                            133u8,
                            246u8,
                            125u8,
                            211u8,
                            93u8,
                            99u8,
                            194u8,
                            105u8,
                            176u8,
                            162u8,
                            238u8,
                            181u8,
                        ],
                    )
                }
                /// Unchecked, signed solutions.
                ///
                /// Together with `SubmissionIndices`, this stores a bounded set of `SignedSubmissions` while
                /// allowing us to keep only a single one in memory at a time.
                ///
                /// Twox note: the key of the map is an auto-incrementing index which users cannot inspect or
                /// affect; we shouldn't need a cryptographically secure hasher.
                pub fn signed_submissions_map(
                    &self,
                    _0: impl ::std::borrow::Borrow<::core::primitive::u32>,
                ) -> ::subxt::storage::address::Address<
                    ::subxt::storage::address::StaticStorageMapKey,
                    runtime_types::pallet_election_provider_multi_phase::signed::SignedSubmission<
                        ::subxt::utils::AccountId32,
                        ::core::primitive::u128,
                        runtime_types::tangle_standalone_runtime::NposSolution16,
                    >,
                    ::subxt::storage::address::Yes,
                    (),
                    ::subxt::storage::address::Yes,
                > {
                    ::subxt::storage::address::Address::new_static(
                        "ElectionProviderMultiPhase",
                        "SignedSubmissionsMap",
                        vec![
                            ::subxt::storage::address::make_static_storage_map_key(_0
                            .borrow())
                        ],
                        [
                            79u8,
                            183u8,
                            109u8,
                            221u8,
                            2u8,
                            64u8,
                            197u8,
                            162u8,
                            221u8,
                            170u8,
                            140u8,
                            136u8,
                            205u8,
                            111u8,
                            8u8,
                            179u8,
                            166u8,
                            104u8,
                            74u8,
                            219u8,
                            202u8,
                            123u8,
                            31u8,
                            129u8,
                            207u8,
                            58u8,
                            241u8,
                            91u8,
                            147u8,
                            112u8,
                            162u8,
                            105u8,
                        ],
                    )
                }
                /// Unchecked, signed solutions.
                ///
                /// Together with `SubmissionIndices`, this stores a bounded set of `SignedSubmissions` while
                /// allowing us to keep only a single one in memory at a time.
                ///
                /// Twox note: the key of the map is an auto-incrementing index which users cannot inspect or
                /// affect; we shouldn't need a cryptographically secure hasher.
                pub fn signed_submissions_map_root(
                    &self,
                ) -> ::subxt::storage::address::Address<
                    ::subxt::storage::address::StaticStorageMapKey,
                    runtime_types::pallet_election_provider_multi_phase::signed::SignedSubmission<
                        ::subxt::utils::AccountId32,
                        ::core::primitive::u128,
                        runtime_types::tangle_standalone_runtime::NposSolution16,
                    >,
                    (),
                    (),
                    ::subxt::storage::address::Yes,
                > {
                    ::subxt::storage::address::Address::new_static(
                        "ElectionProviderMultiPhase",
                        "SignedSubmissionsMap",
                        Vec::new(),
                        [
                            79u8,
                            183u8,
                            109u8,
                            221u8,
                            2u8,
                            64u8,
                            197u8,
                            162u8,
                            221u8,
                            170u8,
                            140u8,
                            136u8,
                            205u8,
                            111u8,
                            8u8,
                            179u8,
                            166u8,
                            104u8,
                            74u8,
                            219u8,
                            202u8,
                            123u8,
                            31u8,
                            129u8,
                            207u8,
                            58u8,
                            241u8,
                            91u8,
                            147u8,
                            112u8,
                            162u8,
                            105u8,
                        ],
                    )
                }
                /// The minimum score that each 'untrusted' solution must attain in order to be considered
                /// feasible.
                ///
                /// Can be set via `set_minimum_untrusted_score`.
                pub fn minimum_untrusted_score(
                    &self,
                ) -> ::subxt::storage::address::Address<
                    ::subxt::storage::address::StaticStorageMapKey,
                    runtime_types::sp_npos_elections::ElectionScore,
                    ::subxt::storage::address::Yes,
                    (),
                    (),
                > {
                    ::subxt::storage::address::Address::new_static(
                        "ElectionProviderMultiPhase",
                        "MinimumUntrustedScore",
                        vec![],
                        [
                            105u8,
                            218u8,
                            96u8,
                            38u8,
                            82u8,
                            115u8,
                            30u8,
                            178u8,
                            21u8,
                            89u8,
                            59u8,
                            7u8,
                            203u8,
                            240u8,
                            224u8,
                            209u8,
                            78u8,
                            28u8,
                            198u8,
                            236u8,
                            252u8,
                            122u8,
                            72u8,
                            59u8,
                            156u8,
                            242u8,
                            26u8,
                            160u8,
                            145u8,
                            40u8,
                            6u8,
                            101u8,
                        ],
                    )
                }
            }
        }
        pub mod constants {
            use super::runtime_types;
            pub struct ConstantsApi;
            impl ConstantsApi {
                /// Duration of the unsigned phase.
                pub fn unsigned_phase(
                    &self,
                ) -> ::subxt::constants::Address<::core::primitive::u32> {
                    ::subxt::constants::Address::new_static(
                        "ElectionProviderMultiPhase",
                        "UnsignedPhase",
                        [
                            98u8,
                            252u8,
                            116u8,
                            72u8,
                            26u8,
                            180u8,
                            225u8,
                            83u8,
                            200u8,
                            157u8,
                            125u8,
                            151u8,
                            53u8,
                            76u8,
                            168u8,
                            26u8,
                            10u8,
                            9u8,
                            98u8,
                            68u8,
                            9u8,
                            178u8,
                            197u8,
                            113u8,
                            31u8,
                            79u8,
                            200u8,
                            90u8,
                            203u8,
                            100u8,
                            41u8,
                            145u8,
                        ],
                    )
                }
                /// Duration of the signed phase.
                pub fn signed_phase(
                    &self,
                ) -> ::subxt::constants::Address<::core::primitive::u32> {
                    ::subxt::constants::Address::new_static(
                        "ElectionProviderMultiPhase",
                        "SignedPhase",
                        [
                            98u8,
                            252u8,
                            116u8,
                            72u8,
                            26u8,
                            180u8,
                            225u8,
                            83u8,
                            200u8,
                            157u8,
                            125u8,
                            151u8,
                            53u8,
                            76u8,
                            168u8,
                            26u8,
                            10u8,
                            9u8,
                            98u8,
                            68u8,
                            9u8,
                            178u8,
                            197u8,
                            113u8,
                            31u8,
                            79u8,
                            200u8,
                            90u8,
                            203u8,
                            100u8,
                            41u8,
                            145u8,
                        ],
                    )
                }
                /// The minimum amount of improvement to the solution score that defines a solution as
                /// "better" in the Signed phase.
                pub fn better_signed_threshold(
                    &self,
                ) -> ::subxt::constants::Address<
                    runtime_types::sp_arithmetic::per_things::Perbill,
                > {
                    ::subxt::constants::Address::new_static(
                        "ElectionProviderMultiPhase",
                        "BetterSignedThreshold",
                        [
                            65u8,
                            93u8,
                            120u8,
                            165u8,
                            204u8,
                            81u8,
                            159u8,
                            163u8,
                            93u8,
                            135u8,
                            114u8,
                            121u8,
                            147u8,
                            35u8,
                            215u8,
                            213u8,
                            4u8,
                            223u8,
                            83u8,
                            37u8,
                            225u8,
                            200u8,
                            189u8,
                            156u8,
                            140u8,
                            36u8,
                            58u8,
                            46u8,
                            42u8,
                            232u8,
                            155u8,
                            0u8,
                        ],
                    )
                }
                /// The minimum amount of improvement to the solution score that defines a solution as
                /// "better" in the Unsigned phase.
                pub fn better_unsigned_threshold(
                    &self,
                ) -> ::subxt::constants::Address<
                    runtime_types::sp_arithmetic::per_things::Perbill,
                > {
                    ::subxt::constants::Address::new_static(
                        "ElectionProviderMultiPhase",
                        "BetterUnsignedThreshold",
                        [
                            65u8,
                            93u8,
                            120u8,
                            165u8,
                            204u8,
                            81u8,
                            159u8,
                            163u8,
                            93u8,
                            135u8,
                            114u8,
                            121u8,
                            147u8,
                            35u8,
                            215u8,
                            213u8,
                            4u8,
                            223u8,
                            83u8,
                            37u8,
                            225u8,
                            200u8,
                            189u8,
                            156u8,
                            140u8,
                            36u8,
                            58u8,
                            46u8,
                            42u8,
                            232u8,
                            155u8,
                            0u8,
                        ],
                    )
                }
                /// The repeat threshold of the offchain worker.
                ///
                /// For example, if it is 5, that means that at least 5 blocks will elapse between attempts
                /// to submit the worker's solution.
                pub fn offchain_repeat(
                    &self,
                ) -> ::subxt::constants::Address<::core::primitive::u32> {
                    ::subxt::constants::Address::new_static(
                        "ElectionProviderMultiPhase",
                        "OffchainRepeat",
                        [
                            98u8,
                            252u8,
                            116u8,
                            72u8,
                            26u8,
                            180u8,
                            225u8,
                            83u8,
                            200u8,
                            157u8,
                            125u8,
                            151u8,
                            53u8,
                            76u8,
                            168u8,
                            26u8,
                            10u8,
                            9u8,
                            98u8,
                            68u8,
                            9u8,
                            178u8,
                            197u8,
                            113u8,
                            31u8,
                            79u8,
                            200u8,
                            90u8,
                            203u8,
                            100u8,
                            41u8,
                            145u8,
                        ],
                    )
                }
                /// The priority of the unsigned transaction submitted in the unsigned-phase
                pub fn miner_tx_priority(
                    &self,
                ) -> ::subxt::constants::Address<::core::primitive::u64> {
                    ::subxt::constants::Address::new_static(
                        "ElectionProviderMultiPhase",
                        "MinerTxPriority",
                        [
                            128u8,
                            214u8,
                            205u8,
                            242u8,
                            181u8,
                            142u8,
                            124u8,
                            231u8,
                            190u8,
                            146u8,
                            59u8,
                            226u8,
                            157u8,
                            101u8,
                            103u8,
                            117u8,
                            249u8,
                            65u8,
                            18u8,
                            191u8,
                            103u8,
                            119u8,
                            53u8,
                            85u8,
                            81u8,
                            96u8,
                            220u8,
                            42u8,
                            184u8,
                            239u8,
                            42u8,
                            246u8,
                        ],
                    )
                }
                /// Maximum number of signed submissions that can be queued.
                ///
                /// It is best to avoid adjusting this during an election, as it impacts downstream data
                /// structures. In particular, `SignedSubmissionIndices<T>` is bounded on this value. If you
                /// update this value during an election, you _must_ ensure that
                /// `SignedSubmissionIndices.len()` is less than or equal to the new value. Otherwise,
                /// attempts to submit new solutions may cause a runtime panic.
                pub fn signed_max_submissions(
                    &self,
                ) -> ::subxt::constants::Address<::core::primitive::u32> {
                    ::subxt::constants::Address::new_static(
                        "ElectionProviderMultiPhase",
                        "SignedMaxSubmissions",
                        [
                            98u8,
                            252u8,
                            116u8,
                            72u8,
                            26u8,
                            180u8,
                            225u8,
                            83u8,
                            200u8,
                            157u8,
                            125u8,
                            151u8,
                            53u8,
                            76u8,
                            168u8,
                            26u8,
                            10u8,
                            9u8,
                            98u8,
                            68u8,
                            9u8,
                            178u8,
                            197u8,
                            113u8,
                            31u8,
                            79u8,
                            200u8,
                            90u8,
                            203u8,
                            100u8,
                            41u8,
                            145u8,
                        ],
                    )
                }
                /// Maximum weight of a signed solution.
                ///
                /// If [`Config::MinerConfig`] is being implemented to submit signed solutions (outside of
                /// this pallet), then [`MinerConfig::solution_weight`] is used to compare against
                /// this value.
                pub fn signed_max_weight(
                    &self,
                ) -> ::subxt::constants::Address<
                    runtime_types::sp_weights::weight_v2::Weight,
                > {
                    ::subxt::constants::Address::new_static(
                        "ElectionProviderMultiPhase",
                        "SignedMaxWeight",
                        [
                            222u8,
                            183u8,
                            203u8,
                            169u8,
                            31u8,
                            134u8,
                            28u8,
                            12u8,
                            47u8,
                            140u8,
                            71u8,
                            74u8,
                            61u8,
                            55u8,
                            71u8,
                            236u8,
                            215u8,
                            83u8,
                            28u8,
                            70u8,
                            45u8,
                            128u8,
                            184u8,
                            57u8,
                            101u8,
                            83u8,
                            42u8,
                            165u8,
                            34u8,
                            155u8,
                            64u8,
                            145u8,
                        ],
                    )
                }
                /// The maximum amount of unchecked solutions to refund the call fee for.
                pub fn signed_max_refunds(
                    &self,
                ) -> ::subxt::constants::Address<::core::primitive::u32> {
                    ::subxt::constants::Address::new_static(
                        "ElectionProviderMultiPhase",
                        "SignedMaxRefunds",
                        [
                            98u8,
                            252u8,
                            116u8,
                            72u8,
                            26u8,
                            180u8,
                            225u8,
                            83u8,
                            200u8,
                            157u8,
                            125u8,
                            151u8,
                            53u8,
                            76u8,
                            168u8,
                            26u8,
                            10u8,
                            9u8,
                            98u8,
                            68u8,
                            9u8,
                            178u8,
                            197u8,
                            113u8,
                            31u8,
                            79u8,
                            200u8,
                            90u8,
                            203u8,
                            100u8,
                            41u8,
                            145u8,
                        ],
                    )
                }
                /// Base reward for a signed solution
                pub fn signed_reward_base(
                    &self,
                ) -> ::subxt::constants::Address<::core::primitive::u128> {
                    ::subxt::constants::Address::new_static(
                        "ElectionProviderMultiPhase",
                        "SignedRewardBase",
                        [
                            84u8,
                            157u8,
                            140u8,
                            4u8,
                            93u8,
                            57u8,
                            29u8,
                            133u8,
                            105u8,
                            200u8,
                            214u8,
                            27u8,
                            144u8,
                            208u8,
                            218u8,
                            160u8,
                            130u8,
                            109u8,
                            101u8,
                            54u8,
                            210u8,
                            136u8,
                            71u8,
                            63u8,
                            49u8,
                            237u8,
                            234u8,
                            15u8,
                            178u8,
                            98u8,
                            148u8,
                            156u8,
                        ],
                    )
                }
                /// Base deposit for a signed solution.
                pub fn signed_deposit_base(
                    &self,
                ) -> ::subxt::constants::Address<::core::primitive::u128> {
                    ::subxt::constants::Address::new_static(
                        "ElectionProviderMultiPhase",
                        "SignedDepositBase",
                        [
                            84u8,
                            157u8,
                            140u8,
                            4u8,
                            93u8,
                            57u8,
                            29u8,
                            133u8,
                            105u8,
                            200u8,
                            214u8,
                            27u8,
                            144u8,
                            208u8,
                            218u8,
                            160u8,
                            130u8,
                            109u8,
                            101u8,
                            54u8,
                            210u8,
                            136u8,
                            71u8,
                            63u8,
                            49u8,
                            237u8,
                            234u8,
                            15u8,
                            178u8,
                            98u8,
                            148u8,
                            156u8,
                        ],
                    )
                }
                /// Per-byte deposit for a signed solution.
                pub fn signed_deposit_byte(
                    &self,
                ) -> ::subxt::constants::Address<::core::primitive::u128> {
                    ::subxt::constants::Address::new_static(
                        "ElectionProviderMultiPhase",
                        "SignedDepositByte",
                        [
                            84u8,
                            157u8,
                            140u8,
                            4u8,
                            93u8,
                            57u8,
                            29u8,
                            133u8,
                            105u8,
                            200u8,
                            214u8,
                            27u8,
                            144u8,
                            208u8,
                            218u8,
                            160u8,
                            130u8,
                            109u8,
                            101u8,
                            54u8,
                            210u8,
                            136u8,
                            71u8,
                            63u8,
                            49u8,
                            237u8,
                            234u8,
                            15u8,
                            178u8,
                            98u8,
                            148u8,
                            156u8,
                        ],
                    )
                }
                /// Per-weight deposit for a signed solution.
                pub fn signed_deposit_weight(
                    &self,
                ) -> ::subxt::constants::Address<::core::primitive::u128> {
                    ::subxt::constants::Address::new_static(
                        "ElectionProviderMultiPhase",
                        "SignedDepositWeight",
                        [
                            84u8,
                            157u8,
                            140u8,
                            4u8,
                            93u8,
                            57u8,
                            29u8,
                            133u8,
                            105u8,
                            200u8,
                            214u8,
                            27u8,
                            144u8,
                            208u8,
                            218u8,
                            160u8,
                            130u8,
                            109u8,
                            101u8,
                            54u8,
                            210u8,
                            136u8,
                            71u8,
                            63u8,
                            49u8,
                            237u8,
                            234u8,
                            15u8,
                            178u8,
                            98u8,
                            148u8,
                            156u8,
                        ],
                    )
                }
                /// The maximum number of electing voters to put in the snapshot. At the moment, snapshots
                /// are only over a single block, but once multi-block elections are introduced they will
                /// take place over multiple blocks.
                pub fn max_electing_voters(
                    &self,
                ) -> ::subxt::constants::Address<::core::primitive::u32> {
                    ::subxt::constants::Address::new_static(
                        "ElectionProviderMultiPhase",
                        "MaxElectingVoters",
                        [
                            98u8,
                            252u8,
                            116u8,
                            72u8,
                            26u8,
                            180u8,
                            225u8,
                            83u8,
                            200u8,
                            157u8,
                            125u8,
                            151u8,
                            53u8,
                            76u8,
                            168u8,
                            26u8,
                            10u8,
                            9u8,
                            98u8,
                            68u8,
                            9u8,
                            178u8,
                            197u8,
                            113u8,
                            31u8,
                            79u8,
                            200u8,
                            90u8,
                            203u8,
                            100u8,
                            41u8,
                            145u8,
                        ],
                    )
                }
                /// The maximum number of electable targets to put in the snapshot.
                pub fn max_electable_targets(
                    &self,
                ) -> ::subxt::constants::Address<::core::primitive::u16> {
                    ::subxt::constants::Address::new_static(
                        "ElectionProviderMultiPhase",
                        "MaxElectableTargets",
                        [
                            116u8,
                            33u8,
                            2u8,
                            170u8,
                            181u8,
                            147u8,
                            171u8,
                            169u8,
                            167u8,
                            227u8,
                            41u8,
                            144u8,
                            11u8,
                            236u8,
                            82u8,
                            100u8,
                            74u8,
                            60u8,
                            184u8,
                            72u8,
                            169u8,
                            90u8,
                            208u8,
                            135u8,
                            15u8,
                            117u8,
                            10u8,
                            123u8,
                            128u8,
                            193u8,
                            29u8,
                            70u8,
                        ],
                    )
                }
                /// The maximum number of winners that can be elected by this `ElectionProvider`
                /// implementation.
                ///
                /// Note: This must always be greater or equal to `T::DataProvider::desired_targets()`.
                pub fn max_winners(
                    &self,
                ) -> ::subxt::constants::Address<::core::primitive::u32> {
                    ::subxt::constants::Address::new_static(
                        "ElectionProviderMultiPhase",
                        "MaxWinners",
                        [
                            98u8,
                            252u8,
                            116u8,
                            72u8,
                            26u8,
                            180u8,
                            225u8,
                            83u8,
                            200u8,
                            157u8,
                            125u8,
                            151u8,
                            53u8,
                            76u8,
                            168u8,
                            26u8,
                            10u8,
                            9u8,
                            98u8,
                            68u8,
                            9u8,
                            178u8,
                            197u8,
                            113u8,
                            31u8,
                            79u8,
                            200u8,
                            90u8,
                            203u8,
                            100u8,
                            41u8,
                            145u8,
                        ],
                    )
                }
                pub fn miner_max_length(
                    &self,
                ) -> ::subxt::constants::Address<::core::primitive::u32> {
                    ::subxt::constants::Address::new_static(
                        "ElectionProviderMultiPhase",
                        "MinerMaxLength",
                        [
                            98u8,
                            252u8,
                            116u8,
                            72u8,
                            26u8,
                            180u8,
                            225u8,
                            83u8,
                            200u8,
                            157u8,
                            125u8,
                            151u8,
                            53u8,
                            76u8,
                            168u8,
                            26u8,
                            10u8,
                            9u8,
                            98u8,
                            68u8,
                            9u8,
                            178u8,
                            197u8,
                            113u8,
                            31u8,
                            79u8,
                            200u8,
                            90u8,
                            203u8,
                            100u8,
                            41u8,
                            145u8,
                        ],
                    )
                }
                pub fn miner_max_weight(
                    &self,
                ) -> ::subxt::constants::Address<
                    runtime_types::sp_weights::weight_v2::Weight,
                > {
                    ::subxt::constants::Address::new_static(
                        "ElectionProviderMultiPhase",
                        "MinerMaxWeight",
                        [
                            222u8,
                            183u8,
                            203u8,
                            169u8,
                            31u8,
                            134u8,
                            28u8,
                            12u8,
                            47u8,
                            140u8,
                            71u8,
                            74u8,
                            61u8,
                            55u8,
                            71u8,
                            236u8,
                            215u8,
                            83u8,
                            28u8,
                            70u8,
                            45u8,
                            128u8,
                            184u8,
                            57u8,
                            101u8,
                            83u8,
                            42u8,
                            165u8,
                            34u8,
                            155u8,
                            64u8,
                            145u8,
                        ],
                    )
                }
                pub fn miner_max_votes_per_voter(
                    &self,
                ) -> ::subxt::constants::Address<::core::primitive::u32> {
                    ::subxt::constants::Address::new_static(
                        "ElectionProviderMultiPhase",
                        "MinerMaxVotesPerVoter",
                        [
                            98u8,
                            252u8,
                            116u8,
                            72u8,
                            26u8,
                            180u8,
                            225u8,
                            83u8,
                            200u8,
                            157u8,
                            125u8,
                            151u8,
                            53u8,
                            76u8,
                            168u8,
                            26u8,
                            10u8,
                            9u8,
                            98u8,
                            68u8,
                            9u8,
                            178u8,
                            197u8,
                            113u8,
                            31u8,
                            79u8,
                            200u8,
                            90u8,
                            203u8,
                            100u8,
                            41u8,
                            145u8,
                        ],
                    )
                }
                pub fn miner_max_winners(
                    &self,
                ) -> ::subxt::constants::Address<::core::primitive::u32> {
                    ::subxt::constants::Address::new_static(
                        "ElectionProviderMultiPhase",
                        "MinerMaxWinners",
                        [
                            98u8,
                            252u8,
                            116u8,
                            72u8,
                            26u8,
                            180u8,
                            225u8,
                            83u8,
                            200u8,
                            157u8,
                            125u8,
                            151u8,
                            53u8,
                            76u8,
                            168u8,
                            26u8,
                            10u8,
                            9u8,
                            98u8,
                            68u8,
                            9u8,
                            178u8,
                            197u8,
                            113u8,
                            31u8,
                            79u8,
                            200u8,
                            90u8,
                            203u8,
                            100u8,
                            41u8,
                            145u8,
                        ],
                    )
                }
            }
        }
    }
    pub mod staking {
        use super::root_mod;
        use super::runtime_types;
        /**
			Custom [dispatch errors](https://docs.substrate.io/main-docs/build/events-errors/)
			of this pallet.
			*/
        pub type Error = runtime_types::pallet_staking::pallet::pallet::Error;
        ///Contains one variant per dispatchable that can be called by an extrinsic.
        pub type Call = runtime_types::pallet_staking::pallet::pallet::Call;
        pub mod calls {
            use super::root_mod;
            use super::runtime_types;
            type DispatchError = runtime_types::sp_runtime::DispatchError;
            pub mod types {
                use super::runtime_types;
                #[derive(
                    ::subxt::ext::codec::Decode,
                    ::subxt::ext::codec::Encode,
                    ::subxt::ext::scale_decode::DecodeAsType,
                    ::subxt::ext::scale_encode::EncodeAsType,
                    Clone,
                    Debug,
                    Eq,
                    PartialEq
                )]
                #[codec(crate = ::subxt::ext::codec)]
                #[decode_as_type(crate_path = ":: subxt :: ext :: scale_decode")]
                #[encode_as_type(crate_path = ":: subxt :: ext :: scale_encode")]
                pub struct Bond {
                    #[codec(compact)]
                    pub value: ::core::primitive::u128,
                    pub payee: runtime_types::pallet_staking::RewardDestination<
                        ::subxt::utils::AccountId32,
                    >,
                }
                impl ::subxt::blocks::StaticExtrinsic for Bond {
                    const PALLET: &'static str = "Staking";
                    const CALL: &'static str = "bond";
                }
                #[derive(
                    ::subxt::ext::codec::Decode,
                    ::subxt::ext::codec::Encode,
                    ::subxt::ext::scale_decode::DecodeAsType,
                    ::subxt::ext::scale_encode::EncodeAsType,
                    Clone,
                    Debug,
                    Eq,
                    PartialEq
                )]
                #[codec(crate = ::subxt::ext::codec)]
                #[decode_as_type(crate_path = ":: subxt :: ext :: scale_decode")]
                #[encode_as_type(crate_path = ":: subxt :: ext :: scale_encode")]
                pub struct BondExtra {
                    #[codec(compact)]
                    pub max_additional: ::core::primitive::u128,
                }
                impl ::subxt::blocks::StaticExtrinsic for BondExtra {
                    const PALLET: &'static str = "Staking";
                    const CALL: &'static str = "bond_extra";
                }
                #[derive(
                    ::subxt::ext::codec::Decode,
                    ::subxt::ext::codec::Encode,
                    ::subxt::ext::scale_decode::DecodeAsType,
                    ::subxt::ext::scale_encode::EncodeAsType,
                    Clone,
                    Debug,
                    Eq,
                    PartialEq
                )]
                #[codec(crate = ::subxt::ext::codec)]
                #[decode_as_type(crate_path = ":: subxt :: ext :: scale_decode")]
                #[encode_as_type(crate_path = ":: subxt :: ext :: scale_encode")]
                pub struct Unbond {
                    #[codec(compact)]
                    pub value: ::core::primitive::u128,
                }
                impl ::subxt::blocks::StaticExtrinsic for Unbond {
                    const PALLET: &'static str = "Staking";
                    const CALL: &'static str = "unbond";
                }
                #[derive(
                    ::subxt::ext::codec::CompactAs,
                    ::subxt::ext::codec::Decode,
                    ::subxt::ext::codec::Encode,
                    ::subxt::ext::scale_decode::DecodeAsType,
                    ::subxt::ext::scale_encode::EncodeAsType,
                    Clone,
                    Debug,
                    Eq,
                    PartialEq
                )]
                #[codec(crate = ::subxt::ext::codec)]
                #[decode_as_type(crate_path = ":: subxt :: ext :: scale_decode")]
                #[encode_as_type(crate_path = ":: subxt :: ext :: scale_encode")]
                pub struct WithdrawUnbonded {
                    pub num_slashing_spans: ::core::primitive::u32,
                }
                impl ::subxt::blocks::StaticExtrinsic for WithdrawUnbonded {
                    const PALLET: &'static str = "Staking";
                    const CALL: &'static str = "withdraw_unbonded";
                }
                #[derive(
                    ::subxt::ext::codec::Decode,
                    ::subxt::ext::codec::Encode,
                    ::subxt::ext::scale_decode::DecodeAsType,
                    ::subxt::ext::scale_encode::EncodeAsType,
                    Clone,
                    Debug,
                    Eq,
                    PartialEq
                )]
                #[codec(crate = ::subxt::ext::codec)]
                #[decode_as_type(crate_path = ":: subxt :: ext :: scale_decode")]
                #[encode_as_type(crate_path = ":: subxt :: ext :: scale_encode")]
                pub struct Validate {
                    pub prefs: runtime_types::pallet_staking::ValidatorPrefs,
                }
                impl ::subxt::blocks::StaticExtrinsic for Validate {
                    const PALLET: &'static str = "Staking";
                    const CALL: &'static str = "validate";
                }
                #[derive(
                    ::subxt::ext::codec::Decode,
                    ::subxt::ext::codec::Encode,
                    ::subxt::ext::scale_decode::DecodeAsType,
                    ::subxt::ext::scale_encode::EncodeAsType,
                    Clone,
                    Debug,
                    Eq,
                    PartialEq
                )]
                #[codec(crate = ::subxt::ext::codec)]
                #[decode_as_type(crate_path = ":: subxt :: ext :: scale_decode")]
                #[encode_as_type(crate_path = ":: subxt :: ext :: scale_encode")]
                pub struct Nominate {
                    pub targets: ::std::vec::Vec<
                        ::subxt::utils::MultiAddress<
                            ::subxt::utils::AccountId32,
                            ::core::primitive::u32,
                        >,
                    >,
                }
                impl ::subxt::blocks::StaticExtrinsic for Nominate {
                    const PALLET: &'static str = "Staking";
                    const CALL: &'static str = "nominate";
                }
                #[derive(
                    ::subxt::ext::codec::Decode,
                    ::subxt::ext::codec::Encode,
                    ::subxt::ext::scale_decode::DecodeAsType,
                    ::subxt::ext::scale_encode::EncodeAsType,
                    Clone,
                    Debug,
                    Eq,
                    PartialEq
                )]
                #[codec(crate = ::subxt::ext::codec)]
                #[decode_as_type(crate_path = ":: subxt :: ext :: scale_decode")]
                #[encode_as_type(crate_path = ":: subxt :: ext :: scale_encode")]
                pub struct Chill;
                impl ::subxt::blocks::StaticExtrinsic for Chill {
                    const PALLET: &'static str = "Staking";
                    const CALL: &'static str = "chill";
                }
                #[derive(
                    ::subxt::ext::codec::Decode,
                    ::subxt::ext::codec::Encode,
                    ::subxt::ext::scale_decode::DecodeAsType,
                    ::subxt::ext::scale_encode::EncodeAsType,
                    Clone,
                    Debug,
                    Eq,
                    PartialEq
                )]
                #[codec(crate = ::subxt::ext::codec)]
                #[decode_as_type(crate_path = ":: subxt :: ext :: scale_decode")]
                #[encode_as_type(crate_path = ":: subxt :: ext :: scale_encode")]
                pub struct SetPayee {
                    pub payee: runtime_types::pallet_staking::RewardDestination<
                        ::subxt::utils::AccountId32,
                    >,
                }
                impl ::subxt::blocks::StaticExtrinsic for SetPayee {
                    const PALLET: &'static str = "Staking";
                    const CALL: &'static str = "set_payee";
                }
                #[derive(
                    ::subxt::ext::codec::Decode,
                    ::subxt::ext::codec::Encode,
                    ::subxt::ext::scale_decode::DecodeAsType,
                    ::subxt::ext::scale_encode::EncodeAsType,
                    Clone,
                    Debug,
                    Eq,
                    PartialEq
                )]
                #[codec(crate = ::subxt::ext::codec)]
                #[decode_as_type(crate_path = ":: subxt :: ext :: scale_decode")]
                #[encode_as_type(crate_path = ":: subxt :: ext :: scale_encode")]
                pub struct SetController;
                impl ::subxt::blocks::StaticExtrinsic for SetController {
                    const PALLET: &'static str = "Staking";
                    const CALL: &'static str = "set_controller";
                }
                #[derive(
                    ::subxt::ext::codec::Decode,
                    ::subxt::ext::codec::Encode,
                    ::subxt::ext::scale_decode::DecodeAsType,
                    ::subxt::ext::scale_encode::EncodeAsType,
                    Clone,
                    Debug,
                    Eq,
                    PartialEq
                )]
                #[codec(crate = ::subxt::ext::codec)]
                #[decode_as_type(crate_path = ":: subxt :: ext :: scale_decode")]
                #[encode_as_type(crate_path = ":: subxt :: ext :: scale_encode")]
                pub struct SetValidatorCount {
                    #[codec(compact)]
                    pub new: ::core::primitive::u32,
                }
                impl ::subxt::blocks::StaticExtrinsic for SetValidatorCount {
                    const PALLET: &'static str = "Staking";
                    const CALL: &'static str = "set_validator_count";
                }
                #[derive(
                    ::subxt::ext::codec::Decode,
                    ::subxt::ext::codec::Encode,
                    ::subxt::ext::scale_decode::DecodeAsType,
                    ::subxt::ext::scale_encode::EncodeAsType,
                    Clone,
                    Debug,
                    Eq,
                    PartialEq
                )]
                #[codec(crate = ::subxt::ext::codec)]
                #[decode_as_type(crate_path = ":: subxt :: ext :: scale_decode")]
                #[encode_as_type(crate_path = ":: subxt :: ext :: scale_encode")]
                pub struct IncreaseValidatorCount {
                    #[codec(compact)]
                    pub additional: ::core::primitive::u32,
                }
                impl ::subxt::blocks::StaticExtrinsic for IncreaseValidatorCount {
                    const PALLET: &'static str = "Staking";
                    const CALL: &'static str = "increase_validator_count";
                }
                #[derive(
                    ::subxt::ext::codec::Decode,
                    ::subxt::ext::codec::Encode,
                    ::subxt::ext::scale_decode::DecodeAsType,
                    ::subxt::ext::scale_encode::EncodeAsType,
                    Clone,
                    Debug,
                    Eq,
                    PartialEq
                )]
                #[codec(crate = ::subxt::ext::codec)]
                #[decode_as_type(crate_path = ":: subxt :: ext :: scale_decode")]
                #[encode_as_type(crate_path = ":: subxt :: ext :: scale_encode")]
                pub struct ScaleValidatorCount {
                    pub factor: runtime_types::sp_arithmetic::per_things::Percent,
                }
                impl ::subxt::blocks::StaticExtrinsic for ScaleValidatorCount {
                    const PALLET: &'static str = "Staking";
                    const CALL: &'static str = "scale_validator_count";
                }
                #[derive(
                    ::subxt::ext::codec::Decode,
                    ::subxt::ext::codec::Encode,
                    ::subxt::ext::scale_decode::DecodeAsType,
                    ::subxt::ext::scale_encode::EncodeAsType,
                    Clone,
                    Debug,
                    Eq,
                    PartialEq
                )]
                #[codec(crate = ::subxt::ext::codec)]
                #[decode_as_type(crate_path = ":: subxt :: ext :: scale_decode")]
                #[encode_as_type(crate_path = ":: subxt :: ext :: scale_encode")]
                pub struct ForceNoEras;
                impl ::subxt::blocks::StaticExtrinsic for ForceNoEras {
                    const PALLET: &'static str = "Staking";
                    const CALL: &'static str = "force_no_eras";
                }
                #[derive(
                    ::subxt::ext::codec::Decode,
                    ::subxt::ext::codec::Encode,
                    ::subxt::ext::scale_decode::DecodeAsType,
                    ::subxt::ext::scale_encode::EncodeAsType,
                    Clone,
                    Debug,
                    Eq,
                    PartialEq
                )]
                #[codec(crate = ::subxt::ext::codec)]
                #[decode_as_type(crate_path = ":: subxt :: ext :: scale_decode")]
                #[encode_as_type(crate_path = ":: subxt :: ext :: scale_encode")]
                pub struct ForceNewEra;
                impl ::subxt::blocks::StaticExtrinsic for ForceNewEra {
                    const PALLET: &'static str = "Staking";
                    const CALL: &'static str = "force_new_era";
                }
                #[derive(
                    ::subxt::ext::codec::Decode,
                    ::subxt::ext::codec::Encode,
                    ::subxt::ext::scale_decode::DecodeAsType,
                    ::subxt::ext::scale_encode::EncodeAsType,
                    Clone,
                    Debug,
                    Eq,
                    PartialEq
                )]
                #[codec(crate = ::subxt::ext::codec)]
                #[decode_as_type(crate_path = ":: subxt :: ext :: scale_decode")]
                #[encode_as_type(crate_path = ":: subxt :: ext :: scale_encode")]
                pub struct SetInvulnerables {
                    pub invulnerables: ::std::vec::Vec<::subxt::utils::AccountId32>,
                }
                impl ::subxt::blocks::StaticExtrinsic for SetInvulnerables {
                    const PALLET: &'static str = "Staking";
                    const CALL: &'static str = "set_invulnerables";
                }
                #[derive(
                    ::subxt::ext::codec::Decode,
                    ::subxt::ext::codec::Encode,
                    ::subxt::ext::scale_decode::DecodeAsType,
                    ::subxt::ext::scale_encode::EncodeAsType,
                    Clone,
                    Debug,
                    Eq,
                    PartialEq
                )]
                #[codec(crate = ::subxt::ext::codec)]
                #[decode_as_type(crate_path = ":: subxt :: ext :: scale_decode")]
                #[encode_as_type(crate_path = ":: subxt :: ext :: scale_encode")]
                pub struct ForceUnstake {
                    pub stash: ::subxt::utils::AccountId32,
                    pub num_slashing_spans: ::core::primitive::u32,
                }
                impl ::subxt::blocks::StaticExtrinsic for ForceUnstake {
                    const PALLET: &'static str = "Staking";
                    const CALL: &'static str = "force_unstake";
                }
                #[derive(
                    ::subxt::ext::codec::Decode,
                    ::subxt::ext::codec::Encode,
                    ::subxt::ext::scale_decode::DecodeAsType,
                    ::subxt::ext::scale_encode::EncodeAsType,
                    Clone,
                    Debug,
                    Eq,
                    PartialEq
                )]
                #[codec(crate = ::subxt::ext::codec)]
                #[decode_as_type(crate_path = ":: subxt :: ext :: scale_decode")]
                #[encode_as_type(crate_path = ":: subxt :: ext :: scale_encode")]
                pub struct ForceNewEraAlways;
                impl ::subxt::blocks::StaticExtrinsic for ForceNewEraAlways {
                    const PALLET: &'static str = "Staking";
                    const CALL: &'static str = "force_new_era_always";
                }
                #[derive(
                    ::subxt::ext::codec::Decode,
                    ::subxt::ext::codec::Encode,
                    ::subxt::ext::scale_decode::DecodeAsType,
                    ::subxt::ext::scale_encode::EncodeAsType,
                    Clone,
                    Debug,
                    Eq,
                    PartialEq
                )]
                #[codec(crate = ::subxt::ext::codec)]
                #[decode_as_type(crate_path = ":: subxt :: ext :: scale_decode")]
                #[encode_as_type(crate_path = ":: subxt :: ext :: scale_encode")]
                pub struct CancelDeferredSlash {
                    pub era: ::core::primitive::u32,
                    pub slash_indices: ::std::vec::Vec<::core::primitive::u32>,
                }
                impl ::subxt::blocks::StaticExtrinsic for CancelDeferredSlash {
                    const PALLET: &'static str = "Staking";
                    const CALL: &'static str = "cancel_deferred_slash";
                }
                #[derive(
                    ::subxt::ext::codec::Decode,
                    ::subxt::ext::codec::Encode,
                    ::subxt::ext::scale_decode::DecodeAsType,
                    ::subxt::ext::scale_encode::EncodeAsType,
                    Clone,
                    Debug,
                    Eq,
                    PartialEq
                )]
                #[codec(crate = ::subxt::ext::codec)]
                #[decode_as_type(crate_path = ":: subxt :: ext :: scale_decode")]
                #[encode_as_type(crate_path = ":: subxt :: ext :: scale_encode")]
                pub struct PayoutStakers {
                    pub validator_stash: ::subxt::utils::AccountId32,
                    pub era: ::core::primitive::u32,
                }
                impl ::subxt::blocks::StaticExtrinsic for PayoutStakers {
                    const PALLET: &'static str = "Staking";
                    const CALL: &'static str = "payout_stakers";
                }
                #[derive(
                    ::subxt::ext::codec::Decode,
                    ::subxt::ext::codec::Encode,
                    ::subxt::ext::scale_decode::DecodeAsType,
                    ::subxt::ext::scale_encode::EncodeAsType,
                    Clone,
                    Debug,
                    Eq,
                    PartialEq
                )]
                #[codec(crate = ::subxt::ext::codec)]
                #[decode_as_type(crate_path = ":: subxt :: ext :: scale_decode")]
                #[encode_as_type(crate_path = ":: subxt :: ext :: scale_encode")]
                pub struct Rebond {
                    #[codec(compact)]
                    pub value: ::core::primitive::u128,
                }
                impl ::subxt::blocks::StaticExtrinsic for Rebond {
                    const PALLET: &'static str = "Staking";
                    const CALL: &'static str = "rebond";
                }
                #[derive(
                    ::subxt::ext::codec::Decode,
                    ::subxt::ext::codec::Encode,
                    ::subxt::ext::scale_decode::DecodeAsType,
                    ::subxt::ext::scale_encode::EncodeAsType,
                    Clone,
                    Debug,
                    Eq,
                    PartialEq
                )]
                #[codec(crate = ::subxt::ext::codec)]
                #[decode_as_type(crate_path = ":: subxt :: ext :: scale_decode")]
                #[encode_as_type(crate_path = ":: subxt :: ext :: scale_encode")]
                pub struct ReapStash {
                    pub stash: ::subxt::utils::AccountId32,
                    pub num_slashing_spans: ::core::primitive::u32,
                }
                impl ::subxt::blocks::StaticExtrinsic for ReapStash {
                    const PALLET: &'static str = "Staking";
                    const CALL: &'static str = "reap_stash";
                }
                #[derive(
                    ::subxt::ext::codec::Decode,
                    ::subxt::ext::codec::Encode,
                    ::subxt::ext::scale_decode::DecodeAsType,
                    ::subxt::ext::scale_encode::EncodeAsType,
                    Clone,
                    Debug,
                    Eq,
                    PartialEq
                )]
                #[codec(crate = ::subxt::ext::codec)]
                #[decode_as_type(crate_path = ":: subxt :: ext :: scale_decode")]
                #[encode_as_type(crate_path = ":: subxt :: ext :: scale_encode")]
                pub struct Kick {
                    pub who: ::std::vec::Vec<
                        ::subxt::utils::MultiAddress<
                            ::subxt::utils::AccountId32,
                            ::core::primitive::u32,
                        >,
                    >,
                }
                impl ::subxt::blocks::StaticExtrinsic for Kick {
                    const PALLET: &'static str = "Staking";
                    const CALL: &'static str = "kick";
                }
                #[derive(
                    ::subxt::ext::codec::Decode,
                    ::subxt::ext::codec::Encode,
                    ::subxt::ext::scale_decode::DecodeAsType,
                    ::subxt::ext::scale_encode::EncodeAsType,
                    Clone,
                    Debug,
                    Eq,
                    PartialEq
                )]
                #[codec(crate = ::subxt::ext::codec)]
                #[decode_as_type(crate_path = ":: subxt :: ext :: scale_decode")]
                #[encode_as_type(crate_path = ":: subxt :: ext :: scale_encode")]
                pub struct SetStakingConfigs {
                    pub min_nominator_bond: runtime_types::pallet_staking::pallet::pallet::ConfigOp<
                        ::core::primitive::u128,
                    >,
                    pub min_validator_bond: runtime_types::pallet_staking::pallet::pallet::ConfigOp<
                        ::core::primitive::u128,
                    >,
                    pub max_nominator_count: runtime_types::pallet_staking::pallet::pallet::ConfigOp<
                        ::core::primitive::u32,
                    >,
                    pub max_validator_count: runtime_types::pallet_staking::pallet::pallet::ConfigOp<
                        ::core::primitive::u32,
                    >,
                    pub chill_threshold: runtime_types::pallet_staking::pallet::pallet::ConfigOp<
                        runtime_types::sp_arithmetic::per_things::Percent,
                    >,
                    pub min_commission: runtime_types::pallet_staking::pallet::pallet::ConfigOp<
                        runtime_types::sp_arithmetic::per_things::Perbill,
                    >,
                }
                impl ::subxt::blocks::StaticExtrinsic for SetStakingConfigs {
                    const PALLET: &'static str = "Staking";
                    const CALL: &'static str = "set_staking_configs";
                }
                #[derive(
                    ::subxt::ext::codec::Decode,
                    ::subxt::ext::codec::Encode,
                    ::subxt::ext::scale_decode::DecodeAsType,
                    ::subxt::ext::scale_encode::EncodeAsType,
                    Clone,
                    Debug,
                    Eq,
                    PartialEq
                )]
                #[codec(crate = ::subxt::ext::codec)]
                #[decode_as_type(crate_path = ":: subxt :: ext :: scale_decode")]
                #[encode_as_type(crate_path = ":: subxt :: ext :: scale_encode")]
                pub struct ChillOther {
                    pub controller: ::subxt::utils::AccountId32,
                }
                impl ::subxt::blocks::StaticExtrinsic for ChillOther {
                    const PALLET: &'static str = "Staking";
                    const CALL: &'static str = "chill_other";
                }
                #[derive(
                    ::subxt::ext::codec::Decode,
                    ::subxt::ext::codec::Encode,
                    ::subxt::ext::scale_decode::DecodeAsType,
                    ::subxt::ext::scale_encode::EncodeAsType,
                    Clone,
                    Debug,
                    Eq,
                    PartialEq
                )]
                #[codec(crate = ::subxt::ext::codec)]
                #[decode_as_type(crate_path = ":: subxt :: ext :: scale_decode")]
                #[encode_as_type(crate_path = ":: subxt :: ext :: scale_encode")]
                pub struct ForceApplyMinCommission {
                    pub validator_stash: ::subxt::utils::AccountId32,
                }
                impl ::subxt::blocks::StaticExtrinsic for ForceApplyMinCommission {
                    const PALLET: &'static str = "Staking";
                    const CALL: &'static str = "force_apply_min_commission";
                }
                #[derive(
                    ::subxt::ext::codec::Decode,
                    ::subxt::ext::codec::Encode,
                    ::subxt::ext::scale_decode::DecodeAsType,
                    ::subxt::ext::scale_encode::EncodeAsType,
                    Clone,
                    Debug,
                    Eq,
                    PartialEq
                )]
                #[codec(crate = ::subxt::ext::codec)]
                #[decode_as_type(crate_path = ":: subxt :: ext :: scale_decode")]
                #[encode_as_type(crate_path = ":: subxt :: ext :: scale_encode")]
                pub struct SetMinCommission {
                    pub new: runtime_types::sp_arithmetic::per_things::Perbill,
                }
                impl ::subxt::blocks::StaticExtrinsic for SetMinCommission {
                    const PALLET: &'static str = "Staking";
                    const CALL: &'static str = "set_min_commission";
                }
            }
            pub struct TransactionApi;
            impl TransactionApi {
                ///Take the origin account as a stash and lock up `value` of its balance. `controller` will
                ///be the account that controls it.
                ///
                ///`value` must be more than the `minimum_balance` specified by `T::Currency`.
                ///
                ///The dispatch origin for this call must be _Signed_ by the stash account.
                ///
                ///Emits `Bonded`.
                ///## Complexity
                ///- Independent of the arguments. Moderate complexity.
                ///- O(1).
                ///- Three extra DB entries.
                ///
                ///NOTE: Two of the storage writes (`Self::bonded`, `Self::payee`) are _never_ cleaned
                ///unless the `origin` falls below _existential deposit_ and gets removed as dust.
                pub fn bond(
                    &self,
                    value: ::core::primitive::u128,
                    payee: runtime_types::pallet_staking::RewardDestination<
                        ::subxt::utils::AccountId32,
                    >,
                ) -> ::subxt::tx::Payload<types::Bond> {
                    ::subxt::tx::Payload::new_static(
                        "Staking",
                        "bond",
                        types::Bond { value, payee },
                        [
                            45u8,
                            207u8,
                            34u8,
                            221u8,
                            252u8,
                            224u8,
                            162u8,
                            185u8,
                            67u8,
                            224u8,
                            88u8,
                            91u8,
                            232u8,
                            114u8,
                            183u8,
                            44u8,
                            39u8,
                            5u8,
                            12u8,
                            163u8,
                            57u8,
                            31u8,
                            251u8,
                            58u8,
                            37u8,
                            232u8,
                            206u8,
                            75u8,
                            164u8,
                            26u8,
                            170u8,
                            101u8,
                        ],
                    )
                }
                ///Add some extra amount that have appeared in the stash `free_balance` into the balance up
                ///for staking.
                ///
                ///The dispatch origin for this call must be _Signed_ by the stash, not the controller.
                ///
                ///Use this if there are additional funds in your stash account that you wish to bond.
                ///Unlike [`bond`](Self::bond) or [`unbond`](Self::unbond) this function does not impose
                ///any limitation on the amount that can be added.
                ///
                ///Emits `Bonded`.
                ///
                ///## Complexity
                ///- Independent of the arguments. Insignificant complexity.
                ///- O(1).
                pub fn bond_extra(
                    &self,
                    max_additional: ::core::primitive::u128,
                ) -> ::subxt::tx::Payload<types::BondExtra> {
                    ::subxt::tx::Payload::new_static(
                        "Staking",
                        "bond_extra",
                        types::BondExtra { max_additional },
                        [
                            9u8,
                            143u8,
                            179u8,
                            99u8,
                            91u8,
                            254u8,
                            114u8,
                            189u8,
                            202u8,
                            245u8,
                            48u8,
                            130u8,
                            103u8,
                            17u8,
                            183u8,
                            177u8,
                            172u8,
                            156u8,
                            227u8,
                            145u8,
                            191u8,
                            134u8,
                            81u8,
                            3u8,
                            170u8,
                            85u8,
                            40u8,
                            56u8,
                            216u8,
                            95u8,
                            232u8,
                            52u8,
                        ],
                    )
                }
                ///Schedule a portion of the stash to be unlocked ready for transfer out after the bond
                ///period ends. If this leaves an amount actively bonded less than
                ///T::Currency::minimum_balance(), then it is increased to the full amount.
                ///
                ///The dispatch origin for this call must be _Signed_ by the controller, not the stash.
                ///
                ///Once the unlock period is done, you can call `withdraw_unbonded` to actually move
                ///the funds out of management ready for transfer.
                ///
                ///No more than a limited number of unlocking chunks (see `MaxUnlockingChunks`)
                ///can co-exists at the same time. If there are no unlocking chunks slots available
                ///[`Call::withdraw_unbonded`] is called to remove some of the chunks (if possible).
                ///
                ///If a user encounters the `InsufficientBond` error when calling this extrinsic,
                ///they should call `chill` first in order to free up their bonded funds.
                ///
                ///Emits `Unbonded`.
                ///
                ///See also [`Call::withdraw_unbonded`].
                pub fn unbond(
                    &self,
                    value: ::core::primitive::u128,
                ) -> ::subxt::tx::Payload<types::Unbond> {
                    ::subxt::tx::Payload::new_static(
                        "Staking",
                        "unbond",
                        types::Unbond { value },
                        [
                            70u8,
                            201u8,
                            146u8,
                            56u8,
                            51u8,
                            237u8,
                            90u8,
                            193u8,
                            69u8,
                            42u8,
                            168u8,
                            96u8,
                            215u8,
                            128u8,
                            253u8,
                            22u8,
                            239u8,
                            14u8,
                            214u8,
                            103u8,
                            170u8,
                            140u8,
                            2u8,
                            182u8,
                            3u8,
                            190u8,
                            184u8,
                            191u8,
                            231u8,
                            137u8,
                            50u8,
                            16u8,
                        ],
                    )
                }
                ///Remove any unlocked chunks from the `unlocking` queue from our management.
                ///
                ///This essentially frees up that balance to be used by the stash account to do
                ///whatever it wants.
                ///
                ///The dispatch origin for this call must be _Signed_ by the controller.
                ///
                ///Emits `Withdrawn`.
                ///
                ///See also [`Call::unbond`].
                ///
                ///## Complexity
                ///O(S) where S is the number of slashing spans to remove
                ///NOTE: Weight annotation is the kill scenario, we refund otherwise.
                pub fn withdraw_unbonded(
                    &self,
                    num_slashing_spans: ::core::primitive::u32,
                ) -> ::subxt::tx::Payload<types::WithdrawUnbonded> {
                    ::subxt::tx::Payload::new_static(
                        "Staking",
                        "withdraw_unbonded",
                        types::WithdrawUnbonded {
                            num_slashing_spans,
                        },
                        [
                            229u8,
                            128u8,
                            177u8,
                            224u8,
                            197u8,
                            118u8,
                            239u8,
                            142u8,
                            179u8,
                            164u8,
                            10u8,
                            205u8,
                            124u8,
                            254u8,
                            209u8,
                            157u8,
                            172u8,
                            87u8,
                            58u8,
                            120u8,
                            74u8,
                            12u8,
                            150u8,
                            117u8,
                            234u8,
                            32u8,
                            191u8,
                            182u8,
                            92u8,
                            97u8,
                            77u8,
                            59u8,
                        ],
                    )
                }
                ///Declare the desire to validate for the origin controller.
                ///
                ///Effects will be felt at the beginning of the next era.
                ///
                ///The dispatch origin for this call must be _Signed_ by the controller, not the stash.
                pub fn validate(
                    &self,
                    prefs: runtime_types::pallet_staking::ValidatorPrefs,
                ) -> ::subxt::tx::Payload<types::Validate> {
                    ::subxt::tx::Payload::new_static(
                        "Staking",
                        "validate",
                        types::Validate { prefs },
                        [
                            63u8,
                            83u8,
                            12u8,
                            16u8,
                            56u8,
                            84u8,
                            41u8,
                            141u8,
                            202u8,
                            0u8,
                            37u8,
                            30u8,
                            115u8,
                            2u8,
                            145u8,
                            101u8,
                            168u8,
                            89u8,
                            94u8,
                            98u8,
                            8u8,
                            45u8,
                            140u8,
                            237u8,
                            101u8,
                            136u8,
                            179u8,
                            162u8,
                            205u8,
                            41u8,
                            88u8,
                            248u8,
                        ],
                    )
                }
                ///Declare the desire to nominate `targets` for the origin controller.
                ///
                ///Effects will be felt at the beginning of the next era.
                ///
                ///The dispatch origin for this call must be _Signed_ by the controller, not the stash.
                ///
                ///## Complexity
                ///- The transaction's complexity is proportional to the size of `targets` (N)
                ///which is capped at CompactAssignments::LIMIT (T::MaxNominations).
                ///- Both the reads and writes follow a similar pattern.
                pub fn nominate(
                    &self,
                    targets: ::std::vec::Vec<
                        ::subxt::utils::MultiAddress<
                            ::subxt::utils::AccountId32,
                            ::core::primitive::u32,
                        >,
                    >,
                ) -> ::subxt::tx::Payload<types::Nominate> {
                    ::subxt::tx::Payload::new_static(
                        "Staking",
                        "nominate",
                        types::Nominate { targets },
                        [
                            15u8,
                            90u8,
                            71u8,
                            240u8,
                            160u8,
                            193u8,
                            136u8,
                            125u8,
                            36u8,
                            150u8,
                            105u8,
                            92u8,
                            188u8,
                            102u8,
                            160u8,
                            56u8,
                            164u8,
                            250u8,
                            75u8,
                            106u8,
                            10u8,
                            123u8,
                            18u8,
                            50u8,
                            59u8,
                            128u8,
                            35u8,
                            199u8,
                            103u8,
                            109u8,
                            45u8,
                            223u8,
                        ],
                    )
                }
                ///Declare no desire to either validate or nominate.
                ///
                ///Effects will be felt at the beginning of the next era.
                ///
                ///The dispatch origin for this call must be _Signed_ by the controller, not the stash.
                ///
                ///## Complexity
                ///- Independent of the arguments. Insignificant complexity.
                ///- Contains one read.
                ///- Writes are limited to the `origin` account key.
                pub fn chill(&self) -> ::subxt::tx::Payload<types::Chill> {
                    ::subxt::tx::Payload::new_static(
                        "Staking",
                        "chill",
                        types::Chill {},
                        [
                            157u8,
                            75u8,
                            243u8,
                            69u8,
                            110u8,
                            192u8,
                            22u8,
                            27u8,
                            107u8,
                            68u8,
                            236u8,
                            58u8,
                            179u8,
                            34u8,
                            118u8,
                            98u8,
                            131u8,
                            62u8,
                            242u8,
                            84u8,
                            149u8,
                            24u8,
                            83u8,
                            223u8,
                            78u8,
                            12u8,
                            192u8,
                            22u8,
                            111u8,
                            11u8,
                            171u8,
                            149u8,
                        ],
                    )
                }
                ///(Re-)set the payment target for a controller.
                ///
                ///Effects will be felt instantly (as soon as this function is completed successfully).
                ///
                ///The dispatch origin for this call must be _Signed_ by the controller, not the stash.
                ///
                ///## Complexity
                ///- O(1)
                ///- Independent of the arguments. Insignificant complexity.
                ///- Contains a limited number of reads.
                ///- Writes are limited to the `origin` account key.
                ///---------
                pub fn set_payee(
                    &self,
                    payee: runtime_types::pallet_staking::RewardDestination<
                        ::subxt::utils::AccountId32,
                    >,
                ) -> ::subxt::tx::Payload<types::SetPayee> {
                    ::subxt::tx::Payload::new_static(
                        "Staking",
                        "set_payee",
                        types::SetPayee { payee },
                        [
                            86u8,
                            172u8,
                            187u8,
                            98u8,
                            106u8,
                            240u8,
                            184u8,
                            60u8,
                            163u8,
                            244u8,
                            7u8,
                            64u8,
                            147u8,
                            168u8,
                            192u8,
                            177u8,
                            211u8,
                            138u8,
                            73u8,
                            188u8,
                            159u8,
                            154u8,
                            175u8,
                            219u8,
                            231u8,
                            235u8,
                            93u8,
                            195u8,
                            204u8,
                            100u8,
                            196u8,
                            241u8,
                        ],
                    )
                }
                ///(Re-)sets the controller of a stash to the stash itself. This function previously
                ///accepted a `controller` argument to set the controller to an account other than the
                ///stash itself. This functionality has now been removed, now only setting the controller
                ///to the stash, if it is not already.
                ///
                ///Effects will be felt instantly (as soon as this function is completed successfully).
                ///
                ///The dispatch origin for this call must be _Signed_ by the stash, not the controller.
                ///
                ///## Complexity
                ///O(1)
                ///- Independent of the arguments. Insignificant complexity.
                ///- Contains a limited number of reads.
                ///- Writes are limited to the `origin` account key.
                pub fn set_controller(
                    &self,
                ) -> ::subxt::tx::Payload<types::SetController> {
                    ::subxt::tx::Payload::new_static(
                        "Staking",
                        "set_controller",
                        types::SetController {},
                        [
                            172u8,
                            27u8,
                            195u8,
                            188u8,
                            145u8,
                            203u8,
                            190u8,
                            174u8,
                            145u8,
                            43u8,
                            253u8,
                            87u8,
                            11u8,
                            229u8,
                            112u8,
                            18u8,
                            57u8,
                            101u8,
                            84u8,
                            235u8,
                            109u8,
                            228u8,
                            58u8,
                            129u8,
                            179u8,
                            174u8,
                            245u8,
                            169u8,
                            89u8,
                            240u8,
                            39u8,
                            67u8,
                        ],
                    )
                }
                ///Sets the ideal number of validators.
                ///
                ///The dispatch origin must be Root.
                ///
                ///## Complexity
                ///O(1)
                pub fn set_validator_count(
                    &self,
                    new: ::core::primitive::u32,
                ) -> ::subxt::tx::Payload<types::SetValidatorCount> {
                    ::subxt::tx::Payload::new_static(
                        "Staking",
                        "set_validator_count",
                        types::SetValidatorCount { new },
                        [
                            172u8,
                            225u8,
                            157u8,
                            48u8,
                            242u8,
                            217u8,
                            126u8,
                            206u8,
                            26u8,
                            156u8,
                            203u8,
                            100u8,
                            116u8,
                            189u8,
                            98u8,
                            89u8,
                            151u8,
                            101u8,
                            77u8,
                            236u8,
                            101u8,
                            8u8,
                            148u8,
                            236u8,
                            180u8,
                            175u8,
                            232u8,
                            146u8,
                            141u8,
                            141u8,
                            78u8,
                            165u8,
                        ],
                    )
                }
                ///Increments the ideal number of validators upto maximum of
                ///`ElectionProviderBase::MaxWinners`.
                ///
                ///The dispatch origin must be Root.
                ///
                ///## Complexity
                ///Same as [`Self::set_validator_count`].
                pub fn increase_validator_count(
                    &self,
                    additional: ::core::primitive::u32,
                ) -> ::subxt::tx::Payload<types::IncreaseValidatorCount> {
                    ::subxt::tx::Payload::new_static(
                        "Staking",
                        "increase_validator_count",
                        types::IncreaseValidatorCount {
                            additional,
                        },
                        [
                            108u8,
                            67u8,
                            131u8,
                            248u8,
                            139u8,
                            227u8,
                            224u8,
                            221u8,
                            248u8,
                            94u8,
                            141u8,
                            104u8,
                            131u8,
                            250u8,
                            127u8,
                            164u8,
                            137u8,
                            211u8,
                            5u8,
                            27u8,
                            185u8,
                            251u8,
                            120u8,
                            243u8,
                            165u8,
                            50u8,
                            197u8,
                            161u8,
                            125u8,
                            195u8,
                            16u8,
                            29u8,
                        ],
                    )
                }
                ///Scale up the ideal number of validators by a factor upto maximum of
                ///`ElectionProviderBase::MaxWinners`.
                ///
                ///The dispatch origin must be Root.
                ///
                ///## Complexity
                ///Same as [`Self::set_validator_count`].
                pub fn scale_validator_count(
                    &self,
                    factor: runtime_types::sp_arithmetic::per_things::Percent,
                ) -> ::subxt::tx::Payload<types::ScaleValidatorCount> {
                    ::subxt::tx::Payload::new_static(
                        "Staking",
                        "scale_validator_count",
                        types::ScaleValidatorCount {
                            factor,
                        },
                        [
                            93u8,
                            200u8,
                            119u8,
                            240u8,
                            148u8,
                            144u8,
                            175u8,
                            135u8,
                            102u8,
                            130u8,
                            183u8,
                            216u8,
                            28u8,
                            215u8,
                            155u8,
                            233u8,
                            152u8,
                            65u8,
                            49u8,
                            125u8,
                            196u8,
                            79u8,
                            31u8,
                            195u8,
                            233u8,
                            79u8,
                            150u8,
                            138u8,
                            103u8,
                            161u8,
                            78u8,
                            154u8,
                        ],
                    )
                }
                ///Force there to be no new eras indefinitely.
                ///
                ///The dispatch origin must be Root.
                ///
                ///# Warning
                ///
                ///The election process starts multiple blocks before the end of the era.
                ///Thus the election process may be ongoing when this is called. In this case the
                ///election will continue until the next era is triggered.
                ///
                ///## Complexity
                ///- No arguments.
                ///- Weight: O(1)
                pub fn force_no_eras(&self) -> ::subxt::tx::Payload<types::ForceNoEras> {
                    ::subxt::tx::Payload::new_static(
                        "Staking",
                        "force_no_eras",
                        types::ForceNoEras {},
                        [
                            77u8,
                            5u8,
                            105u8,
                            167u8,
                            251u8,
                            78u8,
                            52u8,
                            80u8,
                            177u8,
                            226u8,
                            28u8,
                            130u8,
                            106u8,
                            62u8,
                            40u8,
                            210u8,
                            110u8,
                            62u8,
                            21u8,
                            113u8,
                            234u8,
                            227u8,
                            171u8,
                            205u8,
                            240u8,
                            46u8,
                            32u8,
                            84u8,
                            184u8,
                            208u8,
                            61u8,
                            207u8,
                        ],
                    )
                }
                ///Force there to be a new era at the end of the next session. After this, it will be
                ///reset to normal (non-forced) behaviour.
                ///
                ///The dispatch origin must be Root.
                ///
                ///# Warning
                ///
                ///The election process starts multiple blocks before the end of the era.
                ///If this is called just before a new era is triggered, the election process may not
                ///have enough blocks to get a result.
                ///
                ///## Complexity
                ///- No arguments.
                ///- Weight: O(1)
                pub fn force_new_era(&self) -> ::subxt::tx::Payload<types::ForceNewEra> {
                    ::subxt::tx::Payload::new_static(
                        "Staking",
                        "force_new_era",
                        types::ForceNewEra {},
                        [
                            119u8,
                            45u8,
                            11u8,
                            87u8,
                            236u8,
                            189u8,
                            41u8,
                            142u8,
                            130u8,
                            10u8,
                            132u8,
                            140u8,
                            210u8,
                            134u8,
                            66u8,
                            152u8,
                            149u8,
                            55u8,
                            60u8,
                            31u8,
                            190u8,
                            41u8,
                            177u8,
                            103u8,
                            245u8,
                            193u8,
                            95u8,
                            255u8,
                            29u8,
                            79u8,
                            112u8,
                            188u8,
                        ],
                    )
                }
                ///Set the validators who cannot be slashed (if any).
                ///
                ///The dispatch origin must be Root.
                pub fn set_invulnerables(
                    &self,
                    invulnerables: ::std::vec::Vec<::subxt::utils::AccountId32>,
                ) -> ::subxt::tx::Payload<types::SetInvulnerables> {
                    ::subxt::tx::Payload::new_static(
                        "Staking",
                        "set_invulnerables",
                        types::SetInvulnerables {
                            invulnerables,
                        },
                        [
                            31u8,
                            115u8,
                            221u8,
                            229u8,
                            187u8,
                            61u8,
                            33u8,
                            22u8,
                            126u8,
                            142u8,
                            248u8,
                            190u8,
                            213u8,
                            35u8,
                            49u8,
                            208u8,
                            193u8,
                            0u8,
                            58u8,
                            18u8,
                            136u8,
                            220u8,
                            32u8,
                            8u8,
                            121u8,
                            36u8,
                            184u8,
                            57u8,
                            6u8,
                            125u8,
                            199u8,
                            245u8,
                        ],
                    )
                }
                ///Force a current staker to become completely unstaked, immediately.
                ///
                ///The dispatch origin must be Root.
                pub fn force_unstake(
                    &self,
                    stash: ::subxt::utils::AccountId32,
                    num_slashing_spans: ::core::primitive::u32,
                ) -> ::subxt::tx::Payload<types::ForceUnstake> {
                    ::subxt::tx::Payload::new_static(
                        "Staking",
                        "force_unstake",
                        types::ForceUnstake {
                            stash,
                            num_slashing_spans,
                        },
                        [
                            205u8,
                            115u8,
                            222u8,
                            58u8,
                            168u8,
                            3u8,
                            59u8,
                            58u8,
                            220u8,
                            98u8,
                            204u8,
                            90u8,
                            36u8,
                            250u8,
                            178u8,
                            45u8,
                            213u8,
                            158u8,
                            92u8,
                            107u8,
                            3u8,
                            94u8,
                            118u8,
                            194u8,
                            187u8,
                            196u8,
                            101u8,
                            250u8,
                            36u8,
                            119u8,
                            21u8,
                            19u8,
                        ],
                    )
                }
                ///Force there to be a new era at the end of sessions indefinitely.
                ///
                ///The dispatch origin must be Root.
                ///
                ///# Warning
                ///
                ///The election process starts multiple blocks before the end of the era.
                ///If this is called just before a new era is triggered, the election process may not
                ///have enough blocks to get a result.
                pub fn force_new_era_always(
                    &self,
                ) -> ::subxt::tx::Payload<types::ForceNewEraAlways> {
                    ::subxt::tx::Payload::new_static(
                        "Staking",
                        "force_new_era_always",
                        types::ForceNewEraAlways {},
                        [
                            102u8,
                            153u8,
                            116u8,
                            85u8,
                            80u8,
                            52u8,
                            89u8,
                            215u8,
                            173u8,
                            159u8,
                            96u8,
                            99u8,
                            180u8,
                            5u8,
                            62u8,
                            142u8,
                            181u8,
                            101u8,
                            160u8,
                            57u8,
                            177u8,
                            182u8,
                            6u8,
                            252u8,
                            107u8,
                            252u8,
                            225u8,
                            104u8,
                            147u8,
                            123u8,
                            244u8,
                            134u8,
                        ],
                    )
                }
                ///Cancel enactment of a deferred slash.
                ///
                ///Can be called by the `T::AdminOrigin`.
                ///
                ///Parameters: era and indices of the slashes for that era to kill.
                pub fn cancel_deferred_slash(
                    &self,
                    era: ::core::primitive::u32,
                    slash_indices: ::std::vec::Vec<::core::primitive::u32>,
                ) -> ::subxt::tx::Payload<types::CancelDeferredSlash> {
                    ::subxt::tx::Payload::new_static(
                        "Staking",
                        "cancel_deferred_slash",
                        types::CancelDeferredSlash {
                            era,
                            slash_indices,
                        },
                        [
                            65u8,
                            90u8,
                            54u8,
                            7u8,
                            89u8,
                            238u8,
                            254u8,
                            76u8,
                            219u8,
                            26u8,
                            137u8,
                            181u8,
                            154u8,
                            49u8,
                            35u8,
                            99u8,
                            181u8,
                            193u8,
                            209u8,
                            181u8,
                            212u8,
                            153u8,
                            49u8,
                            83u8,
                            77u8,
                            170u8,
                            175u8,
                            142u8,
                            63u8,
                            187u8,
                            183u8,
                            199u8,
                        ],
                    )
                }
                ///Pay out all the stakers behind a single validator for a single era.
                ///
                ///- `validator_stash` is the stash account of the validator. Their nominators, up to
                ///  `T::MaxNominatorRewardedPerValidator`, will also receive their rewards.
                ///- `era` may be any era between `[current_era - history_depth; current_era]`.
                ///
                ///The origin of this call must be _Signed_. Any account can call this function, even if
                ///it is not one of the stakers.
                ///
                ///## Complexity
                ///- At most O(MaxNominatorRewardedPerValidator).
                pub fn payout_stakers(
                    &self,
                    validator_stash: ::subxt::utils::AccountId32,
                    era: ::core::primitive::u32,
                ) -> ::subxt::tx::Payload<types::PayoutStakers> {
                    ::subxt::tx::Payload::new_static(
                        "Staking",
                        "payout_stakers",
                        types::PayoutStakers {
                            validator_stash,
                            era,
                        },
                        [
                            69u8,
                            67u8,
                            140u8,
                            197u8,
                            89u8,
                            20u8,
                            59u8,
                            55u8,
                            142u8,
                            197u8,
                            62u8,
                            107u8,
                            239u8,
                            50u8,
                            237u8,
                            52u8,
                            4u8,
                            65u8,
                            119u8,
                            73u8,
                            138u8,
                            57u8,
                            46u8,
                            78u8,
                            252u8,
                            157u8,
                            187u8,
                            14u8,
                            232u8,
                            244u8,
                            217u8,
                            171u8,
                        ],
                    )
                }
                ///Rebond a portion of the stash scheduled to be unlocked.
                ///
                ///The dispatch origin must be signed by the controller.
                ///
                ///## Complexity
                ///- Time complexity: O(L), where L is unlocking chunks
                ///- Bounded by `MaxUnlockingChunks`.
                pub fn rebond(
                    &self,
                    value: ::core::primitive::u128,
                ) -> ::subxt::tx::Payload<types::Rebond> {
                    ::subxt::tx::Payload::new_static(
                        "Staking",
                        "rebond",
                        types::Rebond { value },
                        [
                            204u8,
                            209u8,
                            27u8,
                            219u8,
                            45u8,
                            129u8,
                            15u8,
                            39u8,
                            105u8,
                            165u8,
                            255u8,
                            55u8,
                            0u8,
                            59u8,
                            115u8,
                            79u8,
                            139u8,
                            82u8,
                            163u8,
                            197u8,
                            44u8,
                            89u8,
                            41u8,
                            234u8,
                            116u8,
                            214u8,
                            248u8,
                            123u8,
                            250u8,
                            49u8,
                            15u8,
                            77u8,
                        ],
                    )
                }
                ///Remove all data structures concerning a staker/stash once it is at a state where it can
                ///be considered `dust` in the staking system. The requirements are:
                ///
                ///1. the `total_balance` of the stash is below existential deposit.
                ///2. or, the `ledger.total` of the stash is below existential deposit.
                ///
                ///The former can happen in cases like a slash; the latter when a fully unbonded account
                ///is still receiving staking rewards in `RewardDestination::Staked`.
                ///
                ///It can be called by anyone, as long as `stash` meets the above requirements.
                ///
                ///Refunds the transaction fees upon successful execution.
                pub fn reap_stash(
                    &self,
                    stash: ::subxt::utils::AccountId32,
                    num_slashing_spans: ::core::primitive::u32,
                ) -> ::subxt::tx::Payload<types::ReapStash> {
                    ::subxt::tx::Payload::new_static(
                        "Staking",
                        "reap_stash",
                        types::ReapStash {
                            stash,
                            num_slashing_spans,
                        },
                        [
                            231u8,
                            240u8,
                            152u8,
                            33u8,
                            10u8,
                            60u8,
                            18u8,
                            233u8,
                            0u8,
                            229u8,
                            90u8,
                            45u8,
                            118u8,
                            29u8,
                            98u8,
                            109u8,
                            89u8,
                            7u8,
                            228u8,
                            254u8,
                            119u8,
                            125u8,
                            172u8,
                            209u8,
                            217u8,
                            107u8,
                            50u8,
                            226u8,
                            31u8,
                            5u8,
                            153u8,
                            93u8,
                        ],
                    )
                }
                ///Remove the given nominations from the calling validator.
                ///
                ///Effects will be felt at the beginning of the next era.
                ///
                ///The dispatch origin for this call must be _Signed_ by the controller, not the stash.
                ///
                ///- `who`: A list of nominator stash accounts who are nominating this validator which
                ///  should no longer be nominating this validator.
                ///
                ///Note: Making this call only makes sense if you first set the validator preferences to
                ///block any further nominations.
                pub fn kick(
                    &self,
                    who: ::std::vec::Vec<
                        ::subxt::utils::MultiAddress<
                            ::subxt::utils::AccountId32,
                            ::core::primitive::u32,
                        >,
                    >,
                ) -> ::subxt::tx::Payload<types::Kick> {
                    ::subxt::tx::Payload::new_static(
                        "Staking",
                        "kick",
                        types::Kick { who },
                        [
                            28u8,
                            254u8,
                            219u8,
                            14u8,
                            44u8,
                            187u8,
                            186u8,
                            72u8,
                            55u8,
                            21u8,
                            129u8,
                            205u8,
                            225u8,
                            204u8,
                            162u8,
                            53u8,
                            255u8,
                            56u8,
                            49u8,
                            194u8,
                            63u8,
                            43u8,
                            96u8,
                            177u8,
                            125u8,
                            0u8,
                            163u8,
                            97u8,
                            231u8,
                            159u8,
                            43u8,
                            249u8,
                        ],
                    )
                }
                ///Update the various staking configurations .
                ///
                ///* `min_nominator_bond`: The minimum active bond needed to be a nominator.
                ///* `min_validator_bond`: The minimum active bond needed to be a validator.
                ///* `max_nominator_count`: The max number of users who can be a nominator at once. When
                ///  set to `None`, no limit is enforced.
                ///* `max_validator_count`: The max number of users who can be a validator at once. When
                ///  set to `None`, no limit is enforced.
                ///* `chill_threshold`: The ratio of `max_nominator_count` or `max_validator_count` which
                ///  should be filled in order for the `chill_other` transaction to work.
                ///* `min_commission`: The minimum amount of commission that each validators must maintain.
                ///  This is checked only upon calling `validate`. Existing validators are not affected.
                ///
                ///RuntimeOrigin must be Root to call this function.
                ///
                ///NOTE: Existing nominators and validators will not be affected by this update.
                ///to kick people under the new limits, `chill_other` should be called.
                pub fn set_staking_configs(
                    &self,
                    min_nominator_bond: runtime_types::pallet_staking::pallet::pallet::ConfigOp<
                        ::core::primitive::u128,
                    >,
                    min_validator_bond: runtime_types::pallet_staking::pallet::pallet::ConfigOp<
                        ::core::primitive::u128,
                    >,
                    max_nominator_count: runtime_types::pallet_staking::pallet::pallet::ConfigOp<
                        ::core::primitive::u32,
                    >,
                    max_validator_count: runtime_types::pallet_staking::pallet::pallet::ConfigOp<
                        ::core::primitive::u32,
                    >,
                    chill_threshold: runtime_types::pallet_staking::pallet::pallet::ConfigOp<
                        runtime_types::sp_arithmetic::per_things::Percent,
                    >,
                    min_commission: runtime_types::pallet_staking::pallet::pallet::ConfigOp<
                        runtime_types::sp_arithmetic::per_things::Perbill,
                    >,
                ) -> ::subxt::tx::Payload<types::SetStakingConfigs> {
                    ::subxt::tx::Payload::new_static(
                        "Staking",
                        "set_staking_configs",
                        types::SetStakingConfigs {
                            min_nominator_bond,
                            min_validator_bond,
                            max_nominator_count,
                            max_validator_count,
                            chill_threshold,
                            min_commission,
                        },
                        [
                            198u8,
                            212u8,
                            176u8,
                            138u8,
                            79u8,
                            177u8,
                            241u8,
                            104u8,
                            72u8,
                            170u8,
                            35u8,
                            178u8,
                            205u8,
                            167u8,
                            218u8,
                            118u8,
                            42u8,
                            226u8,
                            180u8,
                            17u8,
                            112u8,
                            175u8,
                            55u8,
                            248u8,
                            64u8,
                            127u8,
                            51u8,
                            65u8,
                            132u8,
                            210u8,
                            88u8,
                            213u8,
                        ],
                    )
                }
                ///Declare a `controller` to stop participating as either a validator or nominator.
                ///
                ///Effects will be felt at the beginning of the next era.
                ///
                ///The dispatch origin for this call must be _Signed_, but can be called by anyone.
                ///
                ///If the caller is the same as the controller being targeted, then no further checks are
                ///enforced, and this function behaves just like `chill`.
                ///
                ///If the caller is different than the controller being targeted, the following conditions
                ///must be met:
                ///
                ///* `controller` must belong to a nominator who has become non-decodable,
                ///
                ///Or:
                ///
                ///* A `ChillThreshold` must be set and checked which defines how close to the max
                ///  nominators or validators we must reach before users can start chilling one-another.
                ///* A `MaxNominatorCount` and `MaxValidatorCount` must be set which is used to determine
                ///  how close we are to the threshold.
                ///* A `MinNominatorBond` and `MinValidatorBond` must be set and checked, which determines
                ///  if this is a person that should be chilled because they have not met the threshold
                ///  bond required.
                ///
                ///This can be helpful if bond requirements are updated, and we need to remove old users
                ///who do not satisfy these requirements.
                pub fn chill_other(
                    &self,
                    controller: ::subxt::utils::AccountId32,
                ) -> ::subxt::tx::Payload<types::ChillOther> {
                    ::subxt::tx::Payload::new_static(
                        "Staking",
                        "chill_other",
                        types::ChillOther { controller },
                        [
                            143u8,
                            82u8,
                            167u8,
                            43u8,
                            102u8,
                            136u8,
                            78u8,
                            139u8,
                            110u8,
                            159u8,
                            235u8,
                            226u8,
                            237u8,
                            140u8,
                            142u8,
                            47u8,
                            77u8,
                            57u8,
                            209u8,
                            208u8,
                            9u8,
                            193u8,
                            3u8,
                            77u8,
                            147u8,
                            41u8,
                            182u8,
                            122u8,
                            178u8,
                            185u8,
                            32u8,
                            182u8,
                        ],
                    )
                }
                ///Force a validator to have at least the minimum commission. This will not affect a
                ///validator who already has a commission greater than or equal to the minimum. Any account
                ///can call this.
                pub fn force_apply_min_commission(
                    &self,
                    validator_stash: ::subxt::utils::AccountId32,
                ) -> ::subxt::tx::Payload<types::ForceApplyMinCommission> {
                    ::subxt::tx::Payload::new_static(
                        "Staking",
                        "force_apply_min_commission",
                        types::ForceApplyMinCommission {
                            validator_stash,
                        },
                        [
                            158u8,
                            27u8,
                            152u8,
                            23u8,
                            97u8,
                            53u8,
                            54u8,
                            49u8,
                            179u8,
                            236u8,
                            69u8,
                            65u8,
                            253u8,
                            136u8,
                            232u8,
                            44u8,
                            207u8,
                            66u8,
                            5u8,
                            186u8,
                            49u8,
                            91u8,
                            173u8,
                            5u8,
                            84u8,
                            45u8,
                            154u8,
                            91u8,
                            239u8,
                            97u8,
                            62u8,
                            42u8,
                        ],
                    )
                }
                ///Sets the minimum amount of commission that each validators must maintain.
                ///
                ///This call has lower privilege requirements than `set_staking_config` and can be called
                ///by the `T::AdminOrigin`. Root can always call this.
                pub fn set_min_commission(
                    &self,
                    new: runtime_types::sp_arithmetic::per_things::Perbill,
                ) -> ::subxt::tx::Payload<types::SetMinCommission> {
                    ::subxt::tx::Payload::new_static(
                        "Staking",
                        "set_min_commission",
                        types::SetMinCommission { new },
                        [
                            96u8,
                            168u8,
                            55u8,
                            79u8,
                            79u8,
                            49u8,
                            8u8,
                            127u8,
                            98u8,
                            158u8,
                            106u8,
                            187u8,
                            177u8,
                            201u8,
                            68u8,
                            181u8,
                            219u8,
                            172u8,
                            63u8,
                            120u8,
                            172u8,
                            173u8,
                            251u8,
                            167u8,
                            84u8,
                            165u8,
                            238u8,
                            115u8,
                            110u8,
                            97u8,
                            144u8,
                            50u8,
                        ],
                    )
                }
            }
        }
        /**
			The [event](https://docs.substrate.io/main-docs/build/events-errors/) emitted
			by this pallet.
			*/
        pub type Event = runtime_types::pallet_staking::pallet::pallet::Event;
        pub mod events {
            use super::runtime_types;
            #[derive(
                ::subxt::ext::codec::Decode,
                ::subxt::ext::codec::Encode,
                ::subxt::ext::scale_decode::DecodeAsType,
                ::subxt::ext::scale_encode::EncodeAsType,
                Clone,
                Debug,
                Eq,
                PartialEq
            )]
            #[codec(crate = ::subxt::ext::codec)]
            #[decode_as_type(crate_path = ":: subxt :: ext :: scale_decode")]
            #[encode_as_type(crate_path = ":: subxt :: ext :: scale_encode")]
            ///The era payout has been set; the first balance is the validator-payout; the second is
            ///the remainder from the maximum amount of reward.
            pub struct EraPaid {
                pub era_index: ::core::primitive::u32,
                pub validator_payout: ::core::primitive::u128,
                pub remainder: ::core::primitive::u128,
            }
            impl ::subxt::events::StaticEvent for EraPaid {
                const PALLET: &'static str = "Staking";
                const EVENT: &'static str = "EraPaid";
            }
            #[derive(
                ::subxt::ext::codec::Decode,
                ::subxt::ext::codec::Encode,
                ::subxt::ext::scale_decode::DecodeAsType,
                ::subxt::ext::scale_encode::EncodeAsType,
                Clone,
                Debug,
                Eq,
                PartialEq
            )]
            #[codec(crate = ::subxt::ext::codec)]
            #[decode_as_type(crate_path = ":: subxt :: ext :: scale_decode")]
            #[encode_as_type(crate_path = ":: subxt :: ext :: scale_encode")]
            ///The nominator has been rewarded by this amount.
            pub struct Rewarded {
                pub stash: ::subxt::utils::AccountId32,
                pub amount: ::core::primitive::u128,
            }
            impl ::subxt::events::StaticEvent for Rewarded {
                const PALLET: &'static str = "Staking";
                const EVENT: &'static str = "Rewarded";
            }
            #[derive(
                ::subxt::ext::codec::Decode,
                ::subxt::ext::codec::Encode,
                ::subxt::ext::scale_decode::DecodeAsType,
                ::subxt::ext::scale_encode::EncodeAsType,
                Clone,
                Debug,
                Eq,
                PartialEq
            )]
            #[codec(crate = ::subxt::ext::codec)]
            #[decode_as_type(crate_path = ":: subxt :: ext :: scale_decode")]
            #[encode_as_type(crate_path = ":: subxt :: ext :: scale_encode")]
            ///A staker (validator or nominator) has been slashed by the given amount.
            pub struct Slashed {
                pub staker: ::subxt::utils::AccountId32,
                pub amount: ::core::primitive::u128,
            }
            impl ::subxt::events::StaticEvent for Slashed {
                const PALLET: &'static str = "Staking";
                const EVENT: &'static str = "Slashed";
            }
            #[derive(
                ::subxt::ext::codec::Decode,
                ::subxt::ext::codec::Encode,
                ::subxt::ext::scale_decode::DecodeAsType,
                ::subxt::ext::scale_encode::EncodeAsType,
                Clone,
                Debug,
                Eq,
                PartialEq
            )]
            #[codec(crate = ::subxt::ext::codec)]
            #[decode_as_type(crate_path = ":: subxt :: ext :: scale_decode")]
            #[encode_as_type(crate_path = ":: subxt :: ext :: scale_encode")]
            ///A slash for the given validator, for the given percentage of their stake, at the given
            ///era as been reported.
            pub struct SlashReported {
                pub validator: ::subxt::utils::AccountId32,
                pub fraction: runtime_types::sp_arithmetic::per_things::Perbill,
                pub slash_era: ::core::primitive::u32,
            }
            impl ::subxt::events::StaticEvent for SlashReported {
                const PALLET: &'static str = "Staking";
                const EVENT: &'static str = "SlashReported";
            }
            #[derive(
                ::subxt::ext::codec::CompactAs,
                ::subxt::ext::codec::Decode,
                ::subxt::ext::codec::Encode,
                ::subxt::ext::scale_decode::DecodeAsType,
                ::subxt::ext::scale_encode::EncodeAsType,
                Clone,
                Debug,
                Eq,
                PartialEq
            )]
            #[codec(crate = ::subxt::ext::codec)]
            #[decode_as_type(crate_path = ":: subxt :: ext :: scale_decode")]
            #[encode_as_type(crate_path = ":: subxt :: ext :: scale_encode")]
            ///An old slashing report from a prior era was discarded because it could
            ///not be processed.
            pub struct OldSlashingReportDiscarded {
                pub session_index: ::core::primitive::u32,
            }
            impl ::subxt::events::StaticEvent for OldSlashingReportDiscarded {
                const PALLET: &'static str = "Staking";
                const EVENT: &'static str = "OldSlashingReportDiscarded";
            }
            #[derive(
                ::subxt::ext::codec::Decode,
                ::subxt::ext::codec::Encode,
                ::subxt::ext::scale_decode::DecodeAsType,
                ::subxt::ext::scale_encode::EncodeAsType,
                Clone,
                Debug,
                Eq,
                PartialEq
            )]
            #[codec(crate = ::subxt::ext::codec)]
            #[decode_as_type(crate_path = ":: subxt :: ext :: scale_decode")]
            #[encode_as_type(crate_path = ":: subxt :: ext :: scale_encode")]
            ///A new set of stakers was elected.
            pub struct StakersElected;
            impl ::subxt::events::StaticEvent for StakersElected {
                const PALLET: &'static str = "Staking";
                const EVENT: &'static str = "StakersElected";
            }
            #[derive(
                ::subxt::ext::codec::Decode,
                ::subxt::ext::codec::Encode,
                ::subxt::ext::scale_decode::DecodeAsType,
                ::subxt::ext::scale_encode::EncodeAsType,
                Clone,
                Debug,
                Eq,
                PartialEq
            )]
            #[codec(crate = ::subxt::ext::codec)]
            #[decode_as_type(crate_path = ":: subxt :: ext :: scale_decode")]
            #[encode_as_type(crate_path = ":: subxt :: ext :: scale_encode")]
            ///An account has bonded this amount. \[stash, amount\]
            ///
            ///NOTE: This event is only emitted when funds are bonded via a dispatchable. Notably,
            ///it will not be emitted for staking rewards when they are added to stake.
            pub struct Bonded {
                pub stash: ::subxt::utils::AccountId32,
                pub amount: ::core::primitive::u128,
            }
            impl ::subxt::events::StaticEvent for Bonded {
                const PALLET: &'static str = "Staking";
                const EVENT: &'static str = "Bonded";
            }
            #[derive(
                ::subxt::ext::codec::Decode,
                ::subxt::ext::codec::Encode,
                ::subxt::ext::scale_decode::DecodeAsType,
                ::subxt::ext::scale_encode::EncodeAsType,
                Clone,
                Debug,
                Eq,
                PartialEq
            )]
            #[codec(crate = ::subxt::ext::codec)]
            #[decode_as_type(crate_path = ":: subxt :: ext :: scale_decode")]
            #[encode_as_type(crate_path = ":: subxt :: ext :: scale_encode")]
            ///An account has unbonded this amount.
            pub struct Unbonded {
                pub stash: ::subxt::utils::AccountId32,
                pub amount: ::core::primitive::u128,
            }
            impl ::subxt::events::StaticEvent for Unbonded {
                const PALLET: &'static str = "Staking";
                const EVENT: &'static str = "Unbonded";
            }
            #[derive(
                ::subxt::ext::codec::Decode,
                ::subxt::ext::codec::Encode,
                ::subxt::ext::scale_decode::DecodeAsType,
                ::subxt::ext::scale_encode::EncodeAsType,
                Clone,
                Debug,
                Eq,
                PartialEq
            )]
            #[codec(crate = ::subxt::ext::codec)]
            #[decode_as_type(crate_path = ":: subxt :: ext :: scale_decode")]
            #[encode_as_type(crate_path = ":: subxt :: ext :: scale_encode")]
            ///An account has called `withdraw_unbonded` and removed unbonding chunks worth `Balance`
            ///from the unlocking queue.
            pub struct Withdrawn {
                pub stash: ::subxt::utils::AccountId32,
                pub amount: ::core::primitive::u128,
            }
            impl ::subxt::events::StaticEvent for Withdrawn {
                const PALLET: &'static str = "Staking";
                const EVENT: &'static str = "Withdrawn";
            }
            #[derive(
                ::subxt::ext::codec::Decode,
                ::subxt::ext::codec::Encode,
                ::subxt::ext::scale_decode::DecodeAsType,
                ::subxt::ext::scale_encode::EncodeAsType,
                Clone,
                Debug,
                Eq,
                PartialEq
            )]
            #[codec(crate = ::subxt::ext::codec)]
            #[decode_as_type(crate_path = ":: subxt :: ext :: scale_decode")]
            #[encode_as_type(crate_path = ":: subxt :: ext :: scale_encode")]
            ///A nominator has been kicked from a validator.
            pub struct Kicked {
                pub nominator: ::subxt::utils::AccountId32,
                pub stash: ::subxt::utils::AccountId32,
            }
            impl ::subxt::events::StaticEvent for Kicked {
                const PALLET: &'static str = "Staking";
                const EVENT: &'static str = "Kicked";
            }
            #[derive(
                ::subxt::ext::codec::Decode,
                ::subxt::ext::codec::Encode,
                ::subxt::ext::scale_decode::DecodeAsType,
                ::subxt::ext::scale_encode::EncodeAsType,
                Clone,
                Debug,
                Eq,
                PartialEq
            )]
            #[codec(crate = ::subxt::ext::codec)]
            #[decode_as_type(crate_path = ":: subxt :: ext :: scale_decode")]
            #[encode_as_type(crate_path = ":: subxt :: ext :: scale_encode")]
            ///The election failed. No new era is planned.
            pub struct StakingElectionFailed;
            impl ::subxt::events::StaticEvent for StakingElectionFailed {
                const PALLET: &'static str = "Staking";
                const EVENT: &'static str = "StakingElectionFailed";
            }
            #[derive(
                ::subxt::ext::codec::Decode,
                ::subxt::ext::codec::Encode,
                ::subxt::ext::scale_decode::DecodeAsType,
                ::subxt::ext::scale_encode::EncodeAsType,
                Clone,
                Debug,
                Eq,
                PartialEq
            )]
            #[codec(crate = ::subxt::ext::codec)]
            #[decode_as_type(crate_path = ":: subxt :: ext :: scale_decode")]
            #[encode_as_type(crate_path = ":: subxt :: ext :: scale_encode")]
            ///An account has stopped participating as either a validator or nominator.
            pub struct Chilled {
                pub stash: ::subxt::utils::AccountId32,
            }
            impl ::subxt::events::StaticEvent for Chilled {
                const PALLET: &'static str = "Staking";
                const EVENT: &'static str = "Chilled";
            }
            #[derive(
                ::subxt::ext::codec::Decode,
                ::subxt::ext::codec::Encode,
                ::subxt::ext::scale_decode::DecodeAsType,
                ::subxt::ext::scale_encode::EncodeAsType,
                Clone,
                Debug,
                Eq,
                PartialEq
            )]
            #[codec(crate = ::subxt::ext::codec)]
            #[decode_as_type(crate_path = ":: subxt :: ext :: scale_decode")]
            #[encode_as_type(crate_path = ":: subxt :: ext :: scale_encode")]
            ///The stakers' rewards are getting paid.
            pub struct PayoutStarted {
                pub era_index: ::core::primitive::u32,
                pub validator_stash: ::subxt::utils::AccountId32,
            }
            impl ::subxt::events::StaticEvent for PayoutStarted {
                const PALLET: &'static str = "Staking";
                const EVENT: &'static str = "PayoutStarted";
            }
            #[derive(
                ::subxt::ext::codec::Decode,
                ::subxt::ext::codec::Encode,
                ::subxt::ext::scale_decode::DecodeAsType,
                ::subxt::ext::scale_encode::EncodeAsType,
                Clone,
                Debug,
                Eq,
                PartialEq
            )]
            #[codec(crate = ::subxt::ext::codec)]
            #[decode_as_type(crate_path = ":: subxt :: ext :: scale_decode")]
            #[encode_as_type(crate_path = ":: subxt :: ext :: scale_encode")]
            ///A validator has set their preferences.
            pub struct ValidatorPrefsSet {
                pub stash: ::subxt::utils::AccountId32,
                pub prefs: runtime_types::pallet_staking::ValidatorPrefs,
            }
            impl ::subxt::events::StaticEvent for ValidatorPrefsSet {
                const PALLET: &'static str = "Staking";
                const EVENT: &'static str = "ValidatorPrefsSet";
            }
            #[derive(
                ::subxt::ext::codec::Decode,
                ::subxt::ext::codec::Encode,
                ::subxt::ext::scale_decode::DecodeAsType,
                ::subxt::ext::scale_encode::EncodeAsType,
                Clone,
                Debug,
                Eq,
                PartialEq
            )]
            #[codec(crate = ::subxt::ext::codec)]
            #[decode_as_type(crate_path = ":: subxt :: ext :: scale_decode")]
            #[encode_as_type(crate_path = ":: subxt :: ext :: scale_encode")]
            ///A new force era mode was set.
            pub struct ForceEra {
                pub mode: runtime_types::pallet_staking::Forcing,
            }
            impl ::subxt::events::StaticEvent for ForceEra {
                const PALLET: &'static str = "Staking";
                const EVENT: &'static str = "ForceEra";
            }
        }
        pub mod storage {
            use super::runtime_types;
            pub struct StorageApi;
            impl StorageApi {
                /// The ideal number of active validators.
                pub fn validator_count(
                    &self,
                ) -> ::subxt::storage::address::Address<
                    ::subxt::storage::address::StaticStorageMapKey,
                    ::core::primitive::u32,
                    ::subxt::storage::address::Yes,
                    ::subxt::storage::address::Yes,
                    (),
                > {
                    ::subxt::storage::address::Address::new_static(
                        "Staking",
                        "ValidatorCount",
                        vec![],
                        [
                            105u8,
                            251u8,
                            193u8,
                            198u8,
                            232u8,
                            118u8,
                            73u8,
                            115u8,
                            205u8,
                            78u8,
                            49u8,
                            253u8,
                            140u8,
                            193u8,
                            161u8,
                            205u8,
                            13u8,
                            147u8,
                            125u8,
                            102u8,
                            142u8,
                            244u8,
                            210u8,
                            227u8,
                            225u8,
                            46u8,
                            144u8,
                            122u8,
                            254u8,
                            48u8,
                            44u8,
                            169u8,
                        ],
                    )
                }
                /// Minimum number of staking participants before emergency conditions are imposed.
                pub fn minimum_validator_count(
                    &self,
                ) -> ::subxt::storage::address::Address<
                    ::subxt::storage::address::StaticStorageMapKey,
                    ::core::primitive::u32,
                    ::subxt::storage::address::Yes,
                    ::subxt::storage::address::Yes,
                    (),
                > {
                    ::subxt::storage::address::Address::new_static(
                        "Staking",
                        "MinimumValidatorCount",
                        vec![],
                        [
                            103u8,
                            178u8,
                            29u8,
                            91u8,
                            90u8,
                            31u8,
                            49u8,
                            9u8,
                            11u8,
                            58u8,
                            178u8,
                            30u8,
                            219u8,
                            55u8,
                            58u8,
                            181u8,
                            80u8,
                            155u8,
                            9u8,
                            11u8,
                            38u8,
                            46u8,
                            125u8,
                            179u8,
                            220u8,
                            20u8,
                            212u8,
                            181u8,
                            136u8,
                            103u8,
                            58u8,
                            48u8,
                        ],
                    )
                }
                /// Any validators that may never be slashed or forcibly kicked. It's a Vec since they're
                /// easy to initialize and the performance hit is minimal (we expect no more than four
                /// invulnerables) and restricted to testnets.
                pub fn invulnerables(
                    &self,
                ) -> ::subxt::storage::address::Address<
                    ::subxt::storage::address::StaticStorageMapKey,
                    ::std::vec::Vec<::subxt::utils::AccountId32>,
                    ::subxt::storage::address::Yes,
                    ::subxt::storage::address::Yes,
                    (),
                > {
                    ::subxt::storage::address::Address::new_static(
                        "Staking",
                        "Invulnerables",
                        vec![],
                        [
                            199u8,
                            35u8,
                            0u8,
                            229u8,
                            160u8,
                            128u8,
                            139u8,
                            245u8,
                            27u8,
                            133u8,
                            47u8,
                            240u8,
                            86u8,
                            195u8,
                            90u8,
                            169u8,
                            158u8,
                            231u8,
                            128u8,
                            58u8,
                            24u8,
                            173u8,
                            138u8,
                            122u8,
                            226u8,
                            104u8,
                            239u8,
                            114u8,
                            91u8,
                            165u8,
                            207u8,
                            150u8,
                        ],
                    )
                }
                /// Map from all locked "stash" accounts to the controller account.
                ///
                /// TWOX-NOTE: SAFE since `AccountId` is a secure hash.
                pub fn bonded(
                    &self,
                    _0: impl ::std::borrow::Borrow<::subxt::utils::AccountId32>,
                ) -> ::subxt::storage::address::Address<
                    ::subxt::storage::address::StaticStorageMapKey,
                    ::subxt::utils::AccountId32,
                    ::subxt::storage::address::Yes,
                    (),
                    ::subxt::storage::address::Yes,
                > {
                    ::subxt::storage::address::Address::new_static(
                        "Staking",
                        "Bonded",
                        vec![
                            ::subxt::storage::address::make_static_storage_map_key(_0
                            .borrow())
                        ],
                        [
                            146u8,
                            230u8,
                            48u8,
                            190u8,
                            166u8,
                            127u8,
                            237u8,
                            216u8,
                            71u8,
                            33u8,
                            108u8,
                            121u8,
                            204u8,
                            211u8,
                            133u8,
                            123u8,
                            52u8,
                            164u8,
                            201u8,
                            209u8,
                            236u8,
                            35u8,
                            190u8,
                            77u8,
                            126u8,
                            150u8,
                            79u8,
                            244u8,
                            15u8,
                            247u8,
                            161u8,
                            107u8,
                        ],
                    )
                }
                /// Map from all locked "stash" accounts to the controller account.
                ///
                /// TWOX-NOTE: SAFE since `AccountId` is a secure hash.
                pub fn bonded_root(
                    &self,
                ) -> ::subxt::storage::address::Address<
                    ::subxt::storage::address::StaticStorageMapKey,
                    ::subxt::utils::AccountId32,
                    (),
                    (),
                    ::subxt::storage::address::Yes,
                > {
                    ::subxt::storage::address::Address::new_static(
                        "Staking",
                        "Bonded",
                        Vec::new(),
                        [
                            146u8,
                            230u8,
                            48u8,
                            190u8,
                            166u8,
                            127u8,
                            237u8,
                            216u8,
                            71u8,
                            33u8,
                            108u8,
                            121u8,
                            204u8,
                            211u8,
                            133u8,
                            123u8,
                            52u8,
                            164u8,
                            201u8,
                            209u8,
                            236u8,
                            35u8,
                            190u8,
                            77u8,
                            126u8,
                            150u8,
                            79u8,
                            244u8,
                            15u8,
                            247u8,
                            161u8,
                            107u8,
                        ],
                    )
                }
                /// The minimum active bond to become and maintain the role of a nominator.
                pub fn min_nominator_bond(
                    &self,
                ) -> ::subxt::storage::address::Address<
                    ::subxt::storage::address::StaticStorageMapKey,
                    ::core::primitive::u128,
                    ::subxt::storage::address::Yes,
                    ::subxt::storage::address::Yes,
                    (),
                > {
                    ::subxt::storage::address::Address::new_static(
                        "Staking",
                        "MinNominatorBond",
                        vec![],
                        [
                            102u8,
                            115u8,
                            254u8,
                            15u8,
                            191u8,
                            228u8,
                            85u8,
                            249u8,
                            112u8,
                            190u8,
                            129u8,
                            243u8,
                            236u8,
                            39u8,
                            195u8,
                            232u8,
                            10u8,
                            230u8,
                            11u8,
                            144u8,
                            115u8,
                            1u8,
                            45u8,
                            70u8,
                            181u8,
                            161u8,
                            17u8,
                            92u8,
                            19u8,
                            70u8,
                            100u8,
                            94u8,
                        ],
                    )
                }
                /// The minimum active bond to become and maintain the role of a validator.
                pub fn min_validator_bond(
                    &self,
                ) -> ::subxt::storage::address::Address<
                    ::subxt::storage::address::StaticStorageMapKey,
                    ::core::primitive::u128,
                    ::subxt::storage::address::Yes,
                    ::subxt::storage::address::Yes,
                    (),
                > {
                    ::subxt::storage::address::Address::new_static(
                        "Staking",
                        "MinValidatorBond",
                        vec![],
                        [
                            146u8,
                            249u8,
                            26u8,
                            52u8,
                            224u8,
                            81u8,
                            85u8,
                            153u8,
                            118u8,
                            169u8,
                            140u8,
                            37u8,
                            208u8,
                            242u8,
                            8u8,
                            29u8,
                            156u8,
                            73u8,
                            154u8,
                            162u8,
                            186u8,
                            159u8,
                            119u8,
                            100u8,
                            109u8,
                            227u8,
                            6u8,
                            139u8,
                            155u8,
                            203u8,
                            167u8,
                            244u8,
                        ],
                    )
                }
                /// The minimum active nominator stake of the last successful election.
                pub fn minimum_active_stake(
                    &self,
                ) -> ::subxt::storage::address::Address<
                    ::subxt::storage::address::StaticStorageMapKey,
                    ::core::primitive::u128,
                    ::subxt::storage::address::Yes,
                    ::subxt::storage::address::Yes,
                    (),
                > {
                    ::subxt::storage::address::Address::new_static(
                        "Staking",
                        "MinimumActiveStake",
                        vec![],
                        [
                            166u8,
                            211u8,
                            59u8,
                            23u8,
                            2u8,
                            160u8,
                            244u8,
                            52u8,
                            153u8,
                            12u8,
                            103u8,
                            113u8,
                            51u8,
                            232u8,
                            145u8,
                            188u8,
                            54u8,
                            67u8,
                            227u8,
                            221u8,
                            186u8,
                            6u8,
                            28u8,
                            63u8,
                            146u8,
                            212u8,
                            233u8,
                            173u8,
                            134u8,
                            41u8,
                            169u8,
                            153u8,
                        ],
                    )
                }
                /// The minimum amount of commission that validators can set.
                ///
                /// If set to `0`, no limit exists.
                pub fn min_commission(
                    &self,
                ) -> ::subxt::storage::address::Address<
                    ::subxt::storage::address::StaticStorageMapKey,
                    runtime_types::sp_arithmetic::per_things::Perbill,
                    ::subxt::storage::address::Yes,
                    ::subxt::storage::address::Yes,
                    (),
                > {
                    ::subxt::storage::address::Address::new_static(
                        "Staking",
                        "MinCommission",
                        vec![],
                        [
                            220u8,
                            197u8,
                            232u8,
                            212u8,
                            205u8,
                            242u8,
                            121u8,
                            165u8,
                            255u8,
                            199u8,
                            122u8,
                            20u8,
                            145u8,
                            245u8,
                            175u8,
                            26u8,
                            45u8,
                            70u8,
                            207u8,
                            26u8,
                            112u8,
                            234u8,
                            181u8,
                            167u8,
                            140u8,
                            75u8,
                            15u8,
                            1u8,
                            221u8,
                            168u8,
                            17u8,
                            211u8,
                        ],
                    )
                }
                /// Map from all (unlocked) "controller" accounts to the info regarding the staking.
                pub fn ledger(
                    &self,
                    _0: impl ::std::borrow::Borrow<::subxt::utils::AccountId32>,
                ) -> ::subxt::storage::address::Address<
                    ::subxt::storage::address::StaticStorageMapKey,
                    runtime_types::pallet_staking::StakingLedger,
                    ::subxt::storage::address::Yes,
                    (),
                    ::subxt::storage::address::Yes,
                > {
                    ::subxt::storage::address::Address::new_static(
                        "Staking",
                        "Ledger",
                        vec![
                            ::subxt::storage::address::make_static_storage_map_key(_0
                            .borrow())
                        ],
                        [
                            77u8,
                            39u8,
                            230u8,
                            122u8,
                            108u8,
                            191u8,
                            251u8,
                            28u8,
                            233u8,
                            225u8,
                            195u8,
                            224u8,
                            234u8,
                            90u8,
                            173u8,
                            170u8,
                            143u8,
                            246u8,
                            246u8,
                            21u8,
                            38u8,
                            187u8,
                            112u8,
                            111u8,
                            206u8,
                            181u8,
                            183u8,
                            186u8,
                            96u8,
                            8u8,
                            225u8,
                            224u8,
                        ],
                    )
                }
                /// Map from all (unlocked) "controller" accounts to the info regarding the staking.
                pub fn ledger_root(
                    &self,
                ) -> ::subxt::storage::address::Address<
                    ::subxt::storage::address::StaticStorageMapKey,
                    runtime_types::pallet_staking::StakingLedger,
                    (),
                    (),
                    ::subxt::storage::address::Yes,
                > {
                    ::subxt::storage::address::Address::new_static(
                        "Staking",
                        "Ledger",
                        Vec::new(),
                        [
                            77u8,
                            39u8,
                            230u8,
                            122u8,
                            108u8,
                            191u8,
                            251u8,
                            28u8,
                            233u8,
                            225u8,
                            195u8,
                            224u8,
                            234u8,
                            90u8,
                            173u8,
                            170u8,
                            143u8,
                            246u8,
                            246u8,
                            21u8,
                            38u8,
                            187u8,
                            112u8,
                            111u8,
                            206u8,
                            181u8,
                            183u8,
                            186u8,
                            96u8,
                            8u8,
                            225u8,
                            224u8,
                        ],
                    )
                }
                /// Where the reward payment should be made. Keyed by stash.
                ///
                /// TWOX-NOTE: SAFE since `AccountId` is a secure hash.
                pub fn payee(
                    &self,
                    _0: impl ::std::borrow::Borrow<::subxt::utils::AccountId32>,
                ) -> ::subxt::storage::address::Address<
                    ::subxt::storage::address::StaticStorageMapKey,
                    runtime_types::pallet_staking::RewardDestination<
                        ::subxt::utils::AccountId32,
                    >,
                    ::subxt::storage::address::Yes,
                    ::subxt::storage::address::Yes,
                    ::subxt::storage::address::Yes,
                > {
                    ::subxt::storage::address::Address::new_static(
                        "Staking",
                        "Payee",
                        vec![
                            ::subxt::storage::address::make_static_storage_map_key(_0
                            .borrow())
                        ],
                        [
                            198u8,
                            238u8,
                            10u8,
                            104u8,
                            204u8,
                            7u8,
                            193u8,
                            254u8,
                            169u8,
                            18u8,
                            187u8,
                            212u8,
                            90u8,
                            243u8,
                            73u8,
                            29u8,
                            216u8,
                            144u8,
                            93u8,
                            140u8,
                            11u8,
                            124u8,
                            4u8,
                            191u8,
                            107u8,
                            61u8,
                            15u8,
                            152u8,
                            70u8,
                            82u8,
                            60u8,
                            75u8,
                        ],
                    )
                }
                /// Where the reward payment should be made. Keyed by stash.
                ///
                /// TWOX-NOTE: SAFE since `AccountId` is a secure hash.
                pub fn payee_root(
                    &self,
                ) -> ::subxt::storage::address::Address<
                    ::subxt::storage::address::StaticStorageMapKey,
                    runtime_types::pallet_staking::RewardDestination<
                        ::subxt::utils::AccountId32,
                    >,
                    (),
                    ::subxt::storage::address::Yes,
                    ::subxt::storage::address::Yes,
                > {
                    ::subxt::storage::address::Address::new_static(
                        "Staking",
                        "Payee",
                        Vec::new(),
                        [
                            198u8,
                            238u8,
                            10u8,
                            104u8,
                            204u8,
                            7u8,
                            193u8,
                            254u8,
                            169u8,
                            18u8,
                            187u8,
                            212u8,
                            90u8,
                            243u8,
                            73u8,
                            29u8,
                            216u8,
                            144u8,
                            93u8,
                            140u8,
                            11u8,
                            124u8,
                            4u8,
                            191u8,
                            107u8,
                            61u8,
                            15u8,
                            152u8,
                            70u8,
                            82u8,
                            60u8,
                            75u8,
                        ],
                    )
                }
                /// The map from (wannabe) validator stash key to the preferences of that validator.
                ///
                /// TWOX-NOTE: SAFE since `AccountId` is a secure hash.
                pub fn validators(
                    &self,
                    _0: impl ::std::borrow::Borrow<::subxt::utils::AccountId32>,
                ) -> ::subxt::storage::address::Address<
                    ::subxt::storage::address::StaticStorageMapKey,
                    runtime_types::pallet_staking::ValidatorPrefs,
                    ::subxt::storage::address::Yes,
                    ::subxt::storage::address::Yes,
                    ::subxt::storage::address::Yes,
                > {
                    ::subxt::storage::address::Address::new_static(
                        "Staking",
                        "Validators",
                        vec![
                            ::subxt::storage::address::make_static_storage_map_key(_0
                            .borrow())
                        ],
                        [
                            149u8,
                            207u8,
                            68u8,
                            38u8,
                            24u8,
                            220u8,
                            207u8,
                            84u8,
                            236u8,
                            33u8,
                            210u8,
                            124u8,
                            200u8,
                            99u8,
                            98u8,
                            29u8,
                            235u8,
                            46u8,
                            124u8,
                            4u8,
                            203u8,
                            6u8,
                            209u8,
                            21u8,
                            124u8,
                            236u8,
                            112u8,
                            118u8,
                            180u8,
                            85u8,
                            78u8,
                            13u8,
                        ],
                    )
                }
                /// The map from (wannabe) validator stash key to the preferences of that validator.
                ///
                /// TWOX-NOTE: SAFE since `AccountId` is a secure hash.
                pub fn validators_root(
                    &self,
                ) -> ::subxt::storage::address::Address<
                    ::subxt::storage::address::StaticStorageMapKey,
                    runtime_types::pallet_staking::ValidatorPrefs,
                    (),
                    ::subxt::storage::address::Yes,
                    ::subxt::storage::address::Yes,
                > {
                    ::subxt::storage::address::Address::new_static(
                        "Staking",
                        "Validators",
                        Vec::new(),
                        [
                            149u8,
                            207u8,
                            68u8,
                            38u8,
                            24u8,
                            220u8,
                            207u8,
                            84u8,
                            236u8,
                            33u8,
                            210u8,
                            124u8,
                            200u8,
                            99u8,
                            98u8,
                            29u8,
                            235u8,
                            46u8,
                            124u8,
                            4u8,
                            203u8,
                            6u8,
                            209u8,
                            21u8,
                            124u8,
                            236u8,
                            112u8,
                            118u8,
                            180u8,
                            85u8,
                            78u8,
                            13u8,
                        ],
                    )
                }
                ///Counter for the related counted storage map
                pub fn counter_for_validators(
                    &self,
                ) -> ::subxt::storage::address::Address<
                    ::subxt::storage::address::StaticStorageMapKey,
                    ::core::primitive::u32,
                    ::subxt::storage::address::Yes,
                    ::subxt::storage::address::Yes,
                    (),
                > {
                    ::subxt::storage::address::Address::new_static(
                        "Staking",
                        "CounterForValidators",
                        vec![],
                        [
                            169u8,
                            146u8,
                            194u8,
                            114u8,
                            57u8,
                            232u8,
                            137u8,
                            93u8,
                            214u8,
                            98u8,
                            176u8,
                            151u8,
                            237u8,
                            165u8,
                            176u8,
                            252u8,
                            73u8,
                            124u8,
                            22u8,
                            166u8,
                            225u8,
                            217u8,
                            65u8,
                            56u8,
                            174u8,
                            12u8,
                            32u8,
                            2u8,
                            7u8,
                            173u8,
                            125u8,
                            235u8,
                        ],
                    )
                }
                /// The maximum validator count before we stop allowing new validators to join.
                ///
                /// When this value is not set, no limits are enforced.
                pub fn max_validators_count(
                    &self,
                ) -> ::subxt::storage::address::Address<
                    ::subxt::storage::address::StaticStorageMapKey,
                    ::core::primitive::u32,
                    ::subxt::storage::address::Yes,
                    (),
                    (),
                > {
                    ::subxt::storage::address::Address::new_static(
                        "Staking",
                        "MaxValidatorsCount",
                        vec![],
                        [
                            139u8,
                            116u8,
                            236u8,
                            217u8,
                            110u8,
                            47u8,
                            140u8,
                            197u8,
                            184u8,
                            246u8,
                            180u8,
                            188u8,
                            233u8,
                            99u8,
                            102u8,
                            21u8,
                            114u8,
                            23u8,
                            143u8,
                            163u8,
                            224u8,
                            250u8,
                            248u8,
                            185u8,
                            235u8,
                            94u8,
                            110u8,
                            83u8,
                            170u8,
                            123u8,
                            113u8,
                            168u8,
                        ],
                    )
                }
                /// The map from nominator stash key to their nomination preferences, namely the validators that
                /// they wish to support.
                ///
                /// Note that the keys of this storage map might become non-decodable in case the
                /// [`Config::MaxNominations`] configuration is decreased. In this rare case, these nominators
                /// are still existent in storage, their key is correct and retrievable (i.e. `contains_key`
                /// indicates that they exist), but their value cannot be decoded. Therefore, the non-decodable
                /// nominators will effectively not-exist, until they re-submit their preferences such that it
                /// is within the bounds of the newly set `Config::MaxNominations`.
                ///
                /// This implies that `::iter_keys().count()` and `::iter().count()` might return different
                /// values for this map. Moreover, the main `::count()` is aligned with the former, namely the
                /// number of keys that exist.
                ///
                /// Lastly, if any of the nominators become non-decodable, they can be chilled immediately via
                /// [`Call::chill_other`] dispatchable by anyone.
                ///
                /// TWOX-NOTE: SAFE since `AccountId` is a secure hash.
                pub fn nominators(
                    &self,
                    _0: impl ::std::borrow::Borrow<::subxt::utils::AccountId32>,
                ) -> ::subxt::storage::address::Address<
                    ::subxt::storage::address::StaticStorageMapKey,
                    runtime_types::pallet_staking::Nominations,
                    ::subxt::storage::address::Yes,
                    (),
                    ::subxt::storage::address::Yes,
                > {
                    ::subxt::storage::address::Address::new_static(
                        "Staking",
                        "Nominators",
                        vec![
                            ::subxt::storage::address::make_static_storage_map_key(_0
                            .borrow())
                        ],
                        [
                            114u8,
                            45u8,
                            86u8,
                            23u8,
                            12u8,
                            98u8,
                            114u8,
                            3u8,
                            170u8,
                            11u8,
                            100u8,
                            17u8,
                            122u8,
                            158u8,
                            192u8,
                            21u8,
                            160u8,
                            87u8,
                            85u8,
                            142u8,
                            241u8,
                            232u8,
                            25u8,
                            6u8,
                            36u8,
                            85u8,
                            155u8,
                            79u8,
                            124u8,
                            173u8,
                            0u8,
                            252u8,
                        ],
                    )
                }
                /// The map from nominator stash key to their nomination preferences, namely the validators that
                /// they wish to support.
                ///
                /// Note that the keys of this storage map might become non-decodable in case the
                /// [`Config::MaxNominations`] configuration is decreased. In this rare case, these nominators
                /// are still existent in storage, their key is correct and retrievable (i.e. `contains_key`
                /// indicates that they exist), but their value cannot be decoded. Therefore, the non-decodable
                /// nominators will effectively not-exist, until they re-submit their preferences such that it
                /// is within the bounds of the newly set `Config::MaxNominations`.
                ///
                /// This implies that `::iter_keys().count()` and `::iter().count()` might return different
                /// values for this map. Moreover, the main `::count()` is aligned with the former, namely the
                /// number of keys that exist.
                ///
                /// Lastly, if any of the nominators become non-decodable, they can be chilled immediately via
                /// [`Call::chill_other`] dispatchable by anyone.
                ///
                /// TWOX-NOTE: SAFE since `AccountId` is a secure hash.
                pub fn nominators_root(
                    &self,
                ) -> ::subxt::storage::address::Address<
                    ::subxt::storage::address::StaticStorageMapKey,
                    runtime_types::pallet_staking::Nominations,
                    (),
                    (),
                    ::subxt::storage::address::Yes,
                > {
                    ::subxt::storage::address::Address::new_static(
                        "Staking",
                        "Nominators",
                        Vec::new(),
                        [
                            114u8,
                            45u8,
                            86u8,
                            23u8,
                            12u8,
                            98u8,
                            114u8,
                            3u8,
                            170u8,
                            11u8,
                            100u8,
                            17u8,
                            122u8,
                            158u8,
                            192u8,
                            21u8,
                            160u8,
                            87u8,
                            85u8,
                            142u8,
                            241u8,
                            232u8,
                            25u8,
                            6u8,
                            36u8,
                            85u8,
                            155u8,
                            79u8,
                            124u8,
                            173u8,
                            0u8,
                            252u8,
                        ],
                    )
                }
                ///Counter for the related counted storage map
                pub fn counter_for_nominators(
                    &self,
                ) -> ::subxt::storage::address::Address<
                    ::subxt::storage::address::StaticStorageMapKey,
                    ::core::primitive::u32,
                    ::subxt::storage::address::Yes,
                    ::subxt::storage::address::Yes,
                    (),
                > {
                    ::subxt::storage::address::Address::new_static(
                        "Staking",
                        "CounterForNominators",
                        vec![],
                        [
                            150u8,
                            236u8,
                            184u8,
                            12u8,
                            224u8,
                            26u8,
                            13u8,
                            204u8,
                            208u8,
                            178u8,
                            68u8,
                            148u8,
                            232u8,
                            85u8,
                            74u8,
                            248u8,
                            167u8,
                            61u8,
                            88u8,
                            126u8,
                            40u8,
                            20u8,
                            73u8,
                            47u8,
                            94u8,
                            57u8,
                            144u8,
                            77u8,
                            156u8,
                            179u8,
                            55u8,
                            49u8,
                        ],
                    )
                }
                /// The maximum nominator count before we stop allowing new validators to join.
                ///
                /// When this value is not set, no limits are enforced.
                pub fn max_nominators_count(
                    &self,
                ) -> ::subxt::storage::address::Address<
                    ::subxt::storage::address::StaticStorageMapKey,
                    ::core::primitive::u32,
                    ::subxt::storage::address::Yes,
                    (),
                    (),
                > {
                    ::subxt::storage::address::Address::new_static(
                        "Staking",
                        "MaxNominatorsCount",
                        vec![],
                        [
                            11u8,
                            234u8,
                            179u8,
                            254u8,
                            95u8,
                            119u8,
                            35u8,
                            255u8,
                            141u8,
                            95u8,
                            148u8,
                            209u8,
                            43u8,
                            202u8,
                            19u8,
                            57u8,
                            185u8,
                            50u8,
                            152u8,
                            192u8,
                            95u8,
                            13u8,
                            158u8,
                            245u8,
                            113u8,
                            199u8,
                            255u8,
                            187u8,
                            37u8,
                            44u8,
                            8u8,
                            119u8,
                        ],
                    )
                }
                /// The current era index.
                ///
                /// This is the latest planned era, depending on how the Session pallet queues the validator
                /// set, it might be active or not.
                pub fn current_era(
                    &self,
                ) -> ::subxt::storage::address::Address<
                    ::subxt::storage::address::StaticStorageMapKey,
                    ::core::primitive::u32,
                    ::subxt::storage::address::Yes,
                    (),
                    (),
                > {
                    ::subxt::storage::address::Address::new_static(
                        "Staking",
                        "CurrentEra",
                        vec![],
                        [
                            247u8,
                            239u8,
                            171u8,
                            18u8,
                            137u8,
                            240u8,
                            213u8,
                            3u8,
                            173u8,
                            173u8,
                            236u8,
                            141u8,
                            202u8,
                            191u8,
                            228u8,
                            120u8,
                            196u8,
                            188u8,
                            13u8,
                            66u8,
                            253u8,
                            117u8,
                            90u8,
                            8u8,
                            158u8,
                            11u8,
                            236u8,
                            141u8,
                            178u8,
                            44u8,
                            119u8,
                            25u8,
                        ],
                    )
                }
                /// The active era information, it holds index and start.
                ///
                /// The active era is the era being currently rewarded. Validator set of this era must be
                /// equal to [`SessionInterface::validators`].
                pub fn active_era(
                    &self,
                ) -> ::subxt::storage::address::Address<
                    ::subxt::storage::address::StaticStorageMapKey,
                    runtime_types::pallet_staking::ActiveEraInfo,
                    ::subxt::storage::address::Yes,
                    (),
                    (),
                > {
                    ::subxt::storage::address::Address::new_static(
                        "Staking",
                        "ActiveEra",
                        vec![],
                        [
                            24u8,
                            229u8,
                            66u8,
                            56u8,
                            111u8,
                            234u8,
                            139u8,
                            93u8,
                            245u8,
                            137u8,
                            110u8,
                            110u8,
                            121u8,
                            15u8,
                            216u8,
                            207u8,
                            97u8,
                            120u8,
                            125u8,
                            45u8,
                            61u8,
                            2u8,
                            50u8,
                            100u8,
                            3u8,
                            106u8,
                            12u8,
                            233u8,
                            123u8,
                            156u8,
                            145u8,
                            38u8,
                        ],
                    )
                }
                /// The session index at which the era start for the last `HISTORY_DEPTH` eras.
                ///
                /// Note: This tracks the starting session (i.e. session index when era start being active)
                /// for the eras in `[CurrentEra - HISTORY_DEPTH, CurrentEra]`.
                pub fn eras_start_session_index(
                    &self,
                    _0: impl ::std::borrow::Borrow<::core::primitive::u32>,
                ) -> ::subxt::storage::address::Address<
                    ::subxt::storage::address::StaticStorageMapKey,
                    ::core::primitive::u32,
                    ::subxt::storage::address::Yes,
                    (),
                    ::subxt::storage::address::Yes,
                > {
                    ::subxt::storage::address::Address::new_static(
                        "Staking",
                        "ErasStartSessionIndex",
                        vec![
                            ::subxt::storage::address::make_static_storage_map_key(_0
                            .borrow())
                        ],
                        [
                            72u8,
                            185u8,
                            246u8,
                            202u8,
                            79u8,
                            127u8,
                            173u8,
                            74u8,
                            216u8,
                            238u8,
                            58u8,
                            82u8,
                            235u8,
                            222u8,
                            76u8,
                            144u8,
                            97u8,
                            84u8,
                            17u8,
                            164u8,
                            132u8,
                            167u8,
                            24u8,
                            195u8,
                            175u8,
                            132u8,
                            156u8,
                            87u8,
                            234u8,
                            147u8,
                            103u8,
                            58u8,
                        ],
                    )
                }
                /// The session index at which the era start for the last `HISTORY_DEPTH` eras.
                ///
                /// Note: This tracks the starting session (i.e. session index when era start being active)
                /// for the eras in `[CurrentEra - HISTORY_DEPTH, CurrentEra]`.
                pub fn eras_start_session_index_root(
                    &self,
                ) -> ::subxt::storage::address::Address<
                    ::subxt::storage::address::StaticStorageMapKey,
                    ::core::primitive::u32,
                    (),
                    (),
                    ::subxt::storage::address::Yes,
                > {
                    ::subxt::storage::address::Address::new_static(
                        "Staking",
                        "ErasStartSessionIndex",
                        Vec::new(),
                        [
                            72u8,
                            185u8,
                            246u8,
                            202u8,
                            79u8,
                            127u8,
                            173u8,
                            74u8,
                            216u8,
                            238u8,
                            58u8,
                            82u8,
                            235u8,
                            222u8,
                            76u8,
                            144u8,
                            97u8,
                            84u8,
                            17u8,
                            164u8,
                            132u8,
                            167u8,
                            24u8,
                            195u8,
                            175u8,
                            132u8,
                            156u8,
                            87u8,
                            234u8,
                            147u8,
                            103u8,
                            58u8,
                        ],
                    )
                }
                /// Exposure of validator at era.
                ///
                /// This is keyed first by the era index to allow bulk deletion and then the stash account.
                ///
                /// Is it removed after `HISTORY_DEPTH` eras.
                /// If stakers hasn't been set or has been removed then empty exposure is returned.
                pub fn eras_stakers(
                    &self,
                    _0: impl ::std::borrow::Borrow<::core::primitive::u32>,
                    _1: impl ::std::borrow::Borrow<::subxt::utils::AccountId32>,
                ) -> ::subxt::storage::address::Address<
                    ::subxt::storage::address::StaticStorageMapKey,
                    runtime_types::pallet_staking::Exposure<
                        ::subxt::utils::AccountId32,
                        ::core::primitive::u128,
                    >,
                    ::subxt::storage::address::Yes,
                    ::subxt::storage::address::Yes,
                    ::subxt::storage::address::Yes,
                > {
                    ::subxt::storage::address::Address::new_static(
                        "Staking",
                        "ErasStakers",
                        vec![
                            ::subxt::storage::address::make_static_storage_map_key(_0
                            .borrow()),
                            ::subxt::storage::address::make_static_storage_map_key(_1
                            .borrow())
                        ],
                        [
                            103u8,
                            38u8,
                            198u8,
                            91u8,
                            133u8,
                            9u8,
                            10u8,
                            201u8,
                            103u8,
                            169u8,
                            159u8,
                            172u8,
                            59u8,
                            238u8,
                            21u8,
                            30u8,
                            140u8,
                            183u8,
                            160u8,
                            61u8,
                            36u8,
                            162u8,
                            244u8,
                            61u8,
                            78u8,
                            33u8,
                            134u8,
                            176u8,
                            112u8,
                            153u8,
                            192u8,
                            252u8,
                        ],
                    )
                }
                /// Exposure of validator at era.
                ///
                /// This is keyed first by the era index to allow bulk deletion and then the stash account.
                ///
                /// Is it removed after `HISTORY_DEPTH` eras.
                /// If stakers hasn't been set or has been removed then empty exposure is returned.
                pub fn eras_stakers_root(
                    &self,
                ) -> ::subxt::storage::address::Address<
                    ::subxt::storage::address::StaticStorageMapKey,
                    runtime_types::pallet_staking::Exposure<
                        ::subxt::utils::AccountId32,
                        ::core::primitive::u128,
                    >,
                    (),
                    ::subxt::storage::address::Yes,
                    ::subxt::storage::address::Yes,
                > {
                    ::subxt::storage::address::Address::new_static(
                        "Staking",
                        "ErasStakers",
                        Vec::new(),
                        [
                            103u8,
                            38u8,
                            198u8,
                            91u8,
                            133u8,
                            9u8,
                            10u8,
                            201u8,
                            103u8,
                            169u8,
                            159u8,
                            172u8,
                            59u8,
                            238u8,
                            21u8,
                            30u8,
                            140u8,
                            183u8,
                            160u8,
                            61u8,
                            36u8,
                            162u8,
                            244u8,
                            61u8,
                            78u8,
                            33u8,
                            134u8,
                            176u8,
                            112u8,
                            153u8,
                            192u8,
                            252u8,
                        ],
                    )
                }
                /// Clipped Exposure of validator at era.
                ///
                /// This is similar to [`ErasStakers`] but number of nominators exposed is reduced to the
                /// `T::MaxNominatorRewardedPerValidator` biggest stakers.
                /// (Note: the field `total` and `own` of the exposure remains unchanged).
                /// This is used to limit the i/o cost for the nominator payout.
                ///
                /// This is keyed fist by the era index to allow bulk deletion and then the stash account.
                ///
                /// Is it removed after `HISTORY_DEPTH` eras.
                /// If stakers hasn't been set or has been removed then empty exposure is returned.
                pub fn eras_stakers_clipped(
                    &self,
                    _0: impl ::std::borrow::Borrow<::core::primitive::u32>,
                    _1: impl ::std::borrow::Borrow<::subxt::utils::AccountId32>,
                ) -> ::subxt::storage::address::Address<
                    ::subxt::storage::address::StaticStorageMapKey,
                    runtime_types::pallet_staking::Exposure<
                        ::subxt::utils::AccountId32,
                        ::core::primitive::u128,
                    >,
                    ::subxt::storage::address::Yes,
                    ::subxt::storage::address::Yes,
                    ::subxt::storage::address::Yes,
                > {
                    ::subxt::storage::address::Address::new_static(
                        "Staking",
                        "ErasStakersClipped",
                        vec![
                            ::subxt::storage::address::make_static_storage_map_key(_0
                            .borrow()),
                            ::subxt::storage::address::make_static_storage_map_key(_1
                            .borrow())
                        ],
                        [
                            119u8,
                            253u8,
                            51u8,
                            32u8,
                            173u8,
                            173u8,
                            49u8,
                            121u8,
                            141u8,
                            128u8,
                            219u8,
                            112u8,
                            173u8,
                            42u8,
                            145u8,
                            37u8,
                            8u8,
                            12u8,
                            27u8,
                            37u8,
                            232u8,
                            187u8,
                            130u8,
                            227u8,
                            113u8,
                            111u8,
                            185u8,
                            197u8,
                            157u8,
                            136u8,
                            205u8,
                            32u8,
                        ],
                    )
                }
                /// Clipped Exposure of validator at era.
                ///
                /// This is similar to [`ErasStakers`] but number of nominators exposed is reduced to the
                /// `T::MaxNominatorRewardedPerValidator` biggest stakers.
                /// (Note: the field `total` and `own` of the exposure remains unchanged).
                /// This is used to limit the i/o cost for the nominator payout.
                ///
                /// This is keyed fist by the era index to allow bulk deletion and then the stash account.
                ///
                /// Is it removed after `HISTORY_DEPTH` eras.
                /// If stakers hasn't been set or has been removed then empty exposure is returned.
                pub fn eras_stakers_clipped_root(
                    &self,
                ) -> ::subxt::storage::address::Address<
                    ::subxt::storage::address::StaticStorageMapKey,
                    runtime_types::pallet_staking::Exposure<
                        ::subxt::utils::AccountId32,
                        ::core::primitive::u128,
                    >,
                    (),
                    ::subxt::storage::address::Yes,
                    ::subxt::storage::address::Yes,
                > {
                    ::subxt::storage::address::Address::new_static(
                        "Staking",
                        "ErasStakersClipped",
                        Vec::new(),
                        [
                            119u8,
                            253u8,
                            51u8,
                            32u8,
                            173u8,
                            173u8,
                            49u8,
                            121u8,
                            141u8,
                            128u8,
                            219u8,
                            112u8,
                            173u8,
                            42u8,
                            145u8,
                            37u8,
                            8u8,
                            12u8,
                            27u8,
                            37u8,
                            232u8,
                            187u8,
                            130u8,
                            227u8,
                            113u8,
                            111u8,
                            185u8,
                            197u8,
                            157u8,
                            136u8,
                            205u8,
                            32u8,
                        ],
                    )
                }
                /// Similar to `ErasStakers`, this holds the preferences of validators.
                ///
                /// This is keyed first by the era index to allow bulk deletion and then the stash account.
                ///
                /// Is it removed after `HISTORY_DEPTH` eras.
                pub fn eras_validator_prefs(
                    &self,
                    _0: impl ::std::borrow::Borrow<::core::primitive::u32>,
                    _1: impl ::std::borrow::Borrow<::subxt::utils::AccountId32>,
                ) -> ::subxt::storage::address::Address<
                    ::subxt::storage::address::StaticStorageMapKey,
                    runtime_types::pallet_staking::ValidatorPrefs,
                    ::subxt::storage::address::Yes,
                    ::subxt::storage::address::Yes,
                    ::subxt::storage::address::Yes,
                > {
                    ::subxt::storage::address::Address::new_static(
                        "Staking",
                        "ErasValidatorPrefs",
                        vec![
                            ::subxt::storage::address::make_static_storage_map_key(_0
                            .borrow()),
                            ::subxt::storage::address::make_static_storage_map_key(_1
                            .borrow())
                        ],
                        [
                            201u8,
                            204u8,
                            230u8,
                            197u8,
                            37u8,
                            83u8,
                            124u8,
                            26u8,
                            10u8,
                            75u8,
                            164u8,
                            102u8,
                            83u8,
                            24u8,
                            158u8,
                            127u8,
                            27u8,
                            173u8,
                            125u8,
                            63u8,
                            251u8,
                            128u8,
                            239u8,
                            182u8,
                            115u8,
                            109u8,
                            13u8,
                            97u8,
                            211u8,
                            104u8,
                            189u8,
                            127u8,
                        ],
                    )
                }
                /// Similar to `ErasStakers`, this holds the preferences of validators.
                ///
                /// This is keyed first by the era index to allow bulk deletion and then the stash account.
                ///
                /// Is it removed after `HISTORY_DEPTH` eras.
                pub fn eras_validator_prefs_root(
                    &self,
                ) -> ::subxt::storage::address::Address<
                    ::subxt::storage::address::StaticStorageMapKey,
                    runtime_types::pallet_staking::ValidatorPrefs,
                    (),
                    ::subxt::storage::address::Yes,
                    ::subxt::storage::address::Yes,
                > {
                    ::subxt::storage::address::Address::new_static(
                        "Staking",
                        "ErasValidatorPrefs",
                        Vec::new(),
                        [
                            201u8,
                            204u8,
                            230u8,
                            197u8,
                            37u8,
                            83u8,
                            124u8,
                            26u8,
                            10u8,
                            75u8,
                            164u8,
                            102u8,
                            83u8,
                            24u8,
                            158u8,
                            127u8,
                            27u8,
                            173u8,
                            125u8,
                            63u8,
                            251u8,
                            128u8,
                            239u8,
                            182u8,
                            115u8,
                            109u8,
                            13u8,
                            97u8,
                            211u8,
                            104u8,
                            189u8,
                            127u8,
                        ],
                    )
                }
                /// The total validator era payout for the last `HISTORY_DEPTH` eras.
                ///
                /// Eras that haven't finished yet or has been removed doesn't have reward.
                pub fn eras_validator_reward(
                    &self,
                    _0: impl ::std::borrow::Borrow<::core::primitive::u32>,
                ) -> ::subxt::storage::address::Address<
                    ::subxt::storage::address::StaticStorageMapKey,
                    ::core::primitive::u128,
                    ::subxt::storage::address::Yes,
                    (),
                    ::subxt::storage::address::Yes,
                > {
                    ::subxt::storage::address::Address::new_static(
                        "Staking",
                        "ErasValidatorReward",
                        vec![
                            ::subxt::storage::address::make_static_storage_map_key(_0
                            .borrow())
                        ],
                        [
                            185u8,
                            85u8,
                            179u8,
                            163u8,
                            178u8,
                            168u8,
                            141u8,
                            200u8,
                            59u8,
                            77u8,
                            2u8,
                            197u8,
                            36u8,
                            188u8,
                            133u8,
                            117u8,
                            2u8,
                            25u8,
                            105u8,
                            132u8,
                            44u8,
                            75u8,
                            15u8,
                            82u8,
                            57u8,
                            89u8,
                            242u8,
                            234u8,
                            70u8,
                            244u8,
                            198u8,
                            126u8,
                        ],
                    )
                }
                /// The total validator era payout for the last `HISTORY_DEPTH` eras.
                ///
                /// Eras that haven't finished yet or has been removed doesn't have reward.
                pub fn eras_validator_reward_root(
                    &self,
                ) -> ::subxt::storage::address::Address<
                    ::subxt::storage::address::StaticStorageMapKey,
                    ::core::primitive::u128,
                    (),
                    (),
                    ::subxt::storage::address::Yes,
                > {
                    ::subxt::storage::address::Address::new_static(
                        "Staking",
                        "ErasValidatorReward",
                        Vec::new(),
                        [
                            185u8,
                            85u8,
                            179u8,
                            163u8,
                            178u8,
                            168u8,
                            141u8,
                            200u8,
                            59u8,
                            77u8,
                            2u8,
                            197u8,
                            36u8,
                            188u8,
                            133u8,
                            117u8,
                            2u8,
                            25u8,
                            105u8,
                            132u8,
                            44u8,
                            75u8,
                            15u8,
                            82u8,
                            57u8,
                            89u8,
                            242u8,
                            234u8,
                            70u8,
                            244u8,
                            198u8,
                            126u8,
                        ],
                    )
                }
                /// Rewards for the last `HISTORY_DEPTH` eras.
                /// If reward hasn't been set or has been removed then 0 reward is returned.
                pub fn eras_reward_points(
                    &self,
                    _0: impl ::std::borrow::Borrow<::core::primitive::u32>,
                ) -> ::subxt::storage::address::Address<
                    ::subxt::storage::address::StaticStorageMapKey,
                    runtime_types::pallet_staking::EraRewardPoints<
                        ::subxt::utils::AccountId32,
                    >,
                    ::subxt::storage::address::Yes,
                    ::subxt::storage::address::Yes,
                    ::subxt::storage::address::Yes,
                > {
                    ::subxt::storage::address::Address::new_static(
                        "Staking",
                        "ErasRewardPoints",
                        vec![
                            ::subxt::storage::address::make_static_storage_map_key(_0
                            .borrow())
                        ],
                        [
                            237u8,
                            135u8,
                            146u8,
                            156u8,
                            172u8,
                            48u8,
                            147u8,
                            207u8,
                            15u8,
                            86u8,
                            55u8,
                            38u8,
                            29u8,
                            253u8,
                            198u8,
                            192u8,
                            99u8,
                            213u8,
                            80u8,
                            72u8,
                            212u8,
                            60u8,
                            60u8,
                            180u8,
                            33u8,
                            17u8,
                            77u8,
                            0u8,
                            165u8,
                            225u8,
                            60u8,
                            213u8,
                        ],
                    )
                }
                /// Rewards for the last `HISTORY_DEPTH` eras.
                /// If reward hasn't been set or has been removed then 0 reward is returned.
                pub fn eras_reward_points_root(
                    &self,
                ) -> ::subxt::storage::address::Address<
                    ::subxt::storage::address::StaticStorageMapKey,
                    runtime_types::pallet_staking::EraRewardPoints<
                        ::subxt::utils::AccountId32,
                    >,
                    (),
                    ::subxt::storage::address::Yes,
                    ::subxt::storage::address::Yes,
                > {
                    ::subxt::storage::address::Address::new_static(
                        "Staking",
                        "ErasRewardPoints",
                        Vec::new(),
                        [
                            237u8,
                            135u8,
                            146u8,
                            156u8,
                            172u8,
                            48u8,
                            147u8,
                            207u8,
                            15u8,
                            86u8,
                            55u8,
                            38u8,
                            29u8,
                            253u8,
                            198u8,
                            192u8,
                            99u8,
                            213u8,
                            80u8,
                            72u8,
                            212u8,
                            60u8,
                            60u8,
                            180u8,
                            33u8,
                            17u8,
                            77u8,
                            0u8,
                            165u8,
                            225u8,
                            60u8,
                            213u8,
                        ],
                    )
                }
                /// The total amount staked for the last `HISTORY_DEPTH` eras.
                /// If total hasn't been set or has been removed then 0 stake is returned.
                pub fn eras_total_stake(
                    &self,
                    _0: impl ::std::borrow::Borrow<::core::primitive::u32>,
                ) -> ::subxt::storage::address::Address<
                    ::subxt::storage::address::StaticStorageMapKey,
                    ::core::primitive::u128,
                    ::subxt::storage::address::Yes,
                    ::subxt::storage::address::Yes,
                    ::subxt::storage::address::Yes,
                > {
                    ::subxt::storage::address::Address::new_static(
                        "Staking",
                        "ErasTotalStake",
                        vec![
                            ::subxt::storage::address::make_static_storage_map_key(_0
                            .borrow())
                        ],
                        [
                            8u8,
                            78u8,
                            101u8,
                            62u8,
                            124u8,
                            126u8,
                            66u8,
                            26u8,
                            47u8,
                            126u8,
                            239u8,
                            204u8,
                            222u8,
                            104u8,
                            19u8,
                            108u8,
                            238u8,
                            160u8,
                            112u8,
                            242u8,
                            56u8,
                            2u8,
                            250u8,
                            164u8,
                            250u8,
                            213u8,
                            201u8,
                            84u8,
                            193u8,
                            117u8,
                            108u8,
                            146u8,
                        ],
                    )
                }
                /// The total amount staked for the last `HISTORY_DEPTH` eras.
                /// If total hasn't been set or has been removed then 0 stake is returned.
                pub fn eras_total_stake_root(
                    &self,
                ) -> ::subxt::storage::address::Address<
                    ::subxt::storage::address::StaticStorageMapKey,
                    ::core::primitive::u128,
                    (),
                    ::subxt::storage::address::Yes,
                    ::subxt::storage::address::Yes,
                > {
                    ::subxt::storage::address::Address::new_static(
                        "Staking",
                        "ErasTotalStake",
                        Vec::new(),
                        [
                            8u8,
                            78u8,
                            101u8,
                            62u8,
                            124u8,
                            126u8,
                            66u8,
                            26u8,
                            47u8,
                            126u8,
                            239u8,
                            204u8,
                            222u8,
                            104u8,
                            19u8,
                            108u8,
                            238u8,
                            160u8,
                            112u8,
                            242u8,
                            56u8,
                            2u8,
                            250u8,
                            164u8,
                            250u8,
                            213u8,
                            201u8,
                            84u8,
                            193u8,
                            117u8,
                            108u8,
                            146u8,
                        ],
                    )
                }
                /// Mode of era forcing.
                pub fn force_era(
                    &self,
                ) -> ::subxt::storage::address::Address<
                    ::subxt::storage::address::StaticStorageMapKey,
                    runtime_types::pallet_staking::Forcing,
                    ::subxt::storage::address::Yes,
                    ::subxt::storage::address::Yes,
                    (),
                > {
                    ::subxt::storage::address::Address::new_static(
                        "Staking",
                        "ForceEra",
                        vec![],
                        [
                            177u8,
                            148u8,
                            73u8,
                            108u8,
                            136u8,
                            126u8,
                            89u8,
                            18u8,
                            124u8,
                            66u8,
                            30u8,
                            102u8,
                            133u8,
                            164u8,
                            78u8,
                            214u8,
                            184u8,
                            163u8,
                            75u8,
                            164u8,
                            117u8,
                            233u8,
                            209u8,
                            158u8,
                            99u8,
                            208u8,
                            21u8,
                            194u8,
                            152u8,
                            82u8,
                            16u8,
                            222u8,
                        ],
                    )
                }
                /// The percentage of the slash that is distributed to reporters.
                ///
                /// The rest of the slashed value is handled by the `Slash`.
                pub fn slash_reward_fraction(
                    &self,
                ) -> ::subxt::storage::address::Address<
                    ::subxt::storage::address::StaticStorageMapKey,
                    runtime_types::sp_arithmetic::per_things::Perbill,
                    ::subxt::storage::address::Yes,
                    ::subxt::storage::address::Yes,
                    (),
                > {
                    ::subxt::storage::address::Address::new_static(
                        "Staking",
                        "SlashRewardFraction",
                        vec![],
                        [
                            53u8,
                            88u8,
                            253u8,
                            237u8,
                            84u8,
                            228u8,
                            187u8,
                            130u8,
                            108u8,
                            195u8,
                            135u8,
                            25u8,
                            75u8,
                            52u8,
                            238u8,
                            62u8,
                            133u8,
                            38u8,
                            139u8,
                            129u8,
                            216u8,
                            193u8,
                            197u8,
                            216u8,
                            245u8,
                            171u8,
                            128u8,
                            207u8,
                            125u8,
                            246u8,
                            248u8,
                            7u8,
                        ],
                    )
                }
                /// The amount of currency given to reporters of a slash event which was
                /// canceled by extraordinary circumstances (e.g. governance).
                pub fn canceled_slash_payout(
                    &self,
                ) -> ::subxt::storage::address::Address<
                    ::subxt::storage::address::StaticStorageMapKey,
                    ::core::primitive::u128,
                    ::subxt::storage::address::Yes,
                    ::subxt::storage::address::Yes,
                    (),
                > {
                    ::subxt::storage::address::Address::new_static(
                        "Staking",
                        "CanceledSlashPayout",
                        vec![],
                        [
                            221u8,
                            88u8,
                            134u8,
                            81u8,
                            22u8,
                            229u8,
                            100u8,
                            27u8,
                            86u8,
                            244u8,
                            229u8,
                            107u8,
                            251u8,
                            119u8,
                            58u8,
                            153u8,
                            19u8,
                            20u8,
                            254u8,
                            169u8,
                            248u8,
                            220u8,
                            98u8,
                            118u8,
                            48u8,
                            213u8,
                            22u8,
                            79u8,
                            242u8,
                            250u8,
                            147u8,
                            173u8,
                        ],
                    )
                }
                /// All unapplied slashes that are queued for later.
                pub fn unapplied_slashes(
                    &self,
                    _0: impl ::std::borrow::Borrow<::core::primitive::u32>,
                ) -> ::subxt::storage::address::Address<
                    ::subxt::storage::address::StaticStorageMapKey,
                    ::std::vec::Vec<
                        runtime_types::pallet_staking::UnappliedSlash<
                            ::subxt::utils::AccountId32,
                            ::core::primitive::u128,
                        >,
                    >,
                    ::subxt::storage::address::Yes,
                    ::subxt::storage::address::Yes,
                    ::subxt::storage::address::Yes,
                > {
                    ::subxt::storage::address::Address::new_static(
                        "Staking",
                        "UnappliedSlashes",
                        vec![
                            ::subxt::storage::address::make_static_storage_map_key(_0
                            .borrow())
                        ],
                        [
                            121u8,
                            1u8,
                            135u8,
                            243u8,
                            99u8,
                            254u8,
                            238u8,
                            207u8,
                            145u8,
                            172u8,
                            186u8,
                            131u8,
                            181u8,
                            109u8,
                            199u8,
                            93u8,
                            129u8,
                            65u8,
                            106u8,
                            118u8,
                            197u8,
                            83u8,
                            65u8,
                            45u8,
                            149u8,
                            1u8,
                            85u8,
                            99u8,
                            239u8,
                            148u8,
                            40u8,
                            177u8,
                        ],
                    )
                }
                /// All unapplied slashes that are queued for later.
                pub fn unapplied_slashes_root(
                    &self,
                ) -> ::subxt::storage::address::Address<
                    ::subxt::storage::address::StaticStorageMapKey,
                    ::std::vec::Vec<
                        runtime_types::pallet_staking::UnappliedSlash<
                            ::subxt::utils::AccountId32,
                            ::core::primitive::u128,
                        >,
                    >,
                    (),
                    ::subxt::storage::address::Yes,
                    ::subxt::storage::address::Yes,
                > {
                    ::subxt::storage::address::Address::new_static(
                        "Staking",
                        "UnappliedSlashes",
                        Vec::new(),
                        [
                            121u8,
                            1u8,
                            135u8,
                            243u8,
                            99u8,
                            254u8,
                            238u8,
                            207u8,
                            145u8,
                            172u8,
                            186u8,
                            131u8,
                            181u8,
                            109u8,
                            199u8,
                            93u8,
                            129u8,
                            65u8,
                            106u8,
                            118u8,
                            197u8,
                            83u8,
                            65u8,
                            45u8,
                            149u8,
                            1u8,
                            85u8,
                            99u8,
                            239u8,
                            148u8,
                            40u8,
                            177u8,
                        ],
                    )
                }
                /// A mapping from still-bonded eras to the first session index of that era.
                ///
                /// Must contains information for eras for the range:
                /// `[active_era - bounding_duration; active_era]`
                pub fn bonded_eras(
                    &self,
                ) -> ::subxt::storage::address::Address<
                    ::subxt::storage::address::StaticStorageMapKey,
                    ::std::vec::Vec<(::core::primitive::u32, ::core::primitive::u32)>,
                    ::subxt::storage::address::Yes,
                    ::subxt::storage::address::Yes,
                    (),
                > {
                    ::subxt::storage::address::Address::new_static(
                        "Staking",
                        "BondedEras",
                        vec![],
                        [
                            187u8,
                            216u8,
                            245u8,
                            253u8,
                            194u8,
                            182u8,
                            60u8,
                            244u8,
                            203u8,
                            84u8,
                            228u8,
                            163u8,
                            149u8,
                            205u8,
                            57u8,
                            176u8,
                            203u8,
                            156u8,
                            20u8,
                            29u8,
                            52u8,
                            234u8,
                            200u8,
                            63u8,
                            88u8,
                            49u8,
                            89u8,
                            117u8,
                            252u8,
                            75u8,
                            172u8,
                            53u8,
                        ],
                    )
                }
                /// All slashing events on validators, mapped by era to the highest slash proportion
                /// and slash value of the era.
                pub fn validator_slash_in_era(
                    &self,
                    _0: impl ::std::borrow::Borrow<::core::primitive::u32>,
                    _1: impl ::std::borrow::Borrow<::subxt::utils::AccountId32>,
                ) -> ::subxt::storage::address::Address<
                    ::subxt::storage::address::StaticStorageMapKey,
                    (
                        runtime_types::sp_arithmetic::per_things::Perbill,
                        ::core::primitive::u128,
                    ),
                    ::subxt::storage::address::Yes,
                    (),
                    ::subxt::storage::address::Yes,
                > {
                    ::subxt::storage::address::Address::new_static(
                        "Staking",
                        "ValidatorSlashInEra",
                        vec![
                            ::subxt::storage::address::make_static_storage_map_key(_0
                            .borrow()),
                            ::subxt::storage::address::make_static_storage_map_key(_1
                            .borrow())
                        ],
                        [
                            224u8,
                            141u8,
                            93u8,
                            44u8,
                            47u8,
                            157u8,
                            205u8,
                            12u8,
                            68u8,
                            41u8,
                            221u8,
                            210u8,
                            141u8,
                            225u8,
                            253u8,
                            22u8,
                            175u8,
                            11u8,
                            92u8,
                            76u8,
                            180u8,
                            4u8,
                            106u8,
                            135u8,
                            166u8,
                            47u8,
                            201u8,
                            43u8,
                            165u8,
                            42u8,
                            232u8,
                            219u8,
                        ],
                    )
                }
                /// All slashing events on validators, mapped by era to the highest slash proportion
                /// and slash value of the era.
                pub fn validator_slash_in_era_root(
                    &self,
                ) -> ::subxt::storage::address::Address<
                    ::subxt::storage::address::StaticStorageMapKey,
                    (
                        runtime_types::sp_arithmetic::per_things::Perbill,
                        ::core::primitive::u128,
                    ),
                    (),
                    (),
                    ::subxt::storage::address::Yes,
                > {
                    ::subxt::storage::address::Address::new_static(
                        "Staking",
                        "ValidatorSlashInEra",
                        Vec::new(),
                        [
                            224u8,
                            141u8,
                            93u8,
                            44u8,
                            47u8,
                            157u8,
                            205u8,
                            12u8,
                            68u8,
                            41u8,
                            221u8,
                            210u8,
                            141u8,
                            225u8,
                            253u8,
                            22u8,
                            175u8,
                            11u8,
                            92u8,
                            76u8,
                            180u8,
                            4u8,
                            106u8,
                            135u8,
                            166u8,
                            47u8,
                            201u8,
                            43u8,
                            165u8,
                            42u8,
                            232u8,
                            219u8,
                        ],
                    )
                }
                /// All slashing events on nominators, mapped by era to the highest slash value of the era.
                pub fn nominator_slash_in_era(
                    &self,
                    _0: impl ::std::borrow::Borrow<::core::primitive::u32>,
                    _1: impl ::std::borrow::Borrow<::subxt::utils::AccountId32>,
                ) -> ::subxt::storage::address::Address<
                    ::subxt::storage::address::StaticStorageMapKey,
                    ::core::primitive::u128,
                    ::subxt::storage::address::Yes,
                    (),
                    ::subxt::storage::address::Yes,
                > {
                    ::subxt::storage::address::Address::new_static(
                        "Staking",
                        "NominatorSlashInEra",
                        vec![
                            ::subxt::storage::address::make_static_storage_map_key(_0
                            .borrow()),
                            ::subxt::storage::address::make_static_storage_map_key(_1
                            .borrow())
                        ],
                        [
                            8u8,
                            89u8,
                            171u8,
                            183u8,
                            64u8,
                            29u8,
                            44u8,
                            185u8,
                            11u8,
                            204u8,
                            67u8,
                            60u8,
                            208u8,
                            132u8,
                            9u8,
                            214u8,
                            13u8,
                            148u8,
                            205u8,
                            26u8,
                            5u8,
                            7u8,
                            250u8,
                            191u8,
                            83u8,
                            118u8,
                            95u8,
                            17u8,
                            40u8,
                            126u8,
                            16u8,
                            135u8,
                        ],
                    )
                }
                /// All slashing events on nominators, mapped by era to the highest slash value of the era.
                pub fn nominator_slash_in_era_root(
                    &self,
                ) -> ::subxt::storage::address::Address<
                    ::subxt::storage::address::StaticStorageMapKey,
                    ::core::primitive::u128,
                    (),
                    (),
                    ::subxt::storage::address::Yes,
                > {
                    ::subxt::storage::address::Address::new_static(
                        "Staking",
                        "NominatorSlashInEra",
                        Vec::new(),
                        [
                            8u8,
                            89u8,
                            171u8,
                            183u8,
                            64u8,
                            29u8,
                            44u8,
                            185u8,
                            11u8,
                            204u8,
                            67u8,
                            60u8,
                            208u8,
                            132u8,
                            9u8,
                            214u8,
                            13u8,
                            148u8,
                            205u8,
                            26u8,
                            5u8,
                            7u8,
                            250u8,
                            191u8,
                            83u8,
                            118u8,
                            95u8,
                            17u8,
                            40u8,
                            126u8,
                            16u8,
                            135u8,
                        ],
                    )
                }
                /// Slashing spans for stash accounts.
                pub fn slashing_spans(
                    &self,
                    _0: impl ::std::borrow::Borrow<::subxt::utils::AccountId32>,
                ) -> ::subxt::storage::address::Address<
                    ::subxt::storage::address::StaticStorageMapKey,
                    runtime_types::pallet_staking::slashing::SlashingSpans,
                    ::subxt::storage::address::Yes,
                    (),
                    ::subxt::storage::address::Yes,
                > {
                    ::subxt::storage::address::Address::new_static(
                        "Staking",
                        "SlashingSpans",
                        vec![
                            ::subxt::storage::address::make_static_storage_map_key(_0
                            .borrow())
                        ],
                        [
                            160u8,
                            190u8,
                            57u8,
                            128u8,
                            105u8,
                            73u8,
                            194u8,
                            75u8,
                            12u8,
                            120u8,
                            141u8,
                            190u8,
                            235u8,
                            250u8,
                            221u8,
                            200u8,
                            141u8,
                            162u8,
                            31u8,
                            85u8,
                            239u8,
                            108u8,
                            200u8,
                            148u8,
                            155u8,
                            48u8,
                            44u8,
                            89u8,
                            5u8,
                            177u8,
                            236u8,
                            182u8,
                        ],
                    )
                }
                /// Slashing spans for stash accounts.
                pub fn slashing_spans_root(
                    &self,
                ) -> ::subxt::storage::address::Address<
                    ::subxt::storage::address::StaticStorageMapKey,
                    runtime_types::pallet_staking::slashing::SlashingSpans,
                    (),
                    (),
                    ::subxt::storage::address::Yes,
                > {
                    ::subxt::storage::address::Address::new_static(
                        "Staking",
                        "SlashingSpans",
                        Vec::new(),
                        [
                            160u8,
                            190u8,
                            57u8,
                            128u8,
                            105u8,
                            73u8,
                            194u8,
                            75u8,
                            12u8,
                            120u8,
                            141u8,
                            190u8,
                            235u8,
                            250u8,
                            221u8,
                            200u8,
                            141u8,
                            162u8,
                            31u8,
                            85u8,
                            239u8,
                            108u8,
                            200u8,
                            148u8,
                            155u8,
                            48u8,
                            44u8,
                            89u8,
                            5u8,
                            177u8,
                            236u8,
                            182u8,
                        ],
                    )
                }
                /// Records information about the maximum slash of a stash within a slashing span,
                /// as well as how much reward has been paid out.
                pub fn span_slash(
                    &self,
                    _0: impl ::std::borrow::Borrow<::subxt::utils::AccountId32>,
                    _1: impl ::std::borrow::Borrow<::core::primitive::u32>,
                ) -> ::subxt::storage::address::Address<
                    ::subxt::storage::address::StaticStorageMapKey,
                    runtime_types::pallet_staking::slashing::SpanRecord<
                        ::core::primitive::u128,
                    >,
                    ::subxt::storage::address::Yes,
                    ::subxt::storage::address::Yes,
                    ::subxt::storage::address::Yes,
                > {
                    ::subxt::storage::address::Address::new_static(
                        "Staking",
                        "SpanSlash",
                        vec![
                            ::subxt::storage::address::make_static_storage_map_key(_0
                            .borrow()),
                            ::subxt::storage::address::make_static_storage_map_key(_1
                            .borrow())
                        ],
                        [
                            6u8,
                            241u8,
                            205u8,
                            89u8,
                            62u8,
                            181u8,
                            211u8,
                            216u8,
                            190u8,
                            41u8,
                            81u8,
                            136u8,
                            136u8,
                            139u8,
                            57u8,
                            243u8,
                            174u8,
                            150u8,
                            132u8,
                            211u8,
                            79u8,
                            138u8,
                            108u8,
                            218u8,
                            19u8,
                            225u8,
                            60u8,
                            26u8,
                            135u8,
                            6u8,
                            21u8,
                            116u8,
                        ],
                    )
                }
                /// Records information about the maximum slash of a stash within a slashing span,
                /// as well as how much reward has been paid out.
                pub fn span_slash_root(
                    &self,
                ) -> ::subxt::storage::address::Address<
                    ::subxt::storage::address::StaticStorageMapKey,
                    runtime_types::pallet_staking::slashing::SpanRecord<
                        ::core::primitive::u128,
                    >,
                    (),
                    ::subxt::storage::address::Yes,
                    ::subxt::storage::address::Yes,
                > {
                    ::subxt::storage::address::Address::new_static(
                        "Staking",
                        "SpanSlash",
                        Vec::new(),
                        [
                            6u8,
                            241u8,
                            205u8,
                            89u8,
                            62u8,
                            181u8,
                            211u8,
                            216u8,
                            190u8,
                            41u8,
                            81u8,
                            136u8,
                            136u8,
                            139u8,
                            57u8,
                            243u8,
                            174u8,
                            150u8,
                            132u8,
                            211u8,
                            79u8,
                            138u8,
                            108u8,
                            218u8,
                            19u8,
                            225u8,
                            60u8,
                            26u8,
                            135u8,
                            6u8,
                            21u8,
                            116u8,
                        ],
                    )
                }
                /// The last planned session scheduled by the session pallet.
                ///
                /// This is basically in sync with the call to [`pallet_session::SessionManager::new_session`].
                pub fn current_planned_session(
                    &self,
                ) -> ::subxt::storage::address::Address<
                    ::subxt::storage::address::StaticStorageMapKey,
                    ::core::primitive::u32,
                    ::subxt::storage::address::Yes,
                    ::subxt::storage::address::Yes,
                    (),
                > {
                    ::subxt::storage::address::Address::new_static(
                        "Staking",
                        "CurrentPlannedSession",
                        vec![],
                        [
                            12u8,
                            47u8,
                            20u8,
                            104u8,
                            155u8,
                            181u8,
                            35u8,
                            91u8,
                            172u8,
                            97u8,
                            206u8,
                            135u8,
                            185u8,
                            142u8,
                            46u8,
                            72u8,
                            32u8,
                            118u8,
                            225u8,
                            191u8,
                            28u8,
                            130u8,
                            7u8,
                            38u8,
                            181u8,
                            233u8,
                            201u8,
                            8u8,
                            160u8,
                            161u8,
                            86u8,
                            204u8,
                        ],
                    )
                }
                /// Indices of validators that have offended in the active era and whether they are currently
                /// disabled.
                ///
                /// This value should be a superset of disabled validators since not all offences lead to the
                /// validator being disabled (if there was no slash). This is needed to track the percentage of
                /// validators that have offended in the current era, ensuring a new era is forced if
                /// `OffendingValidatorsThreshold` is reached. The vec is always kept sorted so that we can find
                /// whether a given validator has previously offended using binary search. It gets cleared when
                /// the era ends.
                pub fn offending_validators(
                    &self,
                ) -> ::subxt::storage::address::Address<
                    ::subxt::storage::address::StaticStorageMapKey,
                    ::std::vec::Vec<(::core::primitive::u32, ::core::primitive::bool)>,
                    ::subxt::storage::address::Yes,
                    ::subxt::storage::address::Yes,
                    (),
                > {
                    ::subxt::storage::address::Address::new_static(
                        "Staking",
                        "OffendingValidators",
                        vec![],
                        [
                            201u8,
                            31u8,
                            141u8,
                            182u8,
                            160u8,
                            180u8,
                            37u8,
                            226u8,
                            50u8,
                            65u8,
                            103u8,
                            11u8,
                            38u8,
                            120u8,
                            200u8,
                            219u8,
                            219u8,
                            98u8,
                            185u8,
                            137u8,
                            154u8,
                            20u8,
                            130u8,
                            163u8,
                            126u8,
                            185u8,
                            33u8,
                            194u8,
                            76u8,
                            172u8,
                            70u8,
                            220u8,
                        ],
                    )
                }
                /// The threshold for when users can start calling `chill_other` for other validators /
                /// nominators. The threshold is compared to the actual number of validators / nominators
                /// (`CountFor*`) in the system compared to the configured max (`Max*Count`).
                pub fn chill_threshold(
                    &self,
                ) -> ::subxt::storage::address::Address<
                    ::subxt::storage::address::StaticStorageMapKey,
                    runtime_types::sp_arithmetic::per_things::Percent,
                    ::subxt::storage::address::Yes,
                    (),
                    (),
                > {
                    ::subxt::storage::address::Address::new_static(
                        "Staking",
                        "ChillThreshold",
                        vec![],
                        [
                            133u8,
                            222u8,
                            1u8,
                            208u8,
                            212u8,
                            216u8,
                            247u8,
                            66u8,
                            178u8,
                            96u8,
                            35u8,
                            112u8,
                            33u8,
                            245u8,
                            11u8,
                            249u8,
                            255u8,
                            212u8,
                            204u8,
                            161u8,
                            44u8,
                            38u8,
                            126u8,
                            151u8,
                            140u8,
                            42u8,
                            253u8,
                            101u8,
                            1u8,
                            23u8,
                            239u8,
                            39u8,
                        ],
                    )
                }
            }
        }
        pub mod constants {
            use super::runtime_types;
            pub struct ConstantsApi;
            impl ConstantsApi {
                /// Maximum number of nominations per nominator.
                pub fn max_nominations(
                    &self,
                ) -> ::subxt::constants::Address<::core::primitive::u32> {
                    ::subxt::constants::Address::new_static(
                        "Staking",
                        "MaxNominations",
                        [
                            98u8,
                            252u8,
                            116u8,
                            72u8,
                            26u8,
                            180u8,
                            225u8,
                            83u8,
                            200u8,
                            157u8,
                            125u8,
                            151u8,
                            53u8,
                            76u8,
                            168u8,
                            26u8,
                            10u8,
                            9u8,
                            98u8,
                            68u8,
                            9u8,
                            178u8,
                            197u8,
                            113u8,
                            31u8,
                            79u8,
                            200u8,
                            90u8,
                            203u8,
                            100u8,
                            41u8,
                            145u8,
                        ],
                    )
                }
                /// Number of eras to keep in history.
                ///
                /// Following information is kept for eras in `[current_era -
                /// HistoryDepth, current_era]`: `ErasStakers`, `ErasStakersClipped`,
                /// `ErasValidatorPrefs`, `ErasValidatorReward`, `ErasRewardPoints`,
                /// `ErasTotalStake`, `ErasStartSessionIndex`,
                /// `StakingLedger.claimed_rewards`.
                ///
                /// Must be more than the number of eras delayed by session.
                /// I.e. active era must always be in history. I.e. `active_era >
                /// current_era - history_depth` must be guaranteed.
                ///
                /// If migrating an existing pallet from storage value to config value,
                /// this should be set to same value or greater as in storage.
                ///
                /// Note: `HistoryDepth` is used as the upper bound for the `BoundedVec`
                /// item `StakingLedger.claimed_rewards`. Setting this value lower than
                /// the existing value can lead to inconsistencies in the
                /// `StakingLedger` and will need to be handled properly in a migration.
                /// The test `reducing_history_depth_abrupt` shows this effect.
                pub fn history_depth(
                    &self,
                ) -> ::subxt::constants::Address<::core::primitive::u32> {
                    ::subxt::constants::Address::new_static(
                        "Staking",
                        "HistoryDepth",
                        [
                            98u8,
                            252u8,
                            116u8,
                            72u8,
                            26u8,
                            180u8,
                            225u8,
                            83u8,
                            200u8,
                            157u8,
                            125u8,
                            151u8,
                            53u8,
                            76u8,
                            168u8,
                            26u8,
                            10u8,
                            9u8,
                            98u8,
                            68u8,
                            9u8,
                            178u8,
                            197u8,
                            113u8,
                            31u8,
                            79u8,
                            200u8,
                            90u8,
                            203u8,
                            100u8,
                            41u8,
                            145u8,
                        ],
                    )
                }
                /// Number of sessions per era.
                pub fn sessions_per_era(
                    &self,
                ) -> ::subxt::constants::Address<::core::primitive::u32> {
                    ::subxt::constants::Address::new_static(
                        "Staking",
                        "SessionsPerEra",
                        [
                            98u8,
                            252u8,
                            116u8,
                            72u8,
                            26u8,
                            180u8,
                            225u8,
                            83u8,
                            200u8,
                            157u8,
                            125u8,
                            151u8,
                            53u8,
                            76u8,
                            168u8,
                            26u8,
                            10u8,
                            9u8,
                            98u8,
                            68u8,
                            9u8,
                            178u8,
                            197u8,
                            113u8,
                            31u8,
                            79u8,
                            200u8,
                            90u8,
                            203u8,
                            100u8,
                            41u8,
                            145u8,
                        ],
                    )
                }
                /// Number of eras that staked funds must remain bonded for.
                pub fn bonding_duration(
                    &self,
                ) -> ::subxt::constants::Address<::core::primitive::u32> {
                    ::subxt::constants::Address::new_static(
                        "Staking",
                        "BondingDuration",
                        [
                            98u8,
                            252u8,
                            116u8,
                            72u8,
                            26u8,
                            180u8,
                            225u8,
                            83u8,
                            200u8,
                            157u8,
                            125u8,
                            151u8,
                            53u8,
                            76u8,
                            168u8,
                            26u8,
                            10u8,
                            9u8,
                            98u8,
                            68u8,
                            9u8,
                            178u8,
                            197u8,
                            113u8,
                            31u8,
                            79u8,
                            200u8,
                            90u8,
                            203u8,
                            100u8,
                            41u8,
                            145u8,
                        ],
                    )
                }
                /// Number of eras that slashes are deferred by, after computation.
                ///
                /// This should be less than the bonding duration. Set to 0 if slashes
                /// should be applied immediately, without opportunity for intervention.
                pub fn slash_defer_duration(
                    &self,
                ) -> ::subxt::constants::Address<::core::primitive::u32> {
                    ::subxt::constants::Address::new_static(
                        "Staking",
                        "SlashDeferDuration",
                        [
                            98u8,
                            252u8,
                            116u8,
                            72u8,
                            26u8,
                            180u8,
                            225u8,
                            83u8,
                            200u8,
                            157u8,
                            125u8,
                            151u8,
                            53u8,
                            76u8,
                            168u8,
                            26u8,
                            10u8,
                            9u8,
                            98u8,
                            68u8,
                            9u8,
                            178u8,
                            197u8,
                            113u8,
                            31u8,
                            79u8,
                            200u8,
                            90u8,
                            203u8,
                            100u8,
                            41u8,
                            145u8,
                        ],
                    )
                }
                /// The maximum number of nominators rewarded for each validator.
                ///
                /// For each validator only the `$MaxNominatorRewardedPerValidator` biggest stakers can
                /// claim their reward. This used to limit the i/o cost for the nominator payout.
                pub fn max_nominator_rewarded_per_validator(
                    &self,
                ) -> ::subxt::constants::Address<::core::primitive::u32> {
                    ::subxt::constants::Address::new_static(
                        "Staking",
                        "MaxNominatorRewardedPerValidator",
                        [
                            98u8,
                            252u8,
                            116u8,
                            72u8,
                            26u8,
                            180u8,
                            225u8,
                            83u8,
                            200u8,
                            157u8,
                            125u8,
                            151u8,
                            53u8,
                            76u8,
                            168u8,
                            26u8,
                            10u8,
                            9u8,
                            98u8,
                            68u8,
                            9u8,
                            178u8,
                            197u8,
                            113u8,
                            31u8,
                            79u8,
                            200u8,
                            90u8,
                            203u8,
                            100u8,
                            41u8,
                            145u8,
                        ],
                    )
                }
                /// The maximum number of `unlocking` chunks a [`StakingLedger`] can
                /// have. Effectively determines how many unique eras a staker may be
                /// unbonding in.
                ///
                /// Note: `MaxUnlockingChunks` is used as the upper bound for the
                /// `BoundedVec` item `StakingLedger.unlocking`. Setting this value
                /// lower than the existing value can lead to inconsistencies in the
                /// `StakingLedger` and will need to be handled properly in a runtime
                /// migration. The test `reducing_max_unlocking_chunks_abrupt` shows
                /// this effect.
                pub fn max_unlocking_chunks(
                    &self,
                ) -> ::subxt::constants::Address<::core::primitive::u32> {
                    ::subxt::constants::Address::new_static(
                        "Staking",
                        "MaxUnlockingChunks",
                        [
                            98u8,
                            252u8,
                            116u8,
                            72u8,
                            26u8,
                            180u8,
                            225u8,
                            83u8,
                            200u8,
                            157u8,
                            125u8,
                            151u8,
                            53u8,
                            76u8,
                            168u8,
                            26u8,
                            10u8,
                            9u8,
                            98u8,
                            68u8,
                            9u8,
                            178u8,
                            197u8,
                            113u8,
                            31u8,
                            79u8,
                            200u8,
                            90u8,
                            203u8,
                            100u8,
                            41u8,
                            145u8,
                        ],
                    )
                }
            }
        }
    }
    pub mod session {
        use super::root_mod;
        use super::runtime_types;
        ///Error for the session pallet.
        pub type Error = runtime_types::pallet_session::pallet::Error;
        ///Contains one variant per dispatchable that can be called by an extrinsic.
        pub type Call = runtime_types::pallet_session::pallet::Call;
        pub mod calls {
            use super::root_mod;
            use super::runtime_types;
            type DispatchError = runtime_types::sp_runtime::DispatchError;
            pub mod types {
                use super::runtime_types;
                #[derive(
                    ::subxt::ext::codec::Decode,
                    ::subxt::ext::codec::Encode,
                    ::subxt::ext::scale_decode::DecodeAsType,
                    ::subxt::ext::scale_encode::EncodeAsType,
                    Clone,
                    Debug,
                    Eq,
                    PartialEq
                )]
                #[codec(crate = ::subxt::ext::codec)]
                #[decode_as_type(crate_path = ":: subxt :: ext :: scale_decode")]
                #[encode_as_type(crate_path = ":: subxt :: ext :: scale_encode")]
                pub struct SetKeys {
                    pub keys: runtime_types::tangle_standalone_runtime::opaque::SessionKeys,
                    pub proof: ::std::vec::Vec<::core::primitive::u8>,
                }
                impl ::subxt::blocks::StaticExtrinsic for SetKeys {
                    const PALLET: &'static str = "Session";
                    const CALL: &'static str = "set_keys";
                }
                #[derive(
                    ::subxt::ext::codec::Decode,
                    ::subxt::ext::codec::Encode,
                    ::subxt::ext::scale_decode::DecodeAsType,
                    ::subxt::ext::scale_encode::EncodeAsType,
                    Clone,
                    Debug,
                    Eq,
                    PartialEq
                )]
                #[codec(crate = ::subxt::ext::codec)]
                #[decode_as_type(crate_path = ":: subxt :: ext :: scale_decode")]
                #[encode_as_type(crate_path = ":: subxt :: ext :: scale_encode")]
                pub struct PurgeKeys;
                impl ::subxt::blocks::StaticExtrinsic for PurgeKeys {
                    const PALLET: &'static str = "Session";
                    const CALL: &'static str = "purge_keys";
                }
            }
            pub struct TransactionApi;
            impl TransactionApi {
                ///Sets the session key(s) of the function caller to `keys`.
                ///Allows an account to set its session key prior to becoming a validator.
                ///This doesn't take effect until the next session.
                ///
                ///The dispatch origin of this function must be signed.
                ///
                ///## Complexity
                ///- `O(1)`. Actual cost depends on the number of length of `T::Keys::key_ids()` which is
                ///  fixed.
                pub fn set_keys(
                    &self,
                    keys: runtime_types::tangle_standalone_runtime::opaque::SessionKeys,
                    proof: ::std::vec::Vec<::core::primitive::u8>,
                ) -> ::subxt::tx::Payload<types::SetKeys> {
                    ::subxt::tx::Payload::new_static(
                        "Session",
                        "set_keys",
                        types::SetKeys { keys, proof },
                        [
                            214u8,
                            207u8,
                            253u8,
                            96u8,
                            151u8,
                            234u8,
                            185u8,
                            82u8,
                            81u8,
                            73u8,
                            213u8,
                            88u8,
                            120u8,
                            64u8,
                            117u8,
                            212u8,
                            150u8,
                            220u8,
                            53u8,
                            22u8,
                            41u8,
                            194u8,
                            58u8,
                            61u8,
                            171u8,
                            3u8,
                            236u8,
                            208u8,
                            251u8,
                            119u8,
                            97u8,
                            187u8,
                        ],
                    )
                }
                ///Removes any session key(s) of the function caller.
                ///
                ///This doesn't take effect until the next session.
                ///
                ///The dispatch origin of this function must be Signed and the account must be either be
                ///convertible to a validator ID using the chain's typical addressing system (this usually
                ///means being a controller account) or directly convertible into a validator ID (which
                ///usually means being a stash account).
                ///
                ///## Complexity
                ///- `O(1)` in number of key types. Actual cost depends on the number of length of
                ///  `T::Keys::key_ids()` which is fixed.
                pub fn purge_keys(&self) -> ::subxt::tx::Payload<types::PurgeKeys> {
                    ::subxt::tx::Payload::new_static(
                        "Session",
                        "purge_keys",
                        types::PurgeKeys {},
                        [
                            215u8,
                            204u8,
                            146u8,
                            236u8,
                            32u8,
                            78u8,
                            198u8,
                            79u8,
                            85u8,
                            214u8,
                            15u8,
                            151u8,
                            158u8,
                            31u8,
                            146u8,
                            119u8,
                            119u8,
                            204u8,
                            151u8,
                            169u8,
                            226u8,
                            67u8,
                            217u8,
                            39u8,
                            241u8,
                            245u8,
                            203u8,
                            240u8,
                            203u8,
                            172u8,
                            16u8,
                            209u8,
                        ],
                    )
                }
            }
        }
        /**
			The [event](https://docs.substrate.io/main-docs/build/events-errors/) emitted
			by this pallet.
			*/
        pub type Event = runtime_types::pallet_session::pallet::Event;
        pub mod events {
            use super::runtime_types;
            #[derive(
                ::subxt::ext::codec::CompactAs,
                ::subxt::ext::codec::Decode,
                ::subxt::ext::codec::Encode,
                ::subxt::ext::scale_decode::DecodeAsType,
                ::subxt::ext::scale_encode::EncodeAsType,
                Clone,
                Debug,
                Eq,
                PartialEq
            )]
            #[codec(crate = ::subxt::ext::codec)]
            #[decode_as_type(crate_path = ":: subxt :: ext :: scale_decode")]
            #[encode_as_type(crate_path = ":: subxt :: ext :: scale_encode")]
            ///New session has happened. Note that the argument is the session index, not the
            ///block number as the type might suggest.
            pub struct NewSession {
                pub session_index: ::core::primitive::u32,
            }
            impl ::subxt::events::StaticEvent for NewSession {
                const PALLET: &'static str = "Session";
                const EVENT: &'static str = "NewSession";
            }
        }
        pub mod storage {
            use super::runtime_types;
            pub struct StorageApi;
            impl StorageApi {
                /// The current set of validators.
                pub fn validators(
                    &self,
                ) -> ::subxt::storage::address::Address<
                    ::subxt::storage::address::StaticStorageMapKey,
                    ::std::vec::Vec<::subxt::utils::AccountId32>,
                    ::subxt::storage::address::Yes,
                    ::subxt::storage::address::Yes,
                    (),
                > {
                    ::subxt::storage::address::Address::new_static(
                        "Session",
                        "Validators",
                        vec![],
                        [
                            50u8,
                            86u8,
                            154u8,
                            222u8,
                            249u8,
                            209u8,
                            156u8,
                            22u8,
                            155u8,
                            25u8,
                            133u8,
                            194u8,
                            210u8,
                            50u8,
                            38u8,
                            28u8,
                            139u8,
                            201u8,
                            90u8,
                            139u8,
                            115u8,
                            12u8,
                            12u8,
                            141u8,
                            4u8,
                            178u8,
                            201u8,
                            241u8,
                            223u8,
                            234u8,
                            6u8,
                            86u8,
                        ],
                    )
                }
                /// Current index of the session.
                pub fn current_index(
                    &self,
                ) -> ::subxt::storage::address::Address<
                    ::subxt::storage::address::StaticStorageMapKey,
                    ::core::primitive::u32,
                    ::subxt::storage::address::Yes,
                    ::subxt::storage::address::Yes,
                    (),
                > {
                    ::subxt::storage::address::Address::new_static(
                        "Session",
                        "CurrentIndex",
                        vec![],
                        [
                            167u8,
                            151u8,
                            125u8,
                            150u8,
                            159u8,
                            21u8,
                            78u8,
                            217u8,
                            237u8,
                            183u8,
                            135u8,
                            65u8,
                            187u8,
                            114u8,
                            188u8,
                            206u8,
                            16u8,
                            32u8,
                            69u8,
                            208u8,
                            134u8,
                            159u8,
                            232u8,
                            224u8,
                            243u8,
                            27u8,
                            31u8,
                            166u8,
                            145u8,
                            44u8,
                            221u8,
                            230u8,
                        ],
                    )
                }
                /// True if the underlying economic identities or weighting behind the validators
                /// has changed in the queued validator set.
                pub fn queued_changed(
                    &self,
                ) -> ::subxt::storage::address::Address<
                    ::subxt::storage::address::StaticStorageMapKey,
                    ::core::primitive::bool,
                    ::subxt::storage::address::Yes,
                    ::subxt::storage::address::Yes,
                    (),
                > {
                    ::subxt::storage::address::Address::new_static(
                        "Session",
                        "QueuedChanged",
                        vec![],
                        [
                            184u8,
                            137u8,
                            224u8,
                            137u8,
                            31u8,
                            236u8,
                            95u8,
                            164u8,
                            102u8,
                            225u8,
                            198u8,
                            227u8,
                            140u8,
                            37u8,
                            113u8,
                            57u8,
                            59u8,
                            4u8,
                            202u8,
                            102u8,
                            117u8,
                            36u8,
                            226u8,
                            64u8,
                            113u8,
                            141u8,
                            199u8,
                            111u8,
                            99u8,
                            144u8,
                            198u8,
                            153u8,
                        ],
                    )
                }
                /// The queued keys for the next session. When the next session begins, these keys
                /// will be used to determine the validator's session keys.
                pub fn queued_keys(
                    &self,
                ) -> ::subxt::storage::address::Address<
                    ::subxt::storage::address::StaticStorageMapKey,
                    ::std::vec::Vec<
                        (
                            ::subxt::utils::AccountId32,
                            runtime_types::tangle_standalone_runtime::opaque::SessionKeys,
                        ),
                    >,
                    ::subxt::storage::address::Yes,
                    ::subxt::storage::address::Yes,
                    (),
                > {
                    ::subxt::storage::address::Address::new_static(
                        "Session",
                        "QueuedKeys",
                        vec![],
                        [
                            175u8,
                            29u8,
                            30u8,
                            102u8,
                            134u8,
                            46u8,
                            97u8,
                            170u8,
                            82u8,
                            141u8,
                            214u8,
                            92u8,
                            212u8,
                            0u8,
                            124u8,
                            155u8,
                            79u8,
                            59u8,
                            211u8,
                            156u8,
                            14u8,
                            69u8,
                            66u8,
                            134u8,
                            61u8,
                            33u8,
                            72u8,
                            190u8,
                            200u8,
                            150u8,
                            172u8,
                            78u8,
                        ],
                    )
                }
                /// Indices of disabled validators.
                ///
                /// The vec is always kept sorted so that we can find whether a given validator is
                /// disabled using binary search. It gets cleared when `on_session_ending` returns
                /// a new set of identities.
                pub fn disabled_validators(
                    &self,
                ) -> ::subxt::storage::address::Address<
                    ::subxt::storage::address::StaticStorageMapKey,
                    ::std::vec::Vec<::core::primitive::u32>,
                    ::subxt::storage::address::Yes,
                    ::subxt::storage::address::Yes,
                    (),
                > {
                    ::subxt::storage::address::Address::new_static(
                        "Session",
                        "DisabledValidators",
                        vec![],
                        [
                            213u8,
                            19u8,
                            168u8,
                            234u8,
                            187u8,
                            200u8,
                            180u8,
                            97u8,
                            234u8,
                            189u8,
                            36u8,
                            233u8,
                            158u8,
                            184u8,
                            45u8,
                            35u8,
                            129u8,
                            213u8,
                            133u8,
                            8u8,
                            104u8,
                            183u8,
                            46u8,
                            68u8,
                            154u8,
                            240u8,
                            132u8,
                            22u8,
                            247u8,
                            11u8,
                            54u8,
                            221u8,
                        ],
                    )
                }
                /// The next session keys for a validator.
                pub fn next_keys(
                    &self,
                    _0: impl ::std::borrow::Borrow<::subxt::utils::AccountId32>,
                ) -> ::subxt::storage::address::Address<
                    ::subxt::storage::address::StaticStorageMapKey,
                    runtime_types::tangle_standalone_runtime::opaque::SessionKeys,
                    ::subxt::storage::address::Yes,
                    (),
                    ::subxt::storage::address::Yes,
                > {
                    ::subxt::storage::address::Address::new_static(
                        "Session",
                        "NextKeys",
                        vec![
                            ::subxt::storage::address::make_static_storage_map_key(_0
                            .borrow())
                        ],
                        [
                            164u8,
                            152u8,
                            177u8,
                            44u8,
                            182u8,
                            181u8,
                            247u8,
                            115u8,
                            9u8,
                            48u8,
                            213u8,
                            171u8,
                            122u8,
                            113u8,
                            21u8,
                            186u8,
                            183u8,
                            225u8,
                            209u8,
                            221u8,
                            233u8,
                            65u8,
                            107u8,
                            64u8,
                            101u8,
                            179u8,
                            30u8,
                            119u8,
                            165u8,
                            54u8,
                            214u8,
                            196u8,
                        ],
                    )
                }
                /// The next session keys for a validator.
                pub fn next_keys_root(
                    &self,
                ) -> ::subxt::storage::address::Address<
                    ::subxt::storage::address::StaticStorageMapKey,
                    runtime_types::tangle_standalone_runtime::opaque::SessionKeys,
                    (),
                    (),
                    ::subxt::storage::address::Yes,
                > {
                    ::subxt::storage::address::Address::new_static(
                        "Session",
                        "NextKeys",
                        Vec::new(),
                        [
                            164u8,
                            152u8,
                            177u8,
                            44u8,
                            182u8,
                            181u8,
                            247u8,
                            115u8,
                            9u8,
                            48u8,
                            213u8,
                            171u8,
                            122u8,
                            113u8,
                            21u8,
                            186u8,
                            183u8,
                            225u8,
                            209u8,
                            221u8,
                            233u8,
                            65u8,
                            107u8,
                            64u8,
                            101u8,
                            179u8,
                            30u8,
                            119u8,
                            165u8,
                            54u8,
                            214u8,
                            196u8,
                        ],
                    )
                }
                /// The owner of a key. The key is the `KeyTypeId` + the encoded key.
                pub fn key_owner(
                    &self,
                    _0: impl ::std::borrow::Borrow<
                        runtime_types::sp_core::crypto::KeyTypeId,
                    >,
                    _1: impl ::std::borrow::Borrow<[::core::primitive::u8]>,
                ) -> ::subxt::storage::address::Address<
                    ::subxt::storage::address::StaticStorageMapKey,
                    ::subxt::utils::AccountId32,
                    ::subxt::storage::address::Yes,
                    (),
                    ::subxt::storage::address::Yes,
                > {
                    ::subxt::storage::address::Address::new_static(
                        "Session",
                        "KeyOwner",
                        vec![
                            ::subxt::storage::address::make_static_storage_map_key(_0
                            .borrow()),
                            ::subxt::storage::address::make_static_storage_map_key(_1
                            .borrow())
                        ],
                        [
                            177u8,
                            90u8,
                            148u8,
                            24u8,
                            251u8,
                            26u8,
                            65u8,
                            235u8,
                            46u8,
                            25u8,
                            109u8,
                            212u8,
                            208u8,
                            218u8,
                            58u8,
                            196u8,
                            29u8,
                            73u8,
                            145u8,
                            41u8,
                            30u8,
                            251u8,
                            185u8,
                            26u8,
                            205u8,
                            50u8,
                            32u8,
                            200u8,
                            206u8,
                            178u8,
                            255u8,
                            146u8,
                        ],
                    )
                }
                /// The owner of a key. The key is the `KeyTypeId` + the encoded key.
                pub fn key_owner_root(
                    &self,
                ) -> ::subxt::storage::address::Address<
                    ::subxt::storage::address::StaticStorageMapKey,
                    ::subxt::utils::AccountId32,
                    (),
                    (),
                    ::subxt::storage::address::Yes,
                > {
                    ::subxt::storage::address::Address::new_static(
                        "Session",
                        "KeyOwner",
                        Vec::new(),
                        [
                            177u8,
                            90u8,
                            148u8,
                            24u8,
                            251u8,
                            26u8,
                            65u8,
                            235u8,
                            46u8,
                            25u8,
                            109u8,
                            212u8,
                            208u8,
                            218u8,
                            58u8,
                            196u8,
                            29u8,
                            73u8,
                            145u8,
                            41u8,
                            30u8,
                            251u8,
                            185u8,
                            26u8,
                            205u8,
                            50u8,
                            32u8,
                            200u8,
                            206u8,
                            178u8,
                            255u8,
                            146u8,
                        ],
                    )
                }
            }
        }
    }
    pub mod historical {
        use super::root_mod;
        use super::runtime_types;
        pub mod storage {
            use super::runtime_types;
            pub struct StorageApi;
            impl StorageApi {
                /// Mapping from historical session indices to session-data root hash and validator count.
                pub fn historical_sessions(
                    &self,
                    _0: impl ::std::borrow::Borrow<::core::primitive::u32>,
                ) -> ::subxt::storage::address::Address<
                    ::subxt::storage::address::StaticStorageMapKey,
                    (::subxt::utils::H256, ::core::primitive::u32),
                    ::subxt::storage::address::Yes,
                    (),
                    ::subxt::storage::address::Yes,
                > {
                    ::subxt::storage::address::Address::new_static(
                        "Historical",
                        "HistoricalSessions",
                        vec![
                            ::subxt::storage::address::make_static_storage_map_key(_0
                            .borrow())
                        ],
                        [
                            219u8,
                            105u8,
                            245u8,
                            54u8,
                            143u8,
                            81u8,
                            56u8,
                            104u8,
                            60u8,
                            207u8,
                            165u8,
                            92u8,
                            123u8,
                            2u8,
                            64u8,
                            117u8,
                            154u8,
                            135u8,
                            252u8,
                            234u8,
                            129u8,
                            159u8,
                            77u8,
                            38u8,
                            238u8,
                            220u8,
                            9u8,
                            88u8,
                            70u8,
                            200u8,
                            132u8,
                            152u8,
                        ],
                    )
                }
                /// Mapping from historical session indices to session-data root hash and validator count.
                pub fn historical_sessions_root(
                    &self,
                ) -> ::subxt::storage::address::Address<
                    ::subxt::storage::address::StaticStorageMapKey,
                    (::subxt::utils::H256, ::core::primitive::u32),
                    (),
                    (),
                    ::subxt::storage::address::Yes,
                > {
                    ::subxt::storage::address::Address::new_static(
                        "Historical",
                        "HistoricalSessions",
                        Vec::new(),
                        [
                            219u8,
                            105u8,
                            245u8,
                            54u8,
                            143u8,
                            81u8,
                            56u8,
                            104u8,
                            60u8,
                            207u8,
                            165u8,
                            92u8,
                            123u8,
                            2u8,
                            64u8,
                            117u8,
                            154u8,
                            135u8,
                            252u8,
                            234u8,
                            129u8,
                            159u8,
                            77u8,
                            38u8,
                            238u8,
                            220u8,
                            9u8,
                            88u8,
                            70u8,
                            200u8,
                            132u8,
                            152u8,
                        ],
                    )
                }
                /// The range of historical sessions we store. [first, last)
                pub fn stored_range(
                    &self,
                ) -> ::subxt::storage::address::Address<
                    ::subxt::storage::address::StaticStorageMapKey,
                    (::core::primitive::u32, ::core::primitive::u32),
                    ::subxt::storage::address::Yes,
                    (),
                    (),
                > {
                    ::subxt::storage::address::Address::new_static(
                        "Historical",
                        "StoredRange",
                        vec![],
                        [
                            165u8,
                            141u8,
                            148u8,
                            255u8,
                            90u8,
                            168u8,
                            77u8,
                            150u8,
                            198u8,
                            127u8,
                            227u8,
                            146u8,
                            107u8,
                            141u8,
                            43u8,
                            50u8,
                            190u8,
                            186u8,
                            45u8,
                            232u8,
                            46u8,
                            95u8,
                            64u8,
                            155u8,
                            57u8,
                            82u8,
                            45u8,
                            255u8,
                            91u8,
                            109u8,
                            244u8,
                            216u8,
                        ],
                    )
                }
            }
        }
    }
    pub mod treasury {
        use super::root_mod;
        use super::runtime_types;
        ///Error for the treasury pallet.
        pub type Error = runtime_types::pallet_treasury::pallet::Error;
        ///Contains one variant per dispatchable that can be called by an extrinsic.
        pub type Call = runtime_types::pallet_treasury::pallet::Call;
        pub mod calls {
            use super::root_mod;
            use super::runtime_types;
            type DispatchError = runtime_types::sp_runtime::DispatchError;
            pub mod types {
                use super::runtime_types;
                #[derive(
                    ::subxt::ext::codec::Decode,
                    ::subxt::ext::codec::Encode,
                    ::subxt::ext::scale_decode::DecodeAsType,
                    ::subxt::ext::scale_encode::EncodeAsType,
                    Clone,
                    Debug,
                    Eq,
                    PartialEq
                )]
                #[codec(crate = ::subxt::ext::codec)]
                #[decode_as_type(crate_path = ":: subxt :: ext :: scale_decode")]
                #[encode_as_type(crate_path = ":: subxt :: ext :: scale_encode")]
                pub struct ProposeSpend {
                    #[codec(compact)]
                    pub value: ::core::primitive::u128,
                    pub beneficiary: ::subxt::utils::MultiAddress<
                        ::subxt::utils::AccountId32,
                        ::core::primitive::u32,
                    >,
                }
                impl ::subxt::blocks::StaticExtrinsic for ProposeSpend {
                    const PALLET: &'static str = "Treasury";
                    const CALL: &'static str = "propose_spend";
                }
                #[derive(
                    ::subxt::ext::codec::Decode,
                    ::subxt::ext::codec::Encode,
                    ::subxt::ext::scale_decode::DecodeAsType,
                    ::subxt::ext::scale_encode::EncodeAsType,
                    Clone,
                    Debug,
                    Eq,
                    PartialEq
                )]
                #[codec(crate = ::subxt::ext::codec)]
                #[decode_as_type(crate_path = ":: subxt :: ext :: scale_decode")]
                #[encode_as_type(crate_path = ":: subxt :: ext :: scale_encode")]
                pub struct RejectProposal {
                    #[codec(compact)]
                    pub proposal_id: ::core::primitive::u32,
                }
                impl ::subxt::blocks::StaticExtrinsic for RejectProposal {
                    const PALLET: &'static str = "Treasury";
                    const CALL: &'static str = "reject_proposal";
                }
                #[derive(
                    ::subxt::ext::codec::Decode,
                    ::subxt::ext::codec::Encode,
                    ::subxt::ext::scale_decode::DecodeAsType,
                    ::subxt::ext::scale_encode::EncodeAsType,
                    Clone,
                    Debug,
                    Eq,
                    PartialEq
                )]
                #[codec(crate = ::subxt::ext::codec)]
                #[decode_as_type(crate_path = ":: subxt :: ext :: scale_decode")]
                #[encode_as_type(crate_path = ":: subxt :: ext :: scale_encode")]
                pub struct ApproveProposal {
                    #[codec(compact)]
                    pub proposal_id: ::core::primitive::u32,
                }
                impl ::subxt::blocks::StaticExtrinsic for ApproveProposal {
                    const PALLET: &'static str = "Treasury";
                    const CALL: &'static str = "approve_proposal";
                }
                #[derive(
                    ::subxt::ext::codec::Decode,
                    ::subxt::ext::codec::Encode,
                    ::subxt::ext::scale_decode::DecodeAsType,
                    ::subxt::ext::scale_encode::EncodeAsType,
                    Clone,
                    Debug,
                    Eq,
                    PartialEq
                )]
                #[codec(crate = ::subxt::ext::codec)]
                #[decode_as_type(crate_path = ":: subxt :: ext :: scale_decode")]
                #[encode_as_type(crate_path = ":: subxt :: ext :: scale_encode")]
                pub struct Spend {
                    #[codec(compact)]
                    pub amount: ::core::primitive::u128,
                    pub beneficiary: ::subxt::utils::MultiAddress<
                        ::subxt::utils::AccountId32,
                        ::core::primitive::u32,
                    >,
                }
                impl ::subxt::blocks::StaticExtrinsic for Spend {
                    const PALLET: &'static str = "Treasury";
                    const CALL: &'static str = "spend";
                }
                #[derive(
                    ::subxt::ext::codec::Decode,
                    ::subxt::ext::codec::Encode,
                    ::subxt::ext::scale_decode::DecodeAsType,
                    ::subxt::ext::scale_encode::EncodeAsType,
                    Clone,
                    Debug,
                    Eq,
                    PartialEq
                )]
                #[codec(crate = ::subxt::ext::codec)]
                #[decode_as_type(crate_path = ":: subxt :: ext :: scale_decode")]
                #[encode_as_type(crate_path = ":: subxt :: ext :: scale_encode")]
                pub struct RemoveApproval {
                    #[codec(compact)]
                    pub proposal_id: ::core::primitive::u32,
                }
                impl ::subxt::blocks::StaticExtrinsic for RemoveApproval {
                    const PALLET: &'static str = "Treasury";
                    const CALL: &'static str = "remove_approval";
                }
            }
            pub struct TransactionApi;
            impl TransactionApi {
                ///Put forward a suggestion for spending. A deposit proportional to the value
                ///is reserved and slashed if the proposal is rejected. It is returned once the
                ///proposal is awarded.
                ///
                ///## Complexity
                ///- O(1)
                pub fn propose_spend(
                    &self,
                    value: ::core::primitive::u128,
                    beneficiary: ::subxt::utils::MultiAddress<
                        ::subxt::utils::AccountId32,
                        ::core::primitive::u32,
                    >,
                ) -> ::subxt::tx::Payload<types::ProposeSpend> {
                    ::subxt::tx::Payload::new_static(
                        "Treasury",
                        "propose_spend",
                        types::ProposeSpend {
                            value,
                            beneficiary,
                        },
                        [
                            122u8,
                            208u8,
                            182u8,
                            218u8,
                            237u8,
                            127u8,
                            67u8,
                            90u8,
                            119u8,
                            187u8,
                            190u8,
                            131u8,
                            226u8,
                            30u8,
                            123u8,
                            176u8,
                            71u8,
                            150u8,
                            85u8,
                            170u8,
                            123u8,
                            65u8,
                            91u8,
                            229u8,
                            75u8,
                            53u8,
                            144u8,
                            105u8,
                            1u8,
                            167u8,
                            232u8,
                            156u8,
                        ],
                    )
                }
                ///Reject a proposed spend. The original deposit will be slashed.
                ///
                ///May only be called from `T::RejectOrigin`.
                ///
                ///## Complexity
                ///- O(1)
                pub fn reject_proposal(
                    &self,
                    proposal_id: ::core::primitive::u32,
                ) -> ::subxt::tx::Payload<types::RejectProposal> {
                    ::subxt::tx::Payload::new_static(
                        "Treasury",
                        "reject_proposal",
                        types::RejectProposal {
                            proposal_id,
                        },
                        [
                            18u8,
                            166u8,
                            80u8,
                            141u8,
                            222u8,
                            230u8,
                            4u8,
                            36u8,
                            7u8,
                            76u8,
                            12u8,
                            40u8,
                            145u8,
                            114u8,
                            12u8,
                            43u8,
                            223u8,
                            78u8,
                            189u8,
                            222u8,
                            120u8,
                            80u8,
                            225u8,
                            215u8,
                            119u8,
                            68u8,
                            200u8,
                            15u8,
                            25u8,
                            172u8,
                            192u8,
                            173u8,
                        ],
                    )
                }
                ///Approve a proposal. At a later time, the proposal will be allocated to the beneficiary
                ///and the original deposit will be returned.
                ///
                ///May only be called from `T::ApproveOrigin`.
                ///
                ///## Complexity
                /// - O(1).
                pub fn approve_proposal(
                    &self,
                    proposal_id: ::core::primitive::u32,
                ) -> ::subxt::tx::Payload<types::ApproveProposal> {
                    ::subxt::tx::Payload::new_static(
                        "Treasury",
                        "approve_proposal",
                        types::ApproveProposal {
                            proposal_id,
                        },
                        [
                            154u8,
                            176u8,
                            152u8,
                            97u8,
                            167u8,
                            177u8,
                            78u8,
                            9u8,
                            235u8,
                            229u8,
                            199u8,
                            193u8,
                            214u8,
                            3u8,
                            16u8,
                            30u8,
                            4u8,
                            104u8,
                            27u8,
                            184u8,
                            100u8,
                            65u8,
                            179u8,
                            13u8,
                            91u8,
                            62u8,
                            115u8,
                            5u8,
                            219u8,
                            211u8,
                            251u8,
                            153u8,
                        ],
                    )
                }
                ///Propose and approve a spend of treasury funds.
                ///
                ///- `origin`: Must be `SpendOrigin` with the `Success` value being at least `amount`.
                ///- `amount`: The amount to be transferred from the treasury to the `beneficiary`.
                ///- `beneficiary`: The destination account for the transfer.
                ///
                ///NOTE: For record-keeping purposes, the proposer is deemed to be equivalent to the
                ///beneficiary.
                pub fn spend(
                    &self,
                    amount: ::core::primitive::u128,
                    beneficiary: ::subxt::utils::MultiAddress<
                        ::subxt::utils::AccountId32,
                        ::core::primitive::u32,
                    >,
                ) -> ::subxt::tx::Payload<types::Spend> {
                    ::subxt::tx::Payload::new_static(
                        "Treasury",
                        "spend",
                        types::Spend {
                            amount,
                            beneficiary,
                        },
                        [
                            84u8,
                            118u8,
                            232u8,
                            82u8,
                            17u8,
                            184u8,
                            100u8,
                            78u8,
                            38u8,
                            158u8,
                            78u8,
                            200u8,
                            60u8,
                            9u8,
                            47u8,
                            72u8,
                            52u8,
                            70u8,
                            208u8,
                            208u8,
                            169u8,
                            217u8,
                            191u8,
                            76u8,
                            215u8,
                            202u8,
                            72u8,
                            95u8,
                            221u8,
                            78u8,
                            106u8,
                            71u8,
                        ],
                    )
                }
                ///Force a previously approved proposal to be removed from the approval queue.
                ///The original deposit will no longer be returned.
                ///
                ///May only be called from `T::RejectOrigin`.
                ///- `proposal_id`: The index of a proposal
                ///
                ///## Complexity
                ///- O(A) where `A` is the number of approvals
                ///
                ///Errors:
                ///- `ProposalNotApproved`: The `proposal_id` supplied was not found in the approval queue,
                ///i.e., the proposal has not been approved. This could also mean the proposal does not
                ///exist altogether, thus there is no way it would have been approved in the first place.
                pub fn remove_approval(
                    &self,
                    proposal_id: ::core::primitive::u32,
                ) -> ::subxt::tx::Payload<types::RemoveApproval> {
                    ::subxt::tx::Payload::new_static(
                        "Treasury",
                        "remove_approval",
                        types::RemoveApproval {
                            proposal_id,
                        },
                        [
                            180u8,
                            20u8,
                            39u8,
                            227u8,
                            29u8,
                            228u8,
                            234u8,
                            36u8,
                            155u8,
                            114u8,
                            197u8,
                            135u8,
                            185u8,
                            31u8,
                            56u8,
                            247u8,
                            224u8,
                            168u8,
                            254u8,
                            233u8,
                            250u8,
                            134u8,
                            186u8,
                            155u8,
                            108u8,
                            84u8,
                            94u8,
                            226u8,
                            207u8,
                            130u8,
                            196u8,
                            100u8,
                        ],
                    )
                }
            }
        }
        /**
			The [event](https://docs.substrate.io/main-docs/build/events-errors/) emitted
			by this pallet.
			*/
        pub type Event = runtime_types::pallet_treasury::pallet::Event;
        pub mod events {
            use super::runtime_types;
            #[derive(
                ::subxt::ext::codec::CompactAs,
                ::subxt::ext::codec::Decode,
                ::subxt::ext::codec::Encode,
                ::subxt::ext::scale_decode::DecodeAsType,
                ::subxt::ext::scale_encode::EncodeAsType,
                Clone,
                Debug,
                Eq,
                PartialEq
            )]
            #[codec(crate = ::subxt::ext::codec)]
            #[decode_as_type(crate_path = ":: subxt :: ext :: scale_decode")]
            #[encode_as_type(crate_path = ":: subxt :: ext :: scale_encode")]
            ///New proposal.
            pub struct Proposed {
                pub proposal_index: ::core::primitive::u32,
            }
            impl ::subxt::events::StaticEvent for Proposed {
                const PALLET: &'static str = "Treasury";
                const EVENT: &'static str = "Proposed";
            }
            #[derive(
                ::subxt::ext::codec::CompactAs,
                ::subxt::ext::codec::Decode,
                ::subxt::ext::codec::Encode,
                ::subxt::ext::scale_decode::DecodeAsType,
                ::subxt::ext::scale_encode::EncodeAsType,
                Clone,
                Debug,
                Eq,
                PartialEq
            )]
            #[codec(crate = ::subxt::ext::codec)]
            #[decode_as_type(crate_path = ":: subxt :: ext :: scale_decode")]
            #[encode_as_type(crate_path = ":: subxt :: ext :: scale_encode")]
            ///We have ended a spend period and will now allocate funds.
            pub struct Spending {
                pub budget_remaining: ::core::primitive::u128,
            }
            impl ::subxt::events::StaticEvent for Spending {
                const PALLET: &'static str = "Treasury";
                const EVENT: &'static str = "Spending";
            }
            #[derive(
                ::subxt::ext::codec::Decode,
                ::subxt::ext::codec::Encode,
                ::subxt::ext::scale_decode::DecodeAsType,
                ::subxt::ext::scale_encode::EncodeAsType,
                Clone,
                Debug,
                Eq,
                PartialEq
            )]
            #[codec(crate = ::subxt::ext::codec)]
            #[decode_as_type(crate_path = ":: subxt :: ext :: scale_decode")]
            #[encode_as_type(crate_path = ":: subxt :: ext :: scale_encode")]
            ///Some funds have been allocated.
            pub struct Awarded {
                pub proposal_index: ::core::primitive::u32,
                pub award: ::core::primitive::u128,
                pub account: ::subxt::utils::AccountId32,
            }
            impl ::subxt::events::StaticEvent for Awarded {
                const PALLET: &'static str = "Treasury";
                const EVENT: &'static str = "Awarded";
            }
            #[derive(
                ::subxt::ext::codec::Decode,
                ::subxt::ext::codec::Encode,
                ::subxt::ext::scale_decode::DecodeAsType,
                ::subxt::ext::scale_encode::EncodeAsType,
                Clone,
                Debug,
                Eq,
                PartialEq
            )]
            #[codec(crate = ::subxt::ext::codec)]
            #[decode_as_type(crate_path = ":: subxt :: ext :: scale_decode")]
            #[encode_as_type(crate_path = ":: subxt :: ext :: scale_encode")]
            ///A proposal was rejected; funds were slashed.
            pub struct Rejected {
                pub proposal_index: ::core::primitive::u32,
                pub slashed: ::core::primitive::u128,
            }
            impl ::subxt::events::StaticEvent for Rejected {
                const PALLET: &'static str = "Treasury";
                const EVENT: &'static str = "Rejected";
            }
            #[derive(
                ::subxt::ext::codec::CompactAs,
                ::subxt::ext::codec::Decode,
                ::subxt::ext::codec::Encode,
                ::subxt::ext::scale_decode::DecodeAsType,
                ::subxt::ext::scale_encode::EncodeAsType,
                Clone,
                Debug,
                Eq,
                PartialEq
            )]
            #[codec(crate = ::subxt::ext::codec)]
            #[decode_as_type(crate_path = ":: subxt :: ext :: scale_decode")]
            #[encode_as_type(crate_path = ":: subxt :: ext :: scale_encode")]
            ///Some of our funds have been burnt.
            pub struct Burnt {
                pub burnt_funds: ::core::primitive::u128,
            }
            impl ::subxt::events::StaticEvent for Burnt {
                const PALLET: &'static str = "Treasury";
                const EVENT: &'static str = "Burnt";
            }
            #[derive(
                ::subxt::ext::codec::CompactAs,
                ::subxt::ext::codec::Decode,
                ::subxt::ext::codec::Encode,
                ::subxt::ext::scale_decode::DecodeAsType,
                ::subxt::ext::scale_encode::EncodeAsType,
                Clone,
                Debug,
                Eq,
                PartialEq
            )]
            #[codec(crate = ::subxt::ext::codec)]
            #[decode_as_type(crate_path = ":: subxt :: ext :: scale_decode")]
            #[encode_as_type(crate_path = ":: subxt :: ext :: scale_encode")]
            ///Spending has finished; this is the amount that rolls over until next spend.
            pub struct Rollover {
                pub rollover_balance: ::core::primitive::u128,
            }
            impl ::subxt::events::StaticEvent for Rollover {
                const PALLET: &'static str = "Treasury";
                const EVENT: &'static str = "Rollover";
            }
            #[derive(
                ::subxt::ext::codec::CompactAs,
                ::subxt::ext::codec::Decode,
                ::subxt::ext::codec::Encode,
                ::subxt::ext::scale_decode::DecodeAsType,
                ::subxt::ext::scale_encode::EncodeAsType,
                Clone,
                Debug,
                Eq,
                PartialEq
            )]
            #[codec(crate = ::subxt::ext::codec)]
            #[decode_as_type(crate_path = ":: subxt :: ext :: scale_decode")]
            #[encode_as_type(crate_path = ":: subxt :: ext :: scale_encode")]
            ///Some funds have been deposited.
            pub struct Deposit {
                pub value: ::core::primitive::u128,
            }
            impl ::subxt::events::StaticEvent for Deposit {
                const PALLET: &'static str = "Treasury";
                const EVENT: &'static str = "Deposit";
            }
            #[derive(
                ::subxt::ext::codec::Decode,
                ::subxt::ext::codec::Encode,
                ::subxt::ext::scale_decode::DecodeAsType,
                ::subxt::ext::scale_encode::EncodeAsType,
                Clone,
                Debug,
                Eq,
                PartialEq
            )]
            #[codec(crate = ::subxt::ext::codec)]
            #[decode_as_type(crate_path = ":: subxt :: ext :: scale_decode")]
            #[encode_as_type(crate_path = ":: subxt :: ext :: scale_encode")]
            ///A new spend proposal has been approved.
            pub struct SpendApproved {
                pub proposal_index: ::core::primitive::u32,
                pub amount: ::core::primitive::u128,
                pub beneficiary: ::subxt::utils::AccountId32,
            }
            impl ::subxt::events::StaticEvent for SpendApproved {
                const PALLET: &'static str = "Treasury";
                const EVENT: &'static str = "SpendApproved";
            }
            #[derive(
                ::subxt::ext::codec::Decode,
                ::subxt::ext::codec::Encode,
                ::subxt::ext::scale_decode::DecodeAsType,
                ::subxt::ext::scale_encode::EncodeAsType,
                Clone,
                Debug,
                Eq,
                PartialEq
            )]
            #[codec(crate = ::subxt::ext::codec)]
            #[decode_as_type(crate_path = ":: subxt :: ext :: scale_decode")]
            #[encode_as_type(crate_path = ":: subxt :: ext :: scale_encode")]
            ///The inactive funds of the pallet have been updated.
            pub struct UpdatedInactive {
                pub reactivated: ::core::primitive::u128,
                pub deactivated: ::core::primitive::u128,
            }
            impl ::subxt::events::StaticEvent for UpdatedInactive {
                const PALLET: &'static str = "Treasury";
                const EVENT: &'static str = "UpdatedInactive";
            }
        }
        pub mod storage {
            use super::runtime_types;
            pub struct StorageApi;
            impl StorageApi {
                /// Number of proposals that have been made.
                pub fn proposal_count(
                    &self,
                ) -> ::subxt::storage::address::Address<
                    ::subxt::storage::address::StaticStorageMapKey,
                    ::core::primitive::u32,
                    ::subxt::storage::address::Yes,
                    ::subxt::storage::address::Yes,
                    (),
                > {
                    ::subxt::storage::address::Address::new_static(
                        "Treasury",
                        "ProposalCount",
                        vec![],
                        [
                            91u8,
                            238u8,
                            246u8,
                            106u8,
                            95u8,
                            66u8,
                            83u8,
                            134u8,
                            1u8,
                            225u8,
                            164u8,
                            216u8,
                            113u8,
                            101u8,
                            203u8,
                            200u8,
                            113u8,
                            97u8,
                            246u8,
                            228u8,
                            140u8,
                            29u8,
                            29u8,
                            48u8,
                            176u8,
                            137u8,
                            93u8,
                            230u8,
                            56u8,
                            75u8,
                            51u8,
                            149u8,
                        ],
                    )
                }
                /// Proposals that have been made.
                pub fn proposals(
                    &self,
                    _0: impl ::std::borrow::Borrow<::core::primitive::u32>,
                ) -> ::subxt::storage::address::Address<
                    ::subxt::storage::address::StaticStorageMapKey,
                    runtime_types::pallet_treasury::Proposal<
                        ::subxt::utils::AccountId32,
                        ::core::primitive::u128,
                    >,
                    ::subxt::storage::address::Yes,
                    (),
                    ::subxt::storage::address::Yes,
                > {
                    ::subxt::storage::address::Address::new_static(
                        "Treasury",
                        "Proposals",
                        vec![
                            ::subxt::storage::address::make_static_storage_map_key(_0
                            .borrow())
                        ],
                        [
                            182u8,
                            12u8,
                            98u8,
                            64u8,
                            117u8,
                            17u8,
                            90u8,
                            245u8,
                            80u8,
                            99u8,
                            161u8,
                            17u8,
                            59u8,
                            80u8,
                            64u8,
                            139u8,
                            89u8,
                            179u8,
                            254u8,
                            239u8,
                            143u8,
                            114u8,
                            77u8,
                            79u8,
                            75u8,
                            126u8,
                            52u8,
                            227u8,
                            1u8,
                            138u8,
                            35u8,
                            62u8,
                        ],
                    )
                }
                /// Proposals that have been made.
                pub fn proposals_root(
                    &self,
                ) -> ::subxt::storage::address::Address<
                    ::subxt::storage::address::StaticStorageMapKey,
                    runtime_types::pallet_treasury::Proposal<
                        ::subxt::utils::AccountId32,
                        ::core::primitive::u128,
                    >,
                    (),
                    (),
                    ::subxt::storage::address::Yes,
                > {
                    ::subxt::storage::address::Address::new_static(
                        "Treasury",
                        "Proposals",
                        Vec::new(),
                        [
                            182u8,
                            12u8,
                            98u8,
                            64u8,
                            117u8,
                            17u8,
                            90u8,
                            245u8,
                            80u8,
                            99u8,
                            161u8,
                            17u8,
                            59u8,
                            80u8,
                            64u8,
                            139u8,
                            89u8,
                            179u8,
                            254u8,
                            239u8,
                            143u8,
                            114u8,
                            77u8,
                            79u8,
                            75u8,
                            126u8,
                            52u8,
                            227u8,
                            1u8,
                            138u8,
                            35u8,
                            62u8,
                        ],
                    )
                }
                /// The amount which has been reported as inactive to Currency.
                pub fn deactivated(
                    &self,
                ) -> ::subxt::storage::address::Address<
                    ::subxt::storage::address::StaticStorageMapKey,
                    ::core::primitive::u128,
                    ::subxt::storage::address::Yes,
                    ::subxt::storage::address::Yes,
                    (),
                > {
                    ::subxt::storage::address::Address::new_static(
                        "Treasury",
                        "Deactivated",
                        vec![],
                        [
                            120u8,
                            221u8,
                            159u8,
                            56u8,
                            161u8,
                            44u8,
                            54u8,
                            233u8,
                            47u8,
                            114u8,
                            170u8,
                            150u8,
                            52u8,
                            24u8,
                            137u8,
                            212u8,
                            122u8,
                            247u8,
                            40u8,
                            17u8,
                            208u8,
                            130u8,
                            42u8,
                            154u8,
                            33u8,
                            222u8,
                            59u8,
                            116u8,
                            0u8,
                            15u8,
                            79u8,
                            123u8,
                        ],
                    )
                }
                /// Proposal indices that have been approved but not yet awarded.
                pub fn approvals(
                    &self,
                ) -> ::subxt::storage::address::Address<
                    ::subxt::storage::address::StaticStorageMapKey,
                    runtime_types::bounded_collections::bounded_vec::BoundedVec<
                        ::core::primitive::u32,
                    >,
                    ::subxt::storage::address::Yes,
                    ::subxt::storage::address::Yes,
                    (),
                > {
                    ::subxt::storage::address::Address::new_static(
                        "Treasury",
                        "Approvals",
                        vec![],
                        [
                            78u8,
                            147u8,
                            186u8,
                            235u8,
                            17u8,
                            40u8,
                            247u8,
                            235u8,
                            67u8,
                            222u8,
                            3u8,
                            14u8,
                            248u8,
                            17u8,
                            67u8,
                            180u8,
                            93u8,
                            161u8,
                            64u8,
                            35u8,
                            119u8,
                            194u8,
                            187u8,
                            226u8,
                            135u8,
                            162u8,
                            147u8,
                            174u8,
                            139u8,
                            72u8,
                            99u8,
                            212u8,
                        ],
                    )
                }
            }
        }
        pub mod constants {
            use super::runtime_types;
            pub struct ConstantsApi;
            impl ConstantsApi {
                /// Fraction of a proposal's value that should be bonded in order to place the proposal.
                /// An accepted proposal gets these back. A rejected proposal does not.
                pub fn proposal_bond(
                    &self,
                ) -> ::subxt::constants::Address<
                    runtime_types::sp_arithmetic::per_things::Permill,
                > {
                    ::subxt::constants::Address::new_static(
                        "Treasury",
                        "ProposalBond",
                        [
                            65u8,
                            93u8,
                            120u8,
                            165u8,
                            204u8,
                            81u8,
                            159u8,
                            163u8,
                            93u8,
                            135u8,
                            114u8,
                            121u8,
                            147u8,
                            35u8,
                            215u8,
                            213u8,
                            4u8,
                            223u8,
                            83u8,
                            37u8,
                            225u8,
                            200u8,
                            189u8,
                            156u8,
                            140u8,
                            36u8,
                            58u8,
                            46u8,
                            42u8,
                            232u8,
                            155u8,
                            0u8,
                        ],
                    )
                }
                /// Minimum amount of funds that should be placed in a deposit for making a proposal.
                pub fn proposal_bond_minimum(
                    &self,
                ) -> ::subxt::constants::Address<::core::primitive::u128> {
                    ::subxt::constants::Address::new_static(
                        "Treasury",
                        "ProposalBondMinimum",
                        [
                            84u8,
                            157u8,
                            140u8,
                            4u8,
                            93u8,
                            57u8,
                            29u8,
                            133u8,
                            105u8,
                            200u8,
                            214u8,
                            27u8,
                            144u8,
                            208u8,
                            218u8,
                            160u8,
                            130u8,
                            109u8,
                            101u8,
                            54u8,
                            210u8,
                            136u8,
                            71u8,
                            63u8,
                            49u8,
                            237u8,
                            234u8,
                            15u8,
                            178u8,
                            98u8,
                            148u8,
                            156u8,
                        ],
                    )
                }
                /// Maximum amount of funds that should be placed in a deposit for making a proposal.
                pub fn proposal_bond_maximum(
                    &self,
                ) -> ::subxt::constants::Address<
                    ::core::option::Option<::core::primitive::u128>,
                > {
                    ::subxt::constants::Address::new_static(
                        "Treasury",
                        "ProposalBondMaximum",
                        [
                            198u8,
                            51u8,
                            89u8,
                            159u8,
                            124u8,
                            251u8,
                            51u8,
                            80u8,
                            167u8,
                            193u8,
                            44u8,
                            199u8,
                            80u8,
                            36u8,
                            41u8,
                            130u8,
                            137u8,
                            229u8,
                            178u8,
                            208u8,
                            37u8,
                            215u8,
                            169u8,
                            183u8,
                            180u8,
                            191u8,
                            140u8,
                            240u8,
                            250u8,
                            61u8,
                            42u8,
                            147u8,
                        ],
                    )
                }
                /// Period between successive spends.
                pub fn spend_period(
                    &self,
                ) -> ::subxt::constants::Address<::core::primitive::u32> {
                    ::subxt::constants::Address::new_static(
                        "Treasury",
                        "SpendPeriod",
                        [
                            98u8,
                            252u8,
                            116u8,
                            72u8,
                            26u8,
                            180u8,
                            225u8,
                            83u8,
                            200u8,
                            157u8,
                            125u8,
                            151u8,
                            53u8,
                            76u8,
                            168u8,
                            26u8,
                            10u8,
                            9u8,
                            98u8,
                            68u8,
                            9u8,
                            178u8,
                            197u8,
                            113u8,
                            31u8,
                            79u8,
                            200u8,
                            90u8,
                            203u8,
                            100u8,
                            41u8,
                            145u8,
                        ],
                    )
                }
                /// Percentage of spare funds (if any) that are burnt per spend period.
                pub fn burn(
                    &self,
                ) -> ::subxt::constants::Address<
                    runtime_types::sp_arithmetic::per_things::Permill,
                > {
                    ::subxt::constants::Address::new_static(
                        "Treasury",
                        "Burn",
                        [
                            65u8,
                            93u8,
                            120u8,
                            165u8,
                            204u8,
                            81u8,
                            159u8,
                            163u8,
                            93u8,
                            135u8,
                            114u8,
                            121u8,
                            147u8,
                            35u8,
                            215u8,
                            213u8,
                            4u8,
                            223u8,
                            83u8,
                            37u8,
                            225u8,
                            200u8,
                            189u8,
                            156u8,
                            140u8,
                            36u8,
                            58u8,
                            46u8,
                            42u8,
                            232u8,
                            155u8,
                            0u8,
                        ],
                    )
                }
                /// The treasury's pallet id, used for deriving its sovereign account ID.
                pub fn pallet_id(
                    &self,
                ) -> ::subxt::constants::Address<
                    runtime_types::frame_support::PalletId,
                > {
                    ::subxt::constants::Address::new_static(
                        "Treasury",
                        "PalletId",
                        [
                            56u8,
                            243u8,
                            53u8,
                            83u8,
                            154u8,
                            179u8,
                            170u8,
                            80u8,
                            133u8,
                            173u8,
                            61u8,
                            161u8,
                            47u8,
                            225u8,
                            146u8,
                            21u8,
                            50u8,
                            229u8,
                            248u8,
                            27u8,
                            104u8,
                            58u8,
                            129u8,
                            197u8,
                            102u8,
                            160u8,
                            168u8,
                            205u8,
                            154u8,
                            42u8,
                            217u8,
                            53u8,
                        ],
                    )
                }
                /// The maximum number of approvals that can wait in the spending queue.
                ///
                /// NOTE: This parameter is also used within the Bounties Pallet extension if enabled.
                pub fn max_approvals(
                    &self,
                ) -> ::subxt::constants::Address<::core::primitive::u32> {
                    ::subxt::constants::Address::new_static(
                        "Treasury",
                        "MaxApprovals",
                        [
                            98u8,
                            252u8,
                            116u8,
                            72u8,
                            26u8,
                            180u8,
                            225u8,
                            83u8,
                            200u8,
                            157u8,
                            125u8,
                            151u8,
                            53u8,
                            76u8,
                            168u8,
                            26u8,
                            10u8,
                            9u8,
                            98u8,
                            68u8,
                            9u8,
                            178u8,
                            197u8,
                            113u8,
                            31u8,
                            79u8,
                            200u8,
                            90u8,
                            203u8,
                            100u8,
                            41u8,
                            145u8,
                        ],
                    )
                }
            }
        }
    }
    pub mod bounties {
        use super::root_mod;
        use super::runtime_types;
        /**
			Custom [dispatch errors](https://docs.substrate.io/main-docs/build/events-errors/)
			of this pallet.
			*/
        pub type Error = runtime_types::pallet_bounties::pallet::Error;
        ///Contains one variant per dispatchable that can be called by an extrinsic.
        pub type Call = runtime_types::pallet_bounties::pallet::Call;
        pub mod calls {
            use super::root_mod;
            use super::runtime_types;
            type DispatchError = runtime_types::sp_runtime::DispatchError;
            pub mod types {
                use super::runtime_types;
                #[derive(
                    ::subxt::ext::codec::Decode,
                    ::subxt::ext::codec::Encode,
                    ::subxt::ext::scale_decode::DecodeAsType,
                    ::subxt::ext::scale_encode::EncodeAsType,
                    Clone,
                    Debug,
                    Eq,
                    PartialEq
                )]
                #[codec(crate = ::subxt::ext::codec)]
                #[decode_as_type(crate_path = ":: subxt :: ext :: scale_decode")]
                #[encode_as_type(crate_path = ":: subxt :: ext :: scale_encode")]
                pub struct ProposeBounty {
                    #[codec(compact)]
                    pub value: ::core::primitive::u128,
                    pub description: ::std::vec::Vec<::core::primitive::u8>,
                }
                impl ::subxt::blocks::StaticExtrinsic for ProposeBounty {
                    const PALLET: &'static str = "Bounties";
                    const CALL: &'static str = "propose_bounty";
                }
                #[derive(
                    ::subxt::ext::codec::Decode,
                    ::subxt::ext::codec::Encode,
                    ::subxt::ext::scale_decode::DecodeAsType,
                    ::subxt::ext::scale_encode::EncodeAsType,
                    Clone,
                    Debug,
                    Eq,
                    PartialEq
                )]
                #[codec(crate = ::subxt::ext::codec)]
                #[decode_as_type(crate_path = ":: subxt :: ext :: scale_decode")]
                #[encode_as_type(crate_path = ":: subxt :: ext :: scale_encode")]
                pub struct ApproveBounty {
                    #[codec(compact)]
                    pub bounty_id: ::core::primitive::u32,
                }
                impl ::subxt::blocks::StaticExtrinsic for ApproveBounty {
                    const PALLET: &'static str = "Bounties";
                    const CALL: &'static str = "approve_bounty";
                }
                #[derive(
                    ::subxt::ext::codec::Decode,
                    ::subxt::ext::codec::Encode,
                    ::subxt::ext::scale_decode::DecodeAsType,
                    ::subxt::ext::scale_encode::EncodeAsType,
                    Clone,
                    Debug,
                    Eq,
                    PartialEq
                )]
                #[codec(crate = ::subxt::ext::codec)]
                #[decode_as_type(crate_path = ":: subxt :: ext :: scale_decode")]
                #[encode_as_type(crate_path = ":: subxt :: ext :: scale_encode")]
                pub struct ProposeCurator {
                    #[codec(compact)]
                    pub bounty_id: ::core::primitive::u32,
                    pub curator: ::subxt::utils::MultiAddress<
                        ::subxt::utils::AccountId32,
                        ::core::primitive::u32,
                    >,
                    #[codec(compact)]
                    pub fee: ::core::primitive::u128,
                }
                impl ::subxt::blocks::StaticExtrinsic for ProposeCurator {
                    const PALLET: &'static str = "Bounties";
                    const CALL: &'static str = "propose_curator";
                }
                #[derive(
                    ::subxt::ext::codec::Decode,
                    ::subxt::ext::codec::Encode,
                    ::subxt::ext::scale_decode::DecodeAsType,
                    ::subxt::ext::scale_encode::EncodeAsType,
                    Clone,
                    Debug,
                    Eq,
                    PartialEq
                )]
                #[codec(crate = ::subxt::ext::codec)]
                #[decode_as_type(crate_path = ":: subxt :: ext :: scale_decode")]
                #[encode_as_type(crate_path = ":: subxt :: ext :: scale_encode")]
                pub struct UnassignCurator {
                    #[codec(compact)]
                    pub bounty_id: ::core::primitive::u32,
                }
                impl ::subxt::blocks::StaticExtrinsic for UnassignCurator {
                    const PALLET: &'static str = "Bounties";
                    const CALL: &'static str = "unassign_curator";
                }
                #[derive(
                    ::subxt::ext::codec::Decode,
                    ::subxt::ext::codec::Encode,
                    ::subxt::ext::scale_decode::DecodeAsType,
                    ::subxt::ext::scale_encode::EncodeAsType,
                    Clone,
                    Debug,
                    Eq,
                    PartialEq
                )]
                #[codec(crate = ::subxt::ext::codec)]
                #[decode_as_type(crate_path = ":: subxt :: ext :: scale_decode")]
                #[encode_as_type(crate_path = ":: subxt :: ext :: scale_encode")]
                pub struct AcceptCurator {
                    #[codec(compact)]
                    pub bounty_id: ::core::primitive::u32,
                }
                impl ::subxt::blocks::StaticExtrinsic for AcceptCurator {
                    const PALLET: &'static str = "Bounties";
                    const CALL: &'static str = "accept_curator";
                }
                #[derive(
                    ::subxt::ext::codec::Decode,
                    ::subxt::ext::codec::Encode,
                    ::subxt::ext::scale_decode::DecodeAsType,
                    ::subxt::ext::scale_encode::EncodeAsType,
                    Clone,
                    Debug,
                    Eq,
                    PartialEq
                )]
                #[codec(crate = ::subxt::ext::codec)]
                #[decode_as_type(crate_path = ":: subxt :: ext :: scale_decode")]
                #[encode_as_type(crate_path = ":: subxt :: ext :: scale_encode")]
                pub struct AwardBounty {
                    #[codec(compact)]
                    pub bounty_id: ::core::primitive::u32,
                    pub beneficiary: ::subxt::utils::MultiAddress<
                        ::subxt::utils::AccountId32,
                        ::core::primitive::u32,
                    >,
                }
                impl ::subxt::blocks::StaticExtrinsic for AwardBounty {
                    const PALLET: &'static str = "Bounties";
                    const CALL: &'static str = "award_bounty";
                }
                #[derive(
                    ::subxt::ext::codec::Decode,
                    ::subxt::ext::codec::Encode,
                    ::subxt::ext::scale_decode::DecodeAsType,
                    ::subxt::ext::scale_encode::EncodeAsType,
                    Clone,
                    Debug,
                    Eq,
                    PartialEq
                )]
                #[codec(crate = ::subxt::ext::codec)]
                #[decode_as_type(crate_path = ":: subxt :: ext :: scale_decode")]
                #[encode_as_type(crate_path = ":: subxt :: ext :: scale_encode")]
                pub struct ClaimBounty {
                    #[codec(compact)]
                    pub bounty_id: ::core::primitive::u32,
                }
                impl ::subxt::blocks::StaticExtrinsic for ClaimBounty {
                    const PALLET: &'static str = "Bounties";
                    const CALL: &'static str = "claim_bounty";
                }
                #[derive(
                    ::subxt::ext::codec::Decode,
                    ::subxt::ext::codec::Encode,
                    ::subxt::ext::scale_decode::DecodeAsType,
                    ::subxt::ext::scale_encode::EncodeAsType,
                    Clone,
                    Debug,
                    Eq,
                    PartialEq
                )]
                #[codec(crate = ::subxt::ext::codec)]
                #[decode_as_type(crate_path = ":: subxt :: ext :: scale_decode")]
                #[encode_as_type(crate_path = ":: subxt :: ext :: scale_encode")]
                pub struct CloseBounty {
                    #[codec(compact)]
                    pub bounty_id: ::core::primitive::u32,
                }
                impl ::subxt::blocks::StaticExtrinsic for CloseBounty {
                    const PALLET: &'static str = "Bounties";
                    const CALL: &'static str = "close_bounty";
                }
                #[derive(
                    ::subxt::ext::codec::Decode,
                    ::subxt::ext::codec::Encode,
                    ::subxt::ext::scale_decode::DecodeAsType,
                    ::subxt::ext::scale_encode::EncodeAsType,
                    Clone,
                    Debug,
                    Eq,
                    PartialEq
                )]
                #[codec(crate = ::subxt::ext::codec)]
                #[decode_as_type(crate_path = ":: subxt :: ext :: scale_decode")]
                #[encode_as_type(crate_path = ":: subxt :: ext :: scale_encode")]
                pub struct ExtendBountyExpiry {
                    #[codec(compact)]
                    pub bounty_id: ::core::primitive::u32,
                    pub remark: ::std::vec::Vec<::core::primitive::u8>,
                }
                impl ::subxt::blocks::StaticExtrinsic for ExtendBountyExpiry {
                    const PALLET: &'static str = "Bounties";
                    const CALL: &'static str = "extend_bounty_expiry";
                }
            }
            pub struct TransactionApi;
            impl TransactionApi {
                ///Propose a new bounty.
                ///
                ///The dispatch origin for this call must be _Signed_.
                ///
                ///Payment: `TipReportDepositBase` will be reserved from the origin account, as well as
                ///`DataDepositPerByte` for each byte in `reason`. It will be unreserved upon approval,
                ///or slashed when rejected.
                ///
                ///- `curator`: The curator account whom will manage this bounty.
                ///- `fee`: The curator fee.
                ///- `value`: The total payment amount of this bounty, curator fee included.
                ///- `description`: The description of this bounty.
                pub fn propose_bounty(
                    &self,
                    value: ::core::primitive::u128,
                    description: ::std::vec::Vec<::core::primitive::u8>,
                ) -> ::subxt::tx::Payload<types::ProposeBounty> {
                    ::subxt::tx::Payload::new_static(
                        "Bounties",
                        "propose_bounty",
                        types::ProposeBounty {
                            value,
                            description,
                        },
                        [
                            131u8,
                            169u8,
                            55u8,
                            102u8,
                            212u8,
                            139u8,
                            9u8,
                            65u8,
                            75u8,
                            112u8,
                            6u8,
                            180u8,
                            92u8,
                            124u8,
                            43u8,
                            42u8,
                            38u8,
                            40u8,
                            226u8,
                            24u8,
                            28u8,
                            34u8,
                            169u8,
                            220u8,
                            184u8,
                            206u8,
                            109u8,
                            227u8,
                            53u8,
                            228u8,
                            88u8,
                            25u8,
                        ],
                    )
                }
                ///Approve a bounty proposal. At a later time, the bounty will be funded and become active
                ///and the original deposit will be returned.
                ///
                ///May only be called from `T::SpendOrigin`.
                ///
                ///## Complexity
                ///- O(1).
                pub fn approve_bounty(
                    &self,
                    bounty_id: ::core::primitive::u32,
                ) -> ::subxt::tx::Payload<types::ApproveBounty> {
                    ::subxt::tx::Payload::new_static(
                        "Bounties",
                        "approve_bounty",
                        types::ApproveBounty { bounty_id },
                        [
                            85u8,
                            12u8,
                            177u8,
                            91u8,
                            183u8,
                            124u8,
                            175u8,
                            148u8,
                            188u8,
                            200u8,
                            237u8,
                            144u8,
                            6u8,
                            67u8,
                            159u8,
                            48u8,
                            177u8,
                            222u8,
                            183u8,
                            137u8,
                            173u8,
                            131u8,
                            128u8,
                            219u8,
                            255u8,
                            243u8,
                            80u8,
                            224u8,
                            126u8,
                            136u8,
                            90u8,
                            47u8,
                        ],
                    )
                }
                ///Assign a curator to a funded bounty.
                ///
                ///May only be called from `T::SpendOrigin`.
                ///
                ///## Complexity
                ///- O(1).
                pub fn propose_curator(
                    &self,
                    bounty_id: ::core::primitive::u32,
                    curator: ::subxt::utils::MultiAddress<
                        ::subxt::utils::AccountId32,
                        ::core::primitive::u32,
                    >,
                    fee: ::core::primitive::u128,
                ) -> ::subxt::tx::Payload<types::ProposeCurator> {
                    ::subxt::tx::Payload::new_static(
                        "Bounties",
                        "propose_curator",
                        types::ProposeCurator {
                            bounty_id,
                            curator,
                            fee,
                        },
                        [
                            71u8,
                            194u8,
                            107u8,
                            158u8,
                            153u8,
                            106u8,
                            130u8,
                            173u8,
                            57u8,
                            240u8,
                            43u8,
                            213u8,
                            143u8,
                            48u8,
                            179u8,
                            254u8,
                            63u8,
                            190u8,
                            105u8,
                            52u8,
                            127u8,
                            238u8,
                            84u8,
                            105u8,
                            41u8,
                            180u8,
                            25u8,
                            98u8,
                            215u8,
                            197u8,
                            61u8,
                            72u8,
                        ],
                    )
                }
                ///Unassign curator from a bounty.
                ///
                ///This function can only be called by the `RejectOrigin` a signed origin.
                ///
                ///If this function is called by the `RejectOrigin`, we assume that the curator is
                ///malicious or inactive. As a result, we will slash the curator when possible.
                ///
                ///If the origin is the curator, we take this as a sign they are unable to do their job and
                ///they willingly give up. We could slash them, but for now we allow them to recover their
                ///deposit and exit without issue. (We may want to change this if it is abused.)
                ///
                ///Finally, the origin can be anyone if and only if the curator is "inactive". This allows
                ///anyone in the community to call out that a curator is not doing their due diligence, and
                ///we should pick a new curator. In this case the curator should also be slashed.
                ///
                ///## Complexity
                ///- O(1).
                pub fn unassign_curator(
                    &self,
                    bounty_id: ::core::primitive::u32,
                ) -> ::subxt::tx::Payload<types::UnassignCurator> {
                    ::subxt::tx::Payload::new_static(
                        "Bounties",
                        "unassign_curator",
                        types::UnassignCurator {
                            bounty_id,
                        },
                        [
                            98u8,
                            94u8,
                            107u8,
                            111u8,
                            151u8,
                            182u8,
                            71u8,
                            239u8,
                            214u8,
                            88u8,
                            108u8,
                            11u8,
                            51u8,
                            163u8,
                            102u8,
                            162u8,
                            245u8,
                            247u8,
                            244u8,
                            159u8,
                            197u8,
                            23u8,
                            171u8,
                            6u8,
                            60u8,
                            146u8,
                            144u8,
                            101u8,
                            68u8,
                            133u8,
                            245u8,
                            74u8,
                        ],
                    )
                }
                ///Accept the curator role for a bounty.
                ///A deposit will be reserved from curator and refund upon successful payout.
                ///
                ///May only be called from the curator.
                ///
                ///## Complexity
                ///- O(1).
                pub fn accept_curator(
                    &self,
                    bounty_id: ::core::primitive::u32,
                ) -> ::subxt::tx::Payload<types::AcceptCurator> {
                    ::subxt::tx::Payload::new_static(
                        "Bounties",
                        "accept_curator",
                        types::AcceptCurator { bounty_id },
                        [
                            178u8,
                            142u8,
                            138u8,
                            15u8,
                            243u8,
                            10u8,
                            222u8,
                            169u8,
                            150u8,
                            200u8,
                            85u8,
                            185u8,
                            39u8,
                            167u8,
                            134u8,
                            3u8,
                            186u8,
                            84u8,
                            43u8,
                            140u8,
                            11u8,
                            70u8,
                            56u8,
                            197u8,
                            39u8,
                            84u8,
                            138u8,
                            139u8,
                            198u8,
                            104u8,
                            41u8,
                            238u8,
                        ],
                    )
                }
                ///Award bounty to a beneficiary account. The beneficiary will be able to claim the funds
                ///after a delay.
                ///
                ///The dispatch origin for this call must be the curator of this bounty.
                ///
                ///- `bounty_id`: Bounty ID to award.
                ///- `beneficiary`: The beneficiary account whom will receive the payout.
                ///
                ///## Complexity
                ///- O(1).
                pub fn award_bounty(
                    &self,
                    bounty_id: ::core::primitive::u32,
                    beneficiary: ::subxt::utils::MultiAddress<
                        ::subxt::utils::AccountId32,
                        ::core::primitive::u32,
                    >,
                ) -> ::subxt::tx::Payload<types::AwardBounty> {
                    ::subxt::tx::Payload::new_static(
                        "Bounties",
                        "award_bounty",
                        types::AwardBounty {
                            bounty_id,
                            beneficiary,
                        },
                        [
                            69u8,
                            87u8,
                            233u8,
                            113u8,
                            45u8,
                            84u8,
                            104u8,
                            158u8,
                            128u8,
                            111u8,
                            231u8,
                            80u8,
                            175u8,
                            226u8,
                            231u8,
                            61u8,
                            106u8,
                            6u8,
                            192u8,
                            208u8,
                            128u8,
                            160u8,
                            75u8,
                            27u8,
                            190u8,
                            9u8,
                            191u8,
                            90u8,
                            219u8,
                            25u8,
                            129u8,
                            244u8,
                        ],
                    )
                }
                ///Claim the payout from an awarded bounty after payout delay.
                ///
                ///The dispatch origin for this call must be the beneficiary of this bounty.
                ///
                ///- `bounty_id`: Bounty ID to claim.
                ///
                ///## Complexity
                ///- O(1).
                pub fn claim_bounty(
                    &self,
                    bounty_id: ::core::primitive::u32,
                ) -> ::subxt::tx::Payload<types::ClaimBounty> {
                    ::subxt::tx::Payload::new_static(
                        "Bounties",
                        "claim_bounty",
                        types::ClaimBounty { bounty_id },
                        [
                            211u8,
                            143u8,
                            123u8,
                            205u8,
                            140u8,
                            43u8,
                            176u8,
                            103u8,
                            110u8,
                            125u8,
                            158u8,
                            131u8,
                            103u8,
                            62u8,
                            69u8,
                            215u8,
                            220u8,
                            110u8,
                            11u8,
                            3u8,
                            30u8,
                            193u8,
                            235u8,
                            177u8,
                            96u8,
                            241u8,
                            140u8,
                            53u8,
                            62u8,
                            133u8,
                            170u8,
                            25u8,
                        ],
                    )
                }
                ///Cancel a proposed or active bounty. All the funds will be sent to treasury and
                ///the curator deposit will be unreserved if possible.
                ///
                ///Only `T::RejectOrigin` is able to cancel a bounty.
                ///
                ///- `bounty_id`: Bounty ID to cancel.
                ///
                ///## Complexity
                ///- O(1).
                pub fn close_bounty(
                    &self,
                    bounty_id: ::core::primitive::u32,
                ) -> ::subxt::tx::Payload<types::CloseBounty> {
                    ::subxt::tx::Payload::new_static(
                        "Bounties",
                        "close_bounty",
                        types::CloseBounty { bounty_id },
                        [
                            144u8,
                            234u8,
                            109u8,
                            39u8,
                            227u8,
                            231u8,
                            104u8,
                            48u8,
                            45u8,
                            196u8,
                            217u8,
                            220u8,
                            241u8,
                            197u8,
                            157u8,
                            227u8,
                            154u8,
                            156u8,
                            181u8,
                            69u8,
                            146u8,
                            77u8,
                            203u8,
                            167u8,
                            79u8,
                            102u8,
                            15u8,
                            253u8,
                            135u8,
                            53u8,
                            96u8,
                            60u8,
                        ],
                    )
                }
                ///Extend the expiry time of an active bounty.
                ///
                ///The dispatch origin for this call must be the curator of this bounty.
                ///
                ///- `bounty_id`: Bounty ID to extend.
                ///- `remark`: additional information.
                ///
                ///## Complexity
                ///- O(1).
                pub fn extend_bounty_expiry(
                    &self,
                    bounty_id: ::core::primitive::u32,
                    remark: ::std::vec::Vec<::core::primitive::u8>,
                ) -> ::subxt::tx::Payload<types::ExtendBountyExpiry> {
                    ::subxt::tx::Payload::new_static(
                        "Bounties",
                        "extend_bounty_expiry",
                        types::ExtendBountyExpiry {
                            bounty_id,
                            remark,
                        },
                        [
                            102u8,
                            118u8,
                            89u8,
                            189u8,
                            138u8,
                            157u8,
                            216u8,
                            10u8,
                            239u8,
                            3u8,
                            200u8,
                            217u8,
                            219u8,
                            19u8,
                            195u8,
                            182u8,
                            105u8,
                            220u8,
                            11u8,
                            146u8,
                            222u8,
                            79u8,
                            95u8,
                            136u8,
                            188u8,
                            230u8,
                            248u8,
                            119u8,
                            30u8,
                            6u8,
                            242u8,
                            194u8,
                        ],
                    )
                }
            }
        }
        /**
			The [event](https://docs.substrate.io/main-docs/build/events-errors/) emitted
			by this pallet.
			*/
        pub type Event = runtime_types::pallet_bounties::pallet::Event;
        pub mod events {
            use super::runtime_types;
            #[derive(
                ::subxt::ext::codec::CompactAs,
                ::subxt::ext::codec::Decode,
                ::subxt::ext::codec::Encode,
                ::subxt::ext::scale_decode::DecodeAsType,
                ::subxt::ext::scale_encode::EncodeAsType,
                Clone,
                Debug,
                Eq,
                PartialEq
            )]
            #[codec(crate = ::subxt::ext::codec)]
            #[decode_as_type(crate_path = ":: subxt :: ext :: scale_decode")]
            #[encode_as_type(crate_path = ":: subxt :: ext :: scale_encode")]
            ///New bounty proposal.
            pub struct BountyProposed {
                pub index: ::core::primitive::u32,
            }
            impl ::subxt::events::StaticEvent for BountyProposed {
                const PALLET: &'static str = "Bounties";
                const EVENT: &'static str = "BountyProposed";
            }
            #[derive(
                ::subxt::ext::codec::Decode,
                ::subxt::ext::codec::Encode,
                ::subxt::ext::scale_decode::DecodeAsType,
                ::subxt::ext::scale_encode::EncodeAsType,
                Clone,
                Debug,
                Eq,
                PartialEq
            )]
            #[codec(crate = ::subxt::ext::codec)]
            #[decode_as_type(crate_path = ":: subxt :: ext :: scale_decode")]
            #[encode_as_type(crate_path = ":: subxt :: ext :: scale_encode")]
            ///A bounty proposal was rejected; funds were slashed.
            pub struct BountyRejected {
                pub index: ::core::primitive::u32,
                pub bond: ::core::primitive::u128,
            }
            impl ::subxt::events::StaticEvent for BountyRejected {
                const PALLET: &'static str = "Bounties";
                const EVENT: &'static str = "BountyRejected";
            }
            #[derive(
                ::subxt::ext::codec::CompactAs,
                ::subxt::ext::codec::Decode,
                ::subxt::ext::codec::Encode,
                ::subxt::ext::scale_decode::DecodeAsType,
                ::subxt::ext::scale_encode::EncodeAsType,
                Clone,
                Debug,
                Eq,
                PartialEq
            )]
            #[codec(crate = ::subxt::ext::codec)]
            #[decode_as_type(crate_path = ":: subxt :: ext :: scale_decode")]
            #[encode_as_type(crate_path = ":: subxt :: ext :: scale_encode")]
            ///A bounty proposal is funded and became active.
            pub struct BountyBecameActive {
                pub index: ::core::primitive::u32,
            }
            impl ::subxt::events::StaticEvent for BountyBecameActive {
                const PALLET: &'static str = "Bounties";
                const EVENT: &'static str = "BountyBecameActive";
            }
            #[derive(
                ::subxt::ext::codec::Decode,
                ::subxt::ext::codec::Encode,
                ::subxt::ext::scale_decode::DecodeAsType,
                ::subxt::ext::scale_encode::EncodeAsType,
                Clone,
                Debug,
                Eq,
                PartialEq
            )]
            #[codec(crate = ::subxt::ext::codec)]
            #[decode_as_type(crate_path = ":: subxt :: ext :: scale_decode")]
            #[encode_as_type(crate_path = ":: subxt :: ext :: scale_encode")]
            ///A bounty is awarded to a beneficiary.
            pub struct BountyAwarded {
                pub index: ::core::primitive::u32,
                pub beneficiary: ::subxt::utils::AccountId32,
            }
            impl ::subxt::events::StaticEvent for BountyAwarded {
                const PALLET: &'static str = "Bounties";
                const EVENT: &'static str = "BountyAwarded";
            }
            #[derive(
                ::subxt::ext::codec::Decode,
                ::subxt::ext::codec::Encode,
                ::subxt::ext::scale_decode::DecodeAsType,
                ::subxt::ext::scale_encode::EncodeAsType,
                Clone,
                Debug,
                Eq,
                PartialEq
            )]
            #[codec(crate = ::subxt::ext::codec)]
            #[decode_as_type(crate_path = ":: subxt :: ext :: scale_decode")]
            #[encode_as_type(crate_path = ":: subxt :: ext :: scale_encode")]
            ///A bounty is claimed by beneficiary.
            pub struct BountyClaimed {
                pub index: ::core::primitive::u32,
                pub payout: ::core::primitive::u128,
                pub beneficiary: ::subxt::utils::AccountId32,
            }
            impl ::subxt::events::StaticEvent for BountyClaimed {
                const PALLET: &'static str = "Bounties";
                const EVENT: &'static str = "BountyClaimed";
            }
            #[derive(
                ::subxt::ext::codec::CompactAs,
                ::subxt::ext::codec::Decode,
                ::subxt::ext::codec::Encode,
                ::subxt::ext::scale_decode::DecodeAsType,
                ::subxt::ext::scale_encode::EncodeAsType,
                Clone,
                Debug,
                Eq,
                PartialEq
            )]
            #[codec(crate = ::subxt::ext::codec)]
            #[decode_as_type(crate_path = ":: subxt :: ext :: scale_decode")]
            #[encode_as_type(crate_path = ":: subxt :: ext :: scale_encode")]
            ///A bounty is cancelled.
            pub struct BountyCanceled {
                pub index: ::core::primitive::u32,
            }
            impl ::subxt::events::StaticEvent for BountyCanceled {
                const PALLET: &'static str = "Bounties";
                const EVENT: &'static str = "BountyCanceled";
            }
            #[derive(
                ::subxt::ext::codec::CompactAs,
                ::subxt::ext::codec::Decode,
                ::subxt::ext::codec::Encode,
                ::subxt::ext::scale_decode::DecodeAsType,
                ::subxt::ext::scale_encode::EncodeAsType,
                Clone,
                Debug,
                Eq,
                PartialEq
            )]
            #[codec(crate = ::subxt::ext::codec)]
            #[decode_as_type(crate_path = ":: subxt :: ext :: scale_decode")]
            #[encode_as_type(crate_path = ":: subxt :: ext :: scale_encode")]
            ///A bounty expiry is extended.
            pub struct BountyExtended {
                pub index: ::core::primitive::u32,
            }
            impl ::subxt::events::StaticEvent for BountyExtended {
                const PALLET: &'static str = "Bounties";
                const EVENT: &'static str = "BountyExtended";
            }
        }
        pub mod storage {
            use super::runtime_types;
            pub struct StorageApi;
            impl StorageApi {
                /// Number of bounty proposals that have been made.
                pub fn bounty_count(
                    &self,
                ) -> ::subxt::storage::address::Address<
                    ::subxt::storage::address::StaticStorageMapKey,
                    ::core::primitive::u32,
                    ::subxt::storage::address::Yes,
                    ::subxt::storage::address::Yes,
                    (),
                > {
                    ::subxt::storage::address::Address::new_static(
                        "Bounties",
                        "BountyCount",
                        vec![],
                        [
                            120u8,
                            204u8,
                            26u8,
                            150u8,
                            37u8,
                            81u8,
                            43u8,
                            223u8,
                            180u8,
                            252u8,
                            142u8,
                            144u8,
                            109u8,
                            5u8,
                            184u8,
                            72u8,
                            223u8,
                            230u8,
                            66u8,
                            196u8,
                            14u8,
                            14u8,
                            164u8,
                            190u8,
                            246u8,
                            168u8,
                            190u8,
                            56u8,
                            212u8,
                            73u8,
                            175u8,
                            26u8,
                        ],
                    )
                }
                /// Bounties that have been made.
                pub fn bounties(
                    &self,
                    _0: impl ::std::borrow::Borrow<::core::primitive::u32>,
                ) -> ::subxt::storage::address::Address<
                    ::subxt::storage::address::StaticStorageMapKey,
                    runtime_types::pallet_bounties::Bounty<
                        ::subxt::utils::AccountId32,
                        ::core::primitive::u128,
                        ::core::primitive::u32,
                    >,
                    ::subxt::storage::address::Yes,
                    (),
                    ::subxt::storage::address::Yes,
                > {
                    ::subxt::storage::address::Address::new_static(
                        "Bounties",
                        "Bounties",
                        vec![
                            ::subxt::storage::address::make_static_storage_map_key(_0
                            .borrow())
                        ],
                        [
                            197u8,
                            26u8,
                            141u8,
                            98u8,
                            53u8,
                            123u8,
                            87u8,
                            219u8,
                            248u8,
                            200u8,
                            207u8,
                            196u8,
                            211u8,
                            159u8,
                            124u8,
                            173u8,
                            143u8,
                            144u8,
                            85u8,
                            180u8,
                            227u8,
                            24u8,
                            7u8,
                            52u8,
                            130u8,
                            98u8,
                            107u8,
                            145u8,
                            162u8,
                            55u8,
                            64u8,
                            199u8,
                        ],
                    )
                }
                /// Bounties that have been made.
                pub fn bounties_root(
                    &self,
                ) -> ::subxt::storage::address::Address<
                    ::subxt::storage::address::StaticStorageMapKey,
                    runtime_types::pallet_bounties::Bounty<
                        ::subxt::utils::AccountId32,
                        ::core::primitive::u128,
                        ::core::primitive::u32,
                    >,
                    (),
                    (),
                    ::subxt::storage::address::Yes,
                > {
                    ::subxt::storage::address::Address::new_static(
                        "Bounties",
                        "Bounties",
                        Vec::new(),
                        [
                            197u8,
                            26u8,
                            141u8,
                            98u8,
                            53u8,
                            123u8,
                            87u8,
                            219u8,
                            248u8,
                            200u8,
                            207u8,
                            196u8,
                            211u8,
                            159u8,
                            124u8,
                            173u8,
                            143u8,
                            144u8,
                            85u8,
                            180u8,
                            227u8,
                            24u8,
                            7u8,
                            52u8,
                            130u8,
                            98u8,
                            107u8,
                            145u8,
                            162u8,
                            55u8,
                            64u8,
                            199u8,
                        ],
                    )
                }
                /// The description of each bounty.
                pub fn bounty_descriptions(
                    &self,
                    _0: impl ::std::borrow::Borrow<::core::primitive::u32>,
                ) -> ::subxt::storage::address::Address<
                    ::subxt::storage::address::StaticStorageMapKey,
                    runtime_types::bounded_collections::bounded_vec::BoundedVec<
                        ::core::primitive::u8,
                    >,
                    ::subxt::storage::address::Yes,
                    (),
                    ::subxt::storage::address::Yes,
                > {
                    ::subxt::storage::address::Address::new_static(
                        "Bounties",
                        "BountyDescriptions",
                        vec![
                            ::subxt::storage::address::make_static_storage_map_key(_0
                            .borrow())
                        ],
                        [
                            71u8,
                            40u8,
                            133u8,
                            84u8,
                            55u8,
                            207u8,
                            169u8,
                            189u8,
                            160u8,
                            51u8,
                            202u8,
                            144u8,
                            15u8,
                            226u8,
                            97u8,
                            114u8,
                            54u8,
                            247u8,
                            53u8,
                            26u8,
                            36u8,
                            54u8,
                            186u8,
                            163u8,
                            198u8,
                            100u8,
                            191u8,
                            121u8,
                            186u8,
                            160u8,
                            85u8,
                            97u8,
                        ],
                    )
                }
                /// The description of each bounty.
                pub fn bounty_descriptions_root(
                    &self,
                ) -> ::subxt::storage::address::Address<
                    ::subxt::storage::address::StaticStorageMapKey,
                    runtime_types::bounded_collections::bounded_vec::BoundedVec<
                        ::core::primitive::u8,
                    >,
                    (),
                    (),
                    ::subxt::storage::address::Yes,
                > {
                    ::subxt::storage::address::Address::new_static(
                        "Bounties",
                        "BountyDescriptions",
                        Vec::new(),
                        [
                            71u8,
                            40u8,
                            133u8,
                            84u8,
                            55u8,
                            207u8,
                            169u8,
                            189u8,
                            160u8,
                            51u8,
                            202u8,
                            144u8,
                            15u8,
                            226u8,
                            97u8,
                            114u8,
                            54u8,
                            247u8,
                            53u8,
                            26u8,
                            36u8,
                            54u8,
                            186u8,
                            163u8,
                            198u8,
                            100u8,
                            191u8,
                            121u8,
                            186u8,
                            160u8,
                            85u8,
                            97u8,
                        ],
                    )
                }
                /// Bounty indices that have been approved but not yet funded.
                pub fn bounty_approvals(
                    &self,
                ) -> ::subxt::storage::address::Address<
                    ::subxt::storage::address::StaticStorageMapKey,
                    runtime_types::bounded_collections::bounded_vec::BoundedVec<
                        ::core::primitive::u32,
                    >,
                    ::subxt::storage::address::Yes,
                    ::subxt::storage::address::Yes,
                    (),
                > {
                    ::subxt::storage::address::Address::new_static(
                        "Bounties",
                        "BountyApprovals",
                        vec![],
                        [
                            182u8,
                            228u8,
                            0u8,
                            46u8,
                            176u8,
                            25u8,
                            222u8,
                            180u8,
                            51u8,
                            57u8,
                            14u8,
                            0u8,
                            69u8,
                            160u8,
                            64u8,
                            27u8,
                            88u8,
                            29u8,
                            227u8,
                            146u8,
                            2u8,
                            121u8,
                            27u8,
                            85u8,
                            45u8,
                            110u8,
                            244u8,
                            62u8,
                            134u8,
                            77u8,
                            175u8,
                            188u8,
                        ],
                    )
                }
            }
        }
        pub mod constants {
            use super::runtime_types;
            pub struct ConstantsApi;
            impl ConstantsApi {
                /// The amount held on deposit for placing a bounty proposal.
                pub fn bounty_deposit_base(
                    &self,
                ) -> ::subxt::constants::Address<::core::primitive::u128> {
                    ::subxt::constants::Address::new_static(
                        "Bounties",
                        "BountyDepositBase",
                        [
                            84u8,
                            157u8,
                            140u8,
                            4u8,
                            93u8,
                            57u8,
                            29u8,
                            133u8,
                            105u8,
                            200u8,
                            214u8,
                            27u8,
                            144u8,
                            208u8,
                            218u8,
                            160u8,
                            130u8,
                            109u8,
                            101u8,
                            54u8,
                            210u8,
                            136u8,
                            71u8,
                            63u8,
                            49u8,
                            237u8,
                            234u8,
                            15u8,
                            178u8,
                            98u8,
                            148u8,
                            156u8,
                        ],
                    )
                }
                /// The delay period for which a bounty beneficiary need to wait before claim the payout.
                pub fn bounty_deposit_payout_delay(
                    &self,
                ) -> ::subxt::constants::Address<::core::primitive::u32> {
                    ::subxt::constants::Address::new_static(
                        "Bounties",
                        "BountyDepositPayoutDelay",
                        [
                            98u8,
                            252u8,
                            116u8,
                            72u8,
                            26u8,
                            180u8,
                            225u8,
                            83u8,
                            200u8,
                            157u8,
                            125u8,
                            151u8,
                            53u8,
                            76u8,
                            168u8,
                            26u8,
                            10u8,
                            9u8,
                            98u8,
                            68u8,
                            9u8,
                            178u8,
                            197u8,
                            113u8,
                            31u8,
                            79u8,
                            200u8,
                            90u8,
                            203u8,
                            100u8,
                            41u8,
                            145u8,
                        ],
                    )
                }
                /// Bounty duration in blocks.
                pub fn bounty_update_period(
                    &self,
                ) -> ::subxt::constants::Address<::core::primitive::u32> {
                    ::subxt::constants::Address::new_static(
                        "Bounties",
                        "BountyUpdatePeriod",
                        [
                            98u8,
                            252u8,
                            116u8,
                            72u8,
                            26u8,
                            180u8,
                            225u8,
                            83u8,
                            200u8,
                            157u8,
                            125u8,
                            151u8,
                            53u8,
                            76u8,
                            168u8,
                            26u8,
                            10u8,
                            9u8,
                            98u8,
                            68u8,
                            9u8,
                            178u8,
                            197u8,
                            113u8,
                            31u8,
                            79u8,
                            200u8,
                            90u8,
                            203u8,
                            100u8,
                            41u8,
                            145u8,
                        ],
                    )
                }
                /// The curator deposit is calculated as a percentage of the curator fee.
                ///
                /// This deposit has optional upper and lower bounds with `CuratorDepositMax` and
                /// `CuratorDepositMin`.
                pub fn curator_deposit_multiplier(
                    &self,
                ) -> ::subxt::constants::Address<
                    runtime_types::sp_arithmetic::per_things::Permill,
                > {
                    ::subxt::constants::Address::new_static(
                        "Bounties",
                        "CuratorDepositMultiplier",
                        [
                            65u8,
                            93u8,
                            120u8,
                            165u8,
                            204u8,
                            81u8,
                            159u8,
                            163u8,
                            93u8,
                            135u8,
                            114u8,
                            121u8,
                            147u8,
                            35u8,
                            215u8,
                            213u8,
                            4u8,
                            223u8,
                            83u8,
                            37u8,
                            225u8,
                            200u8,
                            189u8,
                            156u8,
                            140u8,
                            36u8,
                            58u8,
                            46u8,
                            42u8,
                            232u8,
                            155u8,
                            0u8,
                        ],
                    )
                }
                /// Maximum amount of funds that should be placed in a deposit for making a proposal.
                pub fn curator_deposit_max(
                    &self,
                ) -> ::subxt::constants::Address<
                    ::core::option::Option<::core::primitive::u128>,
                > {
                    ::subxt::constants::Address::new_static(
                        "Bounties",
                        "CuratorDepositMax",
                        [
                            198u8,
                            51u8,
                            89u8,
                            159u8,
                            124u8,
                            251u8,
                            51u8,
                            80u8,
                            167u8,
                            193u8,
                            44u8,
                            199u8,
                            80u8,
                            36u8,
                            41u8,
                            130u8,
                            137u8,
                            229u8,
                            178u8,
                            208u8,
                            37u8,
                            215u8,
                            169u8,
                            183u8,
                            180u8,
                            191u8,
                            140u8,
                            240u8,
                            250u8,
                            61u8,
                            42u8,
                            147u8,
                        ],
                    )
                }
                /// Minimum amount of funds that should be placed in a deposit for making a proposal.
                pub fn curator_deposit_min(
                    &self,
                ) -> ::subxt::constants::Address<
                    ::core::option::Option<::core::primitive::u128>,
                > {
                    ::subxt::constants::Address::new_static(
                        "Bounties",
                        "CuratorDepositMin",
                        [
                            198u8,
                            51u8,
                            89u8,
                            159u8,
                            124u8,
                            251u8,
                            51u8,
                            80u8,
                            167u8,
                            193u8,
                            44u8,
                            199u8,
                            80u8,
                            36u8,
                            41u8,
                            130u8,
                            137u8,
                            229u8,
                            178u8,
                            208u8,
                            37u8,
                            215u8,
                            169u8,
                            183u8,
                            180u8,
                            191u8,
                            140u8,
                            240u8,
                            250u8,
                            61u8,
                            42u8,
                            147u8,
                        ],
                    )
                }
                /// Minimum value for a bounty.
                pub fn bounty_value_minimum(
                    &self,
                ) -> ::subxt::constants::Address<::core::primitive::u128> {
                    ::subxt::constants::Address::new_static(
                        "Bounties",
                        "BountyValueMinimum",
                        [
                            84u8,
                            157u8,
                            140u8,
                            4u8,
                            93u8,
                            57u8,
                            29u8,
                            133u8,
                            105u8,
                            200u8,
                            214u8,
                            27u8,
                            144u8,
                            208u8,
                            218u8,
                            160u8,
                            130u8,
                            109u8,
                            101u8,
                            54u8,
                            210u8,
                            136u8,
                            71u8,
                            63u8,
                            49u8,
                            237u8,
                            234u8,
                            15u8,
                            178u8,
                            98u8,
                            148u8,
                            156u8,
                        ],
                    )
                }
                /// The amount held on deposit per byte within the tip report reason or bounty description.
                pub fn data_deposit_per_byte(
                    &self,
                ) -> ::subxt::constants::Address<::core::primitive::u128> {
                    ::subxt::constants::Address::new_static(
                        "Bounties",
                        "DataDepositPerByte",
                        [
                            84u8,
                            157u8,
                            140u8,
                            4u8,
                            93u8,
                            57u8,
                            29u8,
                            133u8,
                            105u8,
                            200u8,
                            214u8,
                            27u8,
                            144u8,
                            208u8,
                            218u8,
                            160u8,
                            130u8,
                            109u8,
                            101u8,
                            54u8,
                            210u8,
                            136u8,
                            71u8,
                            63u8,
                            49u8,
                            237u8,
                            234u8,
                            15u8,
                            178u8,
                            98u8,
                            148u8,
                            156u8,
                        ],
                    )
                }
                /// Maximum acceptable reason length.
                ///
                /// Benchmarks depend on this value, be sure to update weights file when changing this value
                pub fn maximum_reason_length(
                    &self,
                ) -> ::subxt::constants::Address<::core::primitive::u32> {
                    ::subxt::constants::Address::new_static(
                        "Bounties",
                        "MaximumReasonLength",
                        [
                            98u8,
                            252u8,
                            116u8,
                            72u8,
                            26u8,
                            180u8,
                            225u8,
                            83u8,
                            200u8,
                            157u8,
                            125u8,
                            151u8,
                            53u8,
                            76u8,
                            168u8,
                            26u8,
                            10u8,
                            9u8,
                            98u8,
                            68u8,
                            9u8,
                            178u8,
                            197u8,
                            113u8,
                            31u8,
                            79u8,
                            200u8,
                            90u8,
                            203u8,
                            100u8,
                            41u8,
                            145u8,
                        ],
                    )
                }
            }
        }
    }
    pub mod child_bounties {
        use super::root_mod;
        use super::runtime_types;
        /**
			Custom [dispatch errors](https://docs.substrate.io/main-docs/build/events-errors/)
			of this pallet.
			*/
        pub type Error = runtime_types::pallet_child_bounties::pallet::Error;
        ///Contains one variant per dispatchable that can be called by an extrinsic.
        pub type Call = runtime_types::pallet_child_bounties::pallet::Call;
        pub mod calls {
            use super::root_mod;
            use super::runtime_types;
            type DispatchError = runtime_types::sp_runtime::DispatchError;
            pub mod types {
                use super::runtime_types;
                #[derive(
                    ::subxt::ext::codec::Decode,
                    ::subxt::ext::codec::Encode,
                    ::subxt::ext::scale_decode::DecodeAsType,
                    ::subxt::ext::scale_encode::EncodeAsType,
                    Clone,
                    Debug,
                    Eq,
                    PartialEq
                )]
                #[codec(crate = ::subxt::ext::codec)]
                #[decode_as_type(crate_path = ":: subxt :: ext :: scale_decode")]
                #[encode_as_type(crate_path = ":: subxt :: ext :: scale_encode")]
                pub struct AddChildBounty {
                    #[codec(compact)]
                    pub parent_bounty_id: ::core::primitive::u32,
                    #[codec(compact)]
                    pub value: ::core::primitive::u128,
                    pub description: ::std::vec::Vec<::core::primitive::u8>,
                }
                impl ::subxt::blocks::StaticExtrinsic for AddChildBounty {
                    const PALLET: &'static str = "ChildBounties";
                    const CALL: &'static str = "add_child_bounty";
                }
                #[derive(
                    ::subxt::ext::codec::Decode,
                    ::subxt::ext::codec::Encode,
                    ::subxt::ext::scale_decode::DecodeAsType,
                    ::subxt::ext::scale_encode::EncodeAsType,
                    Clone,
                    Debug,
                    Eq,
                    PartialEq
                )]
                #[codec(crate = ::subxt::ext::codec)]
                #[decode_as_type(crate_path = ":: subxt :: ext :: scale_decode")]
                #[encode_as_type(crate_path = ":: subxt :: ext :: scale_encode")]
                pub struct ProposeCurator {
                    #[codec(compact)]
                    pub parent_bounty_id: ::core::primitive::u32,
                    #[codec(compact)]
                    pub child_bounty_id: ::core::primitive::u32,
                    pub curator: ::subxt::utils::MultiAddress<
                        ::subxt::utils::AccountId32,
                        ::core::primitive::u32,
                    >,
                    #[codec(compact)]
                    pub fee: ::core::primitive::u128,
                }
                impl ::subxt::blocks::StaticExtrinsic for ProposeCurator {
                    const PALLET: &'static str = "ChildBounties";
                    const CALL: &'static str = "propose_curator";
                }
                #[derive(
                    ::subxt::ext::codec::Decode,
                    ::subxt::ext::codec::Encode,
                    ::subxt::ext::scale_decode::DecodeAsType,
                    ::subxt::ext::scale_encode::EncodeAsType,
                    Clone,
                    Debug,
                    Eq,
                    PartialEq
                )]
                #[codec(crate = ::subxt::ext::codec)]
                #[decode_as_type(crate_path = ":: subxt :: ext :: scale_decode")]
                #[encode_as_type(crate_path = ":: subxt :: ext :: scale_encode")]
                pub struct AcceptCurator {
                    #[codec(compact)]
                    pub parent_bounty_id: ::core::primitive::u32,
                    #[codec(compact)]
                    pub child_bounty_id: ::core::primitive::u32,
                }
                impl ::subxt::blocks::StaticExtrinsic for AcceptCurator {
                    const PALLET: &'static str = "ChildBounties";
                    const CALL: &'static str = "accept_curator";
                }
                #[derive(
                    ::subxt::ext::codec::Decode,
                    ::subxt::ext::codec::Encode,
                    ::subxt::ext::scale_decode::DecodeAsType,
                    ::subxt::ext::scale_encode::EncodeAsType,
                    Clone,
                    Debug,
                    Eq,
                    PartialEq
                )]
                #[codec(crate = ::subxt::ext::codec)]
                #[decode_as_type(crate_path = ":: subxt :: ext :: scale_decode")]
                #[encode_as_type(crate_path = ":: subxt :: ext :: scale_encode")]
                pub struct UnassignCurator {
                    #[codec(compact)]
                    pub parent_bounty_id: ::core::primitive::u32,
                    #[codec(compact)]
                    pub child_bounty_id: ::core::primitive::u32,
                }
                impl ::subxt::blocks::StaticExtrinsic for UnassignCurator {
                    const PALLET: &'static str = "ChildBounties";
                    const CALL: &'static str = "unassign_curator";
                }
                #[derive(
                    ::subxt::ext::codec::Decode,
                    ::subxt::ext::codec::Encode,
                    ::subxt::ext::scale_decode::DecodeAsType,
                    ::subxt::ext::scale_encode::EncodeAsType,
                    Clone,
                    Debug,
                    Eq,
                    PartialEq
                )]
                #[codec(crate = ::subxt::ext::codec)]
                #[decode_as_type(crate_path = ":: subxt :: ext :: scale_decode")]
                #[encode_as_type(crate_path = ":: subxt :: ext :: scale_encode")]
                pub struct AwardChildBounty {
                    #[codec(compact)]
                    pub parent_bounty_id: ::core::primitive::u32,
                    #[codec(compact)]
                    pub child_bounty_id: ::core::primitive::u32,
                    pub beneficiary: ::subxt::utils::MultiAddress<
                        ::subxt::utils::AccountId32,
                        ::core::primitive::u32,
                    >,
                }
                impl ::subxt::blocks::StaticExtrinsic for AwardChildBounty {
                    const PALLET: &'static str = "ChildBounties";
                    const CALL: &'static str = "award_child_bounty";
                }
                #[derive(
                    ::subxt::ext::codec::Decode,
                    ::subxt::ext::codec::Encode,
                    ::subxt::ext::scale_decode::DecodeAsType,
                    ::subxt::ext::scale_encode::EncodeAsType,
                    Clone,
                    Debug,
                    Eq,
                    PartialEq
                )]
                #[codec(crate = ::subxt::ext::codec)]
                #[decode_as_type(crate_path = ":: subxt :: ext :: scale_decode")]
                #[encode_as_type(crate_path = ":: subxt :: ext :: scale_encode")]
                pub struct ClaimChildBounty {
                    #[codec(compact)]
                    pub parent_bounty_id: ::core::primitive::u32,
                    #[codec(compact)]
                    pub child_bounty_id: ::core::primitive::u32,
                }
                impl ::subxt::blocks::StaticExtrinsic for ClaimChildBounty {
                    const PALLET: &'static str = "ChildBounties";
                    const CALL: &'static str = "claim_child_bounty";
                }
                #[derive(
                    ::subxt::ext::codec::Decode,
                    ::subxt::ext::codec::Encode,
                    ::subxt::ext::scale_decode::DecodeAsType,
                    ::subxt::ext::scale_encode::EncodeAsType,
                    Clone,
                    Debug,
                    Eq,
                    PartialEq
                )]
                #[codec(crate = ::subxt::ext::codec)]
                #[decode_as_type(crate_path = ":: subxt :: ext :: scale_decode")]
                #[encode_as_type(crate_path = ":: subxt :: ext :: scale_encode")]
                pub struct CloseChildBounty {
                    #[codec(compact)]
                    pub parent_bounty_id: ::core::primitive::u32,
                    #[codec(compact)]
                    pub child_bounty_id: ::core::primitive::u32,
                }
                impl ::subxt::blocks::StaticExtrinsic for CloseChildBounty {
                    const PALLET: &'static str = "ChildBounties";
                    const CALL: &'static str = "close_child_bounty";
                }
            }
            pub struct TransactionApi;
            impl TransactionApi {
                ///Add a new child-bounty.
                ///
                ///The dispatch origin for this call must be the curator of parent
                ///bounty and the parent bounty must be in "active" state.
                ///
                ///Child-bounty gets added successfully & fund gets transferred from
                ///parent bounty to child-bounty account, if parent bounty has enough
                ///funds, else the call fails.
                ///
                ///Upper bound to maximum number of active  child bounties that can be
                ///added are managed via runtime trait config
                ///[`Config::MaxActiveChildBountyCount`].
                ///
                ///If the call is success, the status of child-bounty is updated to
                ///"Added".
                ///
                ///- `parent_bounty_id`: Index of parent bounty for which child-bounty is being added.
                ///- `value`: Value for executing the proposal.
                ///- `description`: Text description for the child-bounty.
                pub fn add_child_bounty(
                    &self,
                    parent_bounty_id: ::core::primitive::u32,
                    value: ::core::primitive::u128,
                    description: ::std::vec::Vec<::core::primitive::u8>,
                ) -> ::subxt::tx::Payload<types::AddChildBounty> {
                    ::subxt::tx::Payload::new_static(
                        "ChildBounties",
                        "add_child_bounty",
                        types::AddChildBounty {
                            parent_bounty_id,
                            value,
                            description,
                        },
                        [
                            249u8,
                            159u8,
                            185u8,
                            144u8,
                            114u8,
                            142u8,
                            104u8,
                            215u8,
                            136u8,
                            52u8,
                            255u8,
                            125u8,
                            54u8,
                            243u8,
                            220u8,
                            171u8,
                            254u8,
                            49u8,
                            105u8,
                            134u8,
                            137u8,
                            221u8,
                            100u8,
                            111u8,
                            72u8,
                            38u8,
                            184u8,
                            122u8,
                            72u8,
                            204u8,
                            182u8,
                            123u8,
                        ],
                    )
                }
                ///Propose curator for funded child-bounty.
                ///
                ///The dispatch origin for this call must be curator of parent bounty.
                ///
                ///Parent bounty must be in active state, for this child-bounty call to
                ///work.
                ///
                ///Child-bounty must be in "Added" state, for processing the call. And
                ///state of child-bounty is moved to "CuratorProposed" on successful
                ///call completion.
                ///
                ///- `parent_bounty_id`: Index of parent bounty.
                ///- `child_bounty_id`: Index of child bounty.
                ///- `curator`: Address of child-bounty curator.
                ///- `fee`: payment fee to child-bounty curator for execution.
                pub fn propose_curator(
                    &self,
                    parent_bounty_id: ::core::primitive::u32,
                    child_bounty_id: ::core::primitive::u32,
                    curator: ::subxt::utils::MultiAddress<
                        ::subxt::utils::AccountId32,
                        ::core::primitive::u32,
                    >,
                    fee: ::core::primitive::u128,
                ) -> ::subxt::tx::Payload<types::ProposeCurator> {
                    ::subxt::tx::Payload::new_static(
                        "ChildBounties",
                        "propose_curator",
                        types::ProposeCurator {
                            parent_bounty_id,
                            child_bounty_id,
                            curator,
                            fee,
                        },
                        [
                            28u8,
                            8u8,
                            63u8,
                            41u8,
                            70u8,
                            178u8,
                            143u8,
                            178u8,
                            25u8,
                            250u8,
                            7u8,
                            245u8,
                            87u8,
                            115u8,
                            67u8,
                            84u8,
                            160u8,
                            142u8,
                            117u8,
                            234u8,
                            37u8,
                            74u8,
                            172u8,
                            15u8,
                            193u8,
                            190u8,
                            71u8,
                            84u8,
                            172u8,
                            198u8,
                            9u8,
                            39u8,
                        ],
                    )
                }
                ///Accept the curator role for the child-bounty.
                ///
                ///The dispatch origin for this call must be the curator of this
                ///child-bounty.
                ///
                ///A deposit will be reserved from the curator and refund upon
                ///successful payout or cancellation.
                ///
                ///Fee for curator is deducted from curator fee of parent bounty.
                ///
                ///Parent bounty must be in active state, for this child-bounty call to
                ///work.
                ///
                ///Child-bounty must be in "CuratorProposed" state, for processing the
                ///call. And state of child-bounty is moved to "Active" on successful
                ///call completion.
                ///
                ///- `parent_bounty_id`: Index of parent bounty.
                ///- `child_bounty_id`: Index of child bounty.
                pub fn accept_curator(
                    &self,
                    parent_bounty_id: ::core::primitive::u32,
                    child_bounty_id: ::core::primitive::u32,
                ) -> ::subxt::tx::Payload<types::AcceptCurator> {
                    ::subxt::tx::Payload::new_static(
                        "ChildBounties",
                        "accept_curator",
                        types::AcceptCurator {
                            parent_bounty_id,
                            child_bounty_id,
                        },
                        [
                            167u8,
                            196u8,
                            221u8,
                            73u8,
                            86u8,
                            83u8,
                            173u8,
                            219u8,
                            241u8,
                            116u8,
                            28u8,
                            109u8,
                            21u8,
                            209u8,
                            62u8,
                            131u8,
                            182u8,
                            252u8,
                            54u8,
                            114u8,
                            9u8,
                            51u8,
                            225u8,
                            37u8,
                            4u8,
                            127u8,
                            110u8,
                            80u8,
                            172u8,
                            97u8,
                            11u8,
                            78u8,
                        ],
                    )
                }
                ///Unassign curator from a child-bounty.
                ///
                ///The dispatch origin for this call can be either `RejectOrigin`, or
                ///the curator of the parent bounty, or any signed origin.
                ///
                ///For the origin other than T::RejectOrigin and the child-bounty
                ///curator, parent bounty must be in active state, for this call to
                ///work. We allow child-bounty curator and T::RejectOrigin to execute
                ///this call irrespective of the parent bounty state.
                ///
                ///If this function is called by the `RejectOrigin` or the
                ///parent bounty curator, we assume that the child-bounty curator is
                ///malicious or inactive. As a result, child-bounty curator deposit is
                ///slashed.
                ///
                ///If the origin is the child-bounty curator, we take this as a sign
                ///that they are unable to do their job, and are willingly giving up.
                ///We could slash the deposit, but for now we allow them to unreserve
                ///their deposit and exit without issue. (We may want to change this if
                ///it is abused.)
                ///
                ///Finally, the origin can be anyone iff the child-bounty curator is
                ///"inactive". Expiry update due of parent bounty is used to estimate
                ///inactive state of child-bounty curator.
                ///
                ///This allows anyone in the community to call out that a child-bounty
                ///curator is not doing their due diligence, and we should pick a new
                ///one. In this case the child-bounty curator deposit is slashed.
                ///
                ///State of child-bounty is moved to Added state on successful call
                ///completion.
                ///
                ///- `parent_bounty_id`: Index of parent bounty.
                ///- `child_bounty_id`: Index of child bounty.
                pub fn unassign_curator(
                    &self,
                    parent_bounty_id: ::core::primitive::u32,
                    child_bounty_id: ::core::primitive::u32,
                ) -> ::subxt::tx::Payload<types::UnassignCurator> {
                    ::subxt::tx::Payload::new_static(
                        "ChildBounties",
                        "unassign_curator",
                        types::UnassignCurator {
                            parent_bounty_id,
                            child_bounty_id,
                        },
                        [
                            217u8,
                            24u8,
                            147u8,
                            239u8,
                            116u8,
                            226u8,
                            244u8,
                            189u8,
                            62u8,
                            141u8,
                            173u8,
                            70u8,
                            213u8,
                            147u8,
                            68u8,
                            51u8,
                            200u8,
                            66u8,
                            200u8,
                            174u8,
                            243u8,
                            49u8,
                            54u8,
                            219u8,
                            243u8,
                            255u8,
                            250u8,
                            215u8,
                            216u8,
                            248u8,
                            32u8,
                            90u8,
                        ],
                    )
                }
                ///Award child-bounty to a beneficiary.
                ///
                ///The beneficiary will be able to claim the funds after a delay.
                ///
                ///The dispatch origin for this call must be the parent curator or
                ///curator of this child-bounty.
                ///
                ///Parent bounty must be in active state, for this child-bounty call to
                ///work.
                ///
                ///Child-bounty must be in active state, for processing the call. And
                ///state of child-bounty is moved to "PendingPayout" on successful call
                ///completion.
                ///
                ///- `parent_bounty_id`: Index of parent bounty.
                ///- `child_bounty_id`: Index of child bounty.
                ///- `beneficiary`: Beneficiary account.
                pub fn award_child_bounty(
                    &self,
                    parent_bounty_id: ::core::primitive::u32,
                    child_bounty_id: ::core::primitive::u32,
                    beneficiary: ::subxt::utils::MultiAddress<
                        ::subxt::utils::AccountId32,
                        ::core::primitive::u32,
                    >,
                ) -> ::subxt::tx::Payload<types::AwardChildBounty> {
                    ::subxt::tx::Payload::new_static(
                        "ChildBounties",
                        "award_child_bounty",
                        types::AwardChildBounty {
                            parent_bounty_id,
                            child_bounty_id,
                            beneficiary,
                        },
                        [
                            144u8,
                            230u8,
                            45u8,
                            20u8,
                            75u8,
                            100u8,
                            138u8,
                            219u8,
                            127u8,
                            5u8,
                            49u8,
                            161u8,
                            111u8,
                            148u8,
                            114u8,
                            239u8,
                            226u8,
                            154u8,
                            168u8,
                            106u8,
                            13u8,
                            50u8,
                            3u8,
                            88u8,
                            53u8,
                            28u8,
                            158u8,
                            184u8,
                            191u8,
                            80u8,
                            155u8,
                            19u8,
                        ],
                    )
                }
                ///Claim the payout from an awarded child-bounty after payout delay.
                ///
                ///The dispatch origin for this call may be any signed origin.
                ///
                ///Call works independent of parent bounty state, No need for parent
                ///bounty to be in active state.
                ///
                ///The Beneficiary is paid out with agreed bounty value. Curator fee is
                ///paid & curator deposit is unreserved.
                ///
                ///Child-bounty must be in "PendingPayout" state, for processing the
                ///call. And instance of child-bounty is removed from the state on
                ///successful call completion.
                ///
                ///- `parent_bounty_id`: Index of parent bounty.
                ///- `child_bounty_id`: Index of child bounty.
                pub fn claim_child_bounty(
                    &self,
                    parent_bounty_id: ::core::primitive::u32,
                    child_bounty_id: ::core::primitive::u32,
                ) -> ::subxt::tx::Payload<types::ClaimChildBounty> {
                    ::subxt::tx::Payload::new_static(
                        "ChildBounties",
                        "claim_child_bounty",
                        types::ClaimChildBounty {
                            parent_bounty_id,
                            child_bounty_id,
                        },
                        [
                            72u8,
                            55u8,
                            100u8,
                            52u8,
                            218u8,
                            49u8,
                            63u8,
                            107u8,
                            45u8,
                            43u8,
                            34u8,
                            6u8,
                            48u8,
                            56u8,
                            240u8,
                            3u8,
                            96u8,
                            128u8,
                            202u8,
                            30u8,
                            233u8,
                            116u8,
                            86u8,
                            141u8,
                            36u8,
                            184u8,
                            217u8,
                            48u8,
                            20u8,
                            54u8,
                            45u8,
                            65u8,
                        ],
                    )
                }
                ///Cancel a proposed or active child-bounty. Child-bounty account funds
                ///are transferred to parent bounty account. The child-bounty curator
                ///deposit may be unreserved if possible.
                ///
                ///The dispatch origin for this call must be either parent curator or
                ///`T::RejectOrigin`.
                ///
                ///If the state of child-bounty is `Active`, curator deposit is
                ///unreserved.
                ///
                ///If the state of child-bounty is `PendingPayout`, call fails &
                ///returns `PendingPayout` error.
                ///
                ///For the origin other than T::RejectOrigin, parent bounty must be in
                ///active state, for this child-bounty call to work. For origin
                ///T::RejectOrigin execution is forced.
                ///
                ///Instance of child-bounty is removed from the state on successful
                ///call completion.
                ///
                ///- `parent_bounty_id`: Index of parent bounty.
                ///- `child_bounty_id`: Index of child bounty.
                pub fn close_child_bounty(
                    &self,
                    parent_bounty_id: ::core::primitive::u32,
                    child_bounty_id: ::core::primitive::u32,
                ) -> ::subxt::tx::Payload<types::CloseChildBounty> {
                    ::subxt::tx::Payload::new_static(
                        "ChildBounties",
                        "close_child_bounty",
                        types::CloseChildBounty {
                            parent_bounty_id,
                            child_bounty_id,
                        },
                        [
                            127u8,
                            210u8,
                            46u8,
                            3u8,
                            33u8,
                            232u8,
                            159u8,
                            245u8,
                            249u8,
                            217u8,
                            51u8,
                            254u8,
                            167u8,
                            10u8,
                            30u8,
                            195u8,
                            30u8,
                            0u8,
                            204u8,
                            251u8,
                            113u8,
                            1u8,
                            104u8,
                            215u8,
                            88u8,
                            10u8,
                            200u8,
                            144u8,
                            62u8,
                            93u8,
                            223u8,
                            106u8,
                        ],
                    )
                }
            }
        }
        /**
			The [event](https://docs.substrate.io/main-docs/build/events-errors/) emitted
			by this pallet.
			*/
        pub type Event = runtime_types::pallet_child_bounties::pallet::Event;
        pub mod events {
            use super::runtime_types;
            #[derive(
                ::subxt::ext::codec::Decode,
                ::subxt::ext::codec::Encode,
                ::subxt::ext::scale_decode::DecodeAsType,
                ::subxt::ext::scale_encode::EncodeAsType,
                Clone,
                Debug,
                Eq,
                PartialEq
            )]
            #[codec(crate = ::subxt::ext::codec)]
            #[decode_as_type(crate_path = ":: subxt :: ext :: scale_decode")]
            #[encode_as_type(crate_path = ":: subxt :: ext :: scale_encode")]
            ///A child-bounty is added.
            pub struct Added {
                pub index: ::core::primitive::u32,
                pub child_index: ::core::primitive::u32,
            }
            impl ::subxt::events::StaticEvent for Added {
                const PALLET: &'static str = "ChildBounties";
                const EVENT: &'static str = "Added";
            }
            #[derive(
                ::subxt::ext::codec::Decode,
                ::subxt::ext::codec::Encode,
                ::subxt::ext::scale_decode::DecodeAsType,
                ::subxt::ext::scale_encode::EncodeAsType,
                Clone,
                Debug,
                Eq,
                PartialEq
            )]
            #[codec(crate = ::subxt::ext::codec)]
            #[decode_as_type(crate_path = ":: subxt :: ext :: scale_decode")]
            #[encode_as_type(crate_path = ":: subxt :: ext :: scale_encode")]
            ///A child-bounty is awarded to a beneficiary.
            pub struct Awarded {
                pub index: ::core::primitive::u32,
                pub child_index: ::core::primitive::u32,
                pub beneficiary: ::subxt::utils::AccountId32,
            }
            impl ::subxt::events::StaticEvent for Awarded {
                const PALLET: &'static str = "ChildBounties";
                const EVENT: &'static str = "Awarded";
            }
            #[derive(
                ::subxt::ext::codec::Decode,
                ::subxt::ext::codec::Encode,
                ::subxt::ext::scale_decode::DecodeAsType,
                ::subxt::ext::scale_encode::EncodeAsType,
                Clone,
                Debug,
                Eq,
                PartialEq
            )]
            #[codec(crate = ::subxt::ext::codec)]
            #[decode_as_type(crate_path = ":: subxt :: ext :: scale_decode")]
            #[encode_as_type(crate_path = ":: subxt :: ext :: scale_encode")]
            ///A child-bounty is claimed by beneficiary.
            pub struct Claimed {
                pub index: ::core::primitive::u32,
                pub child_index: ::core::primitive::u32,
                pub payout: ::core::primitive::u128,
                pub beneficiary: ::subxt::utils::AccountId32,
            }
            impl ::subxt::events::StaticEvent for Claimed {
                const PALLET: &'static str = "ChildBounties";
                const EVENT: &'static str = "Claimed";
            }
            #[derive(
                ::subxt::ext::codec::Decode,
                ::subxt::ext::codec::Encode,
                ::subxt::ext::scale_decode::DecodeAsType,
                ::subxt::ext::scale_encode::EncodeAsType,
                Clone,
                Debug,
                Eq,
                PartialEq
            )]
            #[codec(crate = ::subxt::ext::codec)]
            #[decode_as_type(crate_path = ":: subxt :: ext :: scale_decode")]
            #[encode_as_type(crate_path = ":: subxt :: ext :: scale_encode")]
            ///A child-bounty is cancelled.
            pub struct Canceled {
                pub index: ::core::primitive::u32,
                pub child_index: ::core::primitive::u32,
            }
            impl ::subxt::events::StaticEvent for Canceled {
                const PALLET: &'static str = "ChildBounties";
                const EVENT: &'static str = "Canceled";
            }
        }
        pub mod storage {
            use super::runtime_types;
            pub struct StorageApi;
            impl StorageApi {
                /// Number of total child bounties.
                pub fn child_bounty_count(
                    &self,
                ) -> ::subxt::storage::address::Address<
                    ::subxt::storage::address::StaticStorageMapKey,
                    ::core::primitive::u32,
                    ::subxt::storage::address::Yes,
                    ::subxt::storage::address::Yes,
                    (),
                > {
                    ::subxt::storage::address::Address::new_static(
                        "ChildBounties",
                        "ChildBountyCount",
                        vec![],
                        [
                            206u8,
                            1u8,
                            40u8,
                            132u8,
                            51u8,
                            139u8,
                            234u8,
                            20u8,
                            89u8,
                            86u8,
                            247u8,
                            107u8,
                            169u8,
                            252u8,
                            5u8,
                            180u8,
                            218u8,
                            24u8,
                            232u8,
                            94u8,
                            82u8,
                            135u8,
                            24u8,
                            16u8,
                            134u8,
                            23u8,
                            201u8,
                            86u8,
                            12u8,
                            19u8,
                            199u8,
                            0u8,
                        ],
                    )
                }
                /// Number of child bounties per parent bounty.
                /// Map of parent bounty index to number of child bounties.
                pub fn parent_child_bounties(
                    &self,
                    _0: impl ::std::borrow::Borrow<::core::primitive::u32>,
                ) -> ::subxt::storage::address::Address<
                    ::subxt::storage::address::StaticStorageMapKey,
                    ::core::primitive::u32,
                    ::subxt::storage::address::Yes,
                    ::subxt::storage::address::Yes,
                    ::subxt::storage::address::Yes,
                > {
                    ::subxt::storage::address::Address::new_static(
                        "ChildBounties",
                        "ParentChildBounties",
                        vec![
                            ::subxt::storage::address::make_static_storage_map_key(_0
                            .borrow())
                        ],
                        [
                            12u8,
                            238u8,
                            185u8,
                            135u8,
                            158u8,
                            191u8,
                            208u8,
                            104u8,
                            37u8,
                            235u8,
                            101u8,
                            15u8,
                            89u8,
                            20u8,
                            191u8,
                            191u8,
                            78u8,
                            206u8,
                            9u8,
                            19u8,
                            169u8,
                            17u8,
                            13u8,
                            213u8,
                            238u8,
                            220u8,
                            189u8,
                            100u8,
                            194u8,
                            62u8,
                            85u8,
                            150u8,
                        ],
                    )
                }
                /// Number of child bounties per parent bounty.
                /// Map of parent bounty index to number of child bounties.
                pub fn parent_child_bounties_root(
                    &self,
                ) -> ::subxt::storage::address::Address<
                    ::subxt::storage::address::StaticStorageMapKey,
                    ::core::primitive::u32,
                    (),
                    ::subxt::storage::address::Yes,
                    ::subxt::storage::address::Yes,
                > {
                    ::subxt::storage::address::Address::new_static(
                        "ChildBounties",
                        "ParentChildBounties",
                        Vec::new(),
                        [
                            12u8,
                            238u8,
                            185u8,
                            135u8,
                            158u8,
                            191u8,
                            208u8,
                            104u8,
                            37u8,
                            235u8,
                            101u8,
                            15u8,
                            89u8,
                            20u8,
                            191u8,
                            191u8,
                            78u8,
                            206u8,
                            9u8,
                            19u8,
                            169u8,
                            17u8,
                            13u8,
                            213u8,
                            238u8,
                            220u8,
                            189u8,
                            100u8,
                            194u8,
                            62u8,
                            85u8,
                            150u8,
                        ],
                    )
                }
                /// Child bounties that have been added.
                pub fn child_bounties(
                    &self,
                    _0: impl ::std::borrow::Borrow<::core::primitive::u32>,
                    _1: impl ::std::borrow::Borrow<::core::primitive::u32>,
                ) -> ::subxt::storage::address::Address<
                    ::subxt::storage::address::StaticStorageMapKey,
                    runtime_types::pallet_child_bounties::ChildBounty<
                        ::subxt::utils::AccountId32,
                        ::core::primitive::u128,
                        ::core::primitive::u32,
                    >,
                    ::subxt::storage::address::Yes,
                    (),
                    ::subxt::storage::address::Yes,
                > {
                    ::subxt::storage::address::Address::new_static(
                        "ChildBounties",
                        "ChildBounties",
                        vec![
                            ::subxt::storage::address::make_static_storage_map_key(_0
                            .borrow()),
                            ::subxt::storage::address::make_static_storage_map_key(_1
                            .borrow())
                        ],
                        [
                            236u8,
                            41u8,
                            10u8,
                            227u8,
                            176u8,
                            177u8,
                            196u8,
                            79u8,
                            112u8,
                            117u8,
                            171u8,
                            175u8,
                            84u8,
                            180u8,
                            69u8,
                            146u8,
                            252u8,
                            228u8,
                            32u8,
                            113u8,
                            226u8,
                            136u8,
                            175u8,
                            129u8,
                            1u8,
                            161u8,
                            145u8,
                            60u8,
                            142u8,
                            25u8,
                            162u8,
                            42u8,
                        ],
                    )
                }
                /// Child bounties that have been added.
                pub fn child_bounties_root(
                    &self,
                ) -> ::subxt::storage::address::Address<
                    ::subxt::storage::address::StaticStorageMapKey,
                    runtime_types::pallet_child_bounties::ChildBounty<
                        ::subxt::utils::AccountId32,
                        ::core::primitive::u128,
                        ::core::primitive::u32,
                    >,
                    (),
                    (),
                    ::subxt::storage::address::Yes,
                > {
                    ::subxt::storage::address::Address::new_static(
                        "ChildBounties",
                        "ChildBounties",
                        Vec::new(),
                        [
                            236u8,
                            41u8,
                            10u8,
                            227u8,
                            176u8,
                            177u8,
                            196u8,
                            79u8,
                            112u8,
                            117u8,
                            171u8,
                            175u8,
                            84u8,
                            180u8,
                            69u8,
                            146u8,
                            252u8,
                            228u8,
                            32u8,
                            113u8,
                            226u8,
                            136u8,
                            175u8,
                            129u8,
                            1u8,
                            161u8,
                            145u8,
                            60u8,
                            142u8,
                            25u8,
                            162u8,
                            42u8,
                        ],
                    )
                }
                /// The description of each child-bounty.
                pub fn child_bounty_descriptions(
                    &self,
                    _0: impl ::std::borrow::Borrow<::core::primitive::u32>,
                ) -> ::subxt::storage::address::Address<
                    ::subxt::storage::address::StaticStorageMapKey,
                    runtime_types::bounded_collections::bounded_vec::BoundedVec<
                        ::core::primitive::u8,
                    >,
                    ::subxt::storage::address::Yes,
                    (),
                    ::subxt::storage::address::Yes,
                > {
                    ::subxt::storage::address::Address::new_static(
                        "ChildBounties",
                        "ChildBountyDescriptions",
                        vec![
                            ::subxt::storage::address::make_static_storage_map_key(_0
                            .borrow())
                        ],
                        [
                            192u8,
                            0u8,
                            220u8,
                            156u8,
                            109u8,
                            65u8,
                            113u8,
                            102u8,
                            119u8,
                            0u8,
                            109u8,
                            141u8,
                            211u8,
                            128u8,
                            237u8,
                            61u8,
                            28u8,
                            56u8,
                            206u8,
                            93u8,
                            183u8,
                            74u8,
                            192u8,
                            220u8,
                            76u8,
                            175u8,
                            85u8,
                            105u8,
                            179u8,
                            11u8,
                            164u8,
                            100u8,
                        ],
                    )
                }
                /// The description of each child-bounty.
                pub fn child_bounty_descriptions_root(
                    &self,
                ) -> ::subxt::storage::address::Address<
                    ::subxt::storage::address::StaticStorageMapKey,
                    runtime_types::bounded_collections::bounded_vec::BoundedVec<
                        ::core::primitive::u8,
                    >,
                    (),
                    (),
                    ::subxt::storage::address::Yes,
                > {
                    ::subxt::storage::address::Address::new_static(
                        "ChildBounties",
                        "ChildBountyDescriptions",
                        Vec::new(),
                        [
                            192u8,
                            0u8,
                            220u8,
                            156u8,
                            109u8,
                            65u8,
                            113u8,
                            102u8,
                            119u8,
                            0u8,
                            109u8,
                            141u8,
                            211u8,
                            128u8,
                            237u8,
                            61u8,
                            28u8,
                            56u8,
                            206u8,
                            93u8,
                            183u8,
                            74u8,
                            192u8,
                            220u8,
                            76u8,
                            175u8,
                            85u8,
                            105u8,
                            179u8,
                            11u8,
                            164u8,
                            100u8,
                        ],
                    )
                }
                /// The cumulative child-bounty curator fee for each parent bounty.
                pub fn children_curator_fees(
                    &self,
                    _0: impl ::std::borrow::Borrow<::core::primitive::u32>,
                ) -> ::subxt::storage::address::Address<
                    ::subxt::storage::address::StaticStorageMapKey,
                    ::core::primitive::u128,
                    ::subxt::storage::address::Yes,
                    ::subxt::storage::address::Yes,
                    ::subxt::storage::address::Yes,
                > {
                    ::subxt::storage::address::Address::new_static(
                        "ChildBounties",
                        "ChildrenCuratorFees",
                        vec![
                            ::subxt::storage::address::make_static_storage_map_key(_0
                            .borrow())
                        ],
                        [
                            32u8,
                            16u8,
                            190u8,
                            193u8,
                            6u8,
                            80u8,
                            163u8,
                            16u8,
                            85u8,
                            111u8,
                            39u8,
                            141u8,
                            209u8,
                            70u8,
                            213u8,
                            167u8,
                            22u8,
                            12u8,
                            93u8,
                            17u8,
                            104u8,
                            94u8,
                            129u8,
                            37u8,
                            179u8,
                            41u8,
                            156u8,
                            117u8,
                            39u8,
                            202u8,
                            227u8,
                            235u8,
                        ],
                    )
                }
                /// The cumulative child-bounty curator fee for each parent bounty.
                pub fn children_curator_fees_root(
                    &self,
                ) -> ::subxt::storage::address::Address<
                    ::subxt::storage::address::StaticStorageMapKey,
                    ::core::primitive::u128,
                    (),
                    ::subxt::storage::address::Yes,
                    ::subxt::storage::address::Yes,
                > {
                    ::subxt::storage::address::Address::new_static(
                        "ChildBounties",
                        "ChildrenCuratorFees",
                        Vec::new(),
                        [
                            32u8,
                            16u8,
                            190u8,
                            193u8,
                            6u8,
                            80u8,
                            163u8,
                            16u8,
                            85u8,
                            111u8,
                            39u8,
                            141u8,
                            209u8,
                            70u8,
                            213u8,
                            167u8,
                            22u8,
                            12u8,
                            93u8,
                            17u8,
                            104u8,
                            94u8,
                            129u8,
                            37u8,
                            179u8,
                            41u8,
                            156u8,
                            117u8,
                            39u8,
                            202u8,
                            227u8,
                            235u8,
                        ],
                    )
                }
            }
        }
        pub mod constants {
            use super::runtime_types;
            pub struct ConstantsApi;
            impl ConstantsApi {
                /// Maximum number of child bounties that can be added to a parent bounty.
                pub fn max_active_child_bounty_count(
                    &self,
                ) -> ::subxt::constants::Address<::core::primitive::u32> {
                    ::subxt::constants::Address::new_static(
                        "ChildBounties",
                        "MaxActiveChildBountyCount",
                        [
                            98u8,
                            252u8,
                            116u8,
                            72u8,
                            26u8,
                            180u8,
                            225u8,
                            83u8,
                            200u8,
                            157u8,
                            125u8,
                            151u8,
                            53u8,
                            76u8,
                            168u8,
                            26u8,
                            10u8,
                            9u8,
                            98u8,
                            68u8,
                            9u8,
                            178u8,
                            197u8,
                            113u8,
                            31u8,
                            79u8,
                            200u8,
                            90u8,
                            203u8,
                            100u8,
                            41u8,
                            145u8,
                        ],
                    )
                }
                /// Minimum value for a child-bounty.
                pub fn child_bounty_value_minimum(
                    &self,
                ) -> ::subxt::constants::Address<::core::primitive::u128> {
                    ::subxt::constants::Address::new_static(
                        "ChildBounties",
                        "ChildBountyValueMinimum",
                        [
                            84u8,
                            157u8,
                            140u8,
                            4u8,
                            93u8,
                            57u8,
                            29u8,
                            133u8,
                            105u8,
                            200u8,
                            214u8,
                            27u8,
                            144u8,
                            208u8,
                            218u8,
                            160u8,
                            130u8,
                            109u8,
                            101u8,
                            54u8,
                            210u8,
                            136u8,
                            71u8,
                            63u8,
                            49u8,
                            237u8,
                            234u8,
                            15u8,
                            178u8,
                            98u8,
                            148u8,
                            156u8,
                        ],
                    )
                }
            }
        }
    }
    pub mod bags_list {
        use super::root_mod;
        use super::runtime_types;
        /**
			Custom [dispatch errors](https://docs.substrate.io/main-docs/build/events-errors/)
			of this pallet.
			*/
        pub type Error = runtime_types::pallet_bags_list::pallet::Error;
        ///Contains one variant per dispatchable that can be called by an extrinsic.
        pub type Call = runtime_types::pallet_bags_list::pallet::Call;
        pub mod calls {
            use super::root_mod;
            use super::runtime_types;
            type DispatchError = runtime_types::sp_runtime::DispatchError;
            pub mod types {
                use super::runtime_types;
                #[derive(
                    ::subxt::ext::codec::Decode,
                    ::subxt::ext::codec::Encode,
                    ::subxt::ext::scale_decode::DecodeAsType,
                    ::subxt::ext::scale_encode::EncodeAsType,
                    Clone,
                    Debug,
                    Eq,
                    PartialEq
                )]
                #[codec(crate = ::subxt::ext::codec)]
                #[decode_as_type(crate_path = ":: subxt :: ext :: scale_decode")]
                #[encode_as_type(crate_path = ":: subxt :: ext :: scale_encode")]
                pub struct Rebag {
                    pub dislocated: ::subxt::utils::MultiAddress<
                        ::subxt::utils::AccountId32,
                        ::core::primitive::u32,
                    >,
                }
                impl ::subxt::blocks::StaticExtrinsic for Rebag {
                    const PALLET: &'static str = "BagsList";
                    const CALL: &'static str = "rebag";
                }
                #[derive(
                    ::subxt::ext::codec::Decode,
                    ::subxt::ext::codec::Encode,
                    ::subxt::ext::scale_decode::DecodeAsType,
                    ::subxt::ext::scale_encode::EncodeAsType,
                    Clone,
                    Debug,
                    Eq,
                    PartialEq
                )]
                #[codec(crate = ::subxt::ext::codec)]
                #[decode_as_type(crate_path = ":: subxt :: ext :: scale_decode")]
                #[encode_as_type(crate_path = ":: subxt :: ext :: scale_encode")]
                pub struct PutInFrontOf {
                    pub lighter: ::subxt::utils::MultiAddress<
                        ::subxt::utils::AccountId32,
                        ::core::primitive::u32,
                    >,
                }
                impl ::subxt::blocks::StaticExtrinsic for PutInFrontOf {
                    const PALLET: &'static str = "BagsList";
                    const CALL: &'static str = "put_in_front_of";
                }
            }
            pub struct TransactionApi;
            impl TransactionApi {
                ///Declare that some `dislocated` account has, through rewards or penalties, sufficiently
                ///changed its score that it should properly fall into a different bag than its current
                ///one.
                ///
                ///Anyone can call this function about any potentially dislocated account.
                ///
                ///Will always update the stored score of `dislocated` to the correct score, based on
                ///`ScoreProvider`.
                ///
                ///If `dislocated` does not exists, it returns an error.
                pub fn rebag(
                    &self,
                    dislocated: ::subxt::utils::MultiAddress<
                        ::subxt::utils::AccountId32,
                        ::core::primitive::u32,
                    >,
                ) -> ::subxt::tx::Payload<types::Rebag> {
                    ::subxt::tx::Payload::new_static(
                        "BagsList",
                        "rebag",
                        types::Rebag { dislocated },
                        [
                            136u8,
                            83u8,
                            36u8,
                            186u8,
                            29u8,
                            197u8,
                            194u8,
                            38u8,
                            185u8,
                            103u8,
                            132u8,
                            73u8,
                            180u8,
                            246u8,
                            141u8,
                            58u8,
                            14u8,
                            74u8,
                            77u8,
                            127u8,
                            235u8,
                            179u8,
                            99u8,
                            149u8,
                            243u8,
                            171u8,
                            40u8,
                            97u8,
                            134u8,
                            179u8,
                            2u8,
                            117u8,
                        ],
                    )
                }
                ///Move the caller's Id directly in front of `lighter`.
                ///
                ///The dispatch origin for this call must be _Signed_ and can only be called by the Id of
                ///the account going in front of `lighter`.
                ///
                ///Only works if
                ///- both nodes are within the same bag,
                ///- and `origin` has a greater `Score` than `lighter`.
                pub fn put_in_front_of(
                    &self,
                    lighter: ::subxt::utils::MultiAddress<
                        ::subxt::utils::AccountId32,
                        ::core::primitive::u32,
                    >,
                ) -> ::subxt::tx::Payload<types::PutInFrontOf> {
                    ::subxt::tx::Payload::new_static(
                        "BagsList",
                        "put_in_front_of",
                        types::PutInFrontOf { lighter },
                        [
                            61u8,
                            66u8,
                            150u8,
                            46u8,
                            249u8,
                            168u8,
                            25u8,
                            138u8,
                            201u8,
                            233u8,
                            191u8,
                            216u8,
                            170u8,
                            197u8,
                            3u8,
                            123u8,
                            116u8,
                            140u8,
                            49u8,
                            226u8,
                            65u8,
                            222u8,
                            235u8,
                            27u8,
                            123u8,
                            195u8,
                            169u8,
                            247u8,
                            50u8,
                            125u8,
                            245u8,
                            111u8,
                        ],
                    )
                }
            }
        }
        /**
			The [event](https://docs.substrate.io/main-docs/build/events-errors/) emitted
			by this pallet.
			*/
        pub type Event = runtime_types::pallet_bags_list::pallet::Event;
        pub mod events {
            use super::runtime_types;
            #[derive(
                ::subxt::ext::codec::Decode,
                ::subxt::ext::codec::Encode,
                ::subxt::ext::scale_decode::DecodeAsType,
                ::subxt::ext::scale_encode::EncodeAsType,
                Clone,
                Debug,
                Eq,
                PartialEq
            )]
            #[codec(crate = ::subxt::ext::codec)]
            #[decode_as_type(crate_path = ":: subxt :: ext :: scale_decode")]
            #[encode_as_type(crate_path = ":: subxt :: ext :: scale_encode")]
            ///Moved an account from one bag to another.
            pub struct Rebagged {
                pub who: ::subxt::utils::AccountId32,
                pub from: ::core::primitive::u64,
                pub to: ::core::primitive::u64,
            }
            impl ::subxt::events::StaticEvent for Rebagged {
                const PALLET: &'static str = "BagsList";
                const EVENT: &'static str = "Rebagged";
            }
            #[derive(
                ::subxt::ext::codec::Decode,
                ::subxt::ext::codec::Encode,
                ::subxt::ext::scale_decode::DecodeAsType,
                ::subxt::ext::scale_encode::EncodeAsType,
                Clone,
                Debug,
                Eq,
                PartialEq
            )]
            #[codec(crate = ::subxt::ext::codec)]
            #[decode_as_type(crate_path = ":: subxt :: ext :: scale_decode")]
            #[encode_as_type(crate_path = ":: subxt :: ext :: scale_encode")]
            ///Updated the score of some account to the given amount.
            pub struct ScoreUpdated {
                pub who: ::subxt::utils::AccountId32,
                pub new_score: ::core::primitive::u64,
            }
            impl ::subxt::events::StaticEvent for ScoreUpdated {
                const PALLET: &'static str = "BagsList";
                const EVENT: &'static str = "ScoreUpdated";
            }
        }
        pub mod storage {
            use super::runtime_types;
            pub struct StorageApi;
            impl StorageApi {
                /// A single node, within some bag.
                ///
                /// Nodes store links forward and back within their respective bags.
                pub fn list_nodes(
                    &self,
                    _0: impl ::std::borrow::Borrow<::subxt::utils::AccountId32>,
                ) -> ::subxt::storage::address::Address<
                    ::subxt::storage::address::StaticStorageMapKey,
                    runtime_types::pallet_bags_list::list::Node,
                    ::subxt::storage::address::Yes,
                    (),
                    ::subxt::storage::address::Yes,
                > {
                    ::subxt::storage::address::Address::new_static(
                        "BagsList",
                        "ListNodes",
                        vec![
                            ::subxt::storage::address::make_static_storage_map_key(_0
                            .borrow())
                        ],
                        [
                            252u8,
                            218u8,
                            186u8,
                            230u8,
                            86u8,
                            177u8,
                            112u8,
                            218u8,
                            9u8,
                            62u8,
                            217u8,
                            5u8,
                            39u8,
                            70u8,
                            15u8,
                            104u8,
                            157u8,
                            19u8,
                            175u8,
                            136u8,
                            71u8,
                            237u8,
                            254u8,
                            254u8,
                            119u8,
                            107u8,
                            84u8,
                            10u8,
                            104u8,
                            142u8,
                            135u8,
                            35u8,
                        ],
                    )
                }
                /// A single node, within some bag.
                ///
                /// Nodes store links forward and back within their respective bags.
                pub fn list_nodes_root(
                    &self,
                ) -> ::subxt::storage::address::Address<
                    ::subxt::storage::address::StaticStorageMapKey,
                    runtime_types::pallet_bags_list::list::Node,
                    (),
                    (),
                    ::subxt::storage::address::Yes,
                > {
                    ::subxt::storage::address::Address::new_static(
                        "BagsList",
                        "ListNodes",
                        Vec::new(),
                        [
                            252u8,
                            218u8,
                            186u8,
                            230u8,
                            86u8,
                            177u8,
                            112u8,
                            218u8,
                            9u8,
                            62u8,
                            217u8,
                            5u8,
                            39u8,
                            70u8,
                            15u8,
                            104u8,
                            157u8,
                            19u8,
                            175u8,
                            136u8,
                            71u8,
                            237u8,
                            254u8,
                            254u8,
                            119u8,
                            107u8,
                            84u8,
                            10u8,
                            104u8,
                            142u8,
                            135u8,
                            35u8,
                        ],
                    )
                }
                ///Counter for the related counted storage map
                pub fn counter_for_list_nodes(
                    &self,
                ) -> ::subxt::storage::address::Address<
                    ::subxt::storage::address::StaticStorageMapKey,
                    ::core::primitive::u32,
                    ::subxt::storage::address::Yes,
                    ::subxt::storage::address::Yes,
                    (),
                > {
                    ::subxt::storage::address::Address::new_static(
                        "BagsList",
                        "CounterForListNodes",
                        vec![],
                        [
                            126u8,
                            150u8,
                            201u8,
                            81u8,
                            155u8,
                            79u8,
                            50u8,
                            48u8,
                            120u8,
                            170u8,
                            3u8,
                            104u8,
                            112u8,
                            254u8,
                            106u8,
                            46u8,
                            108u8,
                            126u8,
                            158u8,
                            245u8,
                            95u8,
                            88u8,
                            236u8,
                            89u8,
                            79u8,
                            172u8,
                            13u8,
                            146u8,
                            202u8,
                            151u8,
                            122u8,
                            132u8,
                        ],
                    )
                }
                /// A bag stored in storage.
                ///
                /// Stores a `Bag` struct, which stores head and tail pointers to itself.
                pub fn list_bags(
                    &self,
                    _0: impl ::std::borrow::Borrow<::core::primitive::u64>,
                ) -> ::subxt::storage::address::Address<
                    ::subxt::storage::address::StaticStorageMapKey,
                    runtime_types::pallet_bags_list::list::Bag,
                    ::subxt::storage::address::Yes,
                    (),
                    ::subxt::storage::address::Yes,
                > {
                    ::subxt::storage::address::Address::new_static(
                        "BagsList",
                        "ListBags",
                        vec![
                            ::subxt::storage::address::make_static_storage_map_key(_0
                            .borrow())
                        ],
                        [
                            157u8,
                            147u8,
                            94u8,
                            26u8,
                            37u8,
                            89u8,
                            114u8,
                            210u8,
                            158u8,
                            36u8,
                            155u8,
                            0u8,
                            137u8,
                            78u8,
                            65u8,
                            165u8,
                            226u8,
                            192u8,
                            65u8,
                            13u8,
                            244u8,
                            159u8,
                            245u8,
                            15u8,
                            210u8,
                            101u8,
                            61u8,
                            111u8,
                            217u8,
                            225u8,
                            197u8,
                            158u8,
                        ],
                    )
                }
                /// A bag stored in storage.
                ///
                /// Stores a `Bag` struct, which stores head and tail pointers to itself.
                pub fn list_bags_root(
                    &self,
                ) -> ::subxt::storage::address::Address<
                    ::subxt::storage::address::StaticStorageMapKey,
                    runtime_types::pallet_bags_list::list::Bag,
                    (),
                    (),
                    ::subxt::storage::address::Yes,
                > {
                    ::subxt::storage::address::Address::new_static(
                        "BagsList",
                        "ListBags",
                        Vec::new(),
                        [
                            157u8,
                            147u8,
                            94u8,
                            26u8,
                            37u8,
                            89u8,
                            114u8,
                            210u8,
                            158u8,
                            36u8,
                            155u8,
                            0u8,
                            137u8,
                            78u8,
                            65u8,
                            165u8,
                            226u8,
                            192u8,
                            65u8,
                            13u8,
                            244u8,
                            159u8,
                            245u8,
                            15u8,
                            210u8,
                            101u8,
                            61u8,
                            111u8,
                            217u8,
                            225u8,
                            197u8,
                            158u8,
                        ],
                    )
                }
            }
        }
        pub mod constants {
            use super::runtime_types;
            pub struct ConstantsApi;
            impl ConstantsApi {
                /// The list of thresholds separating the various bags.
                ///
                /// Ids are separated into unsorted bags according to their score. This specifies the
                /// thresholds separating the bags. An id's bag is the largest bag for which the id's score
                /// is less than or equal to its upper threshold.
                ///
                /// When ids are iterated, higher bags are iterated completely before lower bags. This means
                /// that iteration is _semi-sorted_: ids of higher score tend to come before ids of lower
                /// score, but peer ids within a particular bag are sorted in insertion order.
                ///
                /// # Expressing the constant
                ///
                /// This constant must be sorted in strictly increasing order. Duplicate items are not
                /// permitted.
                ///
                /// There is an implied upper limit of `Score::MAX`; that value does not need to be
                /// specified within the bag. For any two threshold lists, if one ends with
                /// `Score::MAX`, the other one does not, and they are otherwise equal, the two
                /// lists will behave identically.
                ///
                /// # Calculation
                ///
                /// It is recommended to generate the set of thresholds in a geometric series, such that
                /// there exists some constant ratio such that `threshold[k + 1] == (threshold[k] *
                /// constant_ratio).max(threshold[k] + 1)` for all `k`.
                ///
                /// The helpers in the `/utils/frame/generate-bags` module can simplify this calculation.
                ///
                /// # Examples
                ///
                /// - If `BagThresholds::get().is_empty()`, then all ids are put into the same bag, and
                ///   iteration is strictly in insertion order.
                /// - If `BagThresholds::get().len() == 64`, and the thresholds are determined according to
                ///   the procedure given above, then the constant ratio is equal to 2.
                /// - If `BagThresholds::get().len() == 200`, and the thresholds are determined according to
                ///   the procedure given above, then the constant ratio is approximately equal to 1.248.
                /// - If the threshold list begins `[1, 2, 3, ...]`, then an id with score 0 or 1 will fall
                ///   into bag 0, an id with score 2 will fall into bag 1, etc.
                ///
                /// # Migration
                ///
                /// In the event that this list ever changes, a copy of the old bags list must be retained.
                /// With that `List::migrate` can be called, which will perform the appropriate migration.
                pub fn bag_thresholds(
                    &self,
                ) -> ::subxt::constants::Address<
                    ::std::vec::Vec<::core::primitive::u64>,
                > {
                    ::subxt::constants::Address::new_static(
                        "BagsList",
                        "BagThresholds",
                        [
                            215u8,
                            118u8,
                            183u8,
                            172u8,
                            4u8,
                            42u8,
                            248u8,
                            108u8,
                            4u8,
                            110u8,
                            43u8,
                            165u8,
                            228u8,
                            7u8,
                            36u8,
                            30u8,
                            135u8,
                            184u8,
                            56u8,
                            201u8,
                            107u8,
                            68u8,
                            25u8,
                            164u8,
                            134u8,
                            32u8,
                            82u8,
                            107u8,
                            200u8,
                            219u8,
                            212u8,
                            198u8,
                        ],
                    )
                }
            }
        }
    }
    pub mod nomination_pools {
        use super::root_mod;
        use super::runtime_types;
        /**
			Custom [dispatch errors](https://docs.substrate.io/main-docs/build/events-errors/)
			of this pallet.
			*/
        pub type Error = runtime_types::pallet_nomination_pools::pallet::Error;
        ///Contains one variant per dispatchable that can be called by an extrinsic.
        pub type Call = runtime_types::pallet_nomination_pools::pallet::Call;
        pub mod calls {
            use super::root_mod;
            use super::runtime_types;
            type DispatchError = runtime_types::sp_runtime::DispatchError;
            pub mod types {
                use super::runtime_types;
                #[derive(
                    ::subxt::ext::codec::Decode,
                    ::subxt::ext::codec::Encode,
                    ::subxt::ext::scale_decode::DecodeAsType,
                    ::subxt::ext::scale_encode::EncodeAsType,
                    Clone,
                    Debug,
                    Eq,
                    PartialEq
                )]
                #[codec(crate = ::subxt::ext::codec)]
                #[decode_as_type(crate_path = ":: subxt :: ext :: scale_decode")]
                #[encode_as_type(crate_path = ":: subxt :: ext :: scale_encode")]
                pub struct Join {
                    #[codec(compact)]
                    pub amount: ::core::primitive::u128,
                    pub pool_id: ::core::primitive::u32,
                }
                impl ::subxt::blocks::StaticExtrinsic for Join {
                    const PALLET: &'static str = "NominationPools";
                    const CALL: &'static str = "join";
                }
                #[derive(
                    ::subxt::ext::codec::Decode,
                    ::subxt::ext::codec::Encode,
                    ::subxt::ext::scale_decode::DecodeAsType,
                    ::subxt::ext::scale_encode::EncodeAsType,
                    Clone,
                    Debug,
                    Eq,
                    PartialEq
                )]
                #[codec(crate = ::subxt::ext::codec)]
                #[decode_as_type(crate_path = ":: subxt :: ext :: scale_decode")]
                #[encode_as_type(crate_path = ":: subxt :: ext :: scale_encode")]
                pub struct BondExtra {
                    pub extra: runtime_types::pallet_nomination_pools::BondExtra<
                        ::core::primitive::u128,
                    >,
                }
                impl ::subxt::blocks::StaticExtrinsic for BondExtra {
                    const PALLET: &'static str = "NominationPools";
                    const CALL: &'static str = "bond_extra";
                }
                #[derive(
                    ::subxt::ext::codec::Decode,
                    ::subxt::ext::codec::Encode,
                    ::subxt::ext::scale_decode::DecodeAsType,
                    ::subxt::ext::scale_encode::EncodeAsType,
                    Clone,
                    Debug,
                    Eq,
                    PartialEq
                )]
                #[codec(crate = ::subxt::ext::codec)]
                #[decode_as_type(crate_path = ":: subxt :: ext :: scale_decode")]
                #[encode_as_type(crate_path = ":: subxt :: ext :: scale_encode")]
                pub struct ClaimPayout;
                impl ::subxt::blocks::StaticExtrinsic for ClaimPayout {
                    const PALLET: &'static str = "NominationPools";
                    const CALL: &'static str = "claim_payout";
                }
                #[derive(
                    ::subxt::ext::codec::Decode,
                    ::subxt::ext::codec::Encode,
                    ::subxt::ext::scale_decode::DecodeAsType,
                    ::subxt::ext::scale_encode::EncodeAsType,
                    Clone,
                    Debug,
                    Eq,
                    PartialEq
                )]
                #[codec(crate = ::subxt::ext::codec)]
                #[decode_as_type(crate_path = ":: subxt :: ext :: scale_decode")]
                #[encode_as_type(crate_path = ":: subxt :: ext :: scale_encode")]
                pub struct Unbond {
                    pub member_account: ::subxt::utils::MultiAddress<
                        ::subxt::utils::AccountId32,
                        ::core::primitive::u32,
                    >,
                    #[codec(compact)]
                    pub unbonding_points: ::core::primitive::u128,
                }
                impl ::subxt::blocks::StaticExtrinsic for Unbond {
                    const PALLET: &'static str = "NominationPools";
                    const CALL: &'static str = "unbond";
                }
                #[derive(
                    ::subxt::ext::codec::Decode,
                    ::subxt::ext::codec::Encode,
                    ::subxt::ext::scale_decode::DecodeAsType,
                    ::subxt::ext::scale_encode::EncodeAsType,
                    Clone,
                    Debug,
                    Eq,
                    PartialEq
                )]
                #[codec(crate = ::subxt::ext::codec)]
                #[decode_as_type(crate_path = ":: subxt :: ext :: scale_decode")]
                #[encode_as_type(crate_path = ":: subxt :: ext :: scale_encode")]
                pub struct PoolWithdrawUnbonded {
                    pub pool_id: ::core::primitive::u32,
                    pub num_slashing_spans: ::core::primitive::u32,
                }
                impl ::subxt::blocks::StaticExtrinsic for PoolWithdrawUnbonded {
                    const PALLET: &'static str = "NominationPools";
                    const CALL: &'static str = "pool_withdraw_unbonded";
                }
                #[derive(
                    ::subxt::ext::codec::Decode,
                    ::subxt::ext::codec::Encode,
                    ::subxt::ext::scale_decode::DecodeAsType,
                    ::subxt::ext::scale_encode::EncodeAsType,
                    Clone,
                    Debug,
                    Eq,
                    PartialEq
                )]
                #[codec(crate = ::subxt::ext::codec)]
                #[decode_as_type(crate_path = ":: subxt :: ext :: scale_decode")]
                #[encode_as_type(crate_path = ":: subxt :: ext :: scale_encode")]
                pub struct WithdrawUnbonded {
                    pub member_account: ::subxt::utils::MultiAddress<
                        ::subxt::utils::AccountId32,
                        ::core::primitive::u32,
                    >,
                    pub num_slashing_spans: ::core::primitive::u32,
                }
                impl ::subxt::blocks::StaticExtrinsic for WithdrawUnbonded {
                    const PALLET: &'static str = "NominationPools";
                    const CALL: &'static str = "withdraw_unbonded";
                }
                #[derive(
                    ::subxt::ext::codec::Decode,
                    ::subxt::ext::codec::Encode,
                    ::subxt::ext::scale_decode::DecodeAsType,
                    ::subxt::ext::scale_encode::EncodeAsType,
                    Clone,
                    Debug,
                    Eq,
                    PartialEq
                )]
                #[codec(crate = ::subxt::ext::codec)]
                #[decode_as_type(crate_path = ":: subxt :: ext :: scale_decode")]
                #[encode_as_type(crate_path = ":: subxt :: ext :: scale_encode")]
                pub struct Create {
                    #[codec(compact)]
                    pub amount: ::core::primitive::u128,
                    pub root: ::subxt::utils::MultiAddress<
                        ::subxt::utils::AccountId32,
                        ::core::primitive::u32,
                    >,
                    pub nominator: ::subxt::utils::MultiAddress<
                        ::subxt::utils::AccountId32,
                        ::core::primitive::u32,
                    >,
                    pub bouncer: ::subxt::utils::MultiAddress<
                        ::subxt::utils::AccountId32,
                        ::core::primitive::u32,
                    >,
                }
                impl ::subxt::blocks::StaticExtrinsic for Create {
                    const PALLET: &'static str = "NominationPools";
                    const CALL: &'static str = "create";
                }
                #[derive(
                    ::subxt::ext::codec::Decode,
                    ::subxt::ext::codec::Encode,
                    ::subxt::ext::scale_decode::DecodeAsType,
                    ::subxt::ext::scale_encode::EncodeAsType,
                    Clone,
                    Debug,
                    Eq,
                    PartialEq
                )]
                #[codec(crate = ::subxt::ext::codec)]
                #[decode_as_type(crate_path = ":: subxt :: ext :: scale_decode")]
                #[encode_as_type(crate_path = ":: subxt :: ext :: scale_encode")]
                pub struct CreateWithPoolId {
                    #[codec(compact)]
                    pub amount: ::core::primitive::u128,
                    pub root: ::subxt::utils::MultiAddress<
                        ::subxt::utils::AccountId32,
                        ::core::primitive::u32,
                    >,
                    pub nominator: ::subxt::utils::MultiAddress<
                        ::subxt::utils::AccountId32,
                        ::core::primitive::u32,
                    >,
                    pub bouncer: ::subxt::utils::MultiAddress<
                        ::subxt::utils::AccountId32,
                        ::core::primitive::u32,
                    >,
                    pub pool_id: ::core::primitive::u32,
                }
                impl ::subxt::blocks::StaticExtrinsic for CreateWithPoolId {
                    const PALLET: &'static str = "NominationPools";
                    const CALL: &'static str = "create_with_pool_id";
                }
                #[derive(
                    ::subxt::ext::codec::Decode,
                    ::subxt::ext::codec::Encode,
                    ::subxt::ext::scale_decode::DecodeAsType,
                    ::subxt::ext::scale_encode::EncodeAsType,
                    Clone,
                    Debug,
                    Eq,
                    PartialEq
                )]
                #[codec(crate = ::subxt::ext::codec)]
                #[decode_as_type(crate_path = ":: subxt :: ext :: scale_decode")]
                #[encode_as_type(crate_path = ":: subxt :: ext :: scale_encode")]
                pub struct Nominate {
                    pub pool_id: ::core::primitive::u32,
                    pub validators: ::std::vec::Vec<::subxt::utils::AccountId32>,
                }
                impl ::subxt::blocks::StaticExtrinsic for Nominate {
                    const PALLET: &'static str = "NominationPools";
                    const CALL: &'static str = "nominate";
                }
                #[derive(
                    ::subxt::ext::codec::Decode,
                    ::subxt::ext::codec::Encode,
                    ::subxt::ext::scale_decode::DecodeAsType,
                    ::subxt::ext::scale_encode::EncodeAsType,
                    Clone,
                    Debug,
                    Eq,
                    PartialEq
                )]
                #[codec(crate = ::subxt::ext::codec)]
                #[decode_as_type(crate_path = ":: subxt :: ext :: scale_decode")]
                #[encode_as_type(crate_path = ":: subxt :: ext :: scale_encode")]
                pub struct SetState {
                    pub pool_id: ::core::primitive::u32,
                    pub state: runtime_types::pallet_nomination_pools::PoolState,
                }
                impl ::subxt::blocks::StaticExtrinsic for SetState {
                    const PALLET: &'static str = "NominationPools";
                    const CALL: &'static str = "set_state";
                }
                #[derive(
                    ::subxt::ext::codec::Decode,
                    ::subxt::ext::codec::Encode,
                    ::subxt::ext::scale_decode::DecodeAsType,
                    ::subxt::ext::scale_encode::EncodeAsType,
                    Clone,
                    Debug,
                    Eq,
                    PartialEq
                )]
                #[codec(crate = ::subxt::ext::codec)]
                #[decode_as_type(crate_path = ":: subxt :: ext :: scale_decode")]
                #[encode_as_type(crate_path = ":: subxt :: ext :: scale_encode")]
                pub struct SetMetadata {
                    pub pool_id: ::core::primitive::u32,
                    pub metadata: ::std::vec::Vec<::core::primitive::u8>,
                }
                impl ::subxt::blocks::StaticExtrinsic for SetMetadata {
                    const PALLET: &'static str = "NominationPools";
                    const CALL: &'static str = "set_metadata";
                }
                #[derive(
                    ::subxt::ext::codec::Decode,
                    ::subxt::ext::codec::Encode,
                    ::subxt::ext::scale_decode::DecodeAsType,
                    ::subxt::ext::scale_encode::EncodeAsType,
                    Clone,
                    Debug,
                    Eq,
                    PartialEq
                )]
                #[codec(crate = ::subxt::ext::codec)]
                #[decode_as_type(crate_path = ":: subxt :: ext :: scale_decode")]
                #[encode_as_type(crate_path = ":: subxt :: ext :: scale_encode")]
                pub struct SetConfigs {
                    pub min_join_bond: runtime_types::pallet_nomination_pools::ConfigOp<
                        ::core::primitive::u128,
                    >,
                    pub min_create_bond: runtime_types::pallet_nomination_pools::ConfigOp<
                        ::core::primitive::u128,
                    >,
                    pub max_pools: runtime_types::pallet_nomination_pools::ConfigOp<
                        ::core::primitive::u32,
                    >,
                    pub max_members: runtime_types::pallet_nomination_pools::ConfigOp<
                        ::core::primitive::u32,
                    >,
                    pub max_members_per_pool: runtime_types::pallet_nomination_pools::ConfigOp<
                        ::core::primitive::u32,
                    >,
                    pub global_max_commission: runtime_types::pallet_nomination_pools::ConfigOp<
                        runtime_types::sp_arithmetic::per_things::Perbill,
                    >,
                }
                impl ::subxt::blocks::StaticExtrinsic for SetConfigs {
                    const PALLET: &'static str = "NominationPools";
                    const CALL: &'static str = "set_configs";
                }
                #[derive(
                    ::subxt::ext::codec::Decode,
                    ::subxt::ext::codec::Encode,
                    ::subxt::ext::scale_decode::DecodeAsType,
                    ::subxt::ext::scale_encode::EncodeAsType,
                    Clone,
                    Debug,
                    Eq,
                    PartialEq
                )]
                #[codec(crate = ::subxt::ext::codec)]
                #[decode_as_type(crate_path = ":: subxt :: ext :: scale_decode")]
                #[encode_as_type(crate_path = ":: subxt :: ext :: scale_encode")]
                pub struct UpdateRoles {
                    pub pool_id: ::core::primitive::u32,
                    pub new_root: runtime_types::pallet_nomination_pools::ConfigOp<
                        ::subxt::utils::AccountId32,
                    >,
                    pub new_nominator: runtime_types::pallet_nomination_pools::ConfigOp<
                        ::subxt::utils::AccountId32,
                    >,
                    pub new_bouncer: runtime_types::pallet_nomination_pools::ConfigOp<
                        ::subxt::utils::AccountId32,
                    >,
                }
                impl ::subxt::blocks::StaticExtrinsic for UpdateRoles {
                    const PALLET: &'static str = "NominationPools";
                    const CALL: &'static str = "update_roles";
                }
                #[derive(
                    ::subxt::ext::codec::CompactAs,
                    ::subxt::ext::codec::Decode,
                    ::subxt::ext::codec::Encode,
                    ::subxt::ext::scale_decode::DecodeAsType,
                    ::subxt::ext::scale_encode::EncodeAsType,
                    Clone,
                    Debug,
                    Eq,
                    PartialEq
                )]
                #[codec(crate = ::subxt::ext::codec)]
                #[decode_as_type(crate_path = ":: subxt :: ext :: scale_decode")]
                #[encode_as_type(crate_path = ":: subxt :: ext :: scale_encode")]
                pub struct Chill {
                    pub pool_id: ::core::primitive::u32,
                }
                impl ::subxt::blocks::StaticExtrinsic for Chill {
                    const PALLET: &'static str = "NominationPools";
                    const CALL: &'static str = "chill";
                }
                #[derive(
                    ::subxt::ext::codec::Decode,
                    ::subxt::ext::codec::Encode,
                    ::subxt::ext::scale_decode::DecodeAsType,
                    ::subxt::ext::scale_encode::EncodeAsType,
                    Clone,
                    Debug,
                    Eq,
                    PartialEq
                )]
                #[codec(crate = ::subxt::ext::codec)]
                #[decode_as_type(crate_path = ":: subxt :: ext :: scale_decode")]
                #[encode_as_type(crate_path = ":: subxt :: ext :: scale_encode")]
                pub struct BondExtraOther {
                    pub member: ::subxt::utils::MultiAddress<
                        ::subxt::utils::AccountId32,
                        ::core::primitive::u32,
                    >,
                    pub extra: runtime_types::pallet_nomination_pools::BondExtra<
                        ::core::primitive::u128,
                    >,
                }
                impl ::subxt::blocks::StaticExtrinsic for BondExtraOther {
                    const PALLET: &'static str = "NominationPools";
                    const CALL: &'static str = "bond_extra_other";
                }
                #[derive(
                    ::subxt::ext::codec::Decode,
                    ::subxt::ext::codec::Encode,
                    ::subxt::ext::scale_decode::DecodeAsType,
                    ::subxt::ext::scale_encode::EncodeAsType,
                    Clone,
                    Debug,
                    Eq,
                    PartialEq
                )]
                #[codec(crate = ::subxt::ext::codec)]
                #[decode_as_type(crate_path = ":: subxt :: ext :: scale_decode")]
                #[encode_as_type(crate_path = ":: subxt :: ext :: scale_encode")]
                pub struct SetClaimPermission {
                    pub permission: runtime_types::pallet_nomination_pools::ClaimPermission,
                }
                impl ::subxt::blocks::StaticExtrinsic for SetClaimPermission {
                    const PALLET: &'static str = "NominationPools";
                    const CALL: &'static str = "set_claim_permission";
                }
                #[derive(
                    ::subxt::ext::codec::Decode,
                    ::subxt::ext::codec::Encode,
                    ::subxt::ext::scale_decode::DecodeAsType,
                    ::subxt::ext::scale_encode::EncodeAsType,
                    Clone,
                    Debug,
                    Eq,
                    PartialEq
                )]
                #[codec(crate = ::subxt::ext::codec)]
                #[decode_as_type(crate_path = ":: subxt :: ext :: scale_decode")]
                #[encode_as_type(crate_path = ":: subxt :: ext :: scale_encode")]
                pub struct ClaimPayoutOther {
                    pub other: ::subxt::utils::AccountId32,
                }
                impl ::subxt::blocks::StaticExtrinsic for ClaimPayoutOther {
                    const PALLET: &'static str = "NominationPools";
                    const CALL: &'static str = "claim_payout_other";
                }
                #[derive(
                    ::subxt::ext::codec::Decode,
                    ::subxt::ext::codec::Encode,
                    ::subxt::ext::scale_decode::DecodeAsType,
                    ::subxt::ext::scale_encode::EncodeAsType,
                    Clone,
                    Debug,
                    Eq,
                    PartialEq
                )]
                #[codec(crate = ::subxt::ext::codec)]
                #[decode_as_type(crate_path = ":: subxt :: ext :: scale_decode")]
                #[encode_as_type(crate_path = ":: subxt :: ext :: scale_encode")]
                pub struct SetCommission {
                    pub pool_id: ::core::primitive::u32,
                    pub new_commission: ::core::option::Option<
                        (
                            runtime_types::sp_arithmetic::per_things::Perbill,
                            ::subxt::utils::AccountId32,
                        ),
                    >,
                }
                impl ::subxt::blocks::StaticExtrinsic for SetCommission {
                    const PALLET: &'static str = "NominationPools";
                    const CALL: &'static str = "set_commission";
                }
                #[derive(
                    ::subxt::ext::codec::Decode,
                    ::subxt::ext::codec::Encode,
                    ::subxt::ext::scale_decode::DecodeAsType,
                    ::subxt::ext::scale_encode::EncodeAsType,
                    Clone,
                    Debug,
                    Eq,
                    PartialEq
                )]
                #[codec(crate = ::subxt::ext::codec)]
                #[decode_as_type(crate_path = ":: subxt :: ext :: scale_decode")]
                #[encode_as_type(crate_path = ":: subxt :: ext :: scale_encode")]
                pub struct SetCommissionMax {
                    pub pool_id: ::core::primitive::u32,
                    pub max_commission: runtime_types::sp_arithmetic::per_things::Perbill,
                }
                impl ::subxt::blocks::StaticExtrinsic for SetCommissionMax {
                    const PALLET: &'static str = "NominationPools";
                    const CALL: &'static str = "set_commission_max";
                }
                #[derive(
                    ::subxt::ext::codec::Decode,
                    ::subxt::ext::codec::Encode,
                    ::subxt::ext::scale_decode::DecodeAsType,
                    ::subxt::ext::scale_encode::EncodeAsType,
                    Clone,
                    Debug,
                    Eq,
                    PartialEq
                )]
                #[codec(crate = ::subxt::ext::codec)]
                #[decode_as_type(crate_path = ":: subxt :: ext :: scale_decode")]
                #[encode_as_type(crate_path = ":: subxt :: ext :: scale_encode")]
                pub struct SetCommissionChangeRate {
                    pub pool_id: ::core::primitive::u32,
                    pub change_rate: runtime_types::pallet_nomination_pools::CommissionChangeRate<
                        ::core::primitive::u32,
                    >,
                }
                impl ::subxt::blocks::StaticExtrinsic for SetCommissionChangeRate {
                    const PALLET: &'static str = "NominationPools";
                    const CALL: &'static str = "set_commission_change_rate";
                }
                #[derive(
                    ::subxt::ext::codec::CompactAs,
                    ::subxt::ext::codec::Decode,
                    ::subxt::ext::codec::Encode,
                    ::subxt::ext::scale_decode::DecodeAsType,
                    ::subxt::ext::scale_encode::EncodeAsType,
                    Clone,
                    Debug,
                    Eq,
                    PartialEq
                )]
                #[codec(crate = ::subxt::ext::codec)]
                #[decode_as_type(crate_path = ":: subxt :: ext :: scale_decode")]
                #[encode_as_type(crate_path = ":: subxt :: ext :: scale_encode")]
                pub struct ClaimCommission {
                    pub pool_id: ::core::primitive::u32,
                }
                impl ::subxt::blocks::StaticExtrinsic for ClaimCommission {
                    const PALLET: &'static str = "NominationPools";
                    const CALL: &'static str = "claim_commission";
                }
            }
            pub struct TransactionApi;
            impl TransactionApi {
                ///Stake funds with a pool. The amount to bond is transferred from the member to the
                ///pools account and immediately increases the pools bond.
                ///
                ///# Note
                ///
                ///* An account can only be a member of a single pool.
                ///* An account cannot join the same pool multiple times.
                ///* This call will *not* dust the member account, so the member must have at least
                ///  `existential deposit + amount` in their account.
                ///* Only a pool with [`PoolState::Open`] can be joined
                pub fn join(
                    &self,
                    amount: ::core::primitive::u128,
                    pool_id: ::core::primitive::u32,
                ) -> ::subxt::tx::Payload<types::Join> {
                    ::subxt::tx::Payload::new_static(
                        "NominationPools",
                        "join",
                        types::Join { amount, pool_id },
                        [
                            9u8,
                            24u8,
                            209u8,
                            117u8,
                            242u8,
                            76u8,
                            192u8,
                            40u8,
                            196u8,
                            136u8,
                            158u8,
                            182u8,
                            117u8,
                            140u8,
                            164u8,
                            64u8,
                            184u8,
                            160u8,
                            146u8,
                            143u8,
                            173u8,
                            180u8,
                            6u8,
                            242u8,
                            203u8,
                            130u8,
                            41u8,
                            176u8,
                            158u8,
                            96u8,
                            94u8,
                            175u8,
                        ],
                    )
                }
                ///Bond `extra` more funds from `origin` into the pool to which they already belong.
                ///
                ///Additional funds can come from either the free balance of the account, of from the
                ///accumulated rewards, see [`BondExtra`].
                ///
                ///Bonding extra funds implies an automatic payout of all pending rewards as well.
                ///See `bond_extra_other` to bond pending rewards of `other` members.
                pub fn bond_extra(
                    &self,
                    extra: runtime_types::pallet_nomination_pools::BondExtra<
                        ::core::primitive::u128,
                    >,
                ) -> ::subxt::tx::Payload<types::BondExtra> {
                    ::subxt::tx::Payload::new_static(
                        "NominationPools",
                        "bond_extra",
                        types::BondExtra { extra },
                        [
                            149u8,
                            176u8,
                            102u8,
                            52u8,
                            76u8,
                            227u8,
                            61u8,
                            60u8,
                            109u8,
                            187u8,
                            40u8,
                            176u8,
                            163u8,
                            37u8,
                            10u8,
                            228u8,
                            164u8,
                            77u8,
                            155u8,
                            155u8,
                            14u8,
                            106u8,
                            5u8,
                            177u8,
                            176u8,
                            224u8,
                            163u8,
                            28u8,
                            66u8,
                            237u8,
                            186u8,
                            188u8,
                        ],
                    )
                }
                ///A bonded member can use this to claim their payout based on the rewards that the pool
                ///has accumulated since their last claimed payout (OR since joining if this is their first
                ///time claiming rewards). The payout will be transferred to the member's account.
                ///
                ///The member will earn rewards pro rata based on the members stake vs the sum of the
                ///members in the pools stake. Rewards do not "expire".
                ///
                ///See `claim_payout_other` to caim rewards on bahalf of some `other` pool member.
                pub fn claim_payout(&self) -> ::subxt::tx::Payload<types::ClaimPayout> {
                    ::subxt::tx::Payload::new_static(
                        "NominationPools",
                        "claim_payout",
                        types::ClaimPayout {},
                        [
                            28u8,
                            87u8,
                            180u8,
                            5u8,
                            69u8,
                            49u8,
                            121u8,
                            28u8,
                            34u8,
                            63u8,
                            78u8,
                            228u8,
                            223u8,
                            12u8,
                            171u8,
                            41u8,
                            181u8,
                            137u8,
                            145u8,
                            141u8,
                            198u8,
                            220u8,
                            5u8,
                            101u8,
                            173u8,
                            69u8,
                            222u8,
                            59u8,
                            111u8,
                            92u8,
                            182u8,
                            8u8,
                        ],
                    )
                }
                ///Unbond up to `unbonding_points` of the `member_account`'s funds from the pool. It
                ///implicitly collects the rewards one last time, since not doing so would mean some
                ///rewards would be forfeited.
                ///
                ///Under certain conditions, this call can be dispatched permissionlessly (i.e. by any
                ///account).
                ///
                ///# Conditions for a permissionless dispatch.
                ///
                ///* The pool is blocked and the caller is either the root or bouncer. This is refereed to
                ///  as a kick.
                ///* The pool is destroying and the member is not the depositor.
                ///* The pool is destroying, the member is the depositor and no other members are in the
                ///  pool.
                ///
                ///## Conditions for permissioned dispatch (i.e. the caller is also the
                ///`member_account`):
                ///
                ///* The caller is not the depositor.
                ///* The caller is the depositor, the pool is destroying and no other members are in the
                ///  pool.
                ///
                ///# Note
                ///
                ///If there are too many unlocking chunks to unbond with the pool account,
                ///[`Call::pool_withdraw_unbonded`] can be called to try and minimize unlocking chunks.
                ///The [`StakingInterface::unbond`] will implicitly call [`Call::pool_withdraw_unbonded`]
                ///to try to free chunks if necessary (ie. if unbound was called and no unlocking chunks
                ///are available). However, it may not be possible to release the current unlocking chunks,
                ///in which case, the result of this call will likely be the `NoMoreChunks` error from the
                ///staking system.
                pub fn unbond(
                    &self,
                    member_account: ::subxt::utils::MultiAddress<
                        ::subxt::utils::AccountId32,
                        ::core::primitive::u32,
                    >,
                    unbonding_points: ::core::primitive::u128,
                ) -> ::subxt::tx::Payload<types::Unbond> {
                    ::subxt::tx::Payload::new_static(
                        "NominationPools",
                        "unbond",
                        types::Unbond {
                            member_account,
                            unbonding_points,
                        },
                        [
                            230u8,
                            112u8,
                            85u8,
                            216u8,
                            164u8,
                            250u8,
                            5u8,
                            18u8,
                            50u8,
                            206u8,
                            194u8,
                            0u8,
                            167u8,
                            149u8,
                            220u8,
                            212u8,
                            138u8,
                            33u8,
                            117u8,
                            130u8,
                            47u8,
                            197u8,
                            113u8,
                            30u8,
                            84u8,
                            83u8,
                            1u8,
                            105u8,
                            58u8,
                            182u8,
                            44u8,
                            225u8,
                        ],
                    )
                }
                ///Call `withdraw_unbonded` for the pools account. This call can be made by any account.
                ///
                ///This is useful if their are too many unlocking chunks to call `unbond`, and some
                ///can be cleared by withdrawing. In the case there are too many unlocking chunks, the user
                ///would probably see an error like `NoMoreChunks` emitted from the staking system when
                ///they attempt to unbond.
                pub fn pool_withdraw_unbonded(
                    &self,
                    pool_id: ::core::primitive::u32,
                    num_slashing_spans: ::core::primitive::u32,
                ) -> ::subxt::tx::Payload<types::PoolWithdrawUnbonded> {
                    ::subxt::tx::Payload::new_static(
                        "NominationPools",
                        "pool_withdraw_unbonded",
                        types::PoolWithdrawUnbonded {
                            pool_id,
                            num_slashing_spans,
                        },
                        [
                            234u8,
                            49u8,
                            43u8,
                            199u8,
                            55u8,
                            2u8,
                            252u8,
                            39u8,
                            147u8,
                            136u8,
                            34u8,
                            239u8,
                            116u8,
                            155u8,
                            129u8,
                            72u8,
                            83u8,
                            161u8,
                            90u8,
                            207u8,
                            1u8,
                            193u8,
                            254u8,
                            47u8,
                            40u8,
                            185u8,
                            67u8,
                            55u8,
                            238u8,
                            122u8,
                            140u8,
                            230u8,
                        ],
                    )
                }
                ///Withdraw unbonded funds from `member_account`. If no bonded funds can be unbonded, an
                ///error is returned.
                ///
                ///Under certain conditions, this call can be dispatched permissionlessly (i.e. by any
                ///account).
                ///
                ///# Conditions for a permissionless dispatch
                ///
                ///* The pool is in destroy mode and the target is not the depositor.
                ///* The target is the depositor and they are the only member in the sub pools.
                ///* The pool is blocked and the caller is either the root or bouncer.
                ///
                ///# Conditions for permissioned dispatch
                ///
                ///* The caller is the target and they are not the depositor.
                ///
                ///# Note
                ///
                ///If the target is the depositor, the pool will be destroyed.
                pub fn withdraw_unbonded(
                    &self,
                    member_account: ::subxt::utils::MultiAddress<
                        ::subxt::utils::AccountId32,
                        ::core::primitive::u32,
                    >,
                    num_slashing_spans: ::core::primitive::u32,
                ) -> ::subxt::tx::Payload<types::WithdrawUnbonded> {
                    ::subxt::tx::Payload::new_static(
                        "NominationPools",
                        "withdraw_unbonded",
                        types::WithdrawUnbonded {
                            member_account,
                            num_slashing_spans,
                        },
                        [
                            252u8,
                            38u8,
                            22u8,
                            98u8,
                            64u8,
                            133u8,
                            118u8,
                            62u8,
                            179u8,
                            226u8,
                            212u8,
                            186u8,
                            32u8,
                            227u8,
                            253u8,
                            119u8,
                            200u8,
                            53u8,
                            35u8,
                            193u8,
                            20u8,
                            64u8,
                            232u8,
                            35u8,
                            221u8,
                            37u8,
                            63u8,
                            10u8,
                            7u8,
                            250u8,
                            176u8,
                            238u8,
                        ],
                    )
                }
                ///Create a new delegation pool.
                ///
                ///# Arguments
                ///
                ///* `amount` - The amount of funds to delegate to the pool. This also acts of a sort of
                ///  deposit since the pools creator cannot fully unbond funds until the pool is being
                ///  destroyed.
                ///* `index` - A disambiguation index for creating the account. Likely only useful when
                ///  creating multiple pools in the same extrinsic.
                ///* `root` - The account to set as [`PoolRoles::root`].
                ///* `nominator` - The account to set as the [`PoolRoles::nominator`].
                ///* `bouncer` - The account to set as the [`PoolRoles::bouncer`].
                ///
                ///# Note
                ///
                ///In addition to `amount`, the caller will transfer the existential deposit; so the caller
                ///needs at have at least `amount + existential_deposit` transferrable.
                pub fn create(
                    &self,
                    amount: ::core::primitive::u128,
                    root: ::subxt::utils::MultiAddress<
                        ::subxt::utils::AccountId32,
                        ::core::primitive::u32,
                    >,
                    nominator: ::subxt::utils::MultiAddress<
                        ::subxt::utils::AccountId32,
                        ::core::primitive::u32,
                    >,
                    bouncer: ::subxt::utils::MultiAddress<
                        ::subxt::utils::AccountId32,
                        ::core::primitive::u32,
                    >,
                ) -> ::subxt::tx::Payload<types::Create> {
                    ::subxt::tx::Payload::new_static(
                        "NominationPools",
                        "create",
                        types::Create {
                            amount,
                            root,
                            nominator,
                            bouncer,
                        },
                        [
                            4u8,
                            111u8,
                            53u8,
                            212u8,
                            226u8,
                            159u8,
                            144u8,
                            191u8,
                            152u8,
                            252u8,
                            30u8,
                            169u8,
                            185u8,
                            150u8,
                            229u8,
                            234u8,
                            140u8,
                            46u8,
                            237u8,
                            197u8,
                            164u8,
                            233u8,
                            184u8,
                            60u8,
                            51u8,
                            184u8,
                            71u8,
                            40u8,
                            61u8,
                            140u8,
                            204u8,
                            100u8,
                        ],
                    )
                }
                ///Create a new delegation pool with a previously used pool id
                ///
                ///# Arguments
                ///
                ///same as `create` with the inclusion of
                ///* `pool_id` - `A valid PoolId.
                pub fn create_with_pool_id(
                    &self,
                    amount: ::core::primitive::u128,
                    root: ::subxt::utils::MultiAddress<
                        ::subxt::utils::AccountId32,
                        ::core::primitive::u32,
                    >,
                    nominator: ::subxt::utils::MultiAddress<
                        ::subxt::utils::AccountId32,
                        ::core::primitive::u32,
                    >,
                    bouncer: ::subxt::utils::MultiAddress<
                        ::subxt::utils::AccountId32,
                        ::core::primitive::u32,
                    >,
                    pool_id: ::core::primitive::u32,
                ) -> ::subxt::tx::Payload<types::CreateWithPoolId> {
                    ::subxt::tx::Payload::new_static(
                        "NominationPools",
                        "create_with_pool_id",
                        types::CreateWithPoolId {
                            amount,
                            root,
                            nominator,
                            bouncer,
                            pool_id,
                        },
                        [
                            102u8,
                            254u8,
                            178u8,
                            47u8,
                            79u8,
                            12u8,
                            230u8,
                            142u8,
                            226u8,
                            205u8,
                            25u8,
                            166u8,
                            133u8,
                            0u8,
                            172u8,
                            58u8,
                            75u8,
                            96u8,
                            71u8,
                            187u8,
                            237u8,
                            173u8,
                            156u8,
                            20u8,
                            78u8,
                            48u8,
                            62u8,
                            35u8,
                            130u8,
                            8u8,
                            117u8,
                            222u8,
                        ],
                    )
                }
                ///Nominate on behalf of the pool.
                ///
                ///The dispatch origin of this call must be signed by the pool nominator or the pool
                ///root role.
                ///
                ///This directly forward the call to the staking pallet, on behalf of the pool bonded
                ///account.
                pub fn nominate(
                    &self,
                    pool_id: ::core::primitive::u32,
                    validators: ::std::vec::Vec<::subxt::utils::AccountId32>,
                ) -> ::subxt::tx::Payload<types::Nominate> {
                    ::subxt::tx::Payload::new_static(
                        "NominationPools",
                        "nominate",
                        types::Nominate {
                            pool_id,
                            validators,
                        },
                        [
                            118u8,
                            80u8,
                            137u8,
                            47u8,
                            102u8,
                            9u8,
                            20u8,
                            136u8,
                            76u8,
                            164u8,
                            161u8,
                            114u8,
                            33u8,
                            159u8,
                            204u8,
                            49u8,
                            233u8,
                            199u8,
                            246u8,
                            67u8,
                            144u8,
                            169u8,
                            211u8,
                            67u8,
                            12u8,
                            68u8,
                            198u8,
                            149u8,
                            87u8,
                            62u8,
                            226u8,
                            72u8,
                        ],
                    )
                }
                ///Set a new state for the pool.
                ///
                ///If a pool is already in the `Destroying` state, then under no condition can its state
                ///change again.
                ///
                ///The dispatch origin of this call must be either:
                ///
                ///1. signed by the bouncer, or the root role of the pool,
                ///2. if the pool conditions to be open are NOT met (as described by `ok_to_be_open`), and
                ///   then the state of the pool can be permissionlessly changed to `Destroying`.
                pub fn set_state(
                    &self,
                    pool_id: ::core::primitive::u32,
                    state: runtime_types::pallet_nomination_pools::PoolState,
                ) -> ::subxt::tx::Payload<types::SetState> {
                    ::subxt::tx::Payload::new_static(
                        "NominationPools",
                        "set_state",
                        types::SetState { pool_id, state },
                        [
                            39u8,
                            221u8,
                            24u8,
                            65u8,
                            144u8,
                            230u8,
                            228u8,
                            24u8,
                            191u8,
                            53u8,
                            171u8,
                            148u8,
                            131u8,
                            45u8,
                            10u8,
                            22u8,
                            222u8,
                            240u8,
                            13u8,
                            87u8,
                            123u8,
                            182u8,
                            102u8,
                            26u8,
                            124u8,
                            205u8,
                            23u8,
                            31u8,
                            25u8,
                            43u8,
                            12u8,
                            140u8,
                        ],
                    )
                }
                ///Set a new metadata for the pool.
                ///
                ///The dispatch origin of this call must be signed by the bouncer, or the root role of the
                ///pool.
                pub fn set_metadata(
                    &self,
                    pool_id: ::core::primitive::u32,
                    metadata: ::std::vec::Vec<::core::primitive::u8>,
                ) -> ::subxt::tx::Payload<types::SetMetadata> {
                    ::subxt::tx::Payload::new_static(
                        "NominationPools",
                        "set_metadata",
                        types::SetMetadata {
                            pool_id,
                            metadata,
                        },
                        [
                            221u8,
                            189u8,
                            15u8,
                            232u8,
                            0u8,
                            49u8,
                            187u8,
                            67u8,
                            124u8,
                            26u8,
                            114u8,
                            191u8,
                            81u8,
                            14u8,
                            253u8,
                            75u8,
                            88u8,
                            182u8,
                            136u8,
                            18u8,
                            238u8,
                            119u8,
                            215u8,
                            248u8,
                            133u8,
                            160u8,
                            154u8,
                            193u8,
                            177u8,
                            140u8,
                            1u8,
                            16u8,
                        ],
                    )
                }
                ///Update configurations for the nomination pools. The origin for this call must be
                ///Root.
                ///
                ///# Arguments
                ///
                ///* `min_join_bond` - Set [`MinJoinBond`].
                ///* `min_create_bond` - Set [`MinCreateBond`].
                ///* `max_pools` - Set [`MaxPools`].
                ///* `max_members` - Set [`MaxPoolMembers`].
                ///* `max_members_per_pool` - Set [`MaxPoolMembersPerPool`].
                ///* `global_max_commission` - Set [`GlobalMaxCommission`].
                pub fn set_configs(
                    &self,
                    min_join_bond: runtime_types::pallet_nomination_pools::ConfigOp<
                        ::core::primitive::u128,
                    >,
                    min_create_bond: runtime_types::pallet_nomination_pools::ConfigOp<
                        ::core::primitive::u128,
                    >,
                    max_pools: runtime_types::pallet_nomination_pools::ConfigOp<
                        ::core::primitive::u32,
                    >,
                    max_members: runtime_types::pallet_nomination_pools::ConfigOp<
                        ::core::primitive::u32,
                    >,
                    max_members_per_pool: runtime_types::pallet_nomination_pools::ConfigOp<
                        ::core::primitive::u32,
                    >,
                    global_max_commission: runtime_types::pallet_nomination_pools::ConfigOp<
                        runtime_types::sp_arithmetic::per_things::Perbill,
                    >,
                ) -> ::subxt::tx::Payload<types::SetConfigs> {
                    ::subxt::tx::Payload::new_static(
                        "NominationPools",
                        "set_configs",
                        types::SetConfigs {
                            min_join_bond,
                            min_create_bond,
                            max_pools,
                            max_members,
                            max_members_per_pool,
                            global_max_commission,
                        },
                        [
                            60u8,
                            29u8,
                            13u8,
                            45u8,
                            37u8,
                            171u8,
                            129u8,
                            133u8,
                            127u8,
                            42u8,
                            104u8,
                            45u8,
                            29u8,
                            58u8,
                            209u8,
                            48u8,
                            119u8,
                            255u8,
                            86u8,
                            13u8,
                            243u8,
                            124u8,
                            57u8,
                            250u8,
                            156u8,
                            189u8,
                            59u8,
                            88u8,
                            64u8,
                            109u8,
                            219u8,
                            68u8,
                        ],
                    )
                }
                ///Update the roles of the pool.
                ///
                ///The root is the only entity that can change any of the roles, including itself,
                ///excluding the depositor, who can never change.
                ///
                ///It emits an event, notifying UIs of the role change. This event is quite relevant to
                ///most pool members and they should be informed of changes to pool roles.
                pub fn update_roles(
                    &self,
                    pool_id: ::core::primitive::u32,
                    new_root: runtime_types::pallet_nomination_pools::ConfigOp<
                        ::subxt::utils::AccountId32,
                    >,
                    new_nominator: runtime_types::pallet_nomination_pools::ConfigOp<
                        ::subxt::utils::AccountId32,
                    >,
                    new_bouncer: runtime_types::pallet_nomination_pools::ConfigOp<
                        ::subxt::utils::AccountId32,
                    >,
                ) -> ::subxt::tx::Payload<types::UpdateRoles> {
                    ::subxt::tx::Payload::new_static(
                        "NominationPools",
                        "update_roles",
                        types::UpdateRoles {
                            pool_id,
                            new_root,
                            new_nominator,
                            new_bouncer,
                        },
                        [
                            58u8,
                            51u8,
                            136u8,
                            162u8,
                            218u8,
                            195u8,
                            121u8,
                            6u8,
                            243u8,
                            69u8,
                            19u8,
                            130u8,
                            152u8,
                            180u8,
                            226u8,
                            28u8,
                            0u8,
                            218u8,
                            237u8,
                            56u8,
                            52u8,
                            139u8,
                            198u8,
                            155u8,
                            112u8,
                            165u8,
                            142u8,
                            44u8,
                            111u8,
                            197u8,
                            123u8,
                            246u8,
                        ],
                    )
                }
                ///Chill on behalf of the pool.
                ///
                ///The dispatch origin of this call must be signed by the pool nominator or the pool
                ///root role, same as [`Pallet::nominate`].
                ///
                ///This directly forward the call to the staking pallet, on behalf of the pool bonded
                ///account.
                pub fn chill(
                    &self,
                    pool_id: ::core::primitive::u32,
                ) -> ::subxt::tx::Payload<types::Chill> {
                    ::subxt::tx::Payload::new_static(
                        "NominationPools",
                        "chill",
                        types::Chill { pool_id },
                        [
                            65u8,
                            206u8,
                            54u8,
                            53u8,
                            37u8,
                            97u8,
                            161u8,
                            104u8,
                            62u8,
                            9u8,
                            93u8,
                            236u8,
                            61u8,
                            185u8,
                            204u8,
                            245u8,
                            234u8,
                            218u8,
                            213u8,
                            40u8,
                            154u8,
                            29u8,
                            244u8,
                            19u8,
                            207u8,
                            172u8,
                            142u8,
                            221u8,
                            38u8,
                            70u8,
                            39u8,
                            10u8,
                        ],
                    )
                }
                ///`origin` bonds funds from `extra` for some pool member `member` into their respective
                ///pools.
                ///
                ///`origin` can bond extra funds from free balance or pending rewards when `origin ==
                ///other`.
                ///
                ///In the case of `origin != other`, `origin` can only bond extra pending rewards of
                ///`other` members assuming set_claim_permission for the given member is
                ///`PermissionlessAll` or `PermissionlessCompound`.
                pub fn bond_extra_other(
                    &self,
                    member: ::subxt::utils::MultiAddress<
                        ::subxt::utils::AccountId32,
                        ::core::primitive::u32,
                    >,
                    extra: runtime_types::pallet_nomination_pools::BondExtra<
                        ::core::primitive::u128,
                    >,
                ) -> ::subxt::tx::Payload<types::BondExtraOther> {
                    ::subxt::tx::Payload::new_static(
                        "NominationPools",
                        "bond_extra_other",
                        types::BondExtraOther {
                            member,
                            extra,
                        },
                        [
                            217u8,
                            91u8,
                            160u8,
                            244u8,
                            122u8,
                            153u8,
                            236u8,
                            132u8,
                            197u8,
                            31u8,
                            124u8,
                            22u8,
                            89u8,
                            146u8,
                            173u8,
                            96u8,
                            167u8,
                            220u8,
                            91u8,
                            27u8,
                            230u8,
                            128u8,
                            222u8,
                            128u8,
                            97u8,
                            53u8,
                            226u8,
                            222u8,
                            165u8,
                            133u8,
                            54u8,
                            236u8,
                        ],
                    )
                }
                ///Allows a pool member to set a claim permission to allow or disallow permissionless
                ///bonding and withdrawing.
                ///
                ///By default, this is `Permissioned`, which implies only the pool member themselves can
                ///claim their pending rewards. If a pool member wishes so, they can set this to
                ///`PermissionlessAll` to allow any account to claim their rewards and bond extra to the
                ///pool.
                ///
                ///# Arguments
                ///
                ///* `origin` - Member of a pool.
                ///* `actor` - Account to claim reward. // improve this
                pub fn set_claim_permission(
                    &self,
                    permission: runtime_types::pallet_nomination_pools::ClaimPermission,
                ) -> ::subxt::tx::Payload<types::SetClaimPermission> {
                    ::subxt::tx::Payload::new_static(
                        "NominationPools",
                        "set_claim_permission",
                        types::SetClaimPermission {
                            permission,
                        },
                        [
                            36u8,
                            137u8,
                            193u8,
                            200u8,
                            57u8,
                            46u8,
                            87u8,
                            236u8,
                            180u8,
                            170u8,
                            90u8,
                            99u8,
                            137u8,
                            123u8,
                            99u8,
                            197u8,
                            113u8,
                            119u8,
                            72u8,
                            153u8,
                            207u8,
                            189u8,
                            69u8,
                            89u8,
                            225u8,
                            115u8,
                            45u8,
                            32u8,
                            216u8,
                            43u8,
                            92u8,
                            135u8,
                        ],
                    )
                }
                ///`origin` can claim payouts on some pool member `other`'s behalf.
                ///
                ///Pool member `other` must have a `PermissionlessAll` or `PermissionlessWithdraw` in order
                ///for this call to be successful.
                pub fn claim_payout_other(
                    &self,
                    other: ::subxt::utils::AccountId32,
                ) -> ::subxt::tx::Payload<types::ClaimPayoutOther> {
                    ::subxt::tx::Payload::new_static(
                        "NominationPools",
                        "claim_payout_other",
                        types::ClaimPayoutOther { other },
                        [
                            202u8,
                            130u8,
                            122u8,
                            10u8,
                            159u8,
                            181u8,
                            124u8,
                            215u8,
                            23u8,
                            85u8,
                            234u8,
                            178u8,
                            169u8,
                            41u8,
                            204u8,
                            226u8,
                            195u8,
                            69u8,
                            168u8,
                            88u8,
                            58u8,
                            15u8,
                            3u8,
                            227u8,
                            180u8,
                            183u8,
                            62u8,
                            224u8,
                            39u8,
                            218u8,
                            75u8,
                            166u8,
                        ],
                    )
                }
                ///Set the commission of a pool.
                ///Both a commission percentage and a commission payee must be provided in the `current`
                ///tuple. Where a `current` of `None` is provided, any current commission will be removed.
                ///
                ///- If a `None` is supplied to `new_commission`, existing commission will be removed.
                pub fn set_commission(
                    &self,
                    pool_id: ::core::primitive::u32,
                    new_commission: ::core::option::Option<
                        (
                            runtime_types::sp_arithmetic::per_things::Perbill,
                            ::subxt::utils::AccountId32,
                        ),
                    >,
                ) -> ::subxt::tx::Payload<types::SetCommission> {
                    ::subxt::tx::Payload::new_static(
                        "NominationPools",
                        "set_commission",
                        types::SetCommission {
                            pool_id,
                            new_commission,
                        },
                        [
                            144u8,
                            94u8,
                            73u8,
                            69u8,
                            224u8,
                            158u8,
                            244u8,
                            77u8,
                            169u8,
                            219u8,
                            101u8,
                            41u8,
                            37u8,
                            211u8,
                            198u8,
                            32u8,
                            92u8,
                            108u8,
                            7u8,
                            27u8,
                            153u8,
                            37u8,
                            82u8,
                            174u8,
                            196u8,
                            176u8,
                            196u8,
                            181u8,
                            45u8,
                            81u8,
                            134u8,
                            162u8,
                        ],
                    )
                }
                ///Set the maximum commission of a pool.
                ///
                ///- Initial max can be set to any `Perbill`, and only smaller values thereafter.
                ///- Current commission will be lowered in the event it is higher than a new max
                ///  commission.
                pub fn set_commission_max(
                    &self,
                    pool_id: ::core::primitive::u32,
                    max_commission: runtime_types::sp_arithmetic::per_things::Perbill,
                ) -> ::subxt::tx::Payload<types::SetCommissionMax> {
                    ::subxt::tx::Payload::new_static(
                        "NominationPools",
                        "set_commission_max",
                        types::SetCommissionMax {
                            pool_id,
                            max_commission,
                        },
                        [
                            180u8,
                            80u8,
                            204u8,
                            129u8,
                            141u8,
                            86u8,
                            45u8,
                            76u8,
                            224u8,
                            123u8,
                            212u8,
                            38u8,
                            224u8,
                            79u8,
                            41u8,
                            143u8,
                            237u8,
                            174u8,
                            126u8,
                            1u8,
                            215u8,
                            105u8,
                            50u8,
                            46u8,
                            151u8,
                            11u8,
                            118u8,
                            198u8,
                            183u8,
                            95u8,
                            47u8,
                            71u8,
                        ],
                    )
                }
                ///Set the commission change rate for a pool.
                ///
                ///Initial change rate is not bounded, whereas subsequent updates can only be more
                ///restrictive than the current.
                pub fn set_commission_change_rate(
                    &self,
                    pool_id: ::core::primitive::u32,
                    change_rate: runtime_types::pallet_nomination_pools::CommissionChangeRate<
                        ::core::primitive::u32,
                    >,
                ) -> ::subxt::tx::Payload<types::SetCommissionChangeRate> {
                    ::subxt::tx::Payload::new_static(
                        "NominationPools",
                        "set_commission_change_rate",
                        types::SetCommissionChangeRate {
                            pool_id,
                            change_rate,
                        },
                        [
                            138u8,
                            30u8,
                            155u8,
                            127u8,
                            181u8,
                            99u8,
                            89u8,
                            138u8,
                            130u8,
                            53u8,
                            224u8,
                            96u8,
                            190u8,
                            14u8,
                            76u8,
                            244u8,
                            142u8,
                            50u8,
                            39u8,
                            245u8,
                            144u8,
                            87u8,
                            64u8,
                            206u8,
                            246u8,
                            225u8,
                            111u8,
                            197u8,
                            245u8,
                            182u8,
                            121u8,
                            56u8,
                        ],
                    )
                }
                ///Claim pending commission.
                ///
                ///The dispatch origin of this call must be signed by the `root` role of the pool. Pending
                ///commission is paid out and added to total claimed commission`. Total pending commission
                ///is reset to zero. the current.
                pub fn claim_commission(
                    &self,
                    pool_id: ::core::primitive::u32,
                ) -> ::subxt::tx::Payload<types::ClaimCommission> {
                    ::subxt::tx::Payload::new_static(
                        "NominationPools",
                        "claim_commission",
                        types::ClaimCommission { pool_id },
                        [
                            51u8,
                            64u8,
                            163u8,
                            230u8,
                            2u8,
                            119u8,
                            68u8,
                            5u8,
                            154u8,
                            4u8,
                            84u8,
                            149u8,
                            9u8,
                            195u8,
                            173u8,
                            37u8,
                            98u8,
                            48u8,
                            188u8,
                            65u8,
                            81u8,
                            11u8,
                            64u8,
                            254u8,
                            126u8,
                            62u8,
                            29u8,
                            204u8,
                            92u8,
                            230u8,
                            240u8,
                            91u8,
                        ],
                    )
                }
            }
        }
        ///Events of this pallet.
        pub type Event = runtime_types::pallet_nomination_pools::pallet::Event;
        pub mod events {
            use super::runtime_types;
            #[derive(
                ::subxt::ext::codec::Decode,
                ::subxt::ext::codec::Encode,
                ::subxt::ext::scale_decode::DecodeAsType,
                ::subxt::ext::scale_encode::EncodeAsType,
                Clone,
                Debug,
                Eq,
                PartialEq
            )]
            #[codec(crate = ::subxt::ext::codec)]
            #[decode_as_type(crate_path = ":: subxt :: ext :: scale_decode")]
            #[encode_as_type(crate_path = ":: subxt :: ext :: scale_encode")]
            ///A pool has been created.
            pub struct Created {
                pub depositor: ::subxt::utils::AccountId32,
                pub pool_id: ::core::primitive::u32,
            }
            impl ::subxt::events::StaticEvent for Created {
                const PALLET: &'static str = "NominationPools";
                const EVENT: &'static str = "Created";
            }
            #[derive(
                ::subxt::ext::codec::Decode,
                ::subxt::ext::codec::Encode,
                ::subxt::ext::scale_decode::DecodeAsType,
                ::subxt::ext::scale_encode::EncodeAsType,
                Clone,
                Debug,
                Eq,
                PartialEq
            )]
            #[codec(crate = ::subxt::ext::codec)]
            #[decode_as_type(crate_path = ":: subxt :: ext :: scale_decode")]
            #[encode_as_type(crate_path = ":: subxt :: ext :: scale_encode")]
            ///A member has became bonded in a pool.
            pub struct Bonded {
                pub member: ::subxt::utils::AccountId32,
                pub pool_id: ::core::primitive::u32,
                pub bonded: ::core::primitive::u128,
                pub joined: ::core::primitive::bool,
            }
            impl ::subxt::events::StaticEvent for Bonded {
                const PALLET: &'static str = "NominationPools";
                const EVENT: &'static str = "Bonded";
            }
            #[derive(
                ::subxt::ext::codec::Decode,
                ::subxt::ext::codec::Encode,
                ::subxt::ext::scale_decode::DecodeAsType,
                ::subxt::ext::scale_encode::EncodeAsType,
                Clone,
                Debug,
                Eq,
                PartialEq
            )]
            #[codec(crate = ::subxt::ext::codec)]
            #[decode_as_type(crate_path = ":: subxt :: ext :: scale_decode")]
            #[encode_as_type(crate_path = ":: subxt :: ext :: scale_encode")]
            ///A payout has been made to a member.
            pub struct PaidOut {
                pub member: ::subxt::utils::AccountId32,
                pub pool_id: ::core::primitive::u32,
                pub payout: ::core::primitive::u128,
            }
            impl ::subxt::events::StaticEvent for PaidOut {
                const PALLET: &'static str = "NominationPools";
                const EVENT: &'static str = "PaidOut";
            }
            #[derive(
                ::subxt::ext::codec::Decode,
                ::subxt::ext::codec::Encode,
                ::subxt::ext::scale_decode::DecodeAsType,
                ::subxt::ext::scale_encode::EncodeAsType,
                Clone,
                Debug,
                Eq,
                PartialEq
            )]
            #[codec(crate = ::subxt::ext::codec)]
            #[decode_as_type(crate_path = ":: subxt :: ext :: scale_decode")]
            #[encode_as_type(crate_path = ":: subxt :: ext :: scale_encode")]
            ///A member has unbonded from their pool.
            ///
            ///- `balance` is the corresponding balance of the number of points that has been
            ///  requested to be unbonded (the argument of the `unbond` transaction) from the bonded
            ///  pool.
            ///- `points` is the number of points that are issued as a result of `balance` being
            ///dissolved into the corresponding unbonding pool.
            ///- `era` is the era in which the balance will be unbonded.
            ///In the absence of slashing, these values will match. In the presence of slashing, the
            ///number of points that are issued in the unbonding pool will be less than the amount
            ///requested to be unbonded.
            pub struct Unbonded {
                pub member: ::subxt::utils::AccountId32,
                pub pool_id: ::core::primitive::u32,
                pub balance: ::core::primitive::u128,
                pub points: ::core::primitive::u128,
                pub era: ::core::primitive::u32,
            }
            impl ::subxt::events::StaticEvent for Unbonded {
                const PALLET: &'static str = "NominationPools";
                const EVENT: &'static str = "Unbonded";
            }
            #[derive(
                ::subxt::ext::codec::Decode,
                ::subxt::ext::codec::Encode,
                ::subxt::ext::scale_decode::DecodeAsType,
                ::subxt::ext::scale_encode::EncodeAsType,
                Clone,
                Debug,
                Eq,
                PartialEq
            )]
            #[codec(crate = ::subxt::ext::codec)]
            #[decode_as_type(crate_path = ":: subxt :: ext :: scale_decode")]
            #[encode_as_type(crate_path = ":: subxt :: ext :: scale_encode")]
            ///A member has withdrawn from their pool.
            ///
            ///The given number of `points` have been dissolved in return of `balance`.
            ///
            ///Similar to `Unbonded` event, in the absence of slashing, the ratio of point to balance
            ///will be 1.
            pub struct Withdrawn {
                pub member: ::subxt::utils::AccountId32,
                pub pool_id: ::core::primitive::u32,
                pub balance: ::core::primitive::u128,
                pub points: ::core::primitive::u128,
            }
            impl ::subxt::events::StaticEvent for Withdrawn {
                const PALLET: &'static str = "NominationPools";
                const EVENT: &'static str = "Withdrawn";
            }
            #[derive(
                ::subxt::ext::codec::CompactAs,
                ::subxt::ext::codec::Decode,
                ::subxt::ext::codec::Encode,
                ::subxt::ext::scale_decode::DecodeAsType,
                ::subxt::ext::scale_encode::EncodeAsType,
                Clone,
                Debug,
                Eq,
                PartialEq
            )]
            #[codec(crate = ::subxt::ext::codec)]
            #[decode_as_type(crate_path = ":: subxt :: ext :: scale_decode")]
            #[encode_as_type(crate_path = ":: subxt :: ext :: scale_encode")]
            ///A pool has been destroyed.
            pub struct Destroyed {
                pub pool_id: ::core::primitive::u32,
            }
            impl ::subxt::events::StaticEvent for Destroyed {
                const PALLET: &'static str = "NominationPools";
                const EVENT: &'static str = "Destroyed";
            }
            #[derive(
                ::subxt::ext::codec::Decode,
                ::subxt::ext::codec::Encode,
                ::subxt::ext::scale_decode::DecodeAsType,
                ::subxt::ext::scale_encode::EncodeAsType,
                Clone,
                Debug,
                Eq,
                PartialEq
            )]
            #[codec(crate = ::subxt::ext::codec)]
            #[decode_as_type(crate_path = ":: subxt :: ext :: scale_decode")]
            #[encode_as_type(crate_path = ":: subxt :: ext :: scale_encode")]
            ///The state of a pool has changed
            pub struct StateChanged {
                pub pool_id: ::core::primitive::u32,
                pub new_state: runtime_types::pallet_nomination_pools::PoolState,
            }
            impl ::subxt::events::StaticEvent for StateChanged {
                const PALLET: &'static str = "NominationPools";
                const EVENT: &'static str = "StateChanged";
            }
            #[derive(
                ::subxt::ext::codec::Decode,
                ::subxt::ext::codec::Encode,
                ::subxt::ext::scale_decode::DecodeAsType,
                ::subxt::ext::scale_encode::EncodeAsType,
                Clone,
                Debug,
                Eq,
                PartialEq
            )]
            #[codec(crate = ::subxt::ext::codec)]
            #[decode_as_type(crate_path = ":: subxt :: ext :: scale_decode")]
            #[encode_as_type(crate_path = ":: subxt :: ext :: scale_encode")]
            ///A member has been removed from a pool.
            ///
            ///The removal can be voluntary (withdrawn all unbonded funds) or involuntary (kicked).
            pub struct MemberRemoved {
                pub pool_id: ::core::primitive::u32,
                pub member: ::subxt::utils::AccountId32,
            }
            impl ::subxt::events::StaticEvent for MemberRemoved {
                const PALLET: &'static str = "NominationPools";
                const EVENT: &'static str = "MemberRemoved";
            }
            #[derive(
                ::subxt::ext::codec::Decode,
                ::subxt::ext::codec::Encode,
                ::subxt::ext::scale_decode::DecodeAsType,
                ::subxt::ext::scale_encode::EncodeAsType,
                Clone,
                Debug,
                Eq,
                PartialEq
            )]
            #[codec(crate = ::subxt::ext::codec)]
            #[decode_as_type(crate_path = ":: subxt :: ext :: scale_decode")]
            #[encode_as_type(crate_path = ":: subxt :: ext :: scale_encode")]
            ///The roles of a pool have been updated to the given new roles. Note that the depositor
            ///can never change.
            pub struct RolesUpdated {
                pub root: ::core::option::Option<::subxt::utils::AccountId32>,
                pub bouncer: ::core::option::Option<::subxt::utils::AccountId32>,
                pub nominator: ::core::option::Option<::subxt::utils::AccountId32>,
            }
            impl ::subxt::events::StaticEvent for RolesUpdated {
                const PALLET: &'static str = "NominationPools";
                const EVENT: &'static str = "RolesUpdated";
            }
            #[derive(
                ::subxt::ext::codec::Decode,
                ::subxt::ext::codec::Encode,
                ::subxt::ext::scale_decode::DecodeAsType,
                ::subxt::ext::scale_encode::EncodeAsType,
                Clone,
                Debug,
                Eq,
                PartialEq
            )]
            #[codec(crate = ::subxt::ext::codec)]
            #[decode_as_type(crate_path = ":: subxt :: ext :: scale_decode")]
            #[encode_as_type(crate_path = ":: subxt :: ext :: scale_encode")]
            ///The active balance of pool `pool_id` has been slashed to `balance`.
            pub struct PoolSlashed {
                pub pool_id: ::core::primitive::u32,
                pub balance: ::core::primitive::u128,
            }
            impl ::subxt::events::StaticEvent for PoolSlashed {
                const PALLET: &'static str = "NominationPools";
                const EVENT: &'static str = "PoolSlashed";
            }
            #[derive(
                ::subxt::ext::codec::Decode,
                ::subxt::ext::codec::Encode,
                ::subxt::ext::scale_decode::DecodeAsType,
                ::subxt::ext::scale_encode::EncodeAsType,
                Clone,
                Debug,
                Eq,
                PartialEq
            )]
            #[codec(crate = ::subxt::ext::codec)]
            #[decode_as_type(crate_path = ":: subxt :: ext :: scale_decode")]
            #[encode_as_type(crate_path = ":: subxt :: ext :: scale_encode")]
            ///The unbond pool at `era` of pool `pool_id` has been slashed to `balance`.
            pub struct UnbondingPoolSlashed {
                pub pool_id: ::core::primitive::u32,
                pub era: ::core::primitive::u32,
                pub balance: ::core::primitive::u128,
            }
            impl ::subxt::events::StaticEvent for UnbondingPoolSlashed {
                const PALLET: &'static str = "NominationPools";
                const EVENT: &'static str = "UnbondingPoolSlashed";
            }
            #[derive(
                ::subxt::ext::codec::Decode,
                ::subxt::ext::codec::Encode,
                ::subxt::ext::scale_decode::DecodeAsType,
                ::subxt::ext::scale_encode::EncodeAsType,
                Clone,
                Debug,
                Eq,
                PartialEq
            )]
            #[codec(crate = ::subxt::ext::codec)]
            #[decode_as_type(crate_path = ":: subxt :: ext :: scale_decode")]
            #[encode_as_type(crate_path = ":: subxt :: ext :: scale_encode")]
            ///A pool's commission setting has been changed.
            pub struct PoolCommissionUpdated {
                pub pool_id: ::core::primitive::u32,
                pub current: ::core::option::Option<
                    (
                        runtime_types::sp_arithmetic::per_things::Perbill,
                        ::subxt::utils::AccountId32,
                    ),
                >,
            }
            impl ::subxt::events::StaticEvent for PoolCommissionUpdated {
                const PALLET: &'static str = "NominationPools";
                const EVENT: &'static str = "PoolCommissionUpdated";
            }
            #[derive(
                ::subxt::ext::codec::Decode,
                ::subxt::ext::codec::Encode,
                ::subxt::ext::scale_decode::DecodeAsType,
                ::subxt::ext::scale_encode::EncodeAsType,
                Clone,
                Debug,
                Eq,
                PartialEq
            )]
            #[codec(crate = ::subxt::ext::codec)]
            #[decode_as_type(crate_path = ":: subxt :: ext :: scale_decode")]
            #[encode_as_type(crate_path = ":: subxt :: ext :: scale_encode")]
            ///A pool's maximum commission setting has been changed.
            pub struct PoolMaxCommissionUpdated {
                pub pool_id: ::core::primitive::u32,
                pub max_commission: runtime_types::sp_arithmetic::per_things::Perbill,
            }
            impl ::subxt::events::StaticEvent for PoolMaxCommissionUpdated {
                const PALLET: &'static str = "NominationPools";
                const EVENT: &'static str = "PoolMaxCommissionUpdated";
            }
            #[derive(
                ::subxt::ext::codec::Decode,
                ::subxt::ext::codec::Encode,
                ::subxt::ext::scale_decode::DecodeAsType,
                ::subxt::ext::scale_encode::EncodeAsType,
                Clone,
                Debug,
                Eq,
                PartialEq
            )]
            #[codec(crate = ::subxt::ext::codec)]
            #[decode_as_type(crate_path = ":: subxt :: ext :: scale_decode")]
            #[encode_as_type(crate_path = ":: subxt :: ext :: scale_encode")]
            ///A pool's commission `change_rate` has been changed.
            pub struct PoolCommissionChangeRateUpdated {
                pub pool_id: ::core::primitive::u32,
                pub change_rate: runtime_types::pallet_nomination_pools::CommissionChangeRate<
                    ::core::primitive::u32,
                >,
            }
            impl ::subxt::events::StaticEvent for PoolCommissionChangeRateUpdated {
                const PALLET: &'static str = "NominationPools";
                const EVENT: &'static str = "PoolCommissionChangeRateUpdated";
            }
            #[derive(
                ::subxt::ext::codec::Decode,
                ::subxt::ext::codec::Encode,
                ::subxt::ext::scale_decode::DecodeAsType,
                ::subxt::ext::scale_encode::EncodeAsType,
                Clone,
                Debug,
                Eq,
                PartialEq
            )]
            #[codec(crate = ::subxt::ext::codec)]
            #[decode_as_type(crate_path = ":: subxt :: ext :: scale_decode")]
            #[encode_as_type(crate_path = ":: subxt :: ext :: scale_encode")]
            ///Pool commission has been claimed.
            pub struct PoolCommissionClaimed {
                pub pool_id: ::core::primitive::u32,
                pub commission: ::core::primitive::u128,
            }
            impl ::subxt::events::StaticEvent for PoolCommissionClaimed {
                const PALLET: &'static str = "NominationPools";
                const EVENT: &'static str = "PoolCommissionClaimed";
            }
        }
        pub mod storage {
            use super::runtime_types;
            pub struct StorageApi;
            impl StorageApi {
                /// Minimum amount to bond to join a pool.
                pub fn min_join_bond(
                    &self,
                ) -> ::subxt::storage::address::Address<
                    ::subxt::storage::address::StaticStorageMapKey,
                    ::core::primitive::u128,
                    ::subxt::storage::address::Yes,
                    ::subxt::storage::address::Yes,
                    (),
                > {
                    ::subxt::storage::address::Address::new_static(
                        "NominationPools",
                        "MinJoinBond",
                        vec![],
                        [
                            64u8,
                            180u8,
                            71u8,
                            185u8,
                            81u8,
                            46u8,
                            155u8,
                            26u8,
                            251u8,
                            84u8,
                            108u8,
                            80u8,
                            128u8,
                            44u8,
                            163u8,
                            118u8,
                            107u8,
                            79u8,
                            250u8,
                            211u8,
                            194u8,
                            71u8,
                            87u8,
                            16u8,
                            247u8,
                            9u8,
                            76u8,
                            95u8,
                            103u8,
                            227u8,
                            180u8,
                            231u8,
                        ],
                    )
                }
                /// Minimum bond required to create a pool.
                ///
                /// This is the amount that the depositor must put as their initial stake in the pool, as an
                /// indication of "skin in the game".
                ///
                /// This is the value that will always exist in the staking ledger of the pool bonded account
                /// while all other accounts leave.
                pub fn min_create_bond(
                    &self,
                ) -> ::subxt::storage::address::Address<
                    ::subxt::storage::address::StaticStorageMapKey,
                    ::core::primitive::u128,
                    ::subxt::storage::address::Yes,
                    ::subxt::storage::address::Yes,
                    (),
                > {
                    ::subxt::storage::address::Address::new_static(
                        "NominationPools",
                        "MinCreateBond",
                        vec![],
                        [
                            210u8,
                            67u8,
                            92u8,
                            230u8,
                            231u8,
                            105u8,
                            54u8,
                            249u8,
                            154u8,
                            192u8,
                            29u8,
                            217u8,
                            233u8,
                            79u8,
                            170u8,
                            126u8,
                            133u8,
                            98u8,
                            253u8,
                            153u8,
                            248u8,
                            189u8,
                            63u8,
                            107u8,
                            170u8,
                            224u8,
                            12u8,
                            42u8,
                            198u8,
                            185u8,
                            85u8,
                            46u8,
                        ],
                    )
                }
                /// Maximum number of nomination pools that can exist. If `None`, then an unbounded number of
                /// pools can exist.
                pub fn max_pools(
                    &self,
                ) -> ::subxt::storage::address::Address<
                    ::subxt::storage::address::StaticStorageMapKey,
                    ::core::primitive::u32,
                    ::subxt::storage::address::Yes,
                    (),
                    (),
                > {
                    ::subxt::storage::address::Address::new_static(
                        "NominationPools",
                        "MaxPools",
                        vec![],
                        [
                            230u8,
                            184u8,
                            242u8,
                            91u8,
                            118u8,
                            111u8,
                            90u8,
                            204u8,
                            136u8,
                            61u8,
                            228u8,
                            50u8,
                            212u8,
                            40u8,
                            83u8,
                            49u8,
                            121u8,
                            161u8,
                            245u8,
                            80u8,
                            46u8,
                            184u8,
                            105u8,
                            134u8,
                            249u8,
                            225u8,
                            39u8,
                            3u8,
                            123u8,
                            137u8,
                            156u8,
                            240u8,
                        ],
                    )
                }
                /// Maximum number of members that can exist in the system. If `None`, then the count
                /// members are not bound on a system wide basis.
                pub fn max_pool_members(
                    &self,
                ) -> ::subxt::storage::address::Address<
                    ::subxt::storage::address::StaticStorageMapKey,
                    ::core::primitive::u32,
                    ::subxt::storage::address::Yes,
                    (),
                    (),
                > {
                    ::subxt::storage::address::Address::new_static(
                        "NominationPools",
                        "MaxPoolMembers",
                        vec![],
                        [
                            210u8,
                            222u8,
                            181u8,
                            146u8,
                            137u8,
                            200u8,
                            71u8,
                            196u8,
                            74u8,
                            38u8,
                            36u8,
                            122u8,
                            187u8,
                            164u8,
                            218u8,
                            116u8,
                            216u8,
                            143u8,
                            182u8,
                            15u8,
                            23u8,
                            124u8,
                            57u8,
                            121u8,
                            81u8,
                            151u8,
                            8u8,
                            247u8,
                            80u8,
                            136u8,
                            115u8,
                            2u8,
                        ],
                    )
                }
                /// Maximum number of members that may belong to pool. If `None`, then the count of
                /// members is not bound on a per pool basis.
                pub fn max_pool_members_per_pool(
                    &self,
                ) -> ::subxt::storage::address::Address<
                    ::subxt::storage::address::StaticStorageMapKey,
                    ::core::primitive::u32,
                    ::subxt::storage::address::Yes,
                    (),
                    (),
                > {
                    ::subxt::storage::address::Address::new_static(
                        "NominationPools",
                        "MaxPoolMembersPerPool",
                        vec![],
                        [
                            250u8,
                            255u8,
                            136u8,
                            223u8,
                            61u8,
                            119u8,
                            117u8,
                            240u8,
                            68u8,
                            114u8,
                            55u8,
                            1u8,
                            176u8,
                            120u8,
                            143u8,
                            48u8,
                            232u8,
                            125u8,
                            218u8,
                            105u8,
                            28u8,
                            230u8,
                            253u8,
                            36u8,
                            9u8,
                            44u8,
                            129u8,
                            225u8,
                            147u8,
                            33u8,
                            181u8,
                            68u8,
                        ],
                    )
                }
                /// The maximum commission that can be charged by a pool. Used on commission payouts to bound
                /// pool commissions that are > `GlobalMaxCommission`, necessary if a future
                /// `GlobalMaxCommission` is lower than some current pool commissions.
                pub fn global_max_commission(
                    &self,
                ) -> ::subxt::storage::address::Address<
                    ::subxt::storage::address::StaticStorageMapKey,
                    runtime_types::sp_arithmetic::per_things::Perbill,
                    ::subxt::storage::address::Yes,
                    (),
                    (),
                > {
                    ::subxt::storage::address::Address::new_static(
                        "NominationPools",
                        "GlobalMaxCommission",
                        vec![],
                        [
                            2u8,
                            112u8,
                            8u8,
                            116u8,
                            114u8,
                            97u8,
                            250u8,
                            106u8,
                            170u8,
                            215u8,
                            218u8,
                            217u8,
                            80u8,
                            235u8,
                            149u8,
                            81u8,
                            85u8,
                            185u8,
                            201u8,
                            127u8,
                            107u8,
                            251u8,
                            191u8,
                            231u8,
                            142u8,
                            74u8,
                            8u8,
                            70u8,
                            151u8,
                            238u8,
                            117u8,
                            173u8,
                        ],
                    )
                }
                /// Active members.
                ///
                /// TWOX-NOTE: SAFE since `AccountId` is a secure hash.
                pub fn pool_members(
                    &self,
                    _0: impl ::std::borrow::Borrow<::subxt::utils::AccountId32>,
                ) -> ::subxt::storage::address::Address<
                    ::subxt::storage::address::StaticStorageMapKey,
                    runtime_types::pallet_nomination_pools::PoolMember,
                    ::subxt::storage::address::Yes,
                    (),
                    ::subxt::storage::address::Yes,
                > {
                    ::subxt::storage::address::Address::new_static(
                        "NominationPools",
                        "PoolMembers",
                        vec![
                            ::subxt::storage::address::make_static_storage_map_key(_0
                            .borrow())
                        ],
                        [
                            116u8,
                            41u8,
                            89u8,
                            74u8,
                            35u8,
                            243u8,
                            213u8,
                            178u8,
                            41u8,
                            249u8,
                            62u8,
                            119u8,
                            72u8,
                            34u8,
                            197u8,
                            168u8,
                            147u8,
                            178u8,
                            159u8,
                            10u8,
                            181u8,
                            255u8,
                            40u8,
                            211u8,
                            206u8,
                            32u8,
                            130u8,
                            25u8,
                            201u8,
                            54u8,
                            212u8,
                            25u8,
                        ],
                    )
                }
                /// Active members.
                ///
                /// TWOX-NOTE: SAFE since `AccountId` is a secure hash.
                pub fn pool_members_root(
                    &self,
                ) -> ::subxt::storage::address::Address<
                    ::subxt::storage::address::StaticStorageMapKey,
                    runtime_types::pallet_nomination_pools::PoolMember,
                    (),
                    (),
                    ::subxt::storage::address::Yes,
                > {
                    ::subxt::storage::address::Address::new_static(
                        "NominationPools",
                        "PoolMembers",
                        Vec::new(),
                        [
                            116u8,
                            41u8,
                            89u8,
                            74u8,
                            35u8,
                            243u8,
                            213u8,
                            178u8,
                            41u8,
                            249u8,
                            62u8,
                            119u8,
                            72u8,
                            34u8,
                            197u8,
                            168u8,
                            147u8,
                            178u8,
                            159u8,
                            10u8,
                            181u8,
                            255u8,
                            40u8,
                            211u8,
                            206u8,
                            32u8,
                            130u8,
                            25u8,
                            201u8,
                            54u8,
                            212u8,
                            25u8,
                        ],
                    )
                }
                ///Counter for the related counted storage map
                pub fn counter_for_pool_members(
                    &self,
                ) -> ::subxt::storage::address::Address<
                    ::subxt::storage::address::StaticStorageMapKey,
                    ::core::primitive::u32,
                    ::subxt::storage::address::Yes,
                    ::subxt::storage::address::Yes,
                    (),
                > {
                    ::subxt::storage::address::Address::new_static(
                        "NominationPools",
                        "CounterForPoolMembers",
                        vec![],
                        [
                            165u8,
                            158u8,
                            130u8,
                            19u8,
                            106u8,
                            227u8,
                            134u8,
                            73u8,
                            36u8,
                            237u8,
                            103u8,
                            146u8,
                            198u8,
                            68u8,
                            219u8,
                            186u8,
                            134u8,
                            224u8,
                            89u8,
                            251u8,
                            200u8,
                            46u8,
                            87u8,
                            232u8,
                            53u8,
                            152u8,
                            13u8,
                            10u8,
                            105u8,
                            49u8,
                            150u8,
                            212u8,
                        ],
                    )
                }
                /// Storage for bonded pools.
                pub fn bonded_pools(
                    &self,
                    _0: impl ::std::borrow::Borrow<::core::primitive::u32>,
                ) -> ::subxt::storage::address::Address<
                    ::subxt::storage::address::StaticStorageMapKey,
                    runtime_types::pallet_nomination_pools::BondedPoolInner,
                    ::subxt::storage::address::Yes,
                    (),
                    ::subxt::storage::address::Yes,
                > {
                    ::subxt::storage::address::Address::new_static(
                        "NominationPools",
                        "BondedPools",
                        vec![
                            ::subxt::storage::address::make_static_storage_map_key(_0
                            .borrow())
                        ],
                        [
                            171u8,
                            143u8,
                            96u8,
                            95u8,
                            196u8,
                            228u8,
                            116u8,
                            22u8,
                            63u8,
                            105u8,
                            193u8,
                            77u8,
                            171u8,
                            99u8,
                            144u8,
                            70u8,
                            166u8,
                            55u8,
                            14u8,
                            191u8,
                            156u8,
                            17u8,
                            237u8,
                            193u8,
                            228u8,
                            243u8,
                            164u8,
                            187u8,
                            127u8,
                            245u8,
                            117u8,
                            238u8,
                        ],
                    )
                }
                /// Storage for bonded pools.
                pub fn bonded_pools_root(
                    &self,
                ) -> ::subxt::storage::address::Address<
                    ::subxt::storage::address::StaticStorageMapKey,
                    runtime_types::pallet_nomination_pools::BondedPoolInner,
                    (),
                    (),
                    ::subxt::storage::address::Yes,
                > {
                    ::subxt::storage::address::Address::new_static(
                        "NominationPools",
                        "BondedPools",
                        Vec::new(),
                        [
                            171u8,
                            143u8,
                            96u8,
                            95u8,
                            196u8,
                            228u8,
                            116u8,
                            22u8,
                            63u8,
                            105u8,
                            193u8,
                            77u8,
                            171u8,
                            99u8,
                            144u8,
                            70u8,
                            166u8,
                            55u8,
                            14u8,
                            191u8,
                            156u8,
                            17u8,
                            237u8,
                            193u8,
                            228u8,
                            243u8,
                            164u8,
                            187u8,
                            127u8,
                            245u8,
                            117u8,
                            238u8,
                        ],
                    )
                }
                ///Counter for the related counted storage map
                pub fn counter_for_bonded_pools(
                    &self,
                ) -> ::subxt::storage::address::Address<
                    ::subxt::storage::address::StaticStorageMapKey,
                    ::core::primitive::u32,
                    ::subxt::storage::address::Yes,
                    ::subxt::storage::address::Yes,
                    (),
                > {
                    ::subxt::storage::address::Address::new_static(
                        "NominationPools",
                        "CounterForBondedPools",
                        vec![],
                        [
                            198u8,
                            6u8,
                            213u8,
                            92u8,
                            4u8,
                            114u8,
                            164u8,
                            244u8,
                            51u8,
                            55u8,
                            157u8,
                            20u8,
                            224u8,
                            183u8,
                            40u8,
                            236u8,
                            115u8,
                            86u8,
                            171u8,
                            207u8,
                            31u8,
                            111u8,
                            0u8,
                            210u8,
                            48u8,
                            198u8,
                            243u8,
                            153u8,
                            5u8,
                            216u8,
                            107u8,
                            113u8,
                        ],
                    )
                }
                /// Reward pools. This is where there rewards for each pool accumulate. When a members payout is
                /// claimed, the balance comes out fo the reward pool. Keyed by the bonded pools account.
                pub fn reward_pools(
                    &self,
                    _0: impl ::std::borrow::Borrow<::core::primitive::u32>,
                ) -> ::subxt::storage::address::Address<
                    ::subxt::storage::address::StaticStorageMapKey,
                    runtime_types::pallet_nomination_pools::RewardPool,
                    ::subxt::storage::address::Yes,
                    (),
                    ::subxt::storage::address::Yes,
                > {
                    ::subxt::storage::address::Address::new_static(
                        "NominationPools",
                        "RewardPools",
                        vec![
                            ::subxt::storage::address::make_static_storage_map_key(_0
                            .borrow())
                        ],
                        [
                            150u8,
                            53u8,
                            204u8,
                            26u8,
                            187u8,
                            118u8,
                            80u8,
                            133u8,
                            94u8,
                            127u8,
                            155u8,
                            78u8,
                            71u8,
                            72u8,
                            0u8,
                            220u8,
                            174u8,
                            174u8,
                            109u8,
                            238u8,
                            13u8,
                            120u8,
                            193u8,
                            102u8,
                            219u8,
                            22u8,
                            89u8,
                            117u8,
                            169u8,
                            212u8,
                            64u8,
                            204u8,
                        ],
                    )
                }
                /// Reward pools. This is where there rewards for each pool accumulate. When a members payout is
                /// claimed, the balance comes out fo the reward pool. Keyed by the bonded pools account.
                pub fn reward_pools_root(
                    &self,
                ) -> ::subxt::storage::address::Address<
                    ::subxt::storage::address::StaticStorageMapKey,
                    runtime_types::pallet_nomination_pools::RewardPool,
                    (),
                    (),
                    ::subxt::storage::address::Yes,
                > {
                    ::subxt::storage::address::Address::new_static(
                        "NominationPools",
                        "RewardPools",
                        Vec::new(),
                        [
                            150u8,
                            53u8,
                            204u8,
                            26u8,
                            187u8,
                            118u8,
                            80u8,
                            133u8,
                            94u8,
                            127u8,
                            155u8,
                            78u8,
                            71u8,
                            72u8,
                            0u8,
                            220u8,
                            174u8,
                            174u8,
                            109u8,
                            238u8,
                            13u8,
                            120u8,
                            193u8,
                            102u8,
                            219u8,
                            22u8,
                            89u8,
                            117u8,
                            169u8,
                            212u8,
                            64u8,
                            204u8,
                        ],
                    )
                }
                ///Counter for the related counted storage map
                pub fn counter_for_reward_pools(
                    &self,
                ) -> ::subxt::storage::address::Address<
                    ::subxt::storage::address::StaticStorageMapKey,
                    ::core::primitive::u32,
                    ::subxt::storage::address::Yes,
                    ::subxt::storage::address::Yes,
                    (),
                > {
                    ::subxt::storage::address::Address::new_static(
                        "NominationPools",
                        "CounterForRewardPools",
                        vec![],
                        [
                            218u8,
                            186u8,
                            28u8,
                            97u8,
                            205u8,
                            249u8,
                            187u8,
                            10u8,
                            127u8,
                            190u8,
                            213u8,
                            152u8,
                            103u8,
                            20u8,
                            157u8,
                            183u8,
                            86u8,
                            104u8,
                            186u8,
                            236u8,
                            84u8,
                            159u8,
                            117u8,
                            78u8,
                            5u8,
                            242u8,
                            193u8,
                            59u8,
                            112u8,
                            200u8,
                            34u8,
                            166u8,
                        ],
                    )
                }
                /// Groups of unbonding pools. Each group of unbonding pools belongs to a
                /// bonded pool, hence the name sub-pools. Keyed by the bonded pools account.
                pub fn sub_pools_storage(
                    &self,
                    _0: impl ::std::borrow::Borrow<::core::primitive::u32>,
                ) -> ::subxt::storage::address::Address<
                    ::subxt::storage::address::StaticStorageMapKey,
                    runtime_types::pallet_nomination_pools::SubPools,
                    ::subxt::storage::address::Yes,
                    (),
                    ::subxt::storage::address::Yes,
                > {
                    ::subxt::storage::address::Address::new_static(
                        "NominationPools",
                        "SubPoolsStorage",
                        vec![
                            ::subxt::storage::address::make_static_storage_map_key(_0
                            .borrow())
                        ],
                        [
                            248u8,
                            37u8,
                            232u8,
                            231u8,
                            14u8,
                            140u8,
                            12u8,
                            27u8,
                            61u8,
                            222u8,
                            185u8,
                            128u8,
                            158u8,
                            30u8,
                            57u8,
                            121u8,
                            35u8,
                            11u8,
                            42u8,
                            242u8,
                            56u8,
                            1u8,
                            61u8,
                            0u8,
                            67u8,
                            140u8,
                            55u8,
                            62u8,
                            165u8,
                            134u8,
                            136u8,
                            4u8,
                        ],
                    )
                }
                /// Groups of unbonding pools. Each group of unbonding pools belongs to a
                /// bonded pool, hence the name sub-pools. Keyed by the bonded pools account.
                pub fn sub_pools_storage_root(
                    &self,
                ) -> ::subxt::storage::address::Address<
                    ::subxt::storage::address::StaticStorageMapKey,
                    runtime_types::pallet_nomination_pools::SubPools,
                    (),
                    (),
                    ::subxt::storage::address::Yes,
                > {
                    ::subxt::storage::address::Address::new_static(
                        "NominationPools",
                        "SubPoolsStorage",
                        Vec::new(),
                        [
                            248u8,
                            37u8,
                            232u8,
                            231u8,
                            14u8,
                            140u8,
                            12u8,
                            27u8,
                            61u8,
                            222u8,
                            185u8,
                            128u8,
                            158u8,
                            30u8,
                            57u8,
                            121u8,
                            35u8,
                            11u8,
                            42u8,
                            242u8,
                            56u8,
                            1u8,
                            61u8,
                            0u8,
                            67u8,
                            140u8,
                            55u8,
                            62u8,
                            165u8,
                            134u8,
                            136u8,
                            4u8,
                        ],
                    )
                }
                ///Counter for the related counted storage map
                pub fn counter_for_sub_pools_storage(
                    &self,
                ) -> ::subxt::storage::address::Address<
                    ::subxt::storage::address::StaticStorageMapKey,
                    ::core::primitive::u32,
                    ::subxt::storage::address::Yes,
                    ::subxt::storage::address::Yes,
                    (),
                > {
                    ::subxt::storage::address::Address::new_static(
                        "NominationPools",
                        "CounterForSubPoolsStorage",
                        vec![],
                        [
                            137u8,
                            162u8,
                            32u8,
                            44u8,
                            163u8,
                            30u8,
                            54u8,
                            158u8,
                            169u8,
                            118u8,
                            196u8,
                            101u8,
                            78u8,
                            28u8,
                            184u8,
                            78u8,
                            185u8,
                            225u8,
                            226u8,
                            207u8,
                            14u8,
                            119u8,
                            0u8,
                            116u8,
                            140u8,
                            141u8,
                            116u8,
                            106u8,
                            71u8,
                            161u8,
                            200u8,
                            228u8,
                        ],
                    )
                }
                /// Metadata for the pool.
                pub fn metadata(
                    &self,
                    _0: impl ::std::borrow::Borrow<::core::primitive::u32>,
                ) -> ::subxt::storage::address::Address<
                    ::subxt::storage::address::StaticStorageMapKey,
                    runtime_types::bounded_collections::bounded_vec::BoundedVec<
                        ::core::primitive::u8,
                    >,
                    ::subxt::storage::address::Yes,
                    ::subxt::storage::address::Yes,
                    ::subxt::storage::address::Yes,
                > {
                    ::subxt::storage::address::Address::new_static(
                        "NominationPools",
                        "Metadata",
                        vec![
                            ::subxt::storage::address::make_static_storage_map_key(_0
                            .borrow())
                        ],
                        [
                            10u8,
                            171u8,
                            251u8,
                            5u8,
                            72u8,
                            74u8,
                            86u8,
                            144u8,
                            59u8,
                            67u8,
                            92u8,
                            111u8,
                            217u8,
                            111u8,
                            175u8,
                            107u8,
                            119u8,
                            206u8,
                            199u8,
                            78u8,
                            182u8,
                            84u8,
                            12u8,
                            102u8,
                            10u8,
                            124u8,
                            103u8,
                            9u8,
                            86u8,
                            199u8,
                            233u8,
                            54u8,
                        ],
                    )
                }
                /// Metadata for the pool.
                pub fn metadata_root(
                    &self,
                ) -> ::subxt::storage::address::Address<
                    ::subxt::storage::address::StaticStorageMapKey,
                    runtime_types::bounded_collections::bounded_vec::BoundedVec<
                        ::core::primitive::u8,
                    >,
                    (),
                    ::subxt::storage::address::Yes,
                    ::subxt::storage::address::Yes,
                > {
                    ::subxt::storage::address::Address::new_static(
                        "NominationPools",
                        "Metadata",
                        Vec::new(),
                        [
                            10u8,
                            171u8,
                            251u8,
                            5u8,
                            72u8,
                            74u8,
                            86u8,
                            144u8,
                            59u8,
                            67u8,
                            92u8,
                            111u8,
                            217u8,
                            111u8,
                            175u8,
                            107u8,
                            119u8,
                            206u8,
                            199u8,
                            78u8,
                            182u8,
                            84u8,
                            12u8,
                            102u8,
                            10u8,
                            124u8,
                            103u8,
                            9u8,
                            86u8,
                            199u8,
                            233u8,
                            54u8,
                        ],
                    )
                }
                ///Counter for the related counted storage map
                pub fn counter_for_metadata(
                    &self,
                ) -> ::subxt::storage::address::Address<
                    ::subxt::storage::address::StaticStorageMapKey,
                    ::core::primitive::u32,
                    ::subxt::storage::address::Yes,
                    ::subxt::storage::address::Yes,
                    (),
                > {
                    ::subxt::storage::address::Address::new_static(
                        "NominationPools",
                        "CounterForMetadata",
                        vec![],
                        [
                            49u8,
                            76u8,
                            175u8,
                            236u8,
                            99u8,
                            120u8,
                            156u8,
                            116u8,
                            153u8,
                            173u8,
                            10u8,
                            102u8,
                            194u8,
                            139u8,
                            25u8,
                            149u8,
                            109u8,
                            195u8,
                            150u8,
                            21u8,
                            43u8,
                            24u8,
                            196u8,
                            180u8,
                            231u8,
                            101u8,
                            69u8,
                            98u8,
                            82u8,
                            159u8,
                            183u8,
                            174u8,
                        ],
                    )
                }
                /// Ever increasing number of all pools created so far.
                pub fn last_pool_id(
                    &self,
                ) -> ::subxt::storage::address::Address<
                    ::subxt::storage::address::StaticStorageMapKey,
                    ::core::primitive::u32,
                    ::subxt::storage::address::Yes,
                    ::subxt::storage::address::Yes,
                    (),
                > {
                    ::subxt::storage::address::Address::new_static(
                        "NominationPools",
                        "LastPoolId",
                        vec![],
                        [
                            178u8,
                            198u8,
                            245u8,
                            157u8,
                            176u8,
                            45u8,
                            214u8,
                            86u8,
                            73u8,
                            154u8,
                            217u8,
                            39u8,
                            191u8,
                            53u8,
                            233u8,
                            145u8,
                            57u8,
                            100u8,
                            31u8,
                            13u8,
                            202u8,
                            122u8,
                            115u8,
                            16u8,
                            205u8,
                            69u8,
                            157u8,
                            250u8,
                            216u8,
                            180u8,
                            113u8,
                            30u8,
                        ],
                    )
                }
                /// A reverse lookup from the pool's account id to its id.
                ///
                /// This is only used for slashing. In all other instances, the pool id is used, and the
                /// accounts are deterministically derived from it.
                pub fn reverse_pool_id_lookup(
                    &self,
                    _0: impl ::std::borrow::Borrow<::subxt::utils::AccountId32>,
                ) -> ::subxt::storage::address::Address<
                    ::subxt::storage::address::StaticStorageMapKey,
                    ::core::primitive::u32,
                    ::subxt::storage::address::Yes,
                    (),
                    ::subxt::storage::address::Yes,
                > {
                    ::subxt::storage::address::Address::new_static(
                        "NominationPools",
                        "ReversePoolIdLookup",
                        vec![
                            ::subxt::storage::address::make_static_storage_map_key(_0
                            .borrow())
                        ],
                        [
                            76u8,
                            76u8,
                            150u8,
                            33u8,
                            64u8,
                            81u8,
                            90u8,
                            75u8,
                            212u8,
                            221u8,
                            59u8,
                            83u8,
                            178u8,
                            45u8,
                            86u8,
                            206u8,
                            196u8,
                            221u8,
                            117u8,
                            94u8,
                            229u8,
                            160u8,
                            52u8,
                            54u8,
                            11u8,
                            64u8,
                            0u8,
                            103u8,
                            85u8,
                            86u8,
                            5u8,
                            71u8,
                        ],
                    )
                }
                /// A reverse lookup from the pool's account id to its id.
                ///
                /// This is only used for slashing. In all other instances, the pool id is used, and the
                /// accounts are deterministically derived from it.
                pub fn reverse_pool_id_lookup_root(
                    &self,
                ) -> ::subxt::storage::address::Address<
                    ::subxt::storage::address::StaticStorageMapKey,
                    ::core::primitive::u32,
                    (),
                    (),
                    ::subxt::storage::address::Yes,
                > {
                    ::subxt::storage::address::Address::new_static(
                        "NominationPools",
                        "ReversePoolIdLookup",
                        Vec::new(),
                        [
                            76u8,
                            76u8,
                            150u8,
                            33u8,
                            64u8,
                            81u8,
                            90u8,
                            75u8,
                            212u8,
                            221u8,
                            59u8,
                            83u8,
                            178u8,
                            45u8,
                            86u8,
                            206u8,
                            196u8,
                            221u8,
                            117u8,
                            94u8,
                            229u8,
                            160u8,
                            52u8,
                            54u8,
                            11u8,
                            64u8,
                            0u8,
                            103u8,
                            85u8,
                            86u8,
                            5u8,
                            71u8,
                        ],
                    )
                }
                ///Counter for the related counted storage map
                pub fn counter_for_reverse_pool_id_lookup(
                    &self,
                ) -> ::subxt::storage::address::Address<
                    ::subxt::storage::address::StaticStorageMapKey,
                    ::core::primitive::u32,
                    ::subxt::storage::address::Yes,
                    ::subxt::storage::address::Yes,
                    (),
                > {
                    ::subxt::storage::address::Address::new_static(
                        "NominationPools",
                        "CounterForReversePoolIdLookup",
                        vec![],
                        [
                            135u8,
                            72u8,
                            203u8,
                            197u8,
                            101u8,
                            135u8,
                            114u8,
                            202u8,
                            122u8,
                            231u8,
                            128u8,
                            17u8,
                            81u8,
                            70u8,
                            22u8,
                            146u8,
                            100u8,
                            138u8,
                            16u8,
                            74u8,
                            31u8,
                            250u8,
                            110u8,
                            184u8,
                            250u8,
                            75u8,
                            249u8,
                            71u8,
                            171u8,
                            77u8,
                            95u8,
                            251u8,
                        ],
                    )
                }
                /// Map from a pool member account to their opted claim permission.
                pub fn claim_permissions(
                    &self,
                    _0: impl ::std::borrow::Borrow<::subxt::utils::AccountId32>,
                ) -> ::subxt::storage::address::Address<
                    ::subxt::storage::address::StaticStorageMapKey,
                    runtime_types::pallet_nomination_pools::ClaimPermission,
                    ::subxt::storage::address::Yes,
                    ::subxt::storage::address::Yes,
                    ::subxt::storage::address::Yes,
                > {
                    ::subxt::storage::address::Address::new_static(
                        "NominationPools",
                        "ClaimPermissions",
                        vec![
                            ::subxt::storage::address::make_static_storage_map_key(_0
                            .borrow())
                        ],
                        [
                            98u8,
                            241u8,
                            185u8,
                            102u8,
                            61u8,
                            53u8,
                            215u8,
                            105u8,
                            2u8,
                            148u8,
                            197u8,
                            17u8,
                            107u8,
                            253u8,
                            74u8,
                            159u8,
                            14u8,
                            30u8,
                            213u8,
                            38u8,
                            35u8,
                            163u8,
                            249u8,
                            19u8,
                            140u8,
                            201u8,
                            182u8,
                            106u8,
                            0u8,
                            21u8,
                            102u8,
                            15u8,
                        ],
                    )
                }
                /// Map from a pool member account to their opted claim permission.
                pub fn claim_permissions_root(
                    &self,
                ) -> ::subxt::storage::address::Address<
                    ::subxt::storage::address::StaticStorageMapKey,
                    runtime_types::pallet_nomination_pools::ClaimPermission,
                    (),
                    ::subxt::storage::address::Yes,
                    ::subxt::storage::address::Yes,
                > {
                    ::subxt::storage::address::Address::new_static(
                        "NominationPools",
                        "ClaimPermissions",
                        Vec::new(),
                        [
                            98u8,
                            241u8,
                            185u8,
                            102u8,
                            61u8,
                            53u8,
                            215u8,
                            105u8,
                            2u8,
                            148u8,
                            197u8,
                            17u8,
                            107u8,
                            253u8,
                            74u8,
                            159u8,
                            14u8,
                            30u8,
                            213u8,
                            38u8,
                            35u8,
                            163u8,
                            249u8,
                            19u8,
                            140u8,
                            201u8,
                            182u8,
                            106u8,
                            0u8,
                            21u8,
                            102u8,
                            15u8,
                        ],
                    )
                }
            }
        }
        pub mod constants {
            use super::runtime_types;
            pub struct ConstantsApi;
            impl ConstantsApi {
                /// The nomination pool's pallet id.
                pub fn pallet_id(
                    &self,
                ) -> ::subxt::constants::Address<
                    runtime_types::frame_support::PalletId,
                > {
                    ::subxt::constants::Address::new_static(
                        "NominationPools",
                        "PalletId",
                        [
                            56u8,
                            243u8,
                            53u8,
                            83u8,
                            154u8,
                            179u8,
                            170u8,
                            80u8,
                            133u8,
                            173u8,
                            61u8,
                            161u8,
                            47u8,
                            225u8,
                            146u8,
                            21u8,
                            50u8,
                            229u8,
                            248u8,
                            27u8,
                            104u8,
                            58u8,
                            129u8,
                            197u8,
                            102u8,
                            160u8,
                            168u8,
                            205u8,
                            154u8,
                            42u8,
                            217u8,
                            53u8,
                        ],
                    )
                }
                /// The maximum pool points-to-balance ratio that an `open` pool can have.
                ///
                /// This is important in the event slashing takes place and the pool's points-to-balance
                /// ratio becomes disproportional.
                ///
                /// Moreover, this relates to the `RewardCounter` type as well, as the arithmetic operations
                /// are a function of number of points, and by setting this value to e.g. 10, you ensure
                /// that the total number of points in the system are at most 10 times the total_issuance of
                /// the chain, in the absolute worse case.
                ///
                /// For a value of 10, the threshold would be a pool points-to-balance ratio of 10:1.
                /// Such a scenario would also be the equivalent of the pool being 90% slashed.
                pub fn max_points_to_balance(
                    &self,
                ) -> ::subxt::constants::Address<::core::primitive::u8> {
                    ::subxt::constants::Address::new_static(
                        "NominationPools",
                        "MaxPointsToBalance",
                        [
                            141u8,
                            130u8,
                            11u8,
                            35u8,
                            226u8,
                            114u8,
                            92u8,
                            179u8,
                            168u8,
                            110u8,
                            28u8,
                            91u8,
                            221u8,
                            64u8,
                            4u8,
                            148u8,
                            201u8,
                            193u8,
                            185u8,
                            66u8,
                            226u8,
                            114u8,
                            97u8,
                            79u8,
                            62u8,
                            212u8,
                            202u8,
                            114u8,
                            237u8,
                            228u8,
                            183u8,
                            165u8,
                        ],
                    )
                }
            }
        }
    }
    pub mod scheduler {
        use super::root_mod;
        use super::runtime_types;
        /**
			Custom [dispatch errors](https://docs.substrate.io/main-docs/build/events-errors/)
			of this pallet.
			*/
        pub type Error = runtime_types::pallet_scheduler::pallet::Error;
        ///Contains one variant per dispatchable that can be called by an extrinsic.
        pub type Call = runtime_types::pallet_scheduler::pallet::Call;
        pub mod calls {
            use super::root_mod;
            use super::runtime_types;
            type DispatchError = runtime_types::sp_runtime::DispatchError;
            pub mod types {
                use super::runtime_types;
                #[derive(
                    ::subxt::ext::codec::Decode,
                    ::subxt::ext::codec::Encode,
                    ::subxt::ext::scale_decode::DecodeAsType,
                    ::subxt::ext::scale_encode::EncodeAsType,
                    Clone,
                    Debug,
                    Eq,
                    PartialEq
                )]
                #[codec(crate = ::subxt::ext::codec)]
                #[decode_as_type(crate_path = ":: subxt :: ext :: scale_decode")]
                #[encode_as_type(crate_path = ":: subxt :: ext :: scale_encode")]
                pub struct Schedule {
                    pub when: ::core::primitive::u32,
                    pub maybe_periodic: ::core::option::Option<
                        (::core::primitive::u32, ::core::primitive::u32),
                    >,
                    pub priority: ::core::primitive::u8,
                    pub call: ::std::boxed::Box<
                        runtime_types::tangle_standalone_runtime::RuntimeCall,
                    >,
                }
                impl ::subxt::blocks::StaticExtrinsic for Schedule {
                    const PALLET: &'static str = "Scheduler";
                    const CALL: &'static str = "schedule";
                }
                #[derive(
                    ::subxt::ext::codec::Decode,
                    ::subxt::ext::codec::Encode,
                    ::subxt::ext::scale_decode::DecodeAsType,
                    ::subxt::ext::scale_encode::EncodeAsType,
                    Clone,
                    Debug,
                    Eq,
                    PartialEq
                )]
                #[codec(crate = ::subxt::ext::codec)]
                #[decode_as_type(crate_path = ":: subxt :: ext :: scale_decode")]
                #[encode_as_type(crate_path = ":: subxt :: ext :: scale_encode")]
                pub struct Cancel {
                    pub when: ::core::primitive::u32,
                    pub index: ::core::primitive::u32,
                }
                impl ::subxt::blocks::StaticExtrinsic for Cancel {
                    const PALLET: &'static str = "Scheduler";
                    const CALL: &'static str = "cancel";
                }
                #[derive(
                    ::subxt::ext::codec::Decode,
                    ::subxt::ext::codec::Encode,
                    ::subxt::ext::scale_decode::DecodeAsType,
                    ::subxt::ext::scale_encode::EncodeAsType,
                    Clone,
                    Debug,
                    Eq,
                    PartialEq
                )]
                #[codec(crate = ::subxt::ext::codec)]
                #[decode_as_type(crate_path = ":: subxt :: ext :: scale_decode")]
                #[encode_as_type(crate_path = ":: subxt :: ext :: scale_encode")]
                pub struct ScheduleNamed {
                    pub id: [::core::primitive::u8; 32usize],
                    pub when: ::core::primitive::u32,
                    pub maybe_periodic: ::core::option::Option<
                        (::core::primitive::u32, ::core::primitive::u32),
                    >,
                    pub priority: ::core::primitive::u8,
                    pub call: ::std::boxed::Box<
                        runtime_types::tangle_standalone_runtime::RuntimeCall,
                    >,
                }
                impl ::subxt::blocks::StaticExtrinsic for ScheduleNamed {
                    const PALLET: &'static str = "Scheduler";
                    const CALL: &'static str = "schedule_named";
                }
                #[derive(
                    ::subxt::ext::codec::Decode,
                    ::subxt::ext::codec::Encode,
                    ::subxt::ext::scale_decode::DecodeAsType,
                    ::subxt::ext::scale_encode::EncodeAsType,
                    Clone,
                    Debug,
                    Eq,
                    PartialEq
                )]
                #[codec(crate = ::subxt::ext::codec)]
                #[decode_as_type(crate_path = ":: subxt :: ext :: scale_decode")]
                #[encode_as_type(crate_path = ":: subxt :: ext :: scale_encode")]
                pub struct CancelNamed {
                    pub id: [::core::primitive::u8; 32usize],
                }
                impl ::subxt::blocks::StaticExtrinsic for CancelNamed {
                    const PALLET: &'static str = "Scheduler";
                    const CALL: &'static str = "cancel_named";
                }
                #[derive(
                    ::subxt::ext::codec::Decode,
                    ::subxt::ext::codec::Encode,
                    ::subxt::ext::scale_decode::DecodeAsType,
                    ::subxt::ext::scale_encode::EncodeAsType,
                    Clone,
                    Debug,
                    Eq,
                    PartialEq
                )]
                #[codec(crate = ::subxt::ext::codec)]
                #[decode_as_type(crate_path = ":: subxt :: ext :: scale_decode")]
                #[encode_as_type(crate_path = ":: subxt :: ext :: scale_encode")]
                pub struct ScheduleAfter {
                    pub after: ::core::primitive::u32,
                    pub maybe_periodic: ::core::option::Option<
                        (::core::primitive::u32, ::core::primitive::u32),
                    >,
                    pub priority: ::core::primitive::u8,
                    pub call: ::std::boxed::Box<
                        runtime_types::tangle_standalone_runtime::RuntimeCall,
                    >,
                }
                impl ::subxt::blocks::StaticExtrinsic for ScheduleAfter {
                    const PALLET: &'static str = "Scheduler";
                    const CALL: &'static str = "schedule_after";
                }
                #[derive(
                    ::subxt::ext::codec::Decode,
                    ::subxt::ext::codec::Encode,
                    ::subxt::ext::scale_decode::DecodeAsType,
                    ::subxt::ext::scale_encode::EncodeAsType,
                    Clone,
                    Debug,
                    Eq,
                    PartialEq
                )]
                #[codec(crate = ::subxt::ext::codec)]
                #[decode_as_type(crate_path = ":: subxt :: ext :: scale_decode")]
                #[encode_as_type(crate_path = ":: subxt :: ext :: scale_encode")]
                pub struct ScheduleNamedAfter {
                    pub id: [::core::primitive::u8; 32usize],
                    pub after: ::core::primitive::u32,
                    pub maybe_periodic: ::core::option::Option<
                        (::core::primitive::u32, ::core::primitive::u32),
                    >,
                    pub priority: ::core::primitive::u8,
                    pub call: ::std::boxed::Box<
                        runtime_types::tangle_standalone_runtime::RuntimeCall,
                    >,
                }
                impl ::subxt::blocks::StaticExtrinsic for ScheduleNamedAfter {
                    const PALLET: &'static str = "Scheduler";
                    const CALL: &'static str = "schedule_named_after";
                }
            }
            pub struct TransactionApi;
            impl TransactionApi {
                ///Anonymously schedule a task.
                pub fn schedule(
                    &self,
                    when: ::core::primitive::u32,
                    maybe_periodic: ::core::option::Option<
                        (::core::primitive::u32, ::core::primitive::u32),
                    >,
                    priority: ::core::primitive::u8,
                    call: runtime_types::tangle_standalone_runtime::RuntimeCall,
                ) -> ::subxt::tx::Payload<types::Schedule> {
                    ::subxt::tx::Payload::new_static(
                        "Scheduler",
                        "schedule",
                        types::Schedule {
                            when,
                            maybe_periodic,
                            priority,
                            call: ::std::boxed::Box::new(call),
                        },
                        [
                            107u8,
                            109u8,
                            135u8,
                            115u8,
                            235u8,
                            111u8,
                            10u8,
                            181u8,
                            145u8,
                            195u8,
                            19u8,
                            145u8,
                            53u8,
                            199u8,
                            128u8,
                            213u8,
                            237u8,
                            137u8,
                            41u8,
                            191u8,
                            184u8,
                            49u8,
                            122u8,
                            102u8,
                            105u8,
                            66u8,
                            115u8,
                            86u8,
                            90u8,
                            59u8,
                            40u8,
                            14u8,
                        ],
                    )
                }
                ///Cancel an anonymously scheduled task.
                pub fn cancel(
                    &self,
                    when: ::core::primitive::u32,
                    index: ::core::primitive::u32,
                ) -> ::subxt::tx::Payload<types::Cancel> {
                    ::subxt::tx::Payload::new_static(
                        "Scheduler",
                        "cancel",
                        types::Cancel { when, index },
                        [
                            32u8,
                            107u8,
                            14u8,
                            102u8,
                            56u8,
                            200u8,
                            68u8,
                            186u8,
                            192u8,
                            100u8,
                            152u8,
                            124u8,
                            171u8,
                            154u8,
                            230u8,
                            115u8,
                            62u8,
                            140u8,
                            88u8,
                            178u8,
                            119u8,
                            210u8,
                            222u8,
                            31u8,
                            134u8,
                            225u8,
                            133u8,
                            241u8,
                            42u8,
                            110u8,
                            147u8,
                            47u8,
                        ],
                    )
                }
                ///Schedule a named task.
                pub fn schedule_named(
                    &self,
                    id: [::core::primitive::u8; 32usize],
                    when: ::core::primitive::u32,
                    maybe_periodic: ::core::option::Option<
                        (::core::primitive::u32, ::core::primitive::u32),
                    >,
                    priority: ::core::primitive::u8,
                    call: runtime_types::tangle_standalone_runtime::RuntimeCall,
                ) -> ::subxt::tx::Payload<types::ScheduleNamed> {
                    ::subxt::tx::Payload::new_static(
                        "Scheduler",
                        "schedule_named",
                        types::ScheduleNamed {
                            id,
                            when,
                            maybe_periodic,
                            priority,
                            call: ::std::boxed::Box::new(call),
                        },
                        [
                            189u8,
                            129u8,
                            68u8,
                            252u8,
                            227u8,
                            128u8,
                            91u8,
                            137u8,
                            19u8,
                            33u8,
                            131u8,
                            94u8,
                            93u8,
                            62u8,
                            125u8,
                            202u8,
                            209u8,
                            190u8,
                            188u8,
                            184u8,
                            148u8,
                            8u8,
                            25u8,
                            252u8,
                            102u8,
                            178u8,
                            199u8,
                            229u8,
                            15u8,
                            212u8,
                            225u8,
                            31u8,
                        ],
                    )
                }
                ///Cancel a named scheduled task.
                pub fn cancel_named(
                    &self,
                    id: [::core::primitive::u8; 32usize],
                ) -> ::subxt::tx::Payload<types::CancelNamed> {
                    ::subxt::tx::Payload::new_static(
                        "Scheduler",
                        "cancel_named",
                        types::CancelNamed { id },
                        [
                            205u8,
                            35u8,
                            28u8,
                            57u8,
                            224u8,
                            7u8,
                            49u8,
                            233u8,
                            236u8,
                            163u8,
                            93u8,
                            236u8,
                            103u8,
                            69u8,
                            65u8,
                            51u8,
                            121u8,
                            84u8,
                            9u8,
                            196u8,
                            147u8,
                            122u8,
                            227u8,
                            200u8,
                            181u8,
                            233u8,
                            62u8,
                            240u8,
                            174u8,
                            83u8,
                            129u8,
                            193u8,
                        ],
                    )
                }
                ///Anonymously schedule a task after a delay.
                pub fn schedule_after(
                    &self,
                    after: ::core::primitive::u32,
                    maybe_periodic: ::core::option::Option<
                        (::core::primitive::u32, ::core::primitive::u32),
                    >,
                    priority: ::core::primitive::u8,
                    call: runtime_types::tangle_standalone_runtime::RuntimeCall,
                ) -> ::subxt::tx::Payload<types::ScheduleAfter> {
                    ::subxt::tx::Payload::new_static(
                        "Scheduler",
                        "schedule_after",
                        types::ScheduleAfter {
                            after,
                            maybe_periodic,
                            priority,
                            call: ::std::boxed::Box::new(call),
                        },
                        [
                            133u8,
                            35u8,
                            208u8,
                            152u8,
                            254u8,
                            69u8,
                            162u8,
                            189u8,
                            197u8,
                            32u8,
                            2u8,
                            255u8,
                            190u8,
                            70u8,
                            87u8,
                            173u8,
                            164u8,
                            159u8,
                            205u8,
                            83u8,
                            52u8,
                            228u8,
                            225u8,
                            150u8,
                            87u8,
                            229u8,
                            101u8,
                            173u8,
                            121u8,
                            253u8,
                            107u8,
                            202u8,
                        ],
                    )
                }
                ///Schedule a named task after a delay.
                pub fn schedule_named_after(
                    &self,
                    id: [::core::primitive::u8; 32usize],
                    after: ::core::primitive::u32,
                    maybe_periodic: ::core::option::Option<
                        (::core::primitive::u32, ::core::primitive::u32),
                    >,
                    priority: ::core::primitive::u8,
                    call: runtime_types::tangle_standalone_runtime::RuntimeCall,
                ) -> ::subxt::tx::Payload<types::ScheduleNamedAfter> {
                    ::subxt::tx::Payload::new_static(
                        "Scheduler",
                        "schedule_named_after",
                        types::ScheduleNamedAfter {
                            id,
                            after,
                            maybe_periodic,
                            priority,
                            call: ::std::boxed::Box::new(call),
                        },
                        [
                            221u8,
                            126u8,
                            113u8,
                            228u8,
                            234u8,
                            245u8,
                            188u8,
                            183u8,
                            198u8,
                            208u8,
                            32u8,
                            207u8,
                            147u8,
                            210u8,
                            80u8,
                            219u8,
                            85u8,
                            129u8,
                            170u8,
                            201u8,
                            74u8,
                            82u8,
                            145u8,
                            20u8,
                            223u8,
                            114u8,
                            47u8,
                            133u8,
                            109u8,
                            110u8,
                            233u8,
                            203u8,
                        ],
                    )
                }
            }
        }
        ///Events type.
        pub type Event = runtime_types::pallet_scheduler::pallet::Event;
        pub mod events {
            use super::runtime_types;
            #[derive(
                ::subxt::ext::codec::Decode,
                ::subxt::ext::codec::Encode,
                ::subxt::ext::scale_decode::DecodeAsType,
                ::subxt::ext::scale_encode::EncodeAsType,
                Clone,
                Debug,
                Eq,
                PartialEq
            )]
            #[codec(crate = ::subxt::ext::codec)]
            #[decode_as_type(crate_path = ":: subxt :: ext :: scale_decode")]
            #[encode_as_type(crate_path = ":: subxt :: ext :: scale_encode")]
            ///Scheduled some task.
            pub struct Scheduled {
                pub when: ::core::primitive::u32,
                pub index: ::core::primitive::u32,
            }
            impl ::subxt::events::StaticEvent for Scheduled {
                const PALLET: &'static str = "Scheduler";
                const EVENT: &'static str = "Scheduled";
            }
            #[derive(
                ::subxt::ext::codec::Decode,
                ::subxt::ext::codec::Encode,
                ::subxt::ext::scale_decode::DecodeAsType,
                ::subxt::ext::scale_encode::EncodeAsType,
                Clone,
                Debug,
                Eq,
                PartialEq
            )]
            #[codec(crate = ::subxt::ext::codec)]
            #[decode_as_type(crate_path = ":: subxt :: ext :: scale_decode")]
            #[encode_as_type(crate_path = ":: subxt :: ext :: scale_encode")]
            ///Canceled some task.
            pub struct Canceled {
                pub when: ::core::primitive::u32,
                pub index: ::core::primitive::u32,
            }
            impl ::subxt::events::StaticEvent for Canceled {
                const PALLET: &'static str = "Scheduler";
                const EVENT: &'static str = "Canceled";
            }
            #[derive(
                ::subxt::ext::codec::Decode,
                ::subxt::ext::codec::Encode,
                ::subxt::ext::scale_decode::DecodeAsType,
                ::subxt::ext::scale_encode::EncodeAsType,
                Clone,
                Debug,
                Eq,
                PartialEq
            )]
            #[codec(crate = ::subxt::ext::codec)]
            #[decode_as_type(crate_path = ":: subxt :: ext :: scale_decode")]
            #[encode_as_type(crate_path = ":: subxt :: ext :: scale_encode")]
            ///Dispatched some task.
            pub struct Dispatched {
                pub task: (::core::primitive::u32, ::core::primitive::u32),
                pub id: ::core::option::Option<[::core::primitive::u8; 32usize]>,
                pub result: ::core::result::Result<
                    (),
                    runtime_types::sp_runtime::DispatchError,
                >,
            }
            impl ::subxt::events::StaticEvent for Dispatched {
                const PALLET: &'static str = "Scheduler";
                const EVENT: &'static str = "Dispatched";
            }
            #[derive(
                ::subxt::ext::codec::Decode,
                ::subxt::ext::codec::Encode,
                ::subxt::ext::scale_decode::DecodeAsType,
                ::subxt::ext::scale_encode::EncodeAsType,
                Clone,
                Debug,
                Eq,
                PartialEq
            )]
            #[codec(crate = ::subxt::ext::codec)]
            #[decode_as_type(crate_path = ":: subxt :: ext :: scale_decode")]
            #[encode_as_type(crate_path = ":: subxt :: ext :: scale_encode")]
            ///The call for the provided hash was not found so the task has been aborted.
            pub struct CallUnavailable {
                pub task: (::core::primitive::u32, ::core::primitive::u32),
                pub id: ::core::option::Option<[::core::primitive::u8; 32usize]>,
            }
            impl ::subxt::events::StaticEvent for CallUnavailable {
                const PALLET: &'static str = "Scheduler";
                const EVENT: &'static str = "CallUnavailable";
            }
            #[derive(
                ::subxt::ext::codec::Decode,
                ::subxt::ext::codec::Encode,
                ::subxt::ext::scale_decode::DecodeAsType,
                ::subxt::ext::scale_encode::EncodeAsType,
                Clone,
                Debug,
                Eq,
                PartialEq
            )]
            #[codec(crate = ::subxt::ext::codec)]
            #[decode_as_type(crate_path = ":: subxt :: ext :: scale_decode")]
            #[encode_as_type(crate_path = ":: subxt :: ext :: scale_encode")]
            ///The given task was unable to be renewed since the agenda is full at that block.
            pub struct PeriodicFailed {
                pub task: (::core::primitive::u32, ::core::primitive::u32),
                pub id: ::core::option::Option<[::core::primitive::u8; 32usize]>,
            }
            impl ::subxt::events::StaticEvent for PeriodicFailed {
                const PALLET: &'static str = "Scheduler";
                const EVENT: &'static str = "PeriodicFailed";
            }
            #[derive(
                ::subxt::ext::codec::Decode,
                ::subxt::ext::codec::Encode,
                ::subxt::ext::scale_decode::DecodeAsType,
                ::subxt::ext::scale_encode::EncodeAsType,
                Clone,
                Debug,
                Eq,
                PartialEq
            )]
            #[codec(crate = ::subxt::ext::codec)]
            #[decode_as_type(crate_path = ":: subxt :: ext :: scale_decode")]
            #[encode_as_type(crate_path = ":: subxt :: ext :: scale_encode")]
            ///The given task can never be executed since it is overweight.
            pub struct PermanentlyOverweight {
                pub task: (::core::primitive::u32, ::core::primitive::u32),
                pub id: ::core::option::Option<[::core::primitive::u8; 32usize]>,
            }
            impl ::subxt::events::StaticEvent for PermanentlyOverweight {
                const PALLET: &'static str = "Scheduler";
                const EVENT: &'static str = "PermanentlyOverweight";
            }
        }
        pub mod storage {
            use super::runtime_types;
            pub struct StorageApi;
            impl StorageApi {
                pub fn incomplete_since(
                    &self,
                ) -> ::subxt::storage::address::Address<
                    ::subxt::storage::address::StaticStorageMapKey,
                    ::core::primitive::u32,
                    ::subxt::storage::address::Yes,
                    (),
                    (),
                > {
                    ::subxt::storage::address::Address::new_static(
                        "Scheduler",
                        "IncompleteSince",
                        vec![],
                        [
                            250u8,
                            83u8,
                            64u8,
                            167u8,
                            205u8,
                            59u8,
                            225u8,
                            97u8,
                            205u8,
                            12u8,
                            76u8,
                            130u8,
                            197u8,
                            4u8,
                            111u8,
                            208u8,
                            92u8,
                            217u8,
                            145u8,
                            119u8,
                            38u8,
                            135u8,
                            1u8,
                            242u8,
                            228u8,
                            143u8,
                            56u8,
                            25u8,
                            115u8,
                            233u8,
                            227u8,
                            66u8,
                        ],
                    )
                }
                /// Items to be executed, indexed by the block number that they should be executed on.
                pub fn agenda(
                    &self,
                    _0: impl ::std::borrow::Borrow<::core::primitive::u32>,
                ) -> ::subxt::storage::address::Address<
                    ::subxt::storage::address::StaticStorageMapKey,
                    runtime_types::bounded_collections::bounded_vec::BoundedVec<
                        ::core::option::Option<
                            runtime_types::pallet_scheduler::Scheduled<
                                [::core::primitive::u8; 32usize],
                                runtime_types::frame_support::traits::preimages::Bounded<
                                    runtime_types::tangle_standalone_runtime::RuntimeCall,
                                >,
                                ::core::primitive::u32,
                                runtime_types::tangle_standalone_runtime::OriginCaller,
                                ::subxt::utils::AccountId32,
                            >,
                        >,
                    >,
                    ::subxt::storage::address::Yes,
                    ::subxt::storage::address::Yes,
                    ::subxt::storage::address::Yes,
                > {
                    ::subxt::storage::address::Address::new_static(
                        "Scheduler",
                        "Agenda",
                        vec![
                            ::subxt::storage::address::make_static_storage_map_key(_0
                            .borrow())
                        ],
                        [
                            208u8,
                            81u8,
                            183u8,
                            14u8,
                            40u8,
                            41u8,
                            36u8,
                            96u8,
                            212u8,
                            225u8,
                            141u8,
                            76u8,
                            205u8,
                            104u8,
                            128u8,
                            46u8,
                            75u8,
                            146u8,
                            78u8,
                            19u8,
                            168u8,
                            255u8,
                            238u8,
                            236u8,
                            243u8,
                            226u8,
                            237u8,
                            9u8,
                            183u8,
                            249u8,
                            151u8,
                            12u8,
                        ],
                    )
                }
                /// Items to be executed, indexed by the block number that they should be executed on.
                pub fn agenda_root(
                    &self,
                ) -> ::subxt::storage::address::Address<
                    ::subxt::storage::address::StaticStorageMapKey,
                    runtime_types::bounded_collections::bounded_vec::BoundedVec<
                        ::core::option::Option<
                            runtime_types::pallet_scheduler::Scheduled<
                                [::core::primitive::u8; 32usize],
                                runtime_types::frame_support::traits::preimages::Bounded<
                                    runtime_types::tangle_standalone_runtime::RuntimeCall,
                                >,
                                ::core::primitive::u32,
                                runtime_types::tangle_standalone_runtime::OriginCaller,
                                ::subxt::utils::AccountId32,
                            >,
                        >,
                    >,
                    (),
                    ::subxt::storage::address::Yes,
                    ::subxt::storage::address::Yes,
                > {
                    ::subxt::storage::address::Address::new_static(
                        "Scheduler",
                        "Agenda",
                        Vec::new(),
                        [
                            208u8,
                            81u8,
                            183u8,
                            14u8,
                            40u8,
                            41u8,
                            36u8,
                            96u8,
                            212u8,
                            225u8,
                            141u8,
                            76u8,
                            205u8,
                            104u8,
                            128u8,
                            46u8,
                            75u8,
                            146u8,
                            78u8,
                            19u8,
                            168u8,
                            255u8,
                            238u8,
                            236u8,
                            243u8,
                            226u8,
                            237u8,
                            9u8,
                            183u8,
                            249u8,
                            151u8,
                            12u8,
                        ],
                    )
                }
                /// Lookup from a name to the block number and index of the task.
                ///
                /// For v3 -> v4 the previously unbounded identities are Blake2-256 hashed to form the v4
                /// identities.
                pub fn lookup(
                    &self,
                    _0: impl ::std::borrow::Borrow<[::core::primitive::u8; 32usize]>,
                ) -> ::subxt::storage::address::Address<
                    ::subxt::storage::address::StaticStorageMapKey,
                    (::core::primitive::u32, ::core::primitive::u32),
                    ::subxt::storage::address::Yes,
                    (),
                    ::subxt::storage::address::Yes,
                > {
                    ::subxt::storage::address::Address::new_static(
                        "Scheduler",
                        "Lookup",
                        vec![
                            ::subxt::storage::address::make_static_storage_map_key(_0
                            .borrow())
                        ],
                        [
                            157u8,
                            102u8,
                            210u8,
                            65u8,
                            190u8,
                            48u8,
                            168u8,
                            20u8,
                            197u8,
                            184u8,
                            74u8,
                            119u8,
                            176u8,
                            22u8,
                            244u8,
                            186u8,
                            231u8,
                            239u8,
                            97u8,
                            175u8,
                            34u8,
                            133u8,
                            165u8,
                            73u8,
                            223u8,
                            113u8,
                            78u8,
                            150u8,
                            83u8,
                            127u8,
                            126u8,
                            204u8,
                        ],
                    )
                }
                /// Lookup from a name to the block number and index of the task.
                ///
                /// For v3 -> v4 the previously unbounded identities are Blake2-256 hashed to form the v4
                /// identities.
                pub fn lookup_root(
                    &self,
                ) -> ::subxt::storage::address::Address<
                    ::subxt::storage::address::StaticStorageMapKey,
                    (::core::primitive::u32, ::core::primitive::u32),
                    (),
                    (),
                    ::subxt::storage::address::Yes,
                > {
                    ::subxt::storage::address::Address::new_static(
                        "Scheduler",
                        "Lookup",
                        Vec::new(),
                        [
                            157u8,
                            102u8,
                            210u8,
                            65u8,
                            190u8,
                            48u8,
                            168u8,
                            20u8,
                            197u8,
                            184u8,
                            74u8,
                            119u8,
                            176u8,
                            22u8,
                            244u8,
                            186u8,
                            231u8,
                            239u8,
                            97u8,
                            175u8,
                            34u8,
                            133u8,
                            165u8,
                            73u8,
                            223u8,
                            113u8,
                            78u8,
                            150u8,
                            83u8,
                            127u8,
                            126u8,
                            204u8,
                        ],
                    )
                }
            }
        }
        pub mod constants {
            use super::runtime_types;
            pub struct ConstantsApi;
            impl ConstantsApi {
                /// The maximum weight that may be scheduled per block for any dispatchables.
                pub fn maximum_weight(
                    &self,
                ) -> ::subxt::constants::Address<
                    runtime_types::sp_weights::weight_v2::Weight,
                > {
                    ::subxt::constants::Address::new_static(
                        "Scheduler",
                        "MaximumWeight",
                        [
                            222u8,
                            183u8,
                            203u8,
                            169u8,
                            31u8,
                            134u8,
                            28u8,
                            12u8,
                            47u8,
                            140u8,
                            71u8,
                            74u8,
                            61u8,
                            55u8,
                            71u8,
                            236u8,
                            215u8,
                            83u8,
                            28u8,
                            70u8,
                            45u8,
                            128u8,
                            184u8,
                            57u8,
                            101u8,
                            83u8,
                            42u8,
                            165u8,
                            34u8,
                            155u8,
                            64u8,
                            145u8,
                        ],
                    )
                }
                /// The maximum number of scheduled calls in the queue for a single block.
                ///
                /// NOTE:
                /// + Dependent pallets' benchmarks might require a higher limit for the setting. Set a
                /// higher limit under `runtime-benchmarks` feature.
                pub fn max_scheduled_per_block(
                    &self,
                ) -> ::subxt::constants::Address<::core::primitive::u32> {
                    ::subxt::constants::Address::new_static(
                        "Scheduler",
                        "MaxScheduledPerBlock",
                        [
                            98u8,
                            252u8,
                            116u8,
                            72u8,
                            26u8,
                            180u8,
                            225u8,
                            83u8,
                            200u8,
                            157u8,
                            125u8,
                            151u8,
                            53u8,
                            76u8,
                            168u8,
                            26u8,
                            10u8,
                            9u8,
                            98u8,
                            68u8,
                            9u8,
                            178u8,
                            197u8,
                            113u8,
                            31u8,
                            79u8,
                            200u8,
                            90u8,
                            203u8,
                            100u8,
                            41u8,
                            145u8,
                        ],
                    )
                }
            }
        }
    }
    pub mod preimage {
        use super::root_mod;
        use super::runtime_types;
        /**
			Custom [dispatch errors](https://docs.substrate.io/main-docs/build/events-errors/)
			of this pallet.
			*/
        pub type Error = runtime_types::pallet_preimage::pallet::Error;
        ///Contains one variant per dispatchable that can be called by an extrinsic.
        pub type Call = runtime_types::pallet_preimage::pallet::Call;
        pub mod calls {
            use super::root_mod;
            use super::runtime_types;
            type DispatchError = runtime_types::sp_runtime::DispatchError;
            pub mod types {
                use super::runtime_types;
                #[derive(
                    ::subxt::ext::codec::Decode,
                    ::subxt::ext::codec::Encode,
                    ::subxt::ext::scale_decode::DecodeAsType,
                    ::subxt::ext::scale_encode::EncodeAsType,
                    Clone,
                    Debug,
                    Eq,
                    PartialEq
                )]
                #[codec(crate = ::subxt::ext::codec)]
                #[decode_as_type(crate_path = ":: subxt :: ext :: scale_decode")]
                #[encode_as_type(crate_path = ":: subxt :: ext :: scale_encode")]
                pub struct NotePreimage {
                    pub bytes: ::std::vec::Vec<::core::primitive::u8>,
                }
                impl ::subxt::blocks::StaticExtrinsic for NotePreimage {
                    const PALLET: &'static str = "Preimage";
                    const CALL: &'static str = "note_preimage";
                }
                #[derive(
                    ::subxt::ext::codec::Decode,
                    ::subxt::ext::codec::Encode,
                    ::subxt::ext::scale_decode::DecodeAsType,
                    ::subxt::ext::scale_encode::EncodeAsType,
                    Clone,
                    Debug,
                    Eq,
                    PartialEq
                )]
                #[codec(crate = ::subxt::ext::codec)]
                #[decode_as_type(crate_path = ":: subxt :: ext :: scale_decode")]
                #[encode_as_type(crate_path = ":: subxt :: ext :: scale_encode")]
                pub struct UnnotePreimage {
                    pub hash: ::subxt::utils::H256,
                }
                impl ::subxt::blocks::StaticExtrinsic for UnnotePreimage {
                    const PALLET: &'static str = "Preimage";
                    const CALL: &'static str = "unnote_preimage";
                }
                #[derive(
                    ::subxt::ext::codec::Decode,
                    ::subxt::ext::codec::Encode,
                    ::subxt::ext::scale_decode::DecodeAsType,
                    ::subxt::ext::scale_encode::EncodeAsType,
                    Clone,
                    Debug,
                    Eq,
                    PartialEq
                )]
                #[codec(crate = ::subxt::ext::codec)]
                #[decode_as_type(crate_path = ":: subxt :: ext :: scale_decode")]
                #[encode_as_type(crate_path = ":: subxt :: ext :: scale_encode")]
                pub struct RequestPreimage {
                    pub hash: ::subxt::utils::H256,
                }
                impl ::subxt::blocks::StaticExtrinsic for RequestPreimage {
                    const PALLET: &'static str = "Preimage";
                    const CALL: &'static str = "request_preimage";
                }
                #[derive(
                    ::subxt::ext::codec::Decode,
                    ::subxt::ext::codec::Encode,
                    ::subxt::ext::scale_decode::DecodeAsType,
                    ::subxt::ext::scale_encode::EncodeAsType,
                    Clone,
                    Debug,
                    Eq,
                    PartialEq
                )]
                #[codec(crate = ::subxt::ext::codec)]
                #[decode_as_type(crate_path = ":: subxt :: ext :: scale_decode")]
                #[encode_as_type(crate_path = ":: subxt :: ext :: scale_encode")]
                pub struct UnrequestPreimage {
                    pub hash: ::subxt::utils::H256,
                }
                impl ::subxt::blocks::StaticExtrinsic for UnrequestPreimage {
                    const PALLET: &'static str = "Preimage";
                    const CALL: &'static str = "unrequest_preimage";
                }
            }
            pub struct TransactionApi;
            impl TransactionApi {
                ///Register a preimage on-chain.
                ///
                ///If the preimage was previously requested, no fees or deposits are taken for providing
                ///the preimage. Otherwise, a deposit is taken proportional to the size of the preimage.
                pub fn note_preimage(
                    &self,
                    bytes: ::std::vec::Vec<::core::primitive::u8>,
                ) -> ::subxt::tx::Payload<types::NotePreimage> {
                    ::subxt::tx::Payload::new_static(
                        "Preimage",
                        "note_preimage",
                        types::NotePreimage { bytes },
                        [
                            121u8,
                            88u8,
                            18u8,
                            92u8,
                            176u8,
                            15u8,
                            192u8,
                            198u8,
                            146u8,
                            198u8,
                            38u8,
                            242u8,
                            213u8,
                            83u8,
                            7u8,
                            230u8,
                            14u8,
                            110u8,
                            235u8,
                            32u8,
                            215u8,
                            26u8,
                            192u8,
                            217u8,
                            113u8,
                            224u8,
                            206u8,
                            96u8,
                            177u8,
                            198u8,
                            246u8,
                            33u8,
                        ],
                    )
                }
                ///Clear an unrequested preimage from the runtime storage.
                ///
                ///If `len` is provided, then it will be a much cheaper operation.
                ///
                ///- `hash`: The hash of the preimage to be removed from the store.
                ///- `len`: The length of the preimage of `hash`.
                pub fn unnote_preimage(
                    &self,
                    hash: ::subxt::utils::H256,
                ) -> ::subxt::tx::Payload<types::UnnotePreimage> {
                    ::subxt::tx::Payload::new_static(
                        "Preimage",
                        "unnote_preimage",
                        types::UnnotePreimage { hash },
                        [
                            188u8,
                            116u8,
                            222u8,
                            22u8,
                            127u8,
                            215u8,
                            2u8,
                            133u8,
                            96u8,
                            202u8,
                            190u8,
                            123u8,
                            203u8,
                            43u8,
                            200u8,
                            161u8,
                            226u8,
                            24u8,
                            49u8,
                            36u8,
                            221u8,
                            160u8,
                            130u8,
                            119u8,
                            30u8,
                            138u8,
                            144u8,
                            85u8,
                            5u8,
                            164u8,
                            252u8,
                            222u8,
                        ],
                    )
                }
                ///Request a preimage be uploaded to the chain without paying any fees or deposits.
                ///
                ///If the preimage requests has already been provided on-chain, we unreserve any deposit
                ///a user may have paid, and take the control of the preimage out of their hands.
                pub fn request_preimage(
                    &self,
                    hash: ::subxt::utils::H256,
                ) -> ::subxt::tx::Payload<types::RequestPreimage> {
                    ::subxt::tx::Payload::new_static(
                        "Preimage",
                        "request_preimage",
                        types::RequestPreimage { hash },
                        [
                            87u8,
                            0u8,
                            204u8,
                            111u8,
                            43u8,
                            115u8,
                            64u8,
                            209u8,
                            133u8,
                            13u8,
                            83u8,
                            45u8,
                            164u8,
                            166u8,
                            233u8,
                            105u8,
                            242u8,
                            238u8,
                            235u8,
                            208u8,
                            113u8,
                            134u8,
                            93u8,
                            242u8,
                            86u8,
                            32u8,
                            7u8,
                            152u8,
                            107u8,
                            208u8,
                            79u8,
                            59u8,
                        ],
                    )
                }
                ///Clear a previously made request for a preimage.
                ///
                ///NOTE: THIS MUST NOT BE CALLED ON `hash` MORE TIMES THAN `request_preimage`.
                pub fn unrequest_preimage(
                    &self,
                    hash: ::subxt::utils::H256,
                ) -> ::subxt::tx::Payload<types::UnrequestPreimage> {
                    ::subxt::tx::Payload::new_static(
                        "Preimage",
                        "unrequest_preimage",
                        types::UnrequestPreimage { hash },
                        [
                            55u8,
                            37u8,
                            224u8,
                            149u8,
                            142u8,
                            120u8,
                            8u8,
                            68u8,
                            183u8,
                            225u8,
                            255u8,
                            240u8,
                            254u8,
                            111u8,
                            58u8,
                            200u8,
                            113u8,
                            217u8,
                            177u8,
                            203u8,
                            107u8,
                            104u8,
                            233u8,
                            87u8,
                            252u8,
                            53u8,
                            33u8,
                            112u8,
                            116u8,
                            254u8,
                            117u8,
                            134u8,
                        ],
                    )
                }
            }
        }
        /**
			The [event](https://docs.substrate.io/main-docs/build/events-errors/) emitted
			by this pallet.
			*/
        pub type Event = runtime_types::pallet_preimage::pallet::Event;
        pub mod events {
            use super::runtime_types;
            #[derive(
                ::subxt::ext::codec::Decode,
                ::subxt::ext::codec::Encode,
                ::subxt::ext::scale_decode::DecodeAsType,
                ::subxt::ext::scale_encode::EncodeAsType,
                Clone,
                Debug,
                Eq,
                PartialEq
            )]
            #[codec(crate = ::subxt::ext::codec)]
            #[decode_as_type(crate_path = ":: subxt :: ext :: scale_decode")]
            #[encode_as_type(crate_path = ":: subxt :: ext :: scale_encode")]
            ///A preimage has been noted.
            pub struct Noted {
                pub hash: ::subxt::utils::H256,
            }
            impl ::subxt::events::StaticEvent for Noted {
                const PALLET: &'static str = "Preimage";
                const EVENT: &'static str = "Noted";
            }
            #[derive(
                ::subxt::ext::codec::Decode,
                ::subxt::ext::codec::Encode,
                ::subxt::ext::scale_decode::DecodeAsType,
                ::subxt::ext::scale_encode::EncodeAsType,
                Clone,
                Debug,
                Eq,
                PartialEq
            )]
            #[codec(crate = ::subxt::ext::codec)]
            #[decode_as_type(crate_path = ":: subxt :: ext :: scale_decode")]
            #[encode_as_type(crate_path = ":: subxt :: ext :: scale_encode")]
            ///A preimage has been requested.
            pub struct Requested {
                pub hash: ::subxt::utils::H256,
            }
            impl ::subxt::events::StaticEvent for Requested {
                const PALLET: &'static str = "Preimage";
                const EVENT: &'static str = "Requested";
            }
            #[derive(
                ::subxt::ext::codec::Decode,
                ::subxt::ext::codec::Encode,
                ::subxt::ext::scale_decode::DecodeAsType,
                ::subxt::ext::scale_encode::EncodeAsType,
                Clone,
                Debug,
                Eq,
                PartialEq
            )]
            #[codec(crate = ::subxt::ext::codec)]
            #[decode_as_type(crate_path = ":: subxt :: ext :: scale_decode")]
            #[encode_as_type(crate_path = ":: subxt :: ext :: scale_encode")]
            ///A preimage has ben cleared.
            pub struct Cleared {
                pub hash: ::subxt::utils::H256,
            }
            impl ::subxt::events::StaticEvent for Cleared {
                const PALLET: &'static str = "Preimage";
                const EVENT: &'static str = "Cleared";
            }
        }
        pub mod storage {
            use super::runtime_types;
            pub struct StorageApi;
            impl StorageApi {
                /// The request status of a given hash.
                pub fn status_for(
                    &self,
                    _0: impl ::std::borrow::Borrow<::subxt::utils::H256>,
                ) -> ::subxt::storage::address::Address<
                    ::subxt::storage::address::StaticStorageMapKey,
                    runtime_types::pallet_preimage::RequestStatus<
                        ::subxt::utils::AccountId32,
                        ::core::primitive::u128,
                    >,
                    ::subxt::storage::address::Yes,
                    (),
                    ::subxt::storage::address::Yes,
                > {
                    ::subxt::storage::address::Address::new_static(
                        "Preimage",
                        "StatusFor",
                        vec![
                            ::subxt::storage::address::make_static_storage_map_key(_0
                            .borrow())
                        ],
                        [
                            176u8,
                            174u8,
                            255u8,
                            131u8,
                            156u8,
                            64u8,
                            181u8,
                            119u8,
                            81u8,
                            243u8,
                            144u8,
                            55u8,
                            19u8,
                            140u8,
                            119u8,
                            30u8,
                            210u8,
                            112u8,
                            201u8,
                            247u8,
                            13u8,
                            19u8,
                            120u8,
                            190u8,
                            253u8,
                            89u8,
                            4u8,
                            109u8,
                            122u8,
                            62u8,
                            87u8,
                            186u8,
                        ],
                    )
                }
                /// The request status of a given hash.
                pub fn status_for_root(
                    &self,
                ) -> ::subxt::storage::address::Address<
                    ::subxt::storage::address::StaticStorageMapKey,
                    runtime_types::pallet_preimage::RequestStatus<
                        ::subxt::utils::AccountId32,
                        ::core::primitive::u128,
                    >,
                    (),
                    (),
                    ::subxt::storage::address::Yes,
                > {
                    ::subxt::storage::address::Address::new_static(
                        "Preimage",
                        "StatusFor",
                        Vec::new(),
                        [
                            176u8,
                            174u8,
                            255u8,
                            131u8,
                            156u8,
                            64u8,
                            181u8,
                            119u8,
                            81u8,
                            243u8,
                            144u8,
                            55u8,
                            19u8,
                            140u8,
                            119u8,
                            30u8,
                            210u8,
                            112u8,
                            201u8,
                            247u8,
                            13u8,
                            19u8,
                            120u8,
                            190u8,
                            253u8,
                            89u8,
                            4u8,
                            109u8,
                            122u8,
                            62u8,
                            87u8,
                            186u8,
                        ],
                    )
                }
                pub fn preimage_for(
                    &self,
                    _0: impl ::std::borrow::Borrow<::subxt::utils::H256>,
                    _1: impl ::std::borrow::Borrow<::core::primitive::u32>,
                ) -> ::subxt::storage::address::Address<
                    ::subxt::storage::address::StaticStorageMapKey,
                    runtime_types::bounded_collections::bounded_vec::BoundedVec<
                        ::core::primitive::u8,
                    >,
                    ::subxt::storage::address::Yes,
                    (),
                    ::subxt::storage::address::Yes,
                > {
                    ::subxt::storage::address::Address::new_static(
                        "Preimage",
                        "PreimageFor",
                        vec![
                            ::subxt::storage::address::make_static_storage_map_key(_0
                            .borrow()),
                            ::subxt::storage::address::make_static_storage_map_key(_1
                            .borrow())
                        ],
                        [
                            20u8,
                            5u8,
                            33u8,
                            71u8,
                            153u8,
                            129u8,
                            98u8,
                            23u8,
                            214u8,
                            138u8,
                            96u8,
                            113u8,
                            245u8,
                            128u8,
                            51u8,
                            55u8,
                            123u8,
                            218u8,
                            165u8,
                            247u8,
                            14u8,
                            104u8,
                            119u8,
                            87u8,
                            71u8,
                            222u8,
                            200u8,
                            103u8,
                            58u8,
                            10u8,
                            97u8,
                            134u8,
                        ],
                    )
                }
                pub fn preimage_for_root(
                    &self,
                ) -> ::subxt::storage::address::Address<
                    ::subxt::storage::address::StaticStorageMapKey,
                    runtime_types::bounded_collections::bounded_vec::BoundedVec<
                        ::core::primitive::u8,
                    >,
                    (),
                    (),
                    ::subxt::storage::address::Yes,
                > {
                    ::subxt::storage::address::Address::new_static(
                        "Preimage",
                        "PreimageFor",
                        Vec::new(),
                        [
                            20u8,
                            5u8,
                            33u8,
                            71u8,
                            153u8,
                            129u8,
                            98u8,
                            23u8,
                            214u8,
                            138u8,
                            96u8,
                            113u8,
                            245u8,
                            128u8,
                            51u8,
                            55u8,
                            123u8,
                            218u8,
                            165u8,
                            247u8,
                            14u8,
                            104u8,
                            119u8,
                            87u8,
                            71u8,
                            222u8,
                            200u8,
                            103u8,
                            58u8,
                            10u8,
                            97u8,
                            134u8,
                        ],
                    )
                }
            }
        }
    }
    pub mod offences {
        use super::root_mod;
        use super::runtime_types;
        ///Events type.
        pub type Event = runtime_types::pallet_offences::pallet::Event;
        pub mod events {
            use super::runtime_types;
            #[derive(
                ::subxt::ext::codec::Decode,
                ::subxt::ext::codec::Encode,
                ::subxt::ext::scale_decode::DecodeAsType,
                ::subxt::ext::scale_encode::EncodeAsType,
                Clone,
                Debug,
                Eq,
                PartialEq
            )]
            #[codec(crate = ::subxt::ext::codec)]
            #[decode_as_type(crate_path = ":: subxt :: ext :: scale_decode")]
            #[encode_as_type(crate_path = ":: subxt :: ext :: scale_encode")]
            ///There is an offence reported of the given `kind` happened at the `session_index` and
            ///(kind-specific) time slot. This event is not deposited for duplicate slashes.
            ///\[kind, timeslot\].
            pub struct Offence {
                pub kind: [::core::primitive::u8; 16usize],
                pub timeslot: ::std::vec::Vec<::core::primitive::u8>,
            }
            impl ::subxt::events::StaticEvent for Offence {
                const PALLET: &'static str = "Offences";
                const EVENT: &'static str = "Offence";
            }
        }
        pub mod storage {
            use super::runtime_types;
            pub struct StorageApi;
            impl StorageApi {
                /// The primary structure that holds all offence records keyed by report identifiers.
                pub fn reports(
                    &self,
                    _0: impl ::std::borrow::Borrow<::subxt::utils::H256>,
                ) -> ::subxt::storage::address::Address<
                    ::subxt::storage::address::StaticStorageMapKey,
                    runtime_types::sp_staking::offence::OffenceDetails<
                        ::subxt::utils::AccountId32,
                        (
                            ::subxt::utils::AccountId32,
                            runtime_types::pallet_staking::Exposure<
                                ::subxt::utils::AccountId32,
                                ::core::primitive::u128,
                            >,
                        ),
                    >,
                    ::subxt::storage::address::Yes,
                    (),
                    ::subxt::storage::address::Yes,
                > {
                    ::subxt::storage::address::Address::new_static(
                        "Offences",
                        "Reports",
                        vec![
                            ::subxt::storage::address::make_static_storage_map_key(_0
                            .borrow())
                        ],
                        [
                            242u8,
                            69u8,
                            20u8,
                            130u8,
                            250u8,
                            223u8,
                            68u8,
                            121u8,
                            187u8,
                            215u8,
                            62u8,
                            204u8,
                            100u8,
                            51u8,
                            76u8,
                            164u8,
                            188u8,
                            182u8,
                            215u8,
                            93u8,
                            161u8,
                            100u8,
                            187u8,
                            205u8,
                            73u8,
                            158u8,
                            57u8,
                            198u8,
                            239u8,
                            66u8,
                            42u8,
                            65u8,
                        ],
                    )
                }
                /// The primary structure that holds all offence records keyed by report identifiers.
                pub fn reports_root(
                    &self,
                ) -> ::subxt::storage::address::Address<
                    ::subxt::storage::address::StaticStorageMapKey,
                    runtime_types::sp_staking::offence::OffenceDetails<
                        ::subxt::utils::AccountId32,
                        (
                            ::subxt::utils::AccountId32,
                            runtime_types::pallet_staking::Exposure<
                                ::subxt::utils::AccountId32,
                                ::core::primitive::u128,
                            >,
                        ),
                    >,
                    (),
                    (),
                    ::subxt::storage::address::Yes,
                > {
                    ::subxt::storage::address::Address::new_static(
                        "Offences",
                        "Reports",
                        Vec::new(),
                        [
                            242u8,
                            69u8,
                            20u8,
                            130u8,
                            250u8,
                            223u8,
                            68u8,
                            121u8,
                            187u8,
                            215u8,
                            62u8,
                            204u8,
                            100u8,
                            51u8,
                            76u8,
                            164u8,
                            188u8,
                            182u8,
                            215u8,
                            93u8,
                            161u8,
                            100u8,
                            187u8,
                            205u8,
                            73u8,
                            158u8,
                            57u8,
                            198u8,
                            239u8,
                            66u8,
                            42u8,
                            65u8,
                        ],
                    )
                }
                /// A vector of reports of the same kind that happened at the same time slot.
                pub fn concurrent_reports_index(
                    &self,
                    _0: impl ::std::borrow::Borrow<[::core::primitive::u8; 16usize]>,
                    _1: impl ::std::borrow::Borrow<[::core::primitive::u8]>,
                ) -> ::subxt::storage::address::Address<
                    ::subxt::storage::address::StaticStorageMapKey,
                    ::std::vec::Vec<::subxt::utils::H256>,
                    ::subxt::storage::address::Yes,
                    ::subxt::storage::address::Yes,
                    ::subxt::storage::address::Yes,
                > {
                    ::subxt::storage::address::Address::new_static(
                        "Offences",
                        "ConcurrentReportsIndex",
                        vec![
                            ::subxt::storage::address::make_static_storage_map_key(_0
                            .borrow()),
                            ::subxt::storage::address::make_static_storage_map_key(_1
                            .borrow())
                        ],
                        [
                            125u8,
                            222u8,
                            9u8,
                            162u8,
                            38u8,
                            89u8,
                            77u8,
                            187u8,
                            129u8,
                            103u8,
                            21u8,
                            31u8,
                            117u8,
                            101u8,
                            43u8,
                            115u8,
                            170u8,
                            205u8,
                            142u8,
                            26u8,
                            27u8,
                            184u8,
                            152u8,
                            133u8,
                            76u8,
                            203u8,
                            78u8,
                            113u8,
                            51u8,
                            141u8,
                            118u8,
                            171u8,
                        ],
                    )
                }
                /// A vector of reports of the same kind that happened at the same time slot.
                pub fn concurrent_reports_index_root(
                    &self,
                ) -> ::subxt::storage::address::Address<
                    ::subxt::storage::address::StaticStorageMapKey,
                    ::std::vec::Vec<::subxt::utils::H256>,
                    (),
                    ::subxt::storage::address::Yes,
                    ::subxt::storage::address::Yes,
                > {
                    ::subxt::storage::address::Address::new_static(
                        "Offences",
                        "ConcurrentReportsIndex",
                        Vec::new(),
                        [
                            125u8,
                            222u8,
                            9u8,
                            162u8,
                            38u8,
                            89u8,
                            77u8,
                            187u8,
                            129u8,
                            103u8,
                            21u8,
                            31u8,
                            117u8,
                            101u8,
                            43u8,
                            115u8,
                            170u8,
                            205u8,
                            142u8,
                            26u8,
                            27u8,
                            184u8,
                            152u8,
                            133u8,
                            76u8,
                            203u8,
                            78u8,
                            113u8,
                            51u8,
                            141u8,
                            118u8,
                            171u8,
                        ],
                    )
                }
            }
        }
    }
    pub mod transaction_pause {
        use super::root_mod;
        use super::runtime_types;
        /**
			Custom [dispatch errors](https://docs.substrate.io/main-docs/build/events-errors/)
			of this pallet.
			*/
        pub type Error = runtime_types::pallet_transaction_pause::module::Error;
        ///Contains one variant per dispatchable that can be called by an extrinsic.
        pub type Call = runtime_types::pallet_transaction_pause::module::Call;
        pub mod calls {
            use super::root_mod;
            use super::runtime_types;
            type DispatchError = runtime_types::sp_runtime::DispatchError;
            pub mod types {
                use super::runtime_types;
                #[derive(
                    ::subxt::ext::codec::Decode,
                    ::subxt::ext::codec::Encode,
                    ::subxt::ext::scale_decode::DecodeAsType,
                    ::subxt::ext::scale_encode::EncodeAsType,
                    Clone,
                    Debug,
                    Eq,
                    PartialEq
                )]
                #[codec(crate = ::subxt::ext::codec)]
                #[decode_as_type(crate_path = ":: subxt :: ext :: scale_decode")]
                #[encode_as_type(crate_path = ":: subxt :: ext :: scale_encode")]
                pub struct PauseTransaction {
                    pub pallet_name: ::std::vec::Vec<::core::primitive::u8>,
                    pub function_name: ::std::vec::Vec<::core::primitive::u8>,
                }
                impl ::subxt::blocks::StaticExtrinsic for PauseTransaction {
                    const PALLET: &'static str = "TransactionPause";
                    const CALL: &'static str = "pause_transaction";
                }
                #[derive(
                    ::subxt::ext::codec::Decode,
                    ::subxt::ext::codec::Encode,
                    ::subxt::ext::scale_decode::DecodeAsType,
                    ::subxt::ext::scale_encode::EncodeAsType,
                    Clone,
                    Debug,
                    Eq,
                    PartialEq
                )]
                #[codec(crate = ::subxt::ext::codec)]
                #[decode_as_type(crate_path = ":: subxt :: ext :: scale_decode")]
                #[encode_as_type(crate_path = ":: subxt :: ext :: scale_encode")]
                pub struct UnpauseTransaction {
                    pub pallet_name: ::std::vec::Vec<::core::primitive::u8>,
                    pub function_name: ::std::vec::Vec<::core::primitive::u8>,
                }
                impl ::subxt::blocks::StaticExtrinsic for UnpauseTransaction {
                    const PALLET: &'static str = "TransactionPause";
                    const CALL: &'static str = "unpause_transaction";
                }
            }
            pub struct TransactionApi;
            impl TransactionApi {
                pub fn pause_transaction(
                    &self,
                    pallet_name: ::std::vec::Vec<::core::primitive::u8>,
                    function_name: ::std::vec::Vec<::core::primitive::u8>,
                ) -> ::subxt::tx::Payload<types::PauseTransaction> {
                    ::subxt::tx::Payload::new_static(
                        "TransactionPause",
                        "pause_transaction",
                        types::PauseTransaction {
                            pallet_name,
                            function_name,
                        },
                        [
                            138u8,
                            107u8,
                            164u8,
                            19u8,
                            105u8,
                            141u8,
                            247u8,
                            143u8,
                            135u8,
                            26u8,
                            239u8,
                            189u8,
                            143u8,
                            183u8,
                            234u8,
                            218u8,
                            244u8,
                            6u8,
                            239u8,
                            57u8,
                            169u8,
                            140u8,
                            208u8,
                            19u8,
                            78u8,
                            154u8,
                            73u8,
                            109u8,
                            52u8,
                            92u8,
                            173u8,
                            207u8,
                        ],
                    )
                }
                pub fn unpause_transaction(
                    &self,
                    pallet_name: ::std::vec::Vec<::core::primitive::u8>,
                    function_name: ::std::vec::Vec<::core::primitive::u8>,
                ) -> ::subxt::tx::Payload<types::UnpauseTransaction> {
                    ::subxt::tx::Payload::new_static(
                        "TransactionPause",
                        "unpause_transaction",
                        types::UnpauseTransaction {
                            pallet_name,
                            function_name,
                        },
                        [
                            18u8,
                            88u8,
                            203u8,
                            52u8,
                            136u8,
                            162u8,
                            204u8,
                            108u8,
                            156u8,
                            126u8,
                            247u8,
                            215u8,
                            129u8,
                            79u8,
                            65u8,
                            233u8,
                            161u8,
                            94u8,
                            124u8,
                            129u8,
                            32u8,
                            27u8,
                            199u8,
                            94u8,
                            62u8,
                            103u8,
                            59u8,
                            198u8,
                            165u8,
                            189u8,
                            248u8,
                            255u8,
                        ],
                    )
                }
            }
        }
        /**
			The [event](https://docs.substrate.io/main-docs/build/events-errors/) emitted
			by this pallet.
			*/
        pub type Event = runtime_types::pallet_transaction_pause::module::Event;
        pub mod events {
            use super::runtime_types;
            #[derive(
                ::subxt::ext::codec::Decode,
                ::subxt::ext::codec::Encode,
                ::subxt::ext::scale_decode::DecodeAsType,
                ::subxt::ext::scale_encode::EncodeAsType,
                Clone,
                Debug,
                Eq,
                PartialEq
            )]
            #[codec(crate = ::subxt::ext::codec)]
            #[decode_as_type(crate_path = ":: subxt :: ext :: scale_decode")]
            #[encode_as_type(crate_path = ":: subxt :: ext :: scale_encode")]
            ///Paused transaction
            pub struct TransactionPaused {
                pub pallet_name_bytes: ::std::vec::Vec<::core::primitive::u8>,
                pub function_name_bytes: ::std::vec::Vec<::core::primitive::u8>,
            }
            impl ::subxt::events::StaticEvent for TransactionPaused {
                const PALLET: &'static str = "TransactionPause";
                const EVENT: &'static str = "TransactionPaused";
            }
            #[derive(
                ::subxt::ext::codec::Decode,
                ::subxt::ext::codec::Encode,
                ::subxt::ext::scale_decode::DecodeAsType,
                ::subxt::ext::scale_encode::EncodeAsType,
                Clone,
                Debug,
                Eq,
                PartialEq
            )]
            #[codec(crate = ::subxt::ext::codec)]
            #[decode_as_type(crate_path = ":: subxt :: ext :: scale_decode")]
            #[encode_as_type(crate_path = ":: subxt :: ext :: scale_encode")]
            ///Unpaused transaction
            pub struct TransactionUnpaused {
                pub pallet_name_bytes: ::std::vec::Vec<::core::primitive::u8>,
                pub function_name_bytes: ::std::vec::Vec<::core::primitive::u8>,
            }
            impl ::subxt::events::StaticEvent for TransactionUnpaused {
                const PALLET: &'static str = "TransactionPause";
                const EVENT: &'static str = "TransactionUnpaused";
            }
        }
        pub mod storage {
            use super::runtime_types;
            pub struct StorageApi;
            impl StorageApi {
                /// The paused transaction map
                ///
                /// map (PalletNameBytes, FunctionNameBytes) => Option<()>
                pub fn paused_transactions(
                    &self,
                    _0: impl ::std::borrow::Borrow<[::core::primitive::u8]>,
                    _1: impl ::std::borrow::Borrow<[::core::primitive::u8]>,
                ) -> ::subxt::storage::address::Address<
                    ::subxt::storage::address::StaticStorageMapKey,
                    (),
                    ::subxt::storage::address::Yes,
                    (),
                    ::subxt::storage::address::Yes,
                > {
                    ::subxt::storage::address::Address::new_static(
                        "TransactionPause",
                        "PausedTransactions",
                        vec![
                            ::subxt::storage::address::make_static_storage_map_key(_0
                            .borrow()),
                            ::subxt::storage::address::make_static_storage_map_key(_1
                            .borrow())
                        ],
                        [
                            253u8,
                            205u8,
                            177u8,
                            203u8,
                            183u8,
                            24u8,
                            90u8,
                            47u8,
                            136u8,
                            199u8,
                            244u8,
                            175u8,
                            165u8,
                            100u8,
                            224u8,
                            221u8,
                            180u8,
                            115u8,
                            114u8,
                            108u8,
                            60u8,
                            13u8,
                            46u8,
                            108u8,
                            42u8,
                            246u8,
                            220u8,
                            34u8,
                            196u8,
                            95u8,
                            196u8,
                            170u8,
                        ],
                    )
                }
                /// The paused transaction map
                ///
                /// map (PalletNameBytes, FunctionNameBytes) => Option<()>
                pub fn paused_transactions_root(
                    &self,
                ) -> ::subxt::storage::address::Address<
                    ::subxt::storage::address::StaticStorageMapKey,
                    (),
                    (),
                    (),
                    ::subxt::storage::address::Yes,
                > {
                    ::subxt::storage::address::Address::new_static(
                        "TransactionPause",
                        "PausedTransactions",
                        Vec::new(),
                        [
                            253u8,
                            205u8,
                            177u8,
                            203u8,
                            183u8,
                            24u8,
                            90u8,
                            47u8,
                            136u8,
                            199u8,
                            244u8,
                            175u8,
                            165u8,
                            100u8,
                            224u8,
                            221u8,
                            180u8,
                            115u8,
                            114u8,
                            108u8,
                            60u8,
                            13u8,
                            46u8,
                            108u8,
                            42u8,
                            246u8,
                            220u8,
                            34u8,
                            196u8,
                            95u8,
                            196u8,
                            170u8,
                        ],
                    )
                }
            }
        }
    }
    pub mod im_online {
        use super::root_mod;
        use super::runtime_types;
        /**
			Custom [dispatch errors](https://docs.substrate.io/main-docs/build/events-errors/)
			of this pallet.
			*/
        pub type Error = runtime_types::pallet_im_online::pallet::Error;
        ///Contains one variant per dispatchable that can be called by an extrinsic.
        pub type Call = runtime_types::pallet_im_online::pallet::Call;
        pub mod calls {
            use super::root_mod;
            use super::runtime_types;
            type DispatchError = runtime_types::sp_runtime::DispatchError;
            pub mod types {
                use super::runtime_types;
                #[derive(
                    ::subxt::ext::codec::Decode,
                    ::subxt::ext::codec::Encode,
                    ::subxt::ext::scale_decode::DecodeAsType,
                    ::subxt::ext::scale_encode::EncodeAsType,
                    Clone,
                    Debug,
                    Eq,
                    PartialEq
                )]
                #[codec(crate = ::subxt::ext::codec)]
                #[decode_as_type(crate_path = ":: subxt :: ext :: scale_decode")]
                #[encode_as_type(crate_path = ":: subxt :: ext :: scale_encode")]
                pub struct Heartbeat {
                    pub heartbeat: runtime_types::pallet_im_online::Heartbeat<
                        ::core::primitive::u32,
                    >,
                    pub signature: runtime_types::pallet_im_online::sr25519::app_sr25519::Signature,
                }
                impl ::subxt::blocks::StaticExtrinsic for Heartbeat {
                    const PALLET: &'static str = "ImOnline";
                    const CALL: &'static str = "heartbeat";
                }
            }
            pub struct TransactionApi;
            impl TransactionApi {
                ///## Complexity:
                ///- `O(K + E)` where K is length of `Keys` (heartbeat.validators_len) and E is length of
                ///  `heartbeat.network_state.external_address`
                ///  - `O(K)`: decoding of length `K`
                ///  - `O(E)`: decoding/encoding of length `E`
                pub fn heartbeat(
                    &self,
                    heartbeat: runtime_types::pallet_im_online::Heartbeat<
                        ::core::primitive::u32,
                    >,
                    signature: runtime_types::pallet_im_online::sr25519::app_sr25519::Signature,
                ) -> ::subxt::tx::Payload<types::Heartbeat> {
                    ::subxt::tx::Payload::new_static(
                        "ImOnline",
                        "heartbeat",
                        types::Heartbeat {
                            heartbeat,
                            signature,
                        },
                        [
                            191u8,
                            155u8,
                            217u8,
                            65u8,
                            8u8,
                            34u8,
                            41u8,
                            185u8,
                            187u8,
                            199u8,
                            164u8,
                            48u8,
                            76u8,
                            123u8,
                            235u8,
                            182u8,
                            85u8,
                            107u8,
                            48u8,
                            158u8,
                            110u8,
                            206u8,
                            145u8,
                            119u8,
                            165u8,
                            253u8,
                            27u8,
                            59u8,
                            0u8,
                            112u8,
                            241u8,
                            242u8,
                        ],
                    )
                }
            }
        }
        /**
			The [event](https://docs.substrate.io/main-docs/build/events-errors/) emitted
			by this pallet.
			*/
        pub type Event = runtime_types::pallet_im_online::pallet::Event;
        pub mod events {
            use super::runtime_types;
            #[derive(
                ::subxt::ext::codec::Decode,
                ::subxt::ext::codec::Encode,
                ::subxt::ext::scale_decode::DecodeAsType,
                ::subxt::ext::scale_encode::EncodeAsType,
                Clone,
                Debug,
                Eq,
                PartialEq
            )]
            #[codec(crate = ::subxt::ext::codec)]
            #[decode_as_type(crate_path = ":: subxt :: ext :: scale_decode")]
            #[encode_as_type(crate_path = ":: subxt :: ext :: scale_encode")]
            ///A new heartbeat was received from `AuthorityId`.
            pub struct HeartbeatReceived {
                pub authority_id: runtime_types::pallet_im_online::sr25519::app_sr25519::Public,
            }
            impl ::subxt::events::StaticEvent for HeartbeatReceived {
                const PALLET: &'static str = "ImOnline";
                const EVENT: &'static str = "HeartbeatReceived";
            }
            #[derive(
                ::subxt::ext::codec::Decode,
                ::subxt::ext::codec::Encode,
                ::subxt::ext::scale_decode::DecodeAsType,
                ::subxt::ext::scale_encode::EncodeAsType,
                Clone,
                Debug,
                Eq,
                PartialEq
            )]
            #[codec(crate = ::subxt::ext::codec)]
            #[decode_as_type(crate_path = ":: subxt :: ext :: scale_decode")]
            #[encode_as_type(crate_path = ":: subxt :: ext :: scale_encode")]
            ///At the end of the session, no offence was committed.
            pub struct AllGood;
            impl ::subxt::events::StaticEvent for AllGood {
                const PALLET: &'static str = "ImOnline";
                const EVENT: &'static str = "AllGood";
            }
            #[derive(
                ::subxt::ext::codec::Decode,
                ::subxt::ext::codec::Encode,
                ::subxt::ext::scale_decode::DecodeAsType,
                ::subxt::ext::scale_encode::EncodeAsType,
                Clone,
                Debug,
                Eq,
                PartialEq
            )]
            #[codec(crate = ::subxt::ext::codec)]
            #[decode_as_type(crate_path = ":: subxt :: ext :: scale_decode")]
            #[encode_as_type(crate_path = ":: subxt :: ext :: scale_encode")]
            ///At the end of the session, at least one validator was found to be offline.
            pub struct SomeOffline {
                pub offline: ::std::vec::Vec<
                    (
                        ::subxt::utils::AccountId32,
                        runtime_types::pallet_staking::Exposure<
                            ::subxt::utils::AccountId32,
                            ::core::primitive::u128,
                        >,
                    ),
                >,
            }
            impl ::subxt::events::StaticEvent for SomeOffline {
                const PALLET: &'static str = "ImOnline";
                const EVENT: &'static str = "SomeOffline";
            }
        }
        pub mod storage {
            use super::runtime_types;
            pub struct StorageApi;
            impl StorageApi {
                /// The block number after which it's ok to send heartbeats in the current
                /// session.
                ///
                /// At the beginning of each session we set this to a value that should fall
                /// roughly in the middle of the session duration. The idea is to first wait for
                /// the validators to produce a block in the current session, so that the
                /// heartbeat later on will not be necessary.
                ///
                /// This value will only be used as a fallback if we fail to get a proper session
                /// progress estimate from `NextSessionRotation`, as those estimates should be
                /// more accurate then the value we calculate for `HeartbeatAfter`.
                pub fn heartbeat_after(
                    &self,
                ) -> ::subxt::storage::address::Address<
                    ::subxt::storage::address::StaticStorageMapKey,
                    ::core::primitive::u32,
                    ::subxt::storage::address::Yes,
                    ::subxt::storage::address::Yes,
                    (),
                > {
                    ::subxt::storage::address::Address::new_static(
                        "ImOnline",
                        "HeartbeatAfter",
                        vec![],
                        [
                            36u8,
                            179u8,
                            76u8,
                            254u8,
                            3u8,
                            184u8,
                            154u8,
                            142u8,
                            70u8,
                            104u8,
                            44u8,
                            244u8,
                            39u8,
                            97u8,
                            31u8,
                            31u8,
                            93u8,
                            228u8,
                            185u8,
                            224u8,
                            13u8,
                            160u8,
                            231u8,
                            210u8,
                            110u8,
                            143u8,
                            116u8,
                            29u8,
                            0u8,
                            215u8,
                            217u8,
                            137u8,
                        ],
                    )
                }
                /// The current set of keys that may issue a heartbeat.
                pub fn keys(
                    &self,
                ) -> ::subxt::storage::address::Address<
                    ::subxt::storage::address::StaticStorageMapKey,
                    runtime_types::bounded_collections::weak_bounded_vec::WeakBoundedVec<
                        runtime_types::pallet_im_online::sr25519::app_sr25519::Public,
                    >,
                    ::subxt::storage::address::Yes,
                    ::subxt::storage::address::Yes,
                    (),
                > {
                    ::subxt::storage::address::Address::new_static(
                        "ImOnline",
                        "Keys",
                        vec![],
                        [
                            111u8,
                            104u8,
                            188u8,
                            46u8,
                            152u8,
                            140u8,
                            137u8,
                            244u8,
                            52u8,
                            214u8,
                            115u8,
                            156u8,
                            39u8,
                            239u8,
                            15u8,
                            168u8,
                            193u8,
                            125u8,
                            57u8,
                            195u8,
                            250u8,
                            156u8,
                            234u8,
                            222u8,
                            222u8,
                            253u8,
                            135u8,
                            232u8,
                            196u8,
                            163u8,
                            29u8,
                            218u8,
                        ],
                    )
                }
                /// For each session index, we keep a mapping of `SessionIndex` and `AuthIndex` to
                /// `WrapperOpaque<BoundedOpaqueNetworkState>`.
                pub fn received_heartbeats(
                    &self,
                    _0: impl ::std::borrow::Borrow<::core::primitive::u32>,
                    _1: impl ::std::borrow::Borrow<::core::primitive::u32>,
                ) -> ::subxt::storage::address::Address<
                    ::subxt::storage::address::StaticStorageMapKey,
                    runtime_types::frame_support::traits::misc::WrapperOpaque<
                        runtime_types::pallet_im_online::BoundedOpaqueNetworkState,
                    >,
                    ::subxt::storage::address::Yes,
                    (),
                    ::subxt::storage::address::Yes,
                > {
                    ::subxt::storage::address::Address::new_static(
                        "ImOnline",
                        "ReceivedHeartbeats",
                        vec![
                            ::subxt::storage::address::make_static_storage_map_key(_0
                            .borrow()),
                            ::subxt::storage::address::make_static_storage_map_key(_1
                            .borrow())
                        ],
                        [
                            244u8,
                            195u8,
                            226u8,
                            146u8,
                            31u8,
                            109u8,
                            70u8,
                            31u8,
                            198u8,
                            97u8,
                            116u8,
                            249u8,
                            115u8,
                            191u8,
                            13u8,
                            96u8,
                            12u8,
                            200u8,
                            235u8,
                            254u8,
                            3u8,
                            36u8,
                            51u8,
                            43u8,
                            224u8,
                            251u8,
                            76u8,
                            197u8,
                            157u8,
                            173u8,
                            125u8,
                            161u8,
                        ],
                    )
                }
                /// For each session index, we keep a mapping of `SessionIndex` and `AuthIndex` to
                /// `WrapperOpaque<BoundedOpaqueNetworkState>`.
                pub fn received_heartbeats_root(
                    &self,
                ) -> ::subxt::storage::address::Address<
                    ::subxt::storage::address::StaticStorageMapKey,
                    runtime_types::frame_support::traits::misc::WrapperOpaque<
                        runtime_types::pallet_im_online::BoundedOpaqueNetworkState,
                    >,
                    (),
                    (),
                    ::subxt::storage::address::Yes,
                > {
                    ::subxt::storage::address::Address::new_static(
                        "ImOnline",
                        "ReceivedHeartbeats",
                        Vec::new(),
                        [
                            244u8,
                            195u8,
                            226u8,
                            146u8,
                            31u8,
                            109u8,
                            70u8,
                            31u8,
                            198u8,
                            97u8,
                            116u8,
                            249u8,
                            115u8,
                            191u8,
                            13u8,
                            96u8,
                            12u8,
                            200u8,
                            235u8,
                            254u8,
                            3u8,
                            36u8,
                            51u8,
                            43u8,
                            224u8,
                            251u8,
                            76u8,
                            197u8,
                            157u8,
                            173u8,
                            125u8,
                            161u8,
                        ],
                    )
                }
                /// For each session index, we keep a mapping of `ValidatorId<T>` to the
                /// number of blocks authored by the given authority.
                pub fn authored_blocks(
                    &self,
                    _0: impl ::std::borrow::Borrow<::core::primitive::u32>,
                    _1: impl ::std::borrow::Borrow<::subxt::utils::AccountId32>,
                ) -> ::subxt::storage::address::Address<
                    ::subxt::storage::address::StaticStorageMapKey,
                    ::core::primitive::u32,
                    ::subxt::storage::address::Yes,
                    ::subxt::storage::address::Yes,
                    ::subxt::storage::address::Yes,
                > {
                    ::subxt::storage::address::Address::new_static(
                        "ImOnline",
                        "AuthoredBlocks",
                        vec![
                            ::subxt::storage::address::make_static_storage_map_key(_0
                            .borrow()),
                            ::subxt::storage::address::make_static_storage_map_key(_1
                            .borrow())
                        ],
                        [
                            121u8,
                            246u8,
                            100u8,
                            191u8,
                            5u8,
                            211u8,
                            190u8,
                            244u8,
                            61u8,
                            73u8,
                            169u8,
                            127u8,
                            116u8,
                            80u8,
                            118u8,
                            139u8,
                            115u8,
                            58u8,
                            125u8,
                            81u8,
                            75u8,
                            20u8,
                            194u8,
                            74u8,
                            97u8,
                            188u8,
                            55u8,
                            160u8,
                            33u8,
                            155u8,
                            186u8,
                            74u8,
                        ],
                    )
                }
                /// For each session index, we keep a mapping of `ValidatorId<T>` to the
                /// number of blocks authored by the given authority.
                pub fn authored_blocks_root(
                    &self,
                ) -> ::subxt::storage::address::Address<
                    ::subxt::storage::address::StaticStorageMapKey,
                    ::core::primitive::u32,
                    (),
                    ::subxt::storage::address::Yes,
                    ::subxt::storage::address::Yes,
                > {
                    ::subxt::storage::address::Address::new_static(
                        "ImOnline",
                        "AuthoredBlocks",
                        Vec::new(),
                        [
                            121u8,
                            246u8,
                            100u8,
                            191u8,
                            5u8,
                            211u8,
                            190u8,
                            244u8,
                            61u8,
                            73u8,
                            169u8,
                            127u8,
                            116u8,
                            80u8,
                            118u8,
                            139u8,
                            115u8,
                            58u8,
                            125u8,
                            81u8,
                            75u8,
                            20u8,
                            194u8,
                            74u8,
                            97u8,
                            188u8,
                            55u8,
                            160u8,
                            33u8,
                            155u8,
                            186u8,
                            74u8,
                        ],
                    )
                }
            }
        }
        pub mod constants {
            use super::runtime_types;
            pub struct ConstantsApi;
            impl ConstantsApi {
                /// A configuration for base priority of unsigned transactions.
                ///
                /// This is exposed so that it can be tuned for particular runtime, when
                /// multiple pallets send unsigned transactions.
                pub fn unsigned_priority(
                    &self,
                ) -> ::subxt::constants::Address<::core::primitive::u64> {
                    ::subxt::constants::Address::new_static(
                        "ImOnline",
                        "UnsignedPriority",
                        [
                            128u8,
                            214u8,
                            205u8,
                            242u8,
                            181u8,
                            142u8,
                            124u8,
                            231u8,
                            190u8,
                            146u8,
                            59u8,
                            226u8,
                            157u8,
                            101u8,
                            103u8,
                            117u8,
                            249u8,
                            65u8,
                            18u8,
                            191u8,
                            103u8,
                            119u8,
                            53u8,
                            85u8,
                            81u8,
                            96u8,
                            220u8,
                            42u8,
                            184u8,
                            239u8,
                            42u8,
                            246u8,
                        ],
                    )
                }
            }
        }
    }
    pub mod identity {
        use super::root_mod;
        use super::runtime_types;
        /**
			Custom [dispatch errors](https://docs.substrate.io/main-docs/build/events-errors/)
			of this pallet.
			*/
        pub type Error = runtime_types::pallet_identity::pallet::Error;
        ///Identity pallet declaration.
        pub type Call = runtime_types::pallet_identity::pallet::Call;
        pub mod calls {
            use super::root_mod;
            use super::runtime_types;
            type DispatchError = runtime_types::sp_runtime::DispatchError;
            pub mod types {
                use super::runtime_types;
                #[derive(
                    ::subxt::ext::codec::Decode,
                    ::subxt::ext::codec::Encode,
                    ::subxt::ext::scale_decode::DecodeAsType,
                    ::subxt::ext::scale_encode::EncodeAsType,
                    Clone,
                    Debug,
                    Eq,
                    PartialEq
                )]
                #[codec(crate = ::subxt::ext::codec)]
                #[decode_as_type(crate_path = ":: subxt :: ext :: scale_decode")]
                #[encode_as_type(crate_path = ":: subxt :: ext :: scale_encode")]
                pub struct AddRegistrar {
                    pub account: ::subxt::utils::MultiAddress<
                        ::subxt::utils::AccountId32,
                        ::core::primitive::u32,
                    >,
                }
                impl ::subxt::blocks::StaticExtrinsic for AddRegistrar {
                    const PALLET: &'static str = "Identity";
                    const CALL: &'static str = "add_registrar";
                }
                #[derive(
                    ::subxt::ext::codec::Decode,
                    ::subxt::ext::codec::Encode,
                    ::subxt::ext::scale_decode::DecodeAsType,
                    ::subxt::ext::scale_encode::EncodeAsType,
                    Clone,
                    Debug,
                    Eq,
                    PartialEq
                )]
                #[codec(crate = ::subxt::ext::codec)]
                #[decode_as_type(crate_path = ":: subxt :: ext :: scale_decode")]
                #[encode_as_type(crate_path = ":: subxt :: ext :: scale_encode")]
                pub struct SetIdentity {
                    pub info: ::std::boxed::Box<
                        runtime_types::pallet_identity::types::IdentityInfo,
                    >,
                }
                impl ::subxt::blocks::StaticExtrinsic for SetIdentity {
                    const PALLET: &'static str = "Identity";
                    const CALL: &'static str = "set_identity";
                }
                #[derive(
                    ::subxt::ext::codec::Decode,
                    ::subxt::ext::codec::Encode,
                    ::subxt::ext::scale_decode::DecodeAsType,
                    ::subxt::ext::scale_encode::EncodeAsType,
                    Clone,
                    Debug,
                    Eq,
                    PartialEq
                )]
                #[codec(crate = ::subxt::ext::codec)]
                #[decode_as_type(crate_path = ":: subxt :: ext :: scale_decode")]
                #[encode_as_type(crate_path = ":: subxt :: ext :: scale_encode")]
                pub struct SetSubs {
                    pub subs: ::std::vec::Vec<
                        (
                            ::subxt::utils::AccountId32,
                            runtime_types::pallet_identity::types::Data,
                        ),
                    >,
                }
                impl ::subxt::blocks::StaticExtrinsic for SetSubs {
                    const PALLET: &'static str = "Identity";
                    const CALL: &'static str = "set_subs";
                }
                #[derive(
                    ::subxt::ext::codec::Decode,
                    ::subxt::ext::codec::Encode,
                    ::subxt::ext::scale_decode::DecodeAsType,
                    ::subxt::ext::scale_encode::EncodeAsType,
                    Clone,
                    Debug,
                    Eq,
                    PartialEq
                )]
                #[codec(crate = ::subxt::ext::codec)]
                #[decode_as_type(crate_path = ":: subxt :: ext :: scale_decode")]
                #[encode_as_type(crate_path = ":: subxt :: ext :: scale_encode")]
                pub struct ClearIdentity;
                impl ::subxt::blocks::StaticExtrinsic for ClearIdentity {
                    const PALLET: &'static str = "Identity";
                    const CALL: &'static str = "clear_identity";
                }
                #[derive(
                    ::subxt::ext::codec::Decode,
                    ::subxt::ext::codec::Encode,
                    ::subxt::ext::scale_decode::DecodeAsType,
                    ::subxt::ext::scale_encode::EncodeAsType,
                    Clone,
                    Debug,
                    Eq,
                    PartialEq
                )]
                #[codec(crate = ::subxt::ext::codec)]
                #[decode_as_type(crate_path = ":: subxt :: ext :: scale_decode")]
                #[encode_as_type(crate_path = ":: subxt :: ext :: scale_encode")]
                pub struct RequestJudgement {
                    #[codec(compact)]
                    pub reg_index: ::core::primitive::u32,
                    #[codec(compact)]
                    pub max_fee: ::core::primitive::u128,
                }
                impl ::subxt::blocks::StaticExtrinsic for RequestJudgement {
                    const PALLET: &'static str = "Identity";
                    const CALL: &'static str = "request_judgement";
                }
                #[derive(
                    ::subxt::ext::codec::CompactAs,
                    ::subxt::ext::codec::Decode,
                    ::subxt::ext::codec::Encode,
                    ::subxt::ext::scale_decode::DecodeAsType,
                    ::subxt::ext::scale_encode::EncodeAsType,
                    Clone,
                    Debug,
                    Eq,
                    PartialEq
                )]
                #[codec(crate = ::subxt::ext::codec)]
                #[decode_as_type(crate_path = ":: subxt :: ext :: scale_decode")]
                #[encode_as_type(crate_path = ":: subxt :: ext :: scale_encode")]
                pub struct CancelRequest {
                    pub reg_index: ::core::primitive::u32,
                }
                impl ::subxt::blocks::StaticExtrinsic for CancelRequest {
                    const PALLET: &'static str = "Identity";
                    const CALL: &'static str = "cancel_request";
                }
                #[derive(
                    ::subxt::ext::codec::Decode,
                    ::subxt::ext::codec::Encode,
                    ::subxt::ext::scale_decode::DecodeAsType,
                    ::subxt::ext::scale_encode::EncodeAsType,
                    Clone,
                    Debug,
                    Eq,
                    PartialEq
                )]
                #[codec(crate = ::subxt::ext::codec)]
                #[decode_as_type(crate_path = ":: subxt :: ext :: scale_decode")]
                #[encode_as_type(crate_path = ":: subxt :: ext :: scale_encode")]
                pub struct SetFee {
                    #[codec(compact)]
                    pub index: ::core::primitive::u32,
                    #[codec(compact)]
                    pub fee: ::core::primitive::u128,
                }
                impl ::subxt::blocks::StaticExtrinsic for SetFee {
                    const PALLET: &'static str = "Identity";
                    const CALL: &'static str = "set_fee";
                }
                #[derive(
                    ::subxt::ext::codec::Decode,
                    ::subxt::ext::codec::Encode,
                    ::subxt::ext::scale_decode::DecodeAsType,
                    ::subxt::ext::scale_encode::EncodeAsType,
                    Clone,
                    Debug,
                    Eq,
                    PartialEq
                )]
                #[codec(crate = ::subxt::ext::codec)]
                #[decode_as_type(crate_path = ":: subxt :: ext :: scale_decode")]
                #[encode_as_type(crate_path = ":: subxt :: ext :: scale_encode")]
                pub struct SetAccountId {
                    #[codec(compact)]
                    pub index: ::core::primitive::u32,
                    pub new: ::subxt::utils::MultiAddress<
                        ::subxt::utils::AccountId32,
                        ::core::primitive::u32,
                    >,
                }
                impl ::subxt::blocks::StaticExtrinsic for SetAccountId {
                    const PALLET: &'static str = "Identity";
                    const CALL: &'static str = "set_account_id";
                }
                #[derive(
                    ::subxt::ext::codec::Decode,
                    ::subxt::ext::codec::Encode,
                    ::subxt::ext::scale_decode::DecodeAsType,
                    ::subxt::ext::scale_encode::EncodeAsType,
                    Clone,
                    Debug,
                    Eq,
                    PartialEq
                )]
                #[codec(crate = ::subxt::ext::codec)]
                #[decode_as_type(crate_path = ":: subxt :: ext :: scale_decode")]
                #[encode_as_type(crate_path = ":: subxt :: ext :: scale_encode")]
                pub struct SetFields {
                    #[codec(compact)]
                    pub index: ::core::primitive::u32,
                    pub fields: runtime_types::pallet_identity::types::BitFlags<
                        runtime_types::pallet_identity::types::IdentityField,
                    >,
                }
                impl ::subxt::blocks::StaticExtrinsic for SetFields {
                    const PALLET: &'static str = "Identity";
                    const CALL: &'static str = "set_fields";
                }
                #[derive(
                    ::subxt::ext::codec::Decode,
                    ::subxt::ext::codec::Encode,
                    ::subxt::ext::scale_decode::DecodeAsType,
                    ::subxt::ext::scale_encode::EncodeAsType,
                    Clone,
                    Debug,
                    Eq,
                    PartialEq
                )]
                #[codec(crate = ::subxt::ext::codec)]
                #[decode_as_type(crate_path = ":: subxt :: ext :: scale_decode")]
                #[encode_as_type(crate_path = ":: subxt :: ext :: scale_encode")]
                pub struct ProvideJudgement {
                    #[codec(compact)]
                    pub reg_index: ::core::primitive::u32,
                    pub target: ::subxt::utils::MultiAddress<
                        ::subxt::utils::AccountId32,
                        ::core::primitive::u32,
                    >,
                    pub judgement: runtime_types::pallet_identity::types::Judgement<
                        ::core::primitive::u128,
                    >,
                    pub identity: ::subxt::utils::H256,
                }
                impl ::subxt::blocks::StaticExtrinsic for ProvideJudgement {
                    const PALLET: &'static str = "Identity";
                    const CALL: &'static str = "provide_judgement";
                }
                #[derive(
                    ::subxt::ext::codec::Decode,
                    ::subxt::ext::codec::Encode,
                    ::subxt::ext::scale_decode::DecodeAsType,
                    ::subxt::ext::scale_encode::EncodeAsType,
                    Clone,
                    Debug,
                    Eq,
                    PartialEq
                )]
                #[codec(crate = ::subxt::ext::codec)]
                #[decode_as_type(crate_path = ":: subxt :: ext :: scale_decode")]
                #[encode_as_type(crate_path = ":: subxt :: ext :: scale_encode")]
                pub struct KillIdentity {
                    pub target: ::subxt::utils::MultiAddress<
                        ::subxt::utils::AccountId32,
                        ::core::primitive::u32,
                    >,
                }
                impl ::subxt::blocks::StaticExtrinsic for KillIdentity {
                    const PALLET: &'static str = "Identity";
                    const CALL: &'static str = "kill_identity";
                }
                #[derive(
                    ::subxt::ext::codec::Decode,
                    ::subxt::ext::codec::Encode,
                    ::subxt::ext::scale_decode::DecodeAsType,
                    ::subxt::ext::scale_encode::EncodeAsType,
                    Clone,
                    Debug,
                    Eq,
                    PartialEq
                )]
                #[codec(crate = ::subxt::ext::codec)]
                #[decode_as_type(crate_path = ":: subxt :: ext :: scale_decode")]
                #[encode_as_type(crate_path = ":: subxt :: ext :: scale_encode")]
                pub struct AddSub {
                    pub sub: ::subxt::utils::MultiAddress<
                        ::subxt::utils::AccountId32,
                        ::core::primitive::u32,
                    >,
                    pub data: runtime_types::pallet_identity::types::Data,
                }
                impl ::subxt::blocks::StaticExtrinsic for AddSub {
                    const PALLET: &'static str = "Identity";
                    const CALL: &'static str = "add_sub";
                }
                #[derive(
                    ::subxt::ext::codec::Decode,
                    ::subxt::ext::codec::Encode,
                    ::subxt::ext::scale_decode::DecodeAsType,
                    ::subxt::ext::scale_encode::EncodeAsType,
                    Clone,
                    Debug,
                    Eq,
                    PartialEq
                )]
                #[codec(crate = ::subxt::ext::codec)]
                #[decode_as_type(crate_path = ":: subxt :: ext :: scale_decode")]
                #[encode_as_type(crate_path = ":: subxt :: ext :: scale_encode")]
                pub struct RenameSub {
                    pub sub: ::subxt::utils::MultiAddress<
                        ::subxt::utils::AccountId32,
                        ::core::primitive::u32,
                    >,
                    pub data: runtime_types::pallet_identity::types::Data,
                }
                impl ::subxt::blocks::StaticExtrinsic for RenameSub {
                    const PALLET: &'static str = "Identity";
                    const CALL: &'static str = "rename_sub";
                }
                #[derive(
                    ::subxt::ext::codec::Decode,
                    ::subxt::ext::codec::Encode,
                    ::subxt::ext::scale_decode::DecodeAsType,
                    ::subxt::ext::scale_encode::EncodeAsType,
                    Clone,
                    Debug,
                    Eq,
                    PartialEq
                )]
                #[codec(crate = ::subxt::ext::codec)]
                #[decode_as_type(crate_path = ":: subxt :: ext :: scale_decode")]
                #[encode_as_type(crate_path = ":: subxt :: ext :: scale_encode")]
                pub struct RemoveSub {
                    pub sub: ::subxt::utils::MultiAddress<
                        ::subxt::utils::AccountId32,
                        ::core::primitive::u32,
                    >,
                }
                impl ::subxt::blocks::StaticExtrinsic for RemoveSub {
                    const PALLET: &'static str = "Identity";
                    const CALL: &'static str = "remove_sub";
                }
                #[derive(
                    ::subxt::ext::codec::Decode,
                    ::subxt::ext::codec::Encode,
                    ::subxt::ext::scale_decode::DecodeAsType,
                    ::subxt::ext::scale_encode::EncodeAsType,
                    Clone,
                    Debug,
                    Eq,
                    PartialEq
                )]
                #[codec(crate = ::subxt::ext::codec)]
                #[decode_as_type(crate_path = ":: subxt :: ext :: scale_decode")]
                #[encode_as_type(crate_path = ":: subxt :: ext :: scale_encode")]
                pub struct QuitSub;
                impl ::subxt::blocks::StaticExtrinsic for QuitSub {
                    const PALLET: &'static str = "Identity";
                    const CALL: &'static str = "quit_sub";
                }
            }
            pub struct TransactionApi;
            impl TransactionApi {
                ///Add a registrar to the system.
                ///
                ///The dispatch origin for this call must be `T::RegistrarOrigin`.
                ///
                ///- `account`: the account of the registrar.
                ///
                ///Emits `RegistrarAdded` if successful.
                ///
                ///## Complexity
                ///- `O(R)` where `R` registrar-count (governance-bounded and code-bounded).
                pub fn add_registrar(
                    &self,
                    account: ::subxt::utils::MultiAddress<
                        ::subxt::utils::AccountId32,
                        ::core::primitive::u32,
                    >,
                ) -> ::subxt::tx::Payload<types::AddRegistrar> {
                    ::subxt::tx::Payload::new_static(
                        "Identity",
                        "add_registrar",
                        types::AddRegistrar { account },
                        [
                            34u8,
                            133u8,
                            250u8,
                            186u8,
                            71u8,
                            219u8,
                            66u8,
                            250u8,
                            41u8,
                            190u8,
                            237u8,
                            96u8,
                            40u8,
                            51u8,
                            98u8,
                            54u8,
                            242u8,
                            65u8,
                            216u8,
                            135u8,
                            211u8,
                            24u8,
                            57u8,
                            161u8,
                            229u8,
                            174u8,
                            48u8,
                            1u8,
                            88u8,
                            2u8,
                            38u8,
                            206u8,
                        ],
                    )
                }
                ///Set an account's identity information and reserve the appropriate deposit.
                ///
                ///If the account already has identity information, the deposit is taken as part payment
                ///for the new deposit.
                ///
                ///The dispatch origin for this call must be _Signed_.
                ///
                ///- `info`: The identity information.
                ///
                ///Emits `IdentitySet` if successful.
                ///
                ///## Complexity
                ///- `O(X + X' + R)`
                ///  - where `X` additional-field-count (deposit-bounded and code-bounded)
                ///  - where `R` judgements-count (registrar-count-bounded)
                pub fn set_identity(
                    &self,
                    info: runtime_types::pallet_identity::types::IdentityInfo,
                ) -> ::subxt::tx::Payload<types::SetIdentity> {
                    ::subxt::tx::Payload::new_static(
                        "Identity",
                        "set_identity",
                        types::SetIdentity {
                            info: ::std::boxed::Box::new(info),
                        },
                        [
                            205u8,
                            7u8,
                            54u8,
                            226u8,
                            123u8,
                            160u8,
                            173u8,
                            25u8,
                            179u8,
                            93u8,
                            172u8,
                            37u8,
                            222u8,
                            143u8,
                            209u8,
                            1u8,
                            230u8,
                            32u8,
                            84u8,
                            80u8,
                            110u8,
                            195u8,
                            87u8,
                            185u8,
                            27u8,
                            31u8,
                            185u8,
                            161u8,
                            154u8,
                            166u8,
                            177u8,
                            190u8,
                        ],
                    )
                }
                ///Set the sub-accounts of the sender.
                ///
                ///Payment: Any aggregate balance reserved by previous `set_subs` calls will be returned
                ///and an amount `SubAccountDeposit` will be reserved for each item in `subs`.
                ///
                ///The dispatch origin for this call must be _Signed_ and the sender must have a registered
                ///identity.
                ///
                ///- `subs`: The identity's (new) sub-accounts.
                ///
                ///## Complexity
                ///- `O(P + S)`
                ///  - where `P` old-subs-count (hard- and deposit-bounded).
                ///  - where `S` subs-count (hard- and deposit-bounded).
                pub fn set_subs(
                    &self,
                    subs: ::std::vec::Vec<
                        (
                            ::subxt::utils::AccountId32,
                            runtime_types::pallet_identity::types::Data,
                        ),
                    >,
                ) -> ::subxt::tx::Payload<types::SetSubs> {
                    ::subxt::tx::Payload::new_static(
                        "Identity",
                        "set_subs",
                        types::SetSubs { subs },
                        [
                            76u8,
                            193u8,
                            92u8,
                            120u8,
                            9u8,
                            99u8,
                            102u8,
                            220u8,
                            177u8,
                            29u8,
                            65u8,
                            14u8,
                            250u8,
                            101u8,
                            118u8,
                            59u8,
                            251u8,
                            153u8,
                            136u8,
                            141u8,
                            89u8,
                            250u8,
                            74u8,
                            254u8,
                            111u8,
                            220u8,
                            132u8,
                            228u8,
                            248u8,
                            132u8,
                            177u8,
                            128u8,
                        ],
                    )
                }
                ///Clear an account's identity info and all sub-accounts and return all deposits.
                ///
                ///Payment: All reserved balances on the account are returned.
                ///
                ///The dispatch origin for this call must be _Signed_ and the sender must have a registered
                ///identity.
                ///
                ///Emits `IdentityCleared` if successful.
                ///
                ///## Complexity
                ///- `O(R + S + X)`
                ///  - where `R` registrar-count (governance-bounded).
                ///  - where `S` subs-count (hard- and deposit-bounded).
                ///  - where `X` additional-field-count (deposit-bounded and code-bounded).
                pub fn clear_identity(
                    &self,
                ) -> ::subxt::tx::Payload<types::ClearIdentity> {
                    ::subxt::tx::Payload::new_static(
                        "Identity",
                        "clear_identity",
                        types::ClearIdentity {},
                        [
                            43u8,
                            115u8,
                            205u8,
                            44u8,
                            24u8,
                            130u8,
                            220u8,
                            69u8,
                            247u8,
                            176u8,
                            200u8,
                            175u8,
                            67u8,
                            183u8,
                            36u8,
                            200u8,
                            162u8,
                            132u8,
                            242u8,
                            25u8,
                            21u8,
                            106u8,
                            197u8,
                            219u8,
                            141u8,
                            51u8,
                            204u8,
                            13u8,
                            191u8,
                            201u8,
                            31u8,
                            31u8,
                        ],
                    )
                }
                ///Request a judgement from a registrar.
                ///
                ///Payment: At most `max_fee` will be reserved for payment to the registrar if judgement
                ///given.
                ///
                ///The dispatch origin for this call must be _Signed_ and the sender must have a
                ///registered identity.
                ///
                ///- `reg_index`: The index of the registrar whose judgement is requested.
                ///- `max_fee`: The maximum fee that may be paid. This should just be auto-populated as:
                ///
                ///```nocompile
                ///Self::registrars().get(reg_index).unwrap().fee
                ///```
                ///
                ///Emits `JudgementRequested` if successful.
                ///
                ///## Complexity
                ///- `O(R + X)`.
                ///  - where `R` registrar-count (governance-bounded).
                ///  - where `X` additional-field-count (deposit-bounded and code-bounded).
                pub fn request_judgement(
                    &self,
                    reg_index: ::core::primitive::u32,
                    max_fee: ::core::primitive::u128,
                ) -> ::subxt::tx::Payload<types::RequestJudgement> {
                    ::subxt::tx::Payload::new_static(
                        "Identity",
                        "request_judgement",
                        types::RequestJudgement {
                            reg_index,
                            max_fee,
                        },
                        [
                            83u8,
                            85u8,
                            55u8,
                            184u8,
                            14u8,
                            54u8,
                            49u8,
                            212u8,
                            26u8,
                            148u8,
                            33u8,
                            147u8,
                            182u8,
                            54u8,
                            180u8,
                            12u8,
                            61u8,
                            179u8,
                            216u8,
                            157u8,
                            103u8,
                            52u8,
                            120u8,
                            252u8,
                            83u8,
                            203u8,
                            144u8,
                            65u8,
                            15u8,
                            3u8,
                            21u8,
                            33u8,
                        ],
                    )
                }
                ///Cancel a previous request.
                ///
                ///Payment: A previously reserved deposit is returned on success.
                ///
                ///The dispatch origin for this call must be _Signed_ and the sender must have a
                ///registered identity.
                ///
                ///- `reg_index`: The index of the registrar whose judgement is no longer requested.
                ///
                ///Emits `JudgementUnrequested` if successful.
                ///
                ///## Complexity
                ///- `O(R + X)`.
                ///  - where `R` registrar-count (governance-bounded).
                ///  - where `X` additional-field-count (deposit-bounded and code-bounded).
                pub fn cancel_request(
                    &self,
                    reg_index: ::core::primitive::u32,
                ) -> ::subxt::tx::Payload<types::CancelRequest> {
                    ::subxt::tx::Payload::new_static(
                        "Identity",
                        "cancel_request",
                        types::CancelRequest { reg_index },
                        [
                            81u8,
                            14u8,
                            133u8,
                            219u8,
                            43u8,
                            84u8,
                            163u8,
                            208u8,
                            21u8,
                            185u8,
                            75u8,
                            117u8,
                            126u8,
                            33u8,
                            210u8,
                            106u8,
                            122u8,
                            210u8,
                            35u8,
                            207u8,
                            104u8,
                            206u8,
                            41u8,
                            117u8,
                            247u8,
                            108u8,
                            56u8,
                            23u8,
                            123u8,
                            169u8,
                            169u8,
                            61u8,
                        ],
                    )
                }
                ///Set the fee required for a judgement to be requested from a registrar.
                ///
                ///The dispatch origin for this call must be _Signed_ and the sender must be the account
                ///of the registrar whose index is `index`.
                ///
                ///- `index`: the index of the registrar whose fee is to be set.
                ///- `fee`: the new fee.
                ///
                ///## Complexity
                ///- `O(R)`.
                ///  - where `R` registrar-count (governance-bounded).
                pub fn set_fee(
                    &self,
                    index: ::core::primitive::u32,
                    fee: ::core::primitive::u128,
                ) -> ::subxt::tx::Payload<types::SetFee> {
                    ::subxt::tx::Payload::new_static(
                        "Identity",
                        "set_fee",
                        types::SetFee { index, fee },
                        [
                            131u8,
                            20u8,
                            17u8,
                            127u8,
                            180u8,
                            65u8,
                            225u8,
                            144u8,
                            193u8,
                            60u8,
                            131u8,
                            241u8,
                            30u8,
                            149u8,
                            8u8,
                            76u8,
                            29u8,
                            52u8,
                            102u8,
                            108u8,
                            127u8,
                            130u8,
                            70u8,
                            18u8,
                            94u8,
                            145u8,
                            179u8,
                            109u8,
                            252u8,
                            219u8,
                            58u8,
                            163u8,
                        ],
                    )
                }
                ///Change the account associated with a registrar.
                ///
                ///The dispatch origin for this call must be _Signed_ and the sender must be the account
                ///of the registrar whose index is `index`.
                ///
                ///- `index`: the index of the registrar whose fee is to be set.
                ///- `new`: the new account ID.
                ///
                ///## Complexity
                ///- `O(R)`.
                ///  - where `R` registrar-count (governance-bounded).
                pub fn set_account_id(
                    &self,
                    index: ::core::primitive::u32,
                    new: ::subxt::utils::MultiAddress<
                        ::subxt::utils::AccountId32,
                        ::core::primitive::u32,
                    >,
                ) -> ::subxt::tx::Payload<types::SetAccountId> {
                    ::subxt::tx::Payload::new_static(
                        "Identity",
                        "set_account_id",
                        types::SetAccountId { index, new },
                        [
                            127u8,
                            225u8,
                            228u8,
                            150u8,
                            6u8,
                            49u8,
                            67u8,
                            109u8,
                            19u8,
                            172u8,
                            100u8,
                            239u8,
                            81u8,
                            65u8,
                            5u8,
                            126u8,
                            239u8,
                            5u8,
                            203u8,
                            160u8,
                            241u8,
                            250u8,
                            243u8,
                            218u8,
                            208u8,
                            227u8,
                            239u8,
                            124u8,
                            78u8,
                            166u8,
                            40u8,
                            156u8,
                        ],
                    )
                }
                ///Set the field information for a registrar.
                ///
                ///The dispatch origin for this call must be _Signed_ and the sender must be the account
                ///of the registrar whose index is `index`.
                ///
                ///- `index`: the index of the registrar whose fee is to be set.
                ///- `fields`: the fields that the registrar concerns themselves with.
                ///
                ///## Complexity
                ///- `O(R)`.
                ///  - where `R` registrar-count (governance-bounded).
                pub fn set_fields(
                    &self,
                    index: ::core::primitive::u32,
                    fields: runtime_types::pallet_identity::types::BitFlags<
                        runtime_types::pallet_identity::types::IdentityField,
                    >,
                ) -> ::subxt::tx::Payload<types::SetFields> {
                    ::subxt::tx::Payload::new_static(
                        "Identity",
                        "set_fields",
                        types::SetFields { index, fields },
                        [
                            25u8,
                            129u8,
                            119u8,
                            232u8,
                            18u8,
                            32u8,
                            77u8,
                            23u8,
                            185u8,
                            56u8,
                            32u8,
                            199u8,
                            74u8,
                            174u8,
                            104u8,
                            203u8,
                            171u8,
                            253u8,
                            19u8,
                            225u8,
                            101u8,
                            239u8,
                            14u8,
                            242u8,
                            157u8,
                            51u8,
                            203u8,
                            74u8,
                            1u8,
                            65u8,
                            165u8,
                            205u8,
                        ],
                    )
                }
                ///Provide a judgement for an account's identity.
                ///
                ///The dispatch origin for this call must be _Signed_ and the sender must be the account
                ///of the registrar whose index is `reg_index`.
                ///
                ///- `reg_index`: the index of the registrar whose judgement is being made.
                ///- `target`: the account whose identity the judgement is upon. This must be an account
                ///  with a registered identity.
                ///- `judgement`: the judgement of the registrar of index `reg_index` about `target`.
                ///- `identity`: The hash of the [`IdentityInfo`] for that the judgement is provided.
                ///
                ///Emits `JudgementGiven` if successful.
                ///
                ///## Complexity
                ///- `O(R + X)`.
                ///  - where `R` registrar-count (governance-bounded).
                ///  - where `X` additional-field-count (deposit-bounded and code-bounded).
                pub fn provide_judgement(
                    &self,
                    reg_index: ::core::primitive::u32,
                    target: ::subxt::utils::MultiAddress<
                        ::subxt::utils::AccountId32,
                        ::core::primitive::u32,
                    >,
                    judgement: runtime_types::pallet_identity::types::Judgement<
                        ::core::primitive::u128,
                    >,
                    identity: ::subxt::utils::H256,
                ) -> ::subxt::tx::Payload<types::ProvideJudgement> {
                    ::subxt::tx::Payload::new_static(
                        "Identity",
                        "provide_judgement",
                        types::ProvideJudgement {
                            reg_index,
                            target,
                            judgement,
                            identity,
                        },
                        [
                            51u8,
                            75u8,
                            24u8,
                            146u8,
                            141u8,
                            86u8,
                            141u8,
                            188u8,
                            77u8,
                            71u8,
                            5u8,
                            76u8,
                            44u8,
                            35u8,
                            208u8,
                            98u8,
                            217u8,
                            80u8,
                            248u8,
                            201u8,
                            225u8,
                            230u8,
                            162u8,
                            20u8,
                            202u8,
                            242u8,
                            4u8,
                            209u8,
                            9u8,
                            200u8,
                            178u8,
                            5u8,
                        ],
                    )
                }
                ///Remove an account's identity and sub-account information and slash the deposits.
                ///
                ///Payment: Reserved balances from `set_subs` and `set_identity` are slashed and handled by
                ///`Slash`. Verification request deposits are not returned; they should be cancelled
                ///manually using `cancel_request`.
                ///
                ///The dispatch origin for this call must match `T::ForceOrigin`.
                ///
                ///- `target`: the account whose identity the judgement is upon. This must be an account
                ///  with a registered identity.
                ///
                ///Emits `IdentityKilled` if successful.
                ///
                ///## Complexity
                ///- `O(R + S + X)`
                ///  - where `R` registrar-count (governance-bounded).
                ///  - where `S` subs-count (hard- and deposit-bounded).
                ///  - where `X` additional-field-count (deposit-bounded and code-bounded).
                pub fn kill_identity(
                    &self,
                    target: ::subxt::utils::MultiAddress<
                        ::subxt::utils::AccountId32,
                        ::core::primitive::u32,
                    >,
                ) -> ::subxt::tx::Payload<types::KillIdentity> {
                    ::subxt::tx::Payload::new_static(
                        "Identity",
                        "kill_identity",
                        types::KillIdentity { target },
                        [
                            111u8,
                            40u8,
                            34u8,
                            131u8,
                            14u8,
                            102u8,
                            209u8,
                            175u8,
                            202u8,
                            50u8,
                            12u8,
                            19u8,
                            37u8,
                            230u8,
                            120u8,
                            91u8,
                            248u8,
                            67u8,
                            25u8,
                            245u8,
                            228u8,
                            19u8,
                            57u8,
                            187u8,
                            244u8,
                            30u8,
                            59u8,
                            178u8,
                            29u8,
                            114u8,
                            197u8,
                            24u8,
                        ],
                    )
                }
                ///Add the given account to the sender's subs.
                ///
                ///Payment: Balance reserved by a previous `set_subs` call for one sub will be repatriated
                ///to the sender.
                ///
                ///The dispatch origin for this call must be _Signed_ and the sender must have a registered
                ///sub identity of `sub`.
                pub fn add_sub(
                    &self,
                    sub: ::subxt::utils::MultiAddress<
                        ::subxt::utils::AccountId32,
                        ::core::primitive::u32,
                    >,
                    data: runtime_types::pallet_identity::types::Data,
                ) -> ::subxt::tx::Payload<types::AddSub> {
                    ::subxt::tx::Payload::new_static(
                        "Identity",
                        "add_sub",
                        types::AddSub { sub, data },
                        [
                            63u8,
                            142u8,
                            248u8,
                            45u8,
                            29u8,
                            195u8,
                            238u8,
                            249u8,
                            23u8,
                            242u8,
                            54u8,
                            254u8,
                            141u8,
                            12u8,
                            202u8,
                            156u8,
                            52u8,
                            180u8,
                            121u8,
                            168u8,
                            198u8,
                            5u8,
                            44u8,
                            129u8,
                            117u8,
                            178u8,
                            201u8,
                            125u8,
                            209u8,
                            211u8,
                            86u8,
                            140u8,
                        ],
                    )
                }
                ///Alter the associated name of the given sub-account.
                ///
                ///The dispatch origin for this call must be _Signed_ and the sender must have a registered
                ///sub identity of `sub`.
                pub fn rename_sub(
                    &self,
                    sub: ::subxt::utils::MultiAddress<
                        ::subxt::utils::AccountId32,
                        ::core::primitive::u32,
                    >,
                    data: runtime_types::pallet_identity::types::Data,
                ) -> ::subxt::tx::Payload<types::RenameSub> {
                    ::subxt::tx::Payload::new_static(
                        "Identity",
                        "rename_sub",
                        types::RenameSub { sub, data },
                        [
                            201u8,
                            113u8,
                            118u8,
                            210u8,
                            110u8,
                            248u8,
                            42u8,
                            56u8,
                            35u8,
                            208u8,
                            102u8,
                            171u8,
                            128u8,
                            158u8,
                            105u8,
                            232u8,
                            254u8,
                            73u8,
                            44u8,
                            84u8,
                            16u8,
                            32u8,
                            112u8,
                            41u8,
                            19u8,
                            128u8,
                            200u8,
                            118u8,
                            95u8,
                            115u8,
                            220u8,
                            100u8,
                        ],
                    )
                }
                ///Remove the given account from the sender's subs.
                ///
                ///Payment: Balance reserved by a previous `set_subs` call for one sub will be repatriated
                ///to the sender.
                ///
                ///The dispatch origin for this call must be _Signed_ and the sender must have a registered
                ///sub identity of `sub`.
                pub fn remove_sub(
                    &self,
                    sub: ::subxt::utils::MultiAddress<
                        ::subxt::utils::AccountId32,
                        ::core::primitive::u32,
                    >,
                ) -> ::subxt::tx::Payload<types::RemoveSub> {
                    ::subxt::tx::Payload::new_static(
                        "Identity",
                        "remove_sub",
                        types::RemoveSub { sub },
                        [
                            20u8,
                            227u8,
                            205u8,
                            59u8,
                            130u8,
                            76u8,
                            62u8,
                            11u8,
                            69u8,
                            169u8,
                            10u8,
                            199u8,
                            9u8,
                            194u8,
                            142u8,
                            181u8,
                            170u8,
                            170u8,
                            254u8,
                            197u8,
                            74u8,
                            123u8,
                            216u8,
                            87u8,
                            163u8,
                            156u8,
                            153u8,
                            41u8,
                            20u8,
                            173u8,
                            87u8,
                            10u8,
                        ],
                    )
                }
                ///Remove the sender as a sub-account.
                ///
                ///Payment: Balance reserved by a previous `set_subs` call for one sub will be repatriated
                ///to the sender (*not* the original depositor).
                ///
                ///The dispatch origin for this call must be _Signed_ and the sender must have a registered
                ///super-identity.
                ///
                ///NOTE: This should not normally be used, but is provided in the case that the non-
                ///controller of an account is maliciously registered as a sub-account.
                pub fn quit_sub(&self) -> ::subxt::tx::Payload<types::QuitSub> {
                    ::subxt::tx::Payload::new_static(
                        "Identity",
                        "quit_sub",
                        types::QuitSub {},
                        [
                            147u8,
                            131u8,
                            175u8,
                            171u8,
                            187u8,
                            201u8,
                            240u8,
                            26u8,
                            146u8,
                            224u8,
                            74u8,
                            166u8,
                            242u8,
                            193u8,
                            204u8,
                            247u8,
                            168u8,
                            93u8,
                            18u8,
                            32u8,
                            27u8,
                            208u8,
                            149u8,
                            146u8,
                            179u8,
                            172u8,
                            75u8,
                            112u8,
                            84u8,
                            141u8,
                            233u8,
                            223u8,
                        ],
                    )
                }
            }
        }
        /**
			The [event](https://docs.substrate.io/main-docs/build/events-errors/) emitted
			by this pallet.
			*/
        pub type Event = runtime_types::pallet_identity::pallet::Event;
        pub mod events {
            use super::runtime_types;
            #[derive(
                ::subxt::ext::codec::Decode,
                ::subxt::ext::codec::Encode,
                ::subxt::ext::scale_decode::DecodeAsType,
                ::subxt::ext::scale_encode::EncodeAsType,
                Clone,
                Debug,
                Eq,
                PartialEq
            )]
            #[codec(crate = ::subxt::ext::codec)]
            #[decode_as_type(crate_path = ":: subxt :: ext :: scale_decode")]
            #[encode_as_type(crate_path = ":: subxt :: ext :: scale_encode")]
            ///A name was set or reset (which will remove all judgements).
            pub struct IdentitySet {
                pub who: ::subxt::utils::AccountId32,
            }
            impl ::subxt::events::StaticEvent for IdentitySet {
                const PALLET: &'static str = "Identity";
                const EVENT: &'static str = "IdentitySet";
            }
            #[derive(
                ::subxt::ext::codec::Decode,
                ::subxt::ext::codec::Encode,
                ::subxt::ext::scale_decode::DecodeAsType,
                ::subxt::ext::scale_encode::EncodeAsType,
                Clone,
                Debug,
                Eq,
                PartialEq
            )]
            #[codec(crate = ::subxt::ext::codec)]
            #[decode_as_type(crate_path = ":: subxt :: ext :: scale_decode")]
            #[encode_as_type(crate_path = ":: subxt :: ext :: scale_encode")]
            ///A name was cleared, and the given balance returned.
            pub struct IdentityCleared {
                pub who: ::subxt::utils::AccountId32,
                pub deposit: ::core::primitive::u128,
            }
            impl ::subxt::events::StaticEvent for IdentityCleared {
                const PALLET: &'static str = "Identity";
                const EVENT: &'static str = "IdentityCleared";
            }
            #[derive(
                ::subxt::ext::codec::Decode,
                ::subxt::ext::codec::Encode,
                ::subxt::ext::scale_decode::DecodeAsType,
                ::subxt::ext::scale_encode::EncodeAsType,
                Clone,
                Debug,
                Eq,
                PartialEq
            )]
            #[codec(crate = ::subxt::ext::codec)]
            #[decode_as_type(crate_path = ":: subxt :: ext :: scale_decode")]
            #[encode_as_type(crate_path = ":: subxt :: ext :: scale_encode")]
            ///A name was removed and the given balance slashed.
            pub struct IdentityKilled {
                pub who: ::subxt::utils::AccountId32,
                pub deposit: ::core::primitive::u128,
            }
            impl ::subxt::events::StaticEvent for IdentityKilled {
                const PALLET: &'static str = "Identity";
                const EVENT: &'static str = "IdentityKilled";
            }
            #[derive(
                ::subxt::ext::codec::Decode,
                ::subxt::ext::codec::Encode,
                ::subxt::ext::scale_decode::DecodeAsType,
                ::subxt::ext::scale_encode::EncodeAsType,
                Clone,
                Debug,
                Eq,
                PartialEq
            )]
            #[codec(crate = ::subxt::ext::codec)]
            #[decode_as_type(crate_path = ":: subxt :: ext :: scale_decode")]
            #[encode_as_type(crate_path = ":: subxt :: ext :: scale_encode")]
            ///A judgement was asked from a registrar.
            pub struct JudgementRequested {
                pub who: ::subxt::utils::AccountId32,
                pub registrar_index: ::core::primitive::u32,
            }
            impl ::subxt::events::StaticEvent for JudgementRequested {
                const PALLET: &'static str = "Identity";
                const EVENT: &'static str = "JudgementRequested";
            }
            #[derive(
                ::subxt::ext::codec::Decode,
                ::subxt::ext::codec::Encode,
                ::subxt::ext::scale_decode::DecodeAsType,
                ::subxt::ext::scale_encode::EncodeAsType,
                Clone,
                Debug,
                Eq,
                PartialEq
            )]
            #[codec(crate = ::subxt::ext::codec)]
            #[decode_as_type(crate_path = ":: subxt :: ext :: scale_decode")]
            #[encode_as_type(crate_path = ":: subxt :: ext :: scale_encode")]
            ///A judgement request was retracted.
            pub struct JudgementUnrequested {
                pub who: ::subxt::utils::AccountId32,
                pub registrar_index: ::core::primitive::u32,
            }
            impl ::subxt::events::StaticEvent for JudgementUnrequested {
                const PALLET: &'static str = "Identity";
                const EVENT: &'static str = "JudgementUnrequested";
            }
            #[derive(
                ::subxt::ext::codec::Decode,
                ::subxt::ext::codec::Encode,
                ::subxt::ext::scale_decode::DecodeAsType,
                ::subxt::ext::scale_encode::EncodeAsType,
                Clone,
                Debug,
                Eq,
                PartialEq
            )]
            #[codec(crate = ::subxt::ext::codec)]
            #[decode_as_type(crate_path = ":: subxt :: ext :: scale_decode")]
            #[encode_as_type(crate_path = ":: subxt :: ext :: scale_encode")]
            ///A judgement was given by a registrar.
            pub struct JudgementGiven {
                pub target: ::subxt::utils::AccountId32,
                pub registrar_index: ::core::primitive::u32,
            }
            impl ::subxt::events::StaticEvent for JudgementGiven {
                const PALLET: &'static str = "Identity";
                const EVENT: &'static str = "JudgementGiven";
            }
            #[derive(
                ::subxt::ext::codec::CompactAs,
                ::subxt::ext::codec::Decode,
                ::subxt::ext::codec::Encode,
                ::subxt::ext::scale_decode::DecodeAsType,
                ::subxt::ext::scale_encode::EncodeAsType,
                Clone,
                Debug,
                Eq,
                PartialEq
            )]
            #[codec(crate = ::subxt::ext::codec)]
            #[decode_as_type(crate_path = ":: subxt :: ext :: scale_decode")]
            #[encode_as_type(crate_path = ":: subxt :: ext :: scale_encode")]
            ///A registrar was added.
            pub struct RegistrarAdded {
                pub registrar_index: ::core::primitive::u32,
            }
            impl ::subxt::events::StaticEvent for RegistrarAdded {
                const PALLET: &'static str = "Identity";
                const EVENT: &'static str = "RegistrarAdded";
            }
            #[derive(
                ::subxt::ext::codec::Decode,
                ::subxt::ext::codec::Encode,
                ::subxt::ext::scale_decode::DecodeAsType,
                ::subxt::ext::scale_encode::EncodeAsType,
                Clone,
                Debug,
                Eq,
                PartialEq
            )]
            #[codec(crate = ::subxt::ext::codec)]
            #[decode_as_type(crate_path = ":: subxt :: ext :: scale_decode")]
            #[encode_as_type(crate_path = ":: subxt :: ext :: scale_encode")]
            ///A sub-identity was added to an identity and the deposit paid.
            pub struct SubIdentityAdded {
                pub sub: ::subxt::utils::AccountId32,
                pub main: ::subxt::utils::AccountId32,
                pub deposit: ::core::primitive::u128,
            }
            impl ::subxt::events::StaticEvent for SubIdentityAdded {
                const PALLET: &'static str = "Identity";
                const EVENT: &'static str = "SubIdentityAdded";
            }
            #[derive(
                ::subxt::ext::codec::Decode,
                ::subxt::ext::codec::Encode,
                ::subxt::ext::scale_decode::DecodeAsType,
                ::subxt::ext::scale_encode::EncodeAsType,
                Clone,
                Debug,
                Eq,
                PartialEq
            )]
            #[codec(crate = ::subxt::ext::codec)]
            #[decode_as_type(crate_path = ":: subxt :: ext :: scale_decode")]
            #[encode_as_type(crate_path = ":: subxt :: ext :: scale_encode")]
            ///A sub-identity was removed from an identity and the deposit freed.
            pub struct SubIdentityRemoved {
                pub sub: ::subxt::utils::AccountId32,
                pub main: ::subxt::utils::AccountId32,
                pub deposit: ::core::primitive::u128,
            }
            impl ::subxt::events::StaticEvent for SubIdentityRemoved {
                const PALLET: &'static str = "Identity";
                const EVENT: &'static str = "SubIdentityRemoved";
            }
            #[derive(
                ::subxt::ext::codec::Decode,
                ::subxt::ext::codec::Encode,
                ::subxt::ext::scale_decode::DecodeAsType,
                ::subxt::ext::scale_encode::EncodeAsType,
                Clone,
                Debug,
                Eq,
                PartialEq
            )]
            #[codec(crate = ::subxt::ext::codec)]
            #[decode_as_type(crate_path = ":: subxt :: ext :: scale_decode")]
            #[encode_as_type(crate_path = ":: subxt :: ext :: scale_encode")]
            ///A sub-identity was cleared, and the given deposit repatriated from the
            ///main identity account to the sub-identity account.
            pub struct SubIdentityRevoked {
                pub sub: ::subxt::utils::AccountId32,
                pub main: ::subxt::utils::AccountId32,
                pub deposit: ::core::primitive::u128,
            }
            impl ::subxt::events::StaticEvent for SubIdentityRevoked {
                const PALLET: &'static str = "Identity";
                const EVENT: &'static str = "SubIdentityRevoked";
            }
        }
        pub mod storage {
            use super::runtime_types;
            pub struct StorageApi;
            impl StorageApi {
                /// Information that is pertinent to identify the entity behind an account.
                ///
                /// TWOX-NOTE: OK  `AccountId` is a secure hash.
                pub fn identity_of(
                    &self,
                    _0: impl ::std::borrow::Borrow<::subxt::utils::AccountId32>,
                ) -> ::subxt::storage::address::Address<
                    ::subxt::storage::address::StaticStorageMapKey,
                    runtime_types::pallet_identity::types::Registration<
                        ::core::primitive::u128,
                    >,
                    ::subxt::storage::address::Yes,
                    (),
                    ::subxt::storage::address::Yes,
                > {
                    ::subxt::storage::address::Address::new_static(
                        "Identity",
                        "IdentityOf",
                        vec![
                            ::subxt::storage::address::make_static_storage_map_key(_0
                            .borrow())
                        ],
                        [
                            239u8,
                            55u8,
                            5u8,
                            97u8,
                            227u8,
                            243u8,
                            118u8,
                            13u8,
                            98u8,
                            30u8,
                            141u8,
                            84u8,
                            170u8,
                            90u8,
                            166u8,
                            116u8,
                            17u8,
                            122u8,
                            190u8,
                            76u8,
                            34u8,
                            51u8,
                            239u8,
                            41u8,
                            14u8,
                            135u8,
                            11u8,
                            164u8,
                            106u8,
                            228u8,
                            48u8,
                            26u8,
                        ],
                    )
                }
                /// Information that is pertinent to identify the entity behind an account.
                ///
                /// TWOX-NOTE: OK  `AccountId` is a secure hash.
                pub fn identity_of_root(
                    &self,
                ) -> ::subxt::storage::address::Address<
                    ::subxt::storage::address::StaticStorageMapKey,
                    runtime_types::pallet_identity::types::Registration<
                        ::core::primitive::u128,
                    >,
                    (),
                    (),
                    ::subxt::storage::address::Yes,
                > {
                    ::subxt::storage::address::Address::new_static(
                        "Identity",
                        "IdentityOf",
                        Vec::new(),
                        [
                            239u8,
                            55u8,
                            5u8,
                            97u8,
                            227u8,
                            243u8,
                            118u8,
                            13u8,
                            98u8,
                            30u8,
                            141u8,
                            84u8,
                            170u8,
                            90u8,
                            166u8,
                            116u8,
                            17u8,
                            122u8,
                            190u8,
                            76u8,
                            34u8,
                            51u8,
                            239u8,
                            41u8,
                            14u8,
                            135u8,
                            11u8,
                            164u8,
                            106u8,
                            228u8,
                            48u8,
                            26u8,
                        ],
                    )
                }
                /// The super-identity of an alternative "sub" identity together with its name, within that
                /// context. If the account is not some other account's sub-identity, then just `None`.
                pub fn super_of(
                    &self,
                    _0: impl ::std::borrow::Borrow<::subxt::utils::AccountId32>,
                ) -> ::subxt::storage::address::Address<
                    ::subxt::storage::address::StaticStorageMapKey,
                    (
                        ::subxt::utils::AccountId32,
                        runtime_types::pallet_identity::types::Data,
                    ),
                    ::subxt::storage::address::Yes,
                    (),
                    ::subxt::storage::address::Yes,
                > {
                    ::subxt::storage::address::Address::new_static(
                        "Identity",
                        "SuperOf",
                        vec![
                            ::subxt::storage::address::make_static_storage_map_key(_0
                            .borrow())
                        ],
                        [
                            51u8,
                            225u8,
                            21u8,
                            92u8,
                            85u8,
                            14u8,
                            14u8,
                            211u8,
                            61u8,
                            99u8,
                            176u8,
                            236u8,
                            212u8,
                            156u8,
                            103u8,
                            175u8,
                            208u8,
                            105u8,
                            94u8,
                            226u8,
                            136u8,
                            69u8,
                            162u8,
                            170u8,
                            11u8,
                            116u8,
                            72u8,
                            242u8,
                            119u8,
                            14u8,
                            14u8,
                            142u8,
                        ],
                    )
                }
                /// The super-identity of an alternative "sub" identity together with its name, within that
                /// context. If the account is not some other account's sub-identity, then just `None`.
                pub fn super_of_root(
                    &self,
                ) -> ::subxt::storage::address::Address<
                    ::subxt::storage::address::StaticStorageMapKey,
                    (
                        ::subxt::utils::AccountId32,
                        runtime_types::pallet_identity::types::Data,
                    ),
                    (),
                    (),
                    ::subxt::storage::address::Yes,
                > {
                    ::subxt::storage::address::Address::new_static(
                        "Identity",
                        "SuperOf",
                        Vec::new(),
                        [
                            51u8,
                            225u8,
                            21u8,
                            92u8,
                            85u8,
                            14u8,
                            14u8,
                            211u8,
                            61u8,
                            99u8,
                            176u8,
                            236u8,
                            212u8,
                            156u8,
                            103u8,
                            175u8,
                            208u8,
                            105u8,
                            94u8,
                            226u8,
                            136u8,
                            69u8,
                            162u8,
                            170u8,
                            11u8,
                            116u8,
                            72u8,
                            242u8,
                            119u8,
                            14u8,
                            14u8,
                            142u8,
                        ],
                    )
                }
                /// Alternative "sub" identities of this account.
                ///
                /// The first item is the deposit, the second is a vector of the accounts.
                ///
                /// TWOX-NOTE: OK  `AccountId` is a secure hash.
                pub fn subs_of(
                    &self,
                    _0: impl ::std::borrow::Borrow<::subxt::utils::AccountId32>,
                ) -> ::subxt::storage::address::Address<
                    ::subxt::storage::address::StaticStorageMapKey,
                    (
                        ::core::primitive::u128,
                        runtime_types::bounded_collections::bounded_vec::BoundedVec<
                            ::subxt::utils::AccountId32,
                        >,
                    ),
                    ::subxt::storage::address::Yes,
                    ::subxt::storage::address::Yes,
                    ::subxt::storage::address::Yes,
                > {
                    ::subxt::storage::address::Address::new_static(
                        "Identity",
                        "SubsOf",
                        vec![
                            ::subxt::storage::address::make_static_storage_map_key(_0
                            .borrow())
                        ],
                        [
                            93u8,
                            124u8,
                            154u8,
                            157u8,
                            159u8,
                            103u8,
                            233u8,
                            225u8,
                            59u8,
                            20u8,
                            201u8,
                            239u8,
                            128u8,
                            209u8,
                            207u8,
                            38u8,
                            123u8,
                            48u8,
                            119u8,
                            102u8,
                            88u8,
                            42u8,
                            245u8,
                            187u8,
                            244u8,
                            206u8,
                            124u8,
                            216u8,
                            185u8,
                            155u8,
                            207u8,
                            0u8,
                        ],
                    )
                }
                /// Alternative "sub" identities of this account.
                ///
                /// The first item is the deposit, the second is a vector of the accounts.
                ///
                /// TWOX-NOTE: OK  `AccountId` is a secure hash.
                pub fn subs_of_root(
                    &self,
                ) -> ::subxt::storage::address::Address<
                    ::subxt::storage::address::StaticStorageMapKey,
                    (
                        ::core::primitive::u128,
                        runtime_types::bounded_collections::bounded_vec::BoundedVec<
                            ::subxt::utils::AccountId32,
                        >,
                    ),
                    (),
                    ::subxt::storage::address::Yes,
                    ::subxt::storage::address::Yes,
                > {
                    ::subxt::storage::address::Address::new_static(
                        "Identity",
                        "SubsOf",
                        Vec::new(),
                        [
                            93u8,
                            124u8,
                            154u8,
                            157u8,
                            159u8,
                            103u8,
                            233u8,
                            225u8,
                            59u8,
                            20u8,
                            201u8,
                            239u8,
                            128u8,
                            209u8,
                            207u8,
                            38u8,
                            123u8,
                            48u8,
                            119u8,
                            102u8,
                            88u8,
                            42u8,
                            245u8,
                            187u8,
                            244u8,
                            206u8,
                            124u8,
                            216u8,
                            185u8,
                            155u8,
                            207u8,
                            0u8,
                        ],
                    )
                }
                /// The set of registrars. Not expected to get very big as can only be added through a
                /// special origin (likely a council motion).
                ///
                /// The index into this can be cast to `RegistrarIndex` to get a valid value.
                pub fn registrars(
                    &self,
                ) -> ::subxt::storage::address::Address<
                    ::subxt::storage::address::StaticStorageMapKey,
                    runtime_types::bounded_collections::bounded_vec::BoundedVec<
                        ::core::option::Option<
                            runtime_types::pallet_identity::types::RegistrarInfo<
                                ::core::primitive::u128,
                                ::subxt::utils::AccountId32,
                            >,
                        >,
                    >,
                    ::subxt::storage::address::Yes,
                    ::subxt::storage::address::Yes,
                    (),
                > {
                    ::subxt::storage::address::Address::new_static(
                        "Identity",
                        "Registrars",
                        vec![],
                        [
                            207u8,
                            253u8,
                            229u8,
                            237u8,
                            228u8,
                            85u8,
                            173u8,
                            74u8,
                            164u8,
                            67u8,
                            144u8,
                            144u8,
                            5u8,
                            242u8,
                            84u8,
                            187u8,
                            110u8,
                            181u8,
                            2u8,
                            162u8,
                            239u8,
                            212u8,
                            72u8,
                            233u8,
                            160u8,
                            196u8,
                            121u8,
                            218u8,
                            100u8,
                            0u8,
                            219u8,
                            181u8,
                        ],
                    )
                }
            }
        }
        pub mod constants {
            use super::runtime_types;
            pub struct ConstantsApi;
            impl ConstantsApi {
                /// The amount held on deposit for a registered identity
                pub fn basic_deposit(
                    &self,
                ) -> ::subxt::constants::Address<::core::primitive::u128> {
                    ::subxt::constants::Address::new_static(
                        "Identity",
                        "BasicDeposit",
                        [
                            84u8,
                            157u8,
                            140u8,
                            4u8,
                            93u8,
                            57u8,
                            29u8,
                            133u8,
                            105u8,
                            200u8,
                            214u8,
                            27u8,
                            144u8,
                            208u8,
                            218u8,
                            160u8,
                            130u8,
                            109u8,
                            101u8,
                            54u8,
                            210u8,
                            136u8,
                            71u8,
                            63u8,
                            49u8,
                            237u8,
                            234u8,
                            15u8,
                            178u8,
                            98u8,
                            148u8,
                            156u8,
                        ],
                    )
                }
                /// The amount held on deposit per additional field for a registered identity.
                pub fn field_deposit(
                    &self,
                ) -> ::subxt::constants::Address<::core::primitive::u128> {
                    ::subxt::constants::Address::new_static(
                        "Identity",
                        "FieldDeposit",
                        [
                            84u8,
                            157u8,
                            140u8,
                            4u8,
                            93u8,
                            57u8,
                            29u8,
                            133u8,
                            105u8,
                            200u8,
                            214u8,
                            27u8,
                            144u8,
                            208u8,
                            218u8,
                            160u8,
                            130u8,
                            109u8,
                            101u8,
                            54u8,
                            210u8,
                            136u8,
                            71u8,
                            63u8,
                            49u8,
                            237u8,
                            234u8,
                            15u8,
                            178u8,
                            98u8,
                            148u8,
                            156u8,
                        ],
                    )
                }
                /// The amount held on deposit for a registered subaccount. This should account for the fact
                /// that one storage item's value will increase by the size of an account ID, and there will
                /// be another trie item whose value is the size of an account ID plus 32 bytes.
                pub fn sub_account_deposit(
                    &self,
                ) -> ::subxt::constants::Address<::core::primitive::u128> {
                    ::subxt::constants::Address::new_static(
                        "Identity",
                        "SubAccountDeposit",
                        [
                            84u8,
                            157u8,
                            140u8,
                            4u8,
                            93u8,
                            57u8,
                            29u8,
                            133u8,
                            105u8,
                            200u8,
                            214u8,
                            27u8,
                            144u8,
                            208u8,
                            218u8,
                            160u8,
                            130u8,
                            109u8,
                            101u8,
                            54u8,
                            210u8,
                            136u8,
                            71u8,
                            63u8,
                            49u8,
                            237u8,
                            234u8,
                            15u8,
                            178u8,
                            98u8,
                            148u8,
                            156u8,
                        ],
                    )
                }
                /// The maximum number of sub-accounts allowed per identified account.
                pub fn max_sub_accounts(
                    &self,
                ) -> ::subxt::constants::Address<::core::primitive::u32> {
                    ::subxt::constants::Address::new_static(
                        "Identity",
                        "MaxSubAccounts",
                        [
                            98u8,
                            252u8,
                            116u8,
                            72u8,
                            26u8,
                            180u8,
                            225u8,
                            83u8,
                            200u8,
                            157u8,
                            125u8,
                            151u8,
                            53u8,
                            76u8,
                            168u8,
                            26u8,
                            10u8,
                            9u8,
                            98u8,
                            68u8,
                            9u8,
                            178u8,
                            197u8,
                            113u8,
                            31u8,
                            79u8,
                            200u8,
                            90u8,
                            203u8,
                            100u8,
                            41u8,
                            145u8,
                        ],
                    )
                }
                /// Maximum number of additional fields that may be stored in an ID. Needed to bound the I/O
                /// required to access an identity, but can be pretty high.
                pub fn max_additional_fields(
                    &self,
                ) -> ::subxt::constants::Address<::core::primitive::u32> {
                    ::subxt::constants::Address::new_static(
                        "Identity",
                        "MaxAdditionalFields",
                        [
                            98u8,
                            252u8,
                            116u8,
                            72u8,
                            26u8,
                            180u8,
                            225u8,
                            83u8,
                            200u8,
                            157u8,
                            125u8,
                            151u8,
                            53u8,
                            76u8,
                            168u8,
                            26u8,
                            10u8,
                            9u8,
                            98u8,
                            68u8,
                            9u8,
                            178u8,
                            197u8,
                            113u8,
                            31u8,
                            79u8,
                            200u8,
                            90u8,
                            203u8,
                            100u8,
                            41u8,
                            145u8,
                        ],
                    )
                }
                /// Maxmimum number of registrars allowed in the system. Needed to bound the complexity
                /// of, e.g., updating judgements.
                pub fn max_registrars(
                    &self,
                ) -> ::subxt::constants::Address<::core::primitive::u32> {
                    ::subxt::constants::Address::new_static(
                        "Identity",
                        "MaxRegistrars",
                        [
                            98u8,
                            252u8,
                            116u8,
                            72u8,
                            26u8,
                            180u8,
                            225u8,
                            83u8,
                            200u8,
                            157u8,
                            125u8,
                            151u8,
                            53u8,
                            76u8,
                            168u8,
                            26u8,
                            10u8,
                            9u8,
                            98u8,
                            68u8,
                            9u8,
                            178u8,
                            197u8,
                            113u8,
                            31u8,
                            79u8,
                            200u8,
                            90u8,
                            203u8,
                            100u8,
                            41u8,
                            145u8,
                        ],
                    )
                }
            }
        }
    }
    pub mod utility {
        use super::root_mod;
        use super::runtime_types;
        /**
			Custom [dispatch errors](https://docs.substrate.io/main-docs/build/events-errors/)
			of this pallet.
			*/
        pub type Error = runtime_types::pallet_utility::pallet::Error;
        ///Contains one variant per dispatchable that can be called by an extrinsic.
        pub type Call = runtime_types::pallet_utility::pallet::Call;
        pub mod calls {
            use super::root_mod;
            use super::runtime_types;
            type DispatchError = runtime_types::sp_runtime::DispatchError;
            pub mod types {
                use super::runtime_types;
                #[derive(
                    ::subxt::ext::codec::Decode,
                    ::subxt::ext::codec::Encode,
                    ::subxt::ext::scale_decode::DecodeAsType,
                    ::subxt::ext::scale_encode::EncodeAsType,
                    Clone,
                    Debug,
                    Eq,
                    PartialEq
                )]
                #[codec(crate = ::subxt::ext::codec)]
                #[decode_as_type(crate_path = ":: subxt :: ext :: scale_decode")]
                #[encode_as_type(crate_path = ":: subxt :: ext :: scale_encode")]
                pub struct Batch {
                    pub calls: ::std::vec::Vec<
                        runtime_types::tangle_standalone_runtime::RuntimeCall,
                    >,
                }
                impl ::subxt::blocks::StaticExtrinsic for Batch {
                    const PALLET: &'static str = "Utility";
                    const CALL: &'static str = "batch";
                }
                #[derive(
                    ::subxt::ext::codec::Decode,
                    ::subxt::ext::codec::Encode,
                    ::subxt::ext::scale_decode::DecodeAsType,
                    ::subxt::ext::scale_encode::EncodeAsType,
                    Clone,
                    Debug,
                    Eq,
                    PartialEq
                )]
                #[codec(crate = ::subxt::ext::codec)]
                #[decode_as_type(crate_path = ":: subxt :: ext :: scale_decode")]
                #[encode_as_type(crate_path = ":: subxt :: ext :: scale_encode")]
                pub struct AsDerivative {
                    pub index: ::core::primitive::u16,
                    pub call: ::std::boxed::Box<
                        runtime_types::tangle_standalone_runtime::RuntimeCall,
                    >,
                }
                impl ::subxt::blocks::StaticExtrinsic for AsDerivative {
                    const PALLET: &'static str = "Utility";
                    const CALL: &'static str = "as_derivative";
                }
                #[derive(
                    ::subxt::ext::codec::Decode,
                    ::subxt::ext::codec::Encode,
                    ::subxt::ext::scale_decode::DecodeAsType,
                    ::subxt::ext::scale_encode::EncodeAsType,
                    Clone,
                    Debug,
                    Eq,
                    PartialEq
                )]
                #[codec(crate = ::subxt::ext::codec)]
                #[decode_as_type(crate_path = ":: subxt :: ext :: scale_decode")]
                #[encode_as_type(crate_path = ":: subxt :: ext :: scale_encode")]
                pub struct BatchAll {
                    pub calls: ::std::vec::Vec<
                        runtime_types::tangle_standalone_runtime::RuntimeCall,
                    >,
                }
                impl ::subxt::blocks::StaticExtrinsic for BatchAll {
                    const PALLET: &'static str = "Utility";
                    const CALL: &'static str = "batch_all";
                }
                #[derive(
                    ::subxt::ext::codec::Decode,
                    ::subxt::ext::codec::Encode,
                    ::subxt::ext::scale_decode::DecodeAsType,
                    ::subxt::ext::scale_encode::EncodeAsType,
                    Clone,
                    Debug,
                    Eq,
                    PartialEq
                )]
                #[codec(crate = ::subxt::ext::codec)]
                #[decode_as_type(crate_path = ":: subxt :: ext :: scale_decode")]
                #[encode_as_type(crate_path = ":: subxt :: ext :: scale_encode")]
                pub struct DispatchAs {
                    pub as_origin: ::std::boxed::Box<
                        runtime_types::tangle_standalone_runtime::OriginCaller,
                    >,
                    pub call: ::std::boxed::Box<
                        runtime_types::tangle_standalone_runtime::RuntimeCall,
                    >,
                }
                impl ::subxt::blocks::StaticExtrinsic for DispatchAs {
                    const PALLET: &'static str = "Utility";
                    const CALL: &'static str = "dispatch_as";
                }
                #[derive(
                    ::subxt::ext::codec::Decode,
                    ::subxt::ext::codec::Encode,
                    ::subxt::ext::scale_decode::DecodeAsType,
                    ::subxt::ext::scale_encode::EncodeAsType,
                    Clone,
                    Debug,
                    Eq,
                    PartialEq
                )]
                #[codec(crate = ::subxt::ext::codec)]
                #[decode_as_type(crate_path = ":: subxt :: ext :: scale_decode")]
                #[encode_as_type(crate_path = ":: subxt :: ext :: scale_encode")]
                pub struct ForceBatch {
                    pub calls: ::std::vec::Vec<
                        runtime_types::tangle_standalone_runtime::RuntimeCall,
                    >,
                }
                impl ::subxt::blocks::StaticExtrinsic for ForceBatch {
                    const PALLET: &'static str = "Utility";
                    const CALL: &'static str = "force_batch";
                }
                #[derive(
                    ::subxt::ext::codec::Decode,
                    ::subxt::ext::codec::Encode,
                    ::subxt::ext::scale_decode::DecodeAsType,
                    ::subxt::ext::scale_encode::EncodeAsType,
                    Clone,
                    Debug,
                    Eq,
                    PartialEq
                )]
                #[codec(crate = ::subxt::ext::codec)]
                #[decode_as_type(crate_path = ":: subxt :: ext :: scale_decode")]
                #[encode_as_type(crate_path = ":: subxt :: ext :: scale_encode")]
                pub struct WithWeight {
                    pub call: ::std::boxed::Box<
                        runtime_types::tangle_standalone_runtime::RuntimeCall,
                    >,
                    pub weight: runtime_types::sp_weights::weight_v2::Weight,
                }
                impl ::subxt::blocks::StaticExtrinsic for WithWeight {
                    const PALLET: &'static str = "Utility";
                    const CALL: &'static str = "with_weight";
                }
            }
            pub struct TransactionApi;
            impl TransactionApi {
                ///Send a batch of dispatch calls.
                ///
                ///May be called from any origin except `None`.
                ///
                ///- `calls`: The calls to be dispatched from the same origin. The number of call must not
                ///  exceed the constant: `batched_calls_limit` (available in constant metadata).
                ///
                ///If origin is root then the calls are dispatched without checking origin filter. (This
                ///includes bypassing `frame_system::Config::BaseCallFilter`).
                ///
                ///## Complexity
                ///- O(C) where C is the number of calls to be batched.
                ///
                ///This will return `Ok` in all circumstances. To determine the success of the batch, an
                ///event is deposited. If a call failed and the batch was interrupted, then the
                ///`BatchInterrupted` event is deposited, along with the number of successful calls made
                ///and the error of the failed call. If all were successful, then the `BatchCompleted`
                ///event is deposited.
                pub fn batch(
                    &self,
                    calls: ::std::vec::Vec<
                        runtime_types::tangle_standalone_runtime::RuntimeCall,
                    >,
                ) -> ::subxt::tx::Payload<types::Batch> {
                    ::subxt::tx::Payload::new_static(
                        "Utility",
                        "batch",
                        types::Batch { calls },
                        [
                            148u8,
                            82u8,
                            203u8,
                            239u8,
                            130u8,
                            141u8,
                            20u8,
                            115u8,
                            21u8,
                            138u8,
                            121u8,
                            169u8,
                            214u8,
                            64u8,
                            206u8,
                            55u8,
                            93u8,
                            177u8,
                            77u8,
                            157u8,
                            239u8,
                            80u8,
                            221u8,
                            96u8,
                            160u8,
                            170u8,
                            241u8,
                            110u8,
                            101u8,
                            185u8,
                            198u8,
                            180u8,
                        ],
                    )
                }
                ///Send a call through an indexed pseudonym of the sender.
                ///
                ///Filter from origin are passed along. The call will be dispatched with an origin which
                ///use the same filter as the origin of this call.
                ///
                ///NOTE: If you need to ensure that any account-based filtering is not honored (i.e.
                ///because you expect `proxy` to have been used prior in the call stack and you do not want
                ///the call restrictions to apply to any sub-accounts), then use `as_multi_threshold_1`
                ///in the Multisig pallet instead.
                ///
                ///NOTE: Prior to version *12, this was called `as_limited_sub`.
                ///
                ///The dispatch origin for this call must be _Signed_.
                pub fn as_derivative(
                    &self,
                    index: ::core::primitive::u16,
                    call: runtime_types::tangle_standalone_runtime::RuntimeCall,
                ) -> ::subxt::tx::Payload<types::AsDerivative> {
                    ::subxt::tx::Payload::new_static(
                        "Utility",
                        "as_derivative",
                        types::AsDerivative {
                            index,
                            call: ::std::boxed::Box::new(call),
                        },
                        [
                            86u8,
                            82u8,
                            212u8,
                            155u8,
                            84u8,
                            70u8,
                            176u8,
                            46u8,
                            85u8,
                            98u8,
                            70u8,
                            26u8,
                            219u8,
                            231u8,
                            211u8,
                            83u8,
                            176u8,
                            181u8,
                            21u8,
                            95u8,
                            106u8,
                            108u8,
                            81u8,
                            13u8,
                            43u8,
                            25u8,
                            230u8,
                            128u8,
                            26u8,
                            101u8,
                            230u8,
                            251u8,
                        ],
                    )
                }
                ///Send a batch of dispatch calls and atomically execute them.
                ///The whole transaction will rollback and fail if any of the calls failed.
                ///
                ///May be called from any origin except `None`.
                ///
                ///- `calls`: The calls to be dispatched from the same origin. The number of call must not
                ///  exceed the constant: `batched_calls_limit` (available in constant metadata).
                ///
                ///If origin is root then the calls are dispatched without checking origin filter. (This
                ///includes bypassing `frame_system::Config::BaseCallFilter`).
                ///
                ///## Complexity
                ///- O(C) where C is the number of calls to be batched.
                pub fn batch_all(
                    &self,
                    calls: ::std::vec::Vec<
                        runtime_types::tangle_standalone_runtime::RuntimeCall,
                    >,
                ) -> ::subxt::tx::Payload<types::BatchAll> {
                    ::subxt::tx::Payload::new_static(
                        "Utility",
                        "batch_all",
                        types::BatchAll { calls },
                        [
                            35u8,
                            207u8,
                            179u8,
                            93u8,
                            242u8,
                            219u8,
                            248u8,
                            226u8,
                            40u8,
                            28u8,
                            191u8,
                            137u8,
                            91u8,
                            232u8,
                            195u8,
                            148u8,
                            170u8,
                            80u8,
                            162u8,
                            117u8,
                            56u8,
                            212u8,
                            229u8,
                            158u8,
                            36u8,
                            166u8,
                            173u8,
                            163u8,
                            108u8,
                            104u8,
                            37u8,
                            215u8,
                        ],
                    )
                }
                ///Dispatches a function call with a provided origin.
                ///
                ///The dispatch origin for this call must be _Root_.
                ///
                ///## Complexity
                ///- O(1).
                pub fn dispatch_as(
                    &self,
                    as_origin: runtime_types::tangle_standalone_runtime::OriginCaller,
                    call: runtime_types::tangle_standalone_runtime::RuntimeCall,
                ) -> ::subxt::tx::Payload<types::DispatchAs> {
                    ::subxt::tx::Payload::new_static(
                        "Utility",
                        "dispatch_as",
                        types::DispatchAs {
                            as_origin: ::std::boxed::Box::new(as_origin),
                            call: ::std::boxed::Box::new(call),
                        },
                        [
                            12u8,
                            13u8,
                            162u8,
                            248u8,
                            48u8,
                            78u8,
                            61u8,
                            43u8,
                            219u8,
                            12u8,
                            16u8,
                            60u8,
                            128u8,
                            229u8,
                            93u8,
                            175u8,
                            242u8,
                            199u8,
                            25u8,
                            58u8,
                            102u8,
                            25u8,
                            89u8,
                            57u8,
                            123u8,
                            81u8,
                            230u8,
                            210u8,
                            200u8,
                            193u8,
                            28u8,
                            146u8,
                        ],
                    )
                }
                ///Send a batch of dispatch calls.
                ///Unlike `batch`, it allows errors and won't interrupt.
                ///
                ///May be called from any origin except `None`.
                ///
                ///- `calls`: The calls to be dispatched from the same origin. The number of call must not
                ///  exceed the constant: `batched_calls_limit` (available in constant metadata).
                ///
                ///If origin is root then the calls are dispatch without checking origin filter. (This
                ///includes bypassing `frame_system::Config::BaseCallFilter`).
                ///
                ///## Complexity
                ///- O(C) where C is the number of calls to be batched.
                pub fn force_batch(
                    &self,
                    calls: ::std::vec::Vec<
                        runtime_types::tangle_standalone_runtime::RuntimeCall,
                    >,
                ) -> ::subxt::tx::Payload<types::ForceBatch> {
                    ::subxt::tx::Payload::new_static(
                        "Utility",
                        "force_batch",
                        types::ForceBatch { calls },
                        [
                            229u8,
                            153u8,
                            249u8,
                            130u8,
                            228u8,
                            60u8,
                            221u8,
                            82u8,
                            243u8,
                            223u8,
                            178u8,
                            13u8,
                            160u8,
                            142u8,
                            173u8,
                            194u8,
                            95u8,
                            19u8,
                            63u8,
                            33u8,
                            8u8,
                            239u8,
                            107u8,
                            191u8,
                            21u8,
                            1u8,
                            8u8,
                            135u8,
                            141u8,
                            63u8,
                            69u8,
                            252u8,
                        ],
                    )
                }
                ///Dispatch a function call with a specified weight.
                ///
                ///This function does not check the weight of the call, and instead allows the
                ///Root origin to specify the weight of the call.
                ///
                ///The dispatch origin for this call must be _Root_.
                pub fn with_weight(
                    &self,
                    call: runtime_types::tangle_standalone_runtime::RuntimeCall,
                    weight: runtime_types::sp_weights::weight_v2::Weight,
                ) -> ::subxt::tx::Payload<types::WithWeight> {
                    ::subxt::tx::Payload::new_static(
                        "Utility",
                        "with_weight",
                        types::WithWeight {
                            call: ::std::boxed::Box::new(call),
                            weight,
                        },
                        [
                            189u8,
                            119u8,
                            168u8,
                            39u8,
                            189u8,
                            161u8,
                            150u8,
                            250u8,
                            39u8,
                            166u8,
                            3u8,
                            48u8,
                            216u8,
                            253u8,
                            129u8,
                            179u8,
                            39u8,
                            15u8,
                            30u8,
                            35u8,
                            191u8,
                            96u8,
                            135u8,
                            171u8,
                            198u8,
                            149u8,
                            45u8,
                            9u8,
                            251u8,
                            198u8,
                            78u8,
                            7u8,
                        ],
                    )
                }
            }
        }
        /**
			The [event](https://docs.substrate.io/main-docs/build/events-errors/) emitted
			by this pallet.
			*/
        pub type Event = runtime_types::pallet_utility::pallet::Event;
        pub mod events {
            use super::runtime_types;
            #[derive(
                ::subxt::ext::codec::Decode,
                ::subxt::ext::codec::Encode,
                ::subxt::ext::scale_decode::DecodeAsType,
                ::subxt::ext::scale_encode::EncodeAsType,
                Clone,
                Debug,
                Eq,
                PartialEq
            )]
            #[codec(crate = ::subxt::ext::codec)]
            #[decode_as_type(crate_path = ":: subxt :: ext :: scale_decode")]
            #[encode_as_type(crate_path = ":: subxt :: ext :: scale_encode")]
            ///Batch of dispatches did not complete fully. Index of first failing dispatch given, as
            ///well as the error.
            pub struct BatchInterrupted {
                pub index: ::core::primitive::u32,
                pub error: runtime_types::sp_runtime::DispatchError,
            }
            impl ::subxt::events::StaticEvent for BatchInterrupted {
                const PALLET: &'static str = "Utility";
                const EVENT: &'static str = "BatchInterrupted";
            }
            #[derive(
                ::subxt::ext::codec::Decode,
                ::subxt::ext::codec::Encode,
                ::subxt::ext::scale_decode::DecodeAsType,
                ::subxt::ext::scale_encode::EncodeAsType,
                Clone,
                Debug,
                Eq,
                PartialEq
            )]
            #[codec(crate = ::subxt::ext::codec)]
            #[decode_as_type(crate_path = ":: subxt :: ext :: scale_decode")]
            #[encode_as_type(crate_path = ":: subxt :: ext :: scale_encode")]
            ///Batch of dispatches completed fully with no error.
            pub struct BatchCompleted;
            impl ::subxt::events::StaticEvent for BatchCompleted {
                const PALLET: &'static str = "Utility";
                const EVENT: &'static str = "BatchCompleted";
            }
            #[derive(
                ::subxt::ext::codec::Decode,
                ::subxt::ext::codec::Encode,
                ::subxt::ext::scale_decode::DecodeAsType,
                ::subxt::ext::scale_encode::EncodeAsType,
                Clone,
                Debug,
                Eq,
                PartialEq
            )]
            #[codec(crate = ::subxt::ext::codec)]
            #[decode_as_type(crate_path = ":: subxt :: ext :: scale_decode")]
            #[encode_as_type(crate_path = ":: subxt :: ext :: scale_encode")]
            ///Batch of dispatches completed but has errors.
            pub struct BatchCompletedWithErrors;
            impl ::subxt::events::StaticEvent for BatchCompletedWithErrors {
                const PALLET: &'static str = "Utility";
                const EVENT: &'static str = "BatchCompletedWithErrors";
            }
            #[derive(
                ::subxt::ext::codec::Decode,
                ::subxt::ext::codec::Encode,
                ::subxt::ext::scale_decode::DecodeAsType,
                ::subxt::ext::scale_encode::EncodeAsType,
                Clone,
                Debug,
                Eq,
                PartialEq
            )]
            #[codec(crate = ::subxt::ext::codec)]
            #[decode_as_type(crate_path = ":: subxt :: ext :: scale_decode")]
            #[encode_as_type(crate_path = ":: subxt :: ext :: scale_encode")]
            ///A single item within a Batch of dispatches has completed with no error.
            pub struct ItemCompleted;
            impl ::subxt::events::StaticEvent for ItemCompleted {
                const PALLET: &'static str = "Utility";
                const EVENT: &'static str = "ItemCompleted";
            }
            #[derive(
                ::subxt::ext::codec::Decode,
                ::subxt::ext::codec::Encode,
                ::subxt::ext::scale_decode::DecodeAsType,
                ::subxt::ext::scale_encode::EncodeAsType,
                Clone,
                Debug,
                Eq,
                PartialEq
            )]
            #[codec(crate = ::subxt::ext::codec)]
            #[decode_as_type(crate_path = ":: subxt :: ext :: scale_decode")]
            #[encode_as_type(crate_path = ":: subxt :: ext :: scale_encode")]
            ///A single item within a Batch of dispatches has completed with error.
            pub struct ItemFailed {
                pub error: runtime_types::sp_runtime::DispatchError,
            }
            impl ::subxt::events::StaticEvent for ItemFailed {
                const PALLET: &'static str = "Utility";
                const EVENT: &'static str = "ItemFailed";
            }
            #[derive(
                ::subxt::ext::codec::Decode,
                ::subxt::ext::codec::Encode,
                ::subxt::ext::scale_decode::DecodeAsType,
                ::subxt::ext::scale_encode::EncodeAsType,
                Clone,
                Debug,
                Eq,
                PartialEq
            )]
            #[codec(crate = ::subxt::ext::codec)]
            #[decode_as_type(crate_path = ":: subxt :: ext :: scale_decode")]
            #[encode_as_type(crate_path = ":: subxt :: ext :: scale_encode")]
            ///A call was dispatched.
            pub struct DispatchedAs {
                pub result: ::core::result::Result<
                    (),
                    runtime_types::sp_runtime::DispatchError,
                >,
            }
            impl ::subxt::events::StaticEvent for DispatchedAs {
                const PALLET: &'static str = "Utility";
                const EVENT: &'static str = "DispatchedAs";
            }
        }
        pub mod constants {
            use super::runtime_types;
            pub struct ConstantsApi;
            impl ConstantsApi {
                /// The limit on the number of batched calls.
                pub fn batched_calls_limit(
                    &self,
                ) -> ::subxt::constants::Address<::core::primitive::u32> {
                    ::subxt::constants::Address::new_static(
                        "Utility",
                        "batched_calls_limit",
                        [
                            98u8,
                            252u8,
                            116u8,
                            72u8,
                            26u8,
                            180u8,
                            225u8,
                            83u8,
                            200u8,
                            157u8,
                            125u8,
                            151u8,
                            53u8,
                            76u8,
                            168u8,
                            26u8,
                            10u8,
                            9u8,
                            98u8,
                            68u8,
                            9u8,
                            178u8,
                            197u8,
                            113u8,
                            31u8,
                            79u8,
                            200u8,
                            90u8,
                            203u8,
                            100u8,
                            41u8,
                            145u8,
                        ],
                    )
                }
            }
        }
    }
    pub mod ethereum {
        use super::root_mod;
        use super::runtime_types;
        /**
			Custom [dispatch errors](https://docs.substrate.io/main-docs/build/events-errors/)
			of this pallet.
			*/
        pub type Error = runtime_types::pallet_ethereum::pallet::Error;
        ///Contains one variant per dispatchable that can be called by an extrinsic.
        pub type Call = runtime_types::pallet_ethereum::pallet::Call;
        pub mod calls {
            use super::root_mod;
            use super::runtime_types;
            type DispatchError = runtime_types::sp_runtime::DispatchError;
            pub mod types {
                use super::runtime_types;
                #[derive(
                    ::subxt::ext::codec::Decode,
                    ::subxt::ext::codec::Encode,
                    ::subxt::ext::scale_decode::DecodeAsType,
                    ::subxt::ext::scale_encode::EncodeAsType,
                    Clone,
                    Debug,
                    Eq,
                    PartialEq
                )]
                #[codec(crate = ::subxt::ext::codec)]
                #[decode_as_type(crate_path = ":: subxt :: ext :: scale_decode")]
                #[encode_as_type(crate_path = ":: subxt :: ext :: scale_encode")]
                pub struct Transact {
                    pub transaction: runtime_types::ethereum::transaction::TransactionV2,
                }
                impl ::subxt::blocks::StaticExtrinsic for Transact {
                    const PALLET: &'static str = "Ethereum";
                    const CALL: &'static str = "transact";
                }
            }
            pub struct TransactionApi;
            impl TransactionApi {
                ///Transact an Ethereum transaction.
                pub fn transact(
                    &self,
                    transaction: runtime_types::ethereum::transaction::TransactionV2,
                ) -> ::subxt::tx::Payload<types::Transact> {
                    ::subxt::tx::Payload::new_static(
                        "Ethereum",
                        "transact",
                        types::Transact { transaction },
                        [
                            248u8,
                            108u8,
                            75u8,
                            85u8,
                            58u8,
                            246u8,
                            249u8,
                            43u8,
                            29u8,
                            250u8,
                            7u8,
                            20u8,
                            236u8,
                            54u8,
                            22u8,
                            33u8,
                            219u8,
                            68u8,
                            48u8,
                            20u8,
                            112u8,
                            97u8,
                            144u8,
                            52u8,
                            177u8,
                            101u8,
                            142u8,
                            222u8,
                            46u8,
                            45u8,
                            24u8,
                            241u8,
                        ],
                    )
                }
            }
        }
        /**
			The [event](https://docs.substrate.io/main-docs/build/events-errors/) emitted
			by this pallet.
			*/
        pub type Event = runtime_types::pallet_ethereum::pallet::Event;
        pub mod events {
            use super::runtime_types;
            #[derive(
                ::subxt::ext::codec::Decode,
                ::subxt::ext::codec::Encode,
                ::subxt::ext::scale_decode::DecodeAsType,
                ::subxt::ext::scale_encode::EncodeAsType,
                Clone,
                Debug,
                Eq,
                PartialEq
            )]
            #[codec(crate = ::subxt::ext::codec)]
            #[decode_as_type(crate_path = ":: subxt :: ext :: scale_decode")]
            #[encode_as_type(crate_path = ":: subxt :: ext :: scale_encode")]
            ///An ethereum transaction was successfully executed.
            pub struct Executed {
                pub from: ::subxt::utils::H160,
                pub to: ::subxt::utils::H160,
                pub transaction_hash: ::subxt::utils::H256,
                pub exit_reason: runtime_types::evm_core::error::ExitReason,
                pub extra_data: ::std::vec::Vec<::core::primitive::u8>,
            }
            impl ::subxt::events::StaticEvent for Executed {
                const PALLET: &'static str = "Ethereum";
                const EVENT: &'static str = "Executed";
            }
        }
        pub mod storage {
            use super::runtime_types;
            pub struct StorageApi;
            impl StorageApi {
                /// Current building block's transactions and receipts.
                pub fn pending(
                    &self,
                ) -> ::subxt::storage::address::Address<
                    ::subxt::storage::address::StaticStorageMapKey,
                    ::std::vec::Vec<
                        (
                            runtime_types::ethereum::transaction::TransactionV2,
                            runtime_types::fp_rpc::TransactionStatus,
                            runtime_types::ethereum::receipt::ReceiptV3,
                        ),
                    >,
                    ::subxt::storage::address::Yes,
                    ::subxt::storage::address::Yes,
                    (),
                > {
                    ::subxt::storage::address::Address::new_static(
                        "Ethereum",
                        "Pending",
                        vec![],
                        [
                            231u8,
                            24u8,
                            97u8,
                            217u8,
                            199u8,
                            3u8,
                            70u8,
                            61u8,
                            78u8,
                            249u8,
                            115u8,
                            45u8,
                            173u8,
                            201u8,
                            121u8,
                            246u8,
                            141u8,
                            24u8,
                            183u8,
                            26u8,
                            202u8,
                            104u8,
                            140u8,
                            222u8,
                            94u8,
                            235u8,
                            59u8,
                            146u8,
                            67u8,
                            137u8,
                            25u8,
                            75u8,
                        ],
                    )
                }
                /// The current Ethereum block.
                pub fn current_block(
                    &self,
                ) -> ::subxt::storage::address::Address<
                    ::subxt::storage::address::StaticStorageMapKey,
                    runtime_types::ethereum::block::Block<
                        runtime_types::ethereum::transaction::TransactionV2,
                    >,
                    ::subxt::storage::address::Yes,
                    (),
                    (),
                > {
                    ::subxt::storage::address::Address::new_static(
                        "Ethereum",
                        "CurrentBlock",
                        vec![],
                        [
                            25u8,
                            90u8,
                            87u8,
                            29u8,
                            99u8,
                            98u8,
                            206u8,
                            100u8,
                            198u8,
                            125u8,
                            245u8,
                            141u8,
                            121u8,
                            182u8,
                            95u8,
                            234u8,
                            195u8,
                            38u8,
                            63u8,
                            93u8,
                            11u8,
                            58u8,
                            181u8,
                            73u8,
                            156u8,
                            147u8,
                            88u8,
                            162u8,
                            174u8,
                            234u8,
                            143u8,
                            71u8,
                        ],
                    )
                }
                /// The current Ethereum receipts.
                pub fn current_receipts(
                    &self,
                ) -> ::subxt::storage::address::Address<
                    ::subxt::storage::address::StaticStorageMapKey,
                    ::std::vec::Vec<runtime_types::ethereum::receipt::ReceiptV3>,
                    ::subxt::storage::address::Yes,
                    (),
                    (),
                > {
                    ::subxt::storage::address::Address::new_static(
                        "Ethereum",
                        "CurrentReceipts",
                        vec![],
                        [
                            88u8,
                            205u8,
                            87u8,
                            124u8,
                            82u8,
                            43u8,
                            38u8,
                            99u8,
                            217u8,
                            154u8,
                            44u8,
                            212u8,
                            189u8,
                            166u8,
                            42u8,
                            154u8,
                            95u8,
                            133u8,
                            143u8,
                            81u8,
                            36u8,
                            18u8,
                            2u8,
                            115u8,
                            30u8,
                            189u8,
                            52u8,
                            26u8,
                            171u8,
                            75u8,
                            108u8,
                            143u8,
                        ],
                    )
                }
                /// The current transaction statuses.
                pub fn current_transaction_statuses(
                    &self,
                ) -> ::subxt::storage::address::Address<
                    ::subxt::storage::address::StaticStorageMapKey,
                    ::std::vec::Vec<runtime_types::fp_rpc::TransactionStatus>,
                    ::subxt::storage::address::Yes,
                    (),
                    (),
                > {
                    ::subxt::storage::address::Address::new_static(
                        "Ethereum",
                        "CurrentTransactionStatuses",
                        vec![],
                        [
                            236u8,
                            78u8,
                            43u8,
                            37u8,
                            243u8,
                            211u8,
                            105u8,
                            209u8,
                            27u8,
                            201u8,
                            130u8,
                            207u8,
                            58u8,
                            171u8,
                            144u8,
                            57u8,
                            185u8,
                            221u8,
                            36u8,
                            114u8,
                            120u8,
                            74u8,
                            211u8,
                            210u8,
                            19u8,
                            61u8,
                            244u8,
                            70u8,
                            85u8,
                            150u8,
                            172u8,
                            138u8,
                        ],
                    )
                }
                pub fn block_hash(
                    &self,
                    _0: impl ::std::borrow::Borrow<runtime_types::primitive_types::U256>,
                ) -> ::subxt::storage::address::Address<
                    ::subxt::storage::address::StaticStorageMapKey,
                    ::subxt::utils::H256,
                    ::subxt::storage::address::Yes,
                    ::subxt::storage::address::Yes,
                    ::subxt::storage::address::Yes,
                > {
                    ::subxt::storage::address::Address::new_static(
                        "Ethereum",
                        "BlockHash",
                        vec![
                            ::subxt::storage::address::make_static_storage_map_key(_0
                            .borrow())
                        ],
                        [
                            131u8,
                            87u8,
                            201u8,
                            82u8,
                            203u8,
                            241u8,
                            176u8,
                            149u8,
                            39u8,
                            243u8,
                            227u8,
                            1u8,
                            86u8,
                            62u8,
                            6u8,
                            231u8,
                            55u8,
                            6u8,
                            212u8,
                            96u8,
                            207u8,
                            73u8,
                            56u8,
                            204u8,
                            215u8,
                            227u8,
                            48u8,
                            249u8,
                            67u8,
                            137u8,
                            139u8,
                            76u8,
                        ],
                    )
                }
                pub fn block_hash_root(
                    &self,
                ) -> ::subxt::storage::address::Address<
                    ::subxt::storage::address::StaticStorageMapKey,
                    ::subxt::utils::H256,
                    (),
                    ::subxt::storage::address::Yes,
                    ::subxt::storage::address::Yes,
                > {
                    ::subxt::storage::address::Address::new_static(
                        "Ethereum",
                        "BlockHash",
                        Vec::new(),
                        [
                            131u8,
                            87u8,
                            201u8,
                            82u8,
                            203u8,
                            241u8,
                            176u8,
                            149u8,
                            39u8,
                            243u8,
                            227u8,
                            1u8,
                            86u8,
                            62u8,
                            6u8,
                            231u8,
                            55u8,
                            6u8,
                            212u8,
                            96u8,
                            207u8,
                            73u8,
                            56u8,
                            204u8,
                            215u8,
                            227u8,
                            48u8,
                            249u8,
                            67u8,
                            137u8,
                            139u8,
                            76u8,
                        ],
                    )
                }
            }
        }
    }
    pub mod evm {
        use super::root_mod;
        use super::runtime_types;
        /**
			Custom [dispatch errors](https://docs.substrate.io/main-docs/build/events-errors/)
			of this pallet.
			*/
        pub type Error = runtime_types::pallet_evm::pallet::Error;
        ///Contains one variant per dispatchable that can be called by an extrinsic.
        pub type Call = runtime_types::pallet_evm::pallet::Call;
        pub mod calls {
            use super::root_mod;
            use super::runtime_types;
            type DispatchError = runtime_types::sp_runtime::DispatchError;
            pub mod types {
                use super::runtime_types;
                #[derive(
                    ::subxt::ext::codec::Decode,
                    ::subxt::ext::codec::Encode,
                    ::subxt::ext::scale_decode::DecodeAsType,
                    ::subxt::ext::scale_encode::EncodeAsType,
                    Clone,
                    Debug,
                    Eq,
                    PartialEq
                )]
                #[codec(crate = ::subxt::ext::codec)]
                #[decode_as_type(crate_path = ":: subxt :: ext :: scale_decode")]
                #[encode_as_type(crate_path = ":: subxt :: ext :: scale_encode")]
                pub struct Withdraw {
                    pub address: ::subxt::utils::H160,
                    pub value: ::core::primitive::u128,
                }
                impl ::subxt::blocks::StaticExtrinsic for Withdraw {
                    const PALLET: &'static str = "EVM";
                    const CALL: &'static str = "withdraw";
                }
                #[derive(
                    ::subxt::ext::codec::Decode,
                    ::subxt::ext::codec::Encode,
                    ::subxt::ext::scale_decode::DecodeAsType,
                    ::subxt::ext::scale_encode::EncodeAsType,
                    Clone,
                    Debug,
                    Eq,
                    PartialEq
                )]
                #[codec(crate = ::subxt::ext::codec)]
                #[decode_as_type(crate_path = ":: subxt :: ext :: scale_decode")]
                #[encode_as_type(crate_path = ":: subxt :: ext :: scale_encode")]
                pub struct Call {
                    pub source: ::subxt::utils::H160,
                    pub target: ::subxt::utils::H160,
                    pub input: ::std::vec::Vec<::core::primitive::u8>,
                    pub value: runtime_types::primitive_types::U256,
                    pub gas_limit: ::core::primitive::u64,
                    pub max_fee_per_gas: runtime_types::primitive_types::U256,
                    pub max_priority_fee_per_gas: ::core::option::Option<
                        runtime_types::primitive_types::U256,
                    >,
                    pub nonce: ::core::option::Option<
                        runtime_types::primitive_types::U256,
                    >,
                    pub access_list: ::std::vec::Vec<
                        (::subxt::utils::H160, ::std::vec::Vec<::subxt::utils::H256>),
                    >,
                }
                impl ::subxt::blocks::StaticExtrinsic for Call {
                    const PALLET: &'static str = "EVM";
                    const CALL: &'static str = "call";
                }
                #[derive(
                    ::subxt::ext::codec::Decode,
                    ::subxt::ext::codec::Encode,
                    ::subxt::ext::scale_decode::DecodeAsType,
                    ::subxt::ext::scale_encode::EncodeAsType,
                    Clone,
                    Debug,
                    Eq,
                    PartialEq
                )]
                #[codec(crate = ::subxt::ext::codec)]
                #[decode_as_type(crate_path = ":: subxt :: ext :: scale_decode")]
                #[encode_as_type(crate_path = ":: subxt :: ext :: scale_encode")]
                pub struct Create {
                    pub source: ::subxt::utils::H160,
                    pub init: ::std::vec::Vec<::core::primitive::u8>,
                    pub value: runtime_types::primitive_types::U256,
                    pub gas_limit: ::core::primitive::u64,
                    pub max_fee_per_gas: runtime_types::primitive_types::U256,
                    pub max_priority_fee_per_gas: ::core::option::Option<
                        runtime_types::primitive_types::U256,
                    >,
                    pub nonce: ::core::option::Option<
                        runtime_types::primitive_types::U256,
                    >,
                    pub access_list: ::std::vec::Vec<
                        (::subxt::utils::H160, ::std::vec::Vec<::subxt::utils::H256>),
                    >,
                }
                impl ::subxt::blocks::StaticExtrinsic for Create {
                    const PALLET: &'static str = "EVM";
                    const CALL: &'static str = "create";
                }
                #[derive(
                    ::subxt::ext::codec::Decode,
                    ::subxt::ext::codec::Encode,
                    ::subxt::ext::scale_decode::DecodeAsType,
                    ::subxt::ext::scale_encode::EncodeAsType,
                    Clone,
                    Debug,
                    Eq,
                    PartialEq
                )]
                #[codec(crate = ::subxt::ext::codec)]
                #[decode_as_type(crate_path = ":: subxt :: ext :: scale_decode")]
                #[encode_as_type(crate_path = ":: subxt :: ext :: scale_encode")]
                pub struct Create2 {
                    pub source: ::subxt::utils::H160,
                    pub init: ::std::vec::Vec<::core::primitive::u8>,
                    pub salt: ::subxt::utils::H256,
                    pub value: runtime_types::primitive_types::U256,
                    pub gas_limit: ::core::primitive::u64,
                    pub max_fee_per_gas: runtime_types::primitive_types::U256,
                    pub max_priority_fee_per_gas: ::core::option::Option<
                        runtime_types::primitive_types::U256,
                    >,
                    pub nonce: ::core::option::Option<
                        runtime_types::primitive_types::U256,
                    >,
                    pub access_list: ::std::vec::Vec<
                        (::subxt::utils::H160, ::std::vec::Vec<::subxt::utils::H256>),
                    >,
                }
                impl ::subxt::blocks::StaticExtrinsic for Create2 {
                    const PALLET: &'static str = "EVM";
                    const CALL: &'static str = "create2";
                }
            }
            pub struct TransactionApi;
            impl TransactionApi {
                ///Withdraw balance from EVM into currency/balances pallet.
                pub fn withdraw(
                    &self,
                    address: ::subxt::utils::H160,
                    value: ::core::primitive::u128,
                ) -> ::subxt::tx::Payload<types::Withdraw> {
                    ::subxt::tx::Payload::new_static(
                        "EVM",
                        "withdraw",
                        types::Withdraw { address, value },
                        [
                            62u8,
                            162u8,
                            234u8,
                            15u8,
                            176u8,
                            61u8,
                            183u8,
                            203u8,
                            241u8,
                            10u8,
                            202u8,
                            26u8,
                            45u8,
                            116u8,
                            38u8,
                            44u8,
                            32u8,
                            57u8,
                            208u8,
                            55u8,
                            182u8,
                            92u8,
                            136u8,
                            133u8,
                            216u8,
                            255u8,
                            25u8,
                            132u8,
                            242u8,
                            34u8,
                            43u8,
                            64u8,
                        ],
                    )
                }
                ///Issue an EVM call operation. This is similar to a message call transaction in Ethereum.
                pub fn call(
                    &self,
                    source: ::subxt::utils::H160,
                    target: ::subxt::utils::H160,
                    input: ::std::vec::Vec<::core::primitive::u8>,
                    value: runtime_types::primitive_types::U256,
                    gas_limit: ::core::primitive::u64,
                    max_fee_per_gas: runtime_types::primitive_types::U256,
                    max_priority_fee_per_gas: ::core::option::Option<
                        runtime_types::primitive_types::U256,
                    >,
                    nonce: ::core::option::Option<runtime_types::primitive_types::U256>,
                    access_list: ::std::vec::Vec<
                        (::subxt::utils::H160, ::std::vec::Vec<::subxt::utils::H256>),
                    >,
                ) -> ::subxt::tx::Payload<types::Call> {
                    ::subxt::tx::Payload::new_static(
                        "EVM",
                        "call",
                        types::Call {
                            source,
                            target,
                            input,
                            value,
                            gas_limit,
                            max_fee_per_gas,
                            max_priority_fee_per_gas,
                            nonce,
                            access_list,
                        },
                        [
                            31u8,
                            56u8,
                            90u8,
                            21u8,
                            253u8,
                            230u8,
                            198u8,
                            191u8,
                            141u8,
                            49u8,
                            97u8,
                            207u8,
                            47u8,
                            172u8,
                            68u8,
                            131u8,
                            67u8,
                            6u8,
                            242u8,
                            173u8,
                            172u8,
                            228u8,
                            80u8,
                            72u8,
                            196u8,
                            50u8,
                            121u8,
                            174u8,
                            41u8,
                            152u8,
                            25u8,
                            167u8,
                        ],
                    )
                }
                ///Issue an EVM create operation. This is similar to a contract creation transaction in
                ///Ethereum.
                pub fn create(
                    &self,
                    source: ::subxt::utils::H160,
                    init: ::std::vec::Vec<::core::primitive::u8>,
                    value: runtime_types::primitive_types::U256,
                    gas_limit: ::core::primitive::u64,
                    max_fee_per_gas: runtime_types::primitive_types::U256,
                    max_priority_fee_per_gas: ::core::option::Option<
                        runtime_types::primitive_types::U256,
                    >,
                    nonce: ::core::option::Option<runtime_types::primitive_types::U256>,
                    access_list: ::std::vec::Vec<
                        (::subxt::utils::H160, ::std::vec::Vec<::subxt::utils::H256>),
                    >,
                ) -> ::subxt::tx::Payload<types::Create> {
                    ::subxt::tx::Payload::new_static(
                        "EVM",
                        "create",
                        types::Create {
                            source,
                            init,
                            value,
                            gas_limit,
                            max_fee_per_gas,
                            max_priority_fee_per_gas,
                            nonce,
                            access_list,
                        },
                        [
                            95u8,
                            163u8,
                            129u8,
                            250u8,
                            114u8,
                            58u8,
                            161u8,
                            151u8,
                            39u8,
                            45u8,
                            203u8,
                            141u8,
                            107u8,
                            230u8,
                            70u8,
                            3u8,
                            142u8,
                            173u8,
                            223u8,
                            163u8,
                            135u8,
                            84u8,
                            174u8,
                            141u8,
                            125u8,
                            188u8,
                            3u8,
                            31u8,
                            180u8,
                            31u8,
                            39u8,
                            234u8,
                        ],
                    )
                }
                ///Issue an EVM create2 operation.
                pub fn create2(
                    &self,
                    source: ::subxt::utils::H160,
                    init: ::std::vec::Vec<::core::primitive::u8>,
                    salt: ::subxt::utils::H256,
                    value: runtime_types::primitive_types::U256,
                    gas_limit: ::core::primitive::u64,
                    max_fee_per_gas: runtime_types::primitive_types::U256,
                    max_priority_fee_per_gas: ::core::option::Option<
                        runtime_types::primitive_types::U256,
                    >,
                    nonce: ::core::option::Option<runtime_types::primitive_types::U256>,
                    access_list: ::std::vec::Vec<
                        (::subxt::utils::H160, ::std::vec::Vec<::subxt::utils::H256>),
                    >,
                ) -> ::subxt::tx::Payload<types::Create2> {
                    ::subxt::tx::Payload::new_static(
                        "EVM",
                        "create2",
                        types::Create2 {
                            source,
                            init,
                            salt,
                            value,
                            gas_limit,
                            max_fee_per_gas,
                            max_priority_fee_per_gas,
                            nonce,
                            access_list,
                        },
                        [
                            168u8,
                            68u8,
                            11u8,
                            93u8,
                            6u8,
                            200u8,
                            56u8,
                            193u8,
                            161u8,
                            64u8,
                            205u8,
                            55u8,
                            62u8,
                            37u8,
                            91u8,
                            117u8,
                            93u8,
                            171u8,
                            112u8,
                            24u8,
                            84u8,
                            137u8,
                            60u8,
                            109u8,
                            82u8,
                            210u8,
                            156u8,
                            136u8,
                            43u8,
                            105u8,
                            71u8,
                            8u8,
                        ],
                    )
                }
            }
        }
        /**
			The [event](https://docs.substrate.io/main-docs/build/events-errors/) emitted
			by this pallet.
			*/
        pub type Event = runtime_types::pallet_evm::pallet::Event;
        pub mod events {
            use super::runtime_types;
            #[derive(
                ::subxt::ext::codec::Decode,
                ::subxt::ext::codec::Encode,
                ::subxt::ext::scale_decode::DecodeAsType,
                ::subxt::ext::scale_encode::EncodeAsType,
                Clone,
                Debug,
                Eq,
                PartialEq
            )]
            #[codec(crate = ::subxt::ext::codec)]
            #[decode_as_type(crate_path = ":: subxt :: ext :: scale_decode")]
            #[encode_as_type(crate_path = ":: subxt :: ext :: scale_encode")]
            ///Ethereum events from contracts.
            pub struct Log {
                pub log: runtime_types::ethereum::log::Log,
            }
            impl ::subxt::events::StaticEvent for Log {
                const PALLET: &'static str = "EVM";
                const EVENT: &'static str = "Log";
            }
            #[derive(
                ::subxt::ext::codec::Decode,
                ::subxt::ext::codec::Encode,
                ::subxt::ext::scale_decode::DecodeAsType,
                ::subxt::ext::scale_encode::EncodeAsType,
                Clone,
                Debug,
                Eq,
                PartialEq
            )]
            #[codec(crate = ::subxt::ext::codec)]
            #[decode_as_type(crate_path = ":: subxt :: ext :: scale_decode")]
            #[encode_as_type(crate_path = ":: subxt :: ext :: scale_encode")]
            ///A contract has been created at given address.
            pub struct Created {
                pub address: ::subxt::utils::H160,
            }
            impl ::subxt::events::StaticEvent for Created {
                const PALLET: &'static str = "EVM";
                const EVENT: &'static str = "Created";
            }
            #[derive(
                ::subxt::ext::codec::Decode,
                ::subxt::ext::codec::Encode,
                ::subxt::ext::scale_decode::DecodeAsType,
                ::subxt::ext::scale_encode::EncodeAsType,
                Clone,
                Debug,
                Eq,
                PartialEq
            )]
            #[codec(crate = ::subxt::ext::codec)]
            #[decode_as_type(crate_path = ":: subxt :: ext :: scale_decode")]
            #[encode_as_type(crate_path = ":: subxt :: ext :: scale_encode")]
            ///A contract was attempted to be created, but the execution failed.
            pub struct CreatedFailed {
                pub address: ::subxt::utils::H160,
            }
            impl ::subxt::events::StaticEvent for CreatedFailed {
                const PALLET: &'static str = "EVM";
                const EVENT: &'static str = "CreatedFailed";
            }
            #[derive(
                ::subxt::ext::codec::Decode,
                ::subxt::ext::codec::Encode,
                ::subxt::ext::scale_decode::DecodeAsType,
                ::subxt::ext::scale_encode::EncodeAsType,
                Clone,
                Debug,
                Eq,
                PartialEq
            )]
            #[codec(crate = ::subxt::ext::codec)]
            #[decode_as_type(crate_path = ":: subxt :: ext :: scale_decode")]
            #[encode_as_type(crate_path = ":: subxt :: ext :: scale_encode")]
            ///A contract has been executed successfully with states applied.
            pub struct Executed {
                pub address: ::subxt::utils::H160,
            }
            impl ::subxt::events::StaticEvent for Executed {
                const PALLET: &'static str = "EVM";
                const EVENT: &'static str = "Executed";
            }
            #[derive(
                ::subxt::ext::codec::Decode,
                ::subxt::ext::codec::Encode,
                ::subxt::ext::scale_decode::DecodeAsType,
                ::subxt::ext::scale_encode::EncodeAsType,
                Clone,
                Debug,
                Eq,
                PartialEq
            )]
            #[codec(crate = ::subxt::ext::codec)]
            #[decode_as_type(crate_path = ":: subxt :: ext :: scale_decode")]
            #[encode_as_type(crate_path = ":: subxt :: ext :: scale_encode")]
            ///A contract has been executed with errors. States are reverted with only gas fees applied.
            pub struct ExecutedFailed {
                pub address: ::subxt::utils::H160,
            }
            impl ::subxt::events::StaticEvent for ExecutedFailed {
                const PALLET: &'static str = "EVM";
                const EVENT: &'static str = "ExecutedFailed";
            }
        }
        pub mod storage {
            use super::runtime_types;
            pub struct StorageApi;
            impl StorageApi {
                pub fn account_codes(
                    &self,
                    _0: impl ::std::borrow::Borrow<::subxt::utils::H160>,
                ) -> ::subxt::storage::address::Address<
                    ::subxt::storage::address::StaticStorageMapKey,
                    ::std::vec::Vec<::core::primitive::u8>,
                    ::subxt::storage::address::Yes,
                    ::subxt::storage::address::Yes,
                    ::subxt::storage::address::Yes,
                > {
                    ::subxt::storage::address::Address::new_static(
                        "EVM",
                        "AccountCodes",
                        vec![
                            ::subxt::storage::address::make_static_storage_map_key(_0
                            .borrow())
                        ],
                        [
                            1u8,
                            120u8,
                            180u8,
                            110u8,
                            199u8,
                            44u8,
                            76u8,
                            96u8,
                            9u8,
                            241u8,
                            193u8,
                            51u8,
                            127u8,
                            93u8,
                            102u8,
                            21u8,
                            223u8,
                            35u8,
                            174u8,
                            122u8,
                            50u8,
                            242u8,
                            107u8,
                            223u8,
                            79u8,
                            219u8,
                            92u8,
                            18u8,
                            50u8,
                            195u8,
                            169u8,
                            186u8,
                        ],
                    )
                }
                pub fn account_codes_root(
                    &self,
                ) -> ::subxt::storage::address::Address<
                    ::subxt::storage::address::StaticStorageMapKey,
                    ::std::vec::Vec<::core::primitive::u8>,
                    (),
                    ::subxt::storage::address::Yes,
                    ::subxt::storage::address::Yes,
                > {
                    ::subxt::storage::address::Address::new_static(
                        "EVM",
                        "AccountCodes",
                        Vec::new(),
                        [
                            1u8,
                            120u8,
                            180u8,
                            110u8,
                            199u8,
                            44u8,
                            76u8,
                            96u8,
                            9u8,
                            241u8,
                            193u8,
                            51u8,
                            127u8,
                            93u8,
                            102u8,
                            21u8,
                            223u8,
                            35u8,
                            174u8,
                            122u8,
                            50u8,
                            242u8,
                            107u8,
                            223u8,
                            79u8,
                            219u8,
                            92u8,
                            18u8,
                            50u8,
                            195u8,
                            169u8,
                            186u8,
                        ],
                    )
                }
                pub fn account_codes_metadata(
                    &self,
                    _0: impl ::std::borrow::Borrow<::subxt::utils::H160>,
                ) -> ::subxt::storage::address::Address<
                    ::subxt::storage::address::StaticStorageMapKey,
                    runtime_types::pallet_evm::CodeMetadata,
                    ::subxt::storage::address::Yes,
                    (),
                    ::subxt::storage::address::Yes,
                > {
                    ::subxt::storage::address::Address::new_static(
                        "EVM",
                        "AccountCodesMetadata",
                        vec![
                            ::subxt::storage::address::make_static_storage_map_key(_0
                            .borrow())
                        ],
                        [
                            42u8,
                            123u8,
                            20u8,
                            87u8,
                            93u8,
                            176u8,
                            248u8,
                            64u8,
                            61u8,
                            101u8,
                            238u8,
                            187u8,
                            254u8,
                            240u8,
                            217u8,
                            241u8,
                            6u8,
                            120u8,
                            48u8,
                            130u8,
                            191u8,
                            26u8,
                            1u8,
                            248u8,
                            174u8,
                            81u8,
                            35u8,
                            179u8,
                            27u8,
                            161u8,
                            156u8,
                            97u8,
                        ],
                    )
                }
                pub fn account_codes_metadata_root(
                    &self,
                ) -> ::subxt::storage::address::Address<
                    ::subxt::storage::address::StaticStorageMapKey,
                    runtime_types::pallet_evm::CodeMetadata,
                    (),
                    (),
                    ::subxt::storage::address::Yes,
                > {
                    ::subxt::storage::address::Address::new_static(
                        "EVM",
                        "AccountCodesMetadata",
                        Vec::new(),
                        [
                            42u8,
                            123u8,
                            20u8,
                            87u8,
                            93u8,
                            176u8,
                            248u8,
                            64u8,
                            61u8,
                            101u8,
                            238u8,
                            187u8,
                            254u8,
                            240u8,
                            217u8,
                            241u8,
                            6u8,
                            120u8,
                            48u8,
                            130u8,
                            191u8,
                            26u8,
                            1u8,
                            248u8,
                            174u8,
                            81u8,
                            35u8,
                            179u8,
                            27u8,
                            161u8,
                            156u8,
                            97u8,
                        ],
                    )
                }
                pub fn account_storages(
                    &self,
                    _0: impl ::std::borrow::Borrow<::subxt::utils::H160>,
                    _1: impl ::std::borrow::Borrow<::subxt::utils::H256>,
                ) -> ::subxt::storage::address::Address<
                    ::subxt::storage::address::StaticStorageMapKey,
                    ::subxt::utils::H256,
                    ::subxt::storage::address::Yes,
                    ::subxt::storage::address::Yes,
                    ::subxt::storage::address::Yes,
                > {
                    ::subxt::storage::address::Address::new_static(
                        "EVM",
                        "AccountStorages",
                        vec![
                            ::subxt::storage::address::make_static_storage_map_key(_0
                            .borrow()),
                            ::subxt::storage::address::make_static_storage_map_key(_1
                            .borrow())
                        ],
                        [
                            200u8,
                            211u8,
                            77u8,
                            68u8,
                            88u8,
                            0u8,
                            217u8,
                            252u8,
                            31u8,
                            168u8,
                            125u8,
                            198u8,
                            225u8,
                            52u8,
                            102u8,
                            222u8,
                            156u8,
                            238u8,
                            215u8,
                            254u8,
                            11u8,
                            62u8,
                            183u8,
                            234u8,
                            84u8,
                            5u8,
                            11u8,
                            172u8,
                            244u8,
                            199u8,
                            55u8,
                            67u8,
                        ],
                    )
                }
                pub fn account_storages_root(
                    &self,
                ) -> ::subxt::storage::address::Address<
                    ::subxt::storage::address::StaticStorageMapKey,
                    ::subxt::utils::H256,
                    (),
                    ::subxt::storage::address::Yes,
                    ::subxt::storage::address::Yes,
                > {
                    ::subxt::storage::address::Address::new_static(
                        "EVM",
                        "AccountStorages",
                        Vec::new(),
                        [
                            200u8,
                            211u8,
                            77u8,
                            68u8,
                            88u8,
                            0u8,
                            217u8,
                            252u8,
                            31u8,
                            168u8,
                            125u8,
                            198u8,
                            225u8,
                            52u8,
                            102u8,
                            222u8,
                            156u8,
                            238u8,
                            215u8,
                            254u8,
                            11u8,
                            62u8,
                            183u8,
                            234u8,
                            84u8,
                            5u8,
                            11u8,
                            172u8,
                            244u8,
                            199u8,
                            55u8,
                            67u8,
                        ],
                    )
                }
            }
        }
    }
    pub mod evm_chain_id {
        use super::root_mod;
        use super::runtime_types;
        pub mod storage {
            use super::runtime_types;
            pub struct StorageApi;
            impl StorageApi {
                /// The EVM chain ID.
                pub fn chain_id(
                    &self,
                ) -> ::subxt::storage::address::Address<
                    ::subxt::storage::address::StaticStorageMapKey,
                    ::core::primitive::u64,
                    ::subxt::storage::address::Yes,
                    ::subxt::storage::address::Yes,
                    (),
                > {
                    ::subxt::storage::address::Address::new_static(
                        "EVMChainId",
                        "ChainId",
                        vec![],
                        [
                            250u8,
                            158u8,
                            90u8,
                            220u8,
                            184u8,
                            126u8,
                            207u8,
                            222u8,
                            62u8,
                            226u8,
                            144u8,
                            204u8,
                            19u8,
                            136u8,
                            127u8,
                            5u8,
                            135u8,
                            48u8,
                            234u8,
                            138u8,
                            216u8,
                            103u8,
                            28u8,
                            140u8,
                            193u8,
                            197u8,
                            142u8,
                            22u8,
                            159u8,
                            16u8,
                            225u8,
                            255u8,
                        ],
                    )
                }
            }
        }
    }
    pub mod dynamic_fee {
        use super::root_mod;
        use super::runtime_types;
        ///Contains one variant per dispatchable that can be called by an extrinsic.
        pub type Call = runtime_types::pallet_dynamic_fee::pallet::Call;
        pub mod calls {
            use super::root_mod;
            use super::runtime_types;
            type DispatchError = runtime_types::sp_runtime::DispatchError;
            pub mod types {
                use super::runtime_types;
                #[derive(
                    ::subxt::ext::codec::Decode,
                    ::subxt::ext::codec::Encode,
                    ::subxt::ext::scale_decode::DecodeAsType,
                    ::subxt::ext::scale_encode::EncodeAsType,
                    Clone,
                    Debug,
                    Eq,
                    PartialEq
                )]
                #[codec(crate = ::subxt::ext::codec)]
                #[decode_as_type(crate_path = ":: subxt :: ext :: scale_decode")]
                #[encode_as_type(crate_path = ":: subxt :: ext :: scale_encode")]
                pub struct NoteMinGasPriceTarget {
                    pub target: runtime_types::primitive_types::U256,
                }
                impl ::subxt::blocks::StaticExtrinsic for NoteMinGasPriceTarget {
                    const PALLET: &'static str = "DynamicFee";
                    const CALL: &'static str = "note_min_gas_price_target";
                }
            }
            pub struct TransactionApi;
            impl TransactionApi {
                pub fn note_min_gas_price_target(
                    &self,
                    target: runtime_types::primitive_types::U256,
                ) -> ::subxt::tx::Payload<types::NoteMinGasPriceTarget> {
                    ::subxt::tx::Payload::new_static(
                        "DynamicFee",
                        "note_min_gas_price_target",
                        types::NoteMinGasPriceTarget {
                            target,
                        },
                        [
                            195u8,
                            135u8,
                            128u8,
                            209u8,
                            249u8,
                            41u8,
                            223u8,
                            153u8,
                            197u8,
                            51u8,
                            194u8,
                            204u8,
                            79u8,
                            173u8,
                            113u8,
                            25u8,
                            6u8,
                            153u8,
                            167u8,
                            20u8,
                            24u8,
                            86u8,
                            205u8,
                            157u8,
                            213u8,
                            248u8,
                            52u8,
                            247u8,
                            209u8,
                            0u8,
                            17u8,
                            171u8,
                        ],
                    )
                }
            }
        }
        pub mod storage {
            use super::runtime_types;
            pub struct StorageApi;
            impl StorageApi {
                pub fn min_gas_price(
                    &self,
                ) -> ::subxt::storage::address::Address<
                    ::subxt::storage::address::StaticStorageMapKey,
                    runtime_types::primitive_types::U256,
                    ::subxt::storage::address::Yes,
                    ::subxt::storage::address::Yes,
                    (),
                > {
                    ::subxt::storage::address::Address::new_static(
                        "DynamicFee",
                        "MinGasPrice",
                        vec![],
                        [
                            135u8,
                            244u8,
                            108u8,
                            147u8,
                            120u8,
                            36u8,
                            33u8,
                            200u8,
                            200u8,
                            249u8,
                            110u8,
                            39u8,
                            180u8,
                            17u8,
                            231u8,
                            219u8,
                            95u8,
                            60u8,
                            227u8,
                            68u8,
                            150u8,
                            151u8,
                            67u8,
                            45u8,
                            235u8,
                            130u8,
                            4u8,
                            244u8,
                            35u8,
                            112u8,
                            69u8,
                            119u8,
                        ],
                    )
                }
                pub fn target_min_gas_price(
                    &self,
                ) -> ::subxt::storage::address::Address<
                    ::subxt::storage::address::StaticStorageMapKey,
                    runtime_types::primitive_types::U256,
                    ::subxt::storage::address::Yes,
                    (),
                    (),
                > {
                    ::subxt::storage::address::Address::new_static(
                        "DynamicFee",
                        "TargetMinGasPrice",
                        vec![],
                        [
                            219u8,
                            94u8,
                            37u8,
                            223u8,
                            148u8,
                            89u8,
                            16u8,
                            136u8,
                            218u8,
                            154u8,
                            54u8,
                            94u8,
                            202u8,
                            5u8,
                            82u8,
                            185u8,
                            235u8,
                            239u8,
                            152u8,
                            206u8,
                            203u8,
                            71u8,
                            237u8,
                            200u8,
                            28u8,
                            250u8,
                            217u8,
                            29u8,
                            132u8,
                            255u8,
                            78u8,
                            94u8,
                        ],
                    )
                }
            }
        }
    }
    pub mod base_fee {
        use super::root_mod;
        use super::runtime_types;
        ///Contains one variant per dispatchable that can be called by an extrinsic.
        pub type Call = runtime_types::pallet_base_fee::pallet::Call;
        pub mod calls {
            use super::root_mod;
            use super::runtime_types;
            type DispatchError = runtime_types::sp_runtime::DispatchError;
            pub mod types {
                use super::runtime_types;
                #[derive(
                    ::subxt::ext::codec::Decode,
                    ::subxt::ext::codec::Encode,
                    ::subxt::ext::scale_decode::DecodeAsType,
                    ::subxt::ext::scale_encode::EncodeAsType,
                    Clone,
                    Debug,
                    Eq,
                    PartialEq
                )]
                #[codec(crate = ::subxt::ext::codec)]
                #[decode_as_type(crate_path = ":: subxt :: ext :: scale_decode")]
                #[encode_as_type(crate_path = ":: subxt :: ext :: scale_encode")]
                pub struct SetBaseFeePerGas {
                    pub fee: runtime_types::primitive_types::U256,
                }
                impl ::subxt::blocks::StaticExtrinsic for SetBaseFeePerGas {
                    const PALLET: &'static str = "BaseFee";
                    const CALL: &'static str = "set_base_fee_per_gas";
                }
                #[derive(
                    ::subxt::ext::codec::Decode,
                    ::subxt::ext::codec::Encode,
                    ::subxt::ext::scale_decode::DecodeAsType,
                    ::subxt::ext::scale_encode::EncodeAsType,
                    Clone,
                    Debug,
                    Eq,
                    PartialEq
                )]
                #[codec(crate = ::subxt::ext::codec)]
                #[decode_as_type(crate_path = ":: subxt :: ext :: scale_decode")]
                #[encode_as_type(crate_path = ":: subxt :: ext :: scale_encode")]
                pub struct SetElasticity {
                    pub elasticity: runtime_types::sp_arithmetic::per_things::Permill,
                }
                impl ::subxt::blocks::StaticExtrinsic for SetElasticity {
                    const PALLET: &'static str = "BaseFee";
                    const CALL: &'static str = "set_elasticity";
                }
            }
            pub struct TransactionApi;
            impl TransactionApi {
                pub fn set_base_fee_per_gas(
                    &self,
                    fee: runtime_types::primitive_types::U256,
                ) -> ::subxt::tx::Payload<types::SetBaseFeePerGas> {
                    ::subxt::tx::Payload::new_static(
                        "BaseFee",
                        "set_base_fee_per_gas",
                        types::SetBaseFeePerGas { fee },
                        [
                            126u8,
                            236u8,
                            128u8,
                            184u8,
                            42u8,
                            39u8,
                            13u8,
                            175u8,
                            155u8,
                            36u8,
                            229u8,
                            20u8,
                            13u8,
                            15u8,
                            88u8,
                            56u8,
                            206u8,
                            44u8,
                            127u8,
                            182u8,
                            120u8,
                            212u8,
                            35u8,
                            72u8,
                            100u8,
                            181u8,
                            64u8,
                            200u8,
                            63u8,
                            129u8,
                            167u8,
                            132u8,
                        ],
                    )
                }
                pub fn set_elasticity(
                    &self,
                    elasticity: runtime_types::sp_arithmetic::per_things::Permill,
                ) -> ::subxt::tx::Payload<types::SetElasticity> {
                    ::subxt::tx::Payload::new_static(
                        "BaseFee",
                        "set_elasticity",
                        types::SetElasticity { elasticity },
                        [
                            209u8,
                            8u8,
                            19u8,
                            35u8,
                            199u8,
                            151u8,
                            122u8,
                            91u8,
                            181u8,
                            133u8,
                            162u8,
                            167u8,
                            186u8,
                            150u8,
                            54u8,
                            83u8,
                            101u8,
                            180u8,
                            188u8,
                            136u8,
                            111u8,
                            100u8,
                            76u8,
                            51u8,
                            118u8,
                            171u8,
                            15u8,
                            75u8,
                            120u8,
                            106u8,
                            37u8,
                            1u8,
                        ],
                    )
                }
            }
        }
        /**
			The [event](https://docs.substrate.io/main-docs/build/events-errors/) emitted
			by this pallet.
			*/
        pub type Event = runtime_types::pallet_base_fee::pallet::Event;
        pub mod events {
            use super::runtime_types;
            #[derive(
                ::subxt::ext::codec::Decode,
                ::subxt::ext::codec::Encode,
                ::subxt::ext::scale_decode::DecodeAsType,
                ::subxt::ext::scale_encode::EncodeAsType,
                Clone,
                Debug,
                Eq,
                PartialEq
            )]
            #[codec(crate = ::subxt::ext::codec)]
            #[decode_as_type(crate_path = ":: subxt :: ext :: scale_decode")]
            #[encode_as_type(crate_path = ":: subxt :: ext :: scale_encode")]
            pub struct NewBaseFeePerGas {
                pub fee: runtime_types::primitive_types::U256,
            }
            impl ::subxt::events::StaticEvent for NewBaseFeePerGas {
                const PALLET: &'static str = "BaseFee";
                const EVENT: &'static str = "NewBaseFeePerGas";
            }
            #[derive(
                ::subxt::ext::codec::Decode,
                ::subxt::ext::codec::Encode,
                ::subxt::ext::scale_decode::DecodeAsType,
                ::subxt::ext::scale_encode::EncodeAsType,
                Clone,
                Debug,
                Eq,
                PartialEq
            )]
            #[codec(crate = ::subxt::ext::codec)]
            #[decode_as_type(crate_path = ":: subxt :: ext :: scale_decode")]
            #[encode_as_type(crate_path = ":: subxt :: ext :: scale_encode")]
            pub struct BaseFeeOverflow;
            impl ::subxt::events::StaticEvent for BaseFeeOverflow {
                const PALLET: &'static str = "BaseFee";
                const EVENT: &'static str = "BaseFeeOverflow";
            }
            #[derive(
                ::subxt::ext::codec::Decode,
                ::subxt::ext::codec::Encode,
                ::subxt::ext::scale_decode::DecodeAsType,
                ::subxt::ext::scale_encode::EncodeAsType,
                Clone,
                Debug,
                Eq,
                PartialEq
            )]
            #[codec(crate = ::subxt::ext::codec)]
            #[decode_as_type(crate_path = ":: subxt :: ext :: scale_decode")]
            #[encode_as_type(crate_path = ":: subxt :: ext :: scale_encode")]
            pub struct NewElasticity {
                pub elasticity: runtime_types::sp_arithmetic::per_things::Permill,
            }
            impl ::subxt::events::StaticEvent for NewElasticity {
                const PALLET: &'static str = "BaseFee";
                const EVENT: &'static str = "NewElasticity";
            }
        }
        pub mod storage {
            use super::runtime_types;
            pub struct StorageApi;
            impl StorageApi {
                pub fn base_fee_per_gas(
                    &self,
                ) -> ::subxt::storage::address::Address<
                    ::subxt::storage::address::StaticStorageMapKey,
                    runtime_types::primitive_types::U256,
                    ::subxt::storage::address::Yes,
                    ::subxt::storage::address::Yes,
                    (),
                > {
                    ::subxt::storage::address::Address::new_static(
                        "BaseFee",
                        "BaseFeePerGas",
                        vec![],
                        [
                            72u8,
                            143u8,
                            208u8,
                            233u8,
                            10u8,
                            122u8,
                            20u8,
                            183u8,
                            203u8,
                            61u8,
                            240u8,
                            154u8,
                            28u8,
                            65u8,
                            239u8,
                            220u8,
                            205u8,
                            19u8,
                            227u8,
                            113u8,
                            146u8,
                            90u8,
                            234u8,
                            209u8,
                            113u8,
                            169u8,
                            216u8,
                            194u8,
                            189u8,
                            0u8,
                            154u8,
                            144u8,
                        ],
                    )
                }
                pub fn elasticity(
                    &self,
                ) -> ::subxt::storage::address::Address<
                    ::subxt::storage::address::StaticStorageMapKey,
                    runtime_types::sp_arithmetic::per_things::Permill,
                    ::subxt::storage::address::Yes,
                    ::subxt::storage::address::Yes,
                    (),
                > {
                    ::subxt::storage::address::Address::new_static(
                        "BaseFee",
                        "Elasticity",
                        vec![],
                        [
                            196u8,
                            184u8,
                            245u8,
                            90u8,
                            25u8,
                            50u8,
                            66u8,
                            69u8,
                            140u8,
                            128u8,
                            179u8,
                            63u8,
                            197u8,
                            133u8,
                            135u8,
                            141u8,
                            56u8,
                            0u8,
                            143u8,
                            241u8,
                            200u8,
                            114u8,
                            73u8,
                            157u8,
                            85u8,
                            190u8,
                            1u8,
                            2u8,
                            208u8,
                            235u8,
                            62u8,
                            16u8,
                        ],
                    )
                }
            }
        }
    }
    pub mod hotfix_sufficients {
        use super::root_mod;
        use super::runtime_types;
        /**
			Custom [dispatch errors](https://docs.substrate.io/main-docs/build/events-errors/)
			of this pallet.
			*/
        pub type Error = runtime_types::pallet_hotfix_sufficients::pallet::Error;
        ///Contains one variant per dispatchable that can be called by an extrinsic.
        pub type Call = runtime_types::pallet_hotfix_sufficients::pallet::Call;
        pub mod calls {
            use super::root_mod;
            use super::runtime_types;
            type DispatchError = runtime_types::sp_runtime::DispatchError;
            pub mod types {
                use super::runtime_types;
                #[derive(
                    ::subxt::ext::codec::Decode,
                    ::subxt::ext::codec::Encode,
                    ::subxt::ext::scale_decode::DecodeAsType,
                    ::subxt::ext::scale_encode::EncodeAsType,
                    Clone,
                    Debug,
                    Eq,
                    PartialEq
                )]
                #[codec(crate = ::subxt::ext::codec)]
                #[decode_as_type(crate_path = ":: subxt :: ext :: scale_decode")]
                #[encode_as_type(crate_path = ":: subxt :: ext :: scale_encode")]
                pub struct HotfixIncAccountSufficients {
                    pub addresses: ::std::vec::Vec<::subxt::utils::H160>,
                }
                impl ::subxt::blocks::StaticExtrinsic for HotfixIncAccountSufficients {
                    const PALLET: &'static str = "HotfixSufficients";
                    const CALL: &'static str = "hotfix_inc_account_sufficients";
                }
            }
            pub struct TransactionApi;
            impl TransactionApi {
                ///Increment `sufficients` for existing accounts having a nonzero `nonce` but zero `sufficients`, `consumers` and `providers` value.
                ///This state was caused by a previous bug in EVM create account dispatchable.
                ///
                ///Any accounts in the input list not satisfying the above condition will remain unaffected.
                pub fn hotfix_inc_account_sufficients(
                    &self,
                    addresses: ::std::vec::Vec<::subxt::utils::H160>,
                ) -> ::subxt::tx::Payload<types::HotfixIncAccountSufficients> {
                    ::subxt::tx::Payload::new_static(
                        "HotfixSufficients",
                        "hotfix_inc_account_sufficients",
                        types::HotfixIncAccountSufficients {
                            addresses,
                        },
                        [
                            135u8,
                            117u8,
                            192u8,
                            209u8,
                            218u8,
                            115u8,
                            124u8,
                            21u8,
                            78u8,
                            250u8,
                            55u8,
                            209u8,
                            86u8,
                            92u8,
                            17u8,
                            196u8,
                            209u8,
                            131u8,
                            185u8,
                            20u8,
                            166u8,
                            25u8,
                            175u8,
                            119u8,
                            21u8,
                            155u8,
                            139u8,
                            112u8,
                            128u8,
                            35u8,
                            223u8,
                            195u8,
                        ],
                    )
                }
            }
        }
    }
    pub mod eth2_client {
        use super::root_mod;
        use super::runtime_types;
        /**
			Custom [dispatch errors](https://docs.substrate.io/main-docs/build/events-errors/)
			of this pallet.
			*/
        pub type Error = runtime_types::pallet_eth2_light_client::pallet::Error;
        ///Contains one variant per dispatchable that can be called by an extrinsic.
        pub type Call = runtime_types::pallet_eth2_light_client::pallet::Call;
        pub mod calls {
            use super::root_mod;
            use super::runtime_types;
            type DispatchError = runtime_types::sp_runtime::DispatchError;
            pub mod types {
                use super::runtime_types;
                #[derive(
                    ::subxt::ext::codec::Decode,
                    ::subxt::ext::codec::Encode,
                    ::subxt::ext::scale_decode::DecodeAsType,
                    ::subxt::ext::scale_encode::EncodeAsType,
                    Clone,
                    Debug,
                    Eq,
                    PartialEq
                )]
                #[codec(crate = ::subxt::ext::codec)]
                #[decode_as_type(crate_path = ":: subxt :: ext :: scale_decode")]
                #[encode_as_type(crate_path = ":: subxt :: ext :: scale_encode")]
                pub struct Init {
                    pub typed_chain_id: runtime_types::webb_proposals::header::TypedChainId,
                    pub args: ::std::boxed::Box<
                        runtime_types::eth_types::pallet::InitInput<
                            ::subxt::utils::AccountId32,
                        >,
                    >,
                }
                impl ::subxt::blocks::StaticExtrinsic for Init {
                    const PALLET: &'static str = "Eth2Client";
                    const CALL: &'static str = "init";
                }
                #[derive(
                    ::subxt::ext::codec::Decode,
                    ::subxt::ext::codec::Encode,
                    ::subxt::ext::scale_decode::DecodeAsType,
                    ::subxt::ext::scale_encode::EncodeAsType,
                    Clone,
                    Debug,
                    Eq,
                    PartialEq
                )]
                #[codec(crate = ::subxt::ext::codec)]
                #[decode_as_type(crate_path = ":: subxt :: ext :: scale_decode")]
                #[encode_as_type(crate_path = ":: subxt :: ext :: scale_encode")]
                pub struct RegisterSubmitter {
                    pub typed_chain_id: runtime_types::webb_proposals::header::TypedChainId,
                }
                impl ::subxt::blocks::StaticExtrinsic for RegisterSubmitter {
                    const PALLET: &'static str = "Eth2Client";
                    const CALL: &'static str = "register_submitter";
                }
                #[derive(
                    ::subxt::ext::codec::Decode,
                    ::subxt::ext::codec::Encode,
                    ::subxt::ext::scale_decode::DecodeAsType,
                    ::subxt::ext::scale_encode::EncodeAsType,
                    Clone,
                    Debug,
                    Eq,
                    PartialEq
                )]
                #[codec(crate = ::subxt::ext::codec)]
                #[decode_as_type(crate_path = ":: subxt :: ext :: scale_decode")]
                #[encode_as_type(crate_path = ":: subxt :: ext :: scale_encode")]
                pub struct UnregisterSubmitter {
                    pub typed_chain_id: runtime_types::webb_proposals::header::TypedChainId,
                }
                impl ::subxt::blocks::StaticExtrinsic for UnregisterSubmitter {
                    const PALLET: &'static str = "Eth2Client";
                    const CALL: &'static str = "unregister_submitter";
                }
                #[derive(
                    ::subxt::ext::codec::Decode,
                    ::subxt::ext::codec::Encode,
                    ::subxt::ext::scale_decode::DecodeAsType,
                    ::subxt::ext::scale_encode::EncodeAsType,
                    Clone,
                    Debug,
                    Eq,
                    PartialEq
                )]
                #[codec(crate = ::subxt::ext::codec)]
                #[decode_as_type(crate_path = ":: subxt :: ext :: scale_decode")]
                #[encode_as_type(crate_path = ":: subxt :: ext :: scale_encode")]
                pub struct SubmitBeaconChainLightClientUpdate {
                    pub typed_chain_id: runtime_types::webb_proposals::header::TypedChainId,
                    pub light_client_update: runtime_types::eth_types::eth2::LightClientUpdate,
                }
                impl ::subxt::blocks::StaticExtrinsic
                for SubmitBeaconChainLightClientUpdate {
                    const PALLET: &'static str = "Eth2Client";
                    const CALL: &'static str = "submit_beacon_chain_light_client_update";
                }
                #[derive(
                    ::subxt::ext::codec::Decode,
                    ::subxt::ext::codec::Encode,
                    ::subxt::ext::scale_decode::DecodeAsType,
                    ::subxt::ext::scale_encode::EncodeAsType,
                    Clone,
                    Debug,
                    Eq,
                    PartialEq
                )]
                #[codec(crate = ::subxt::ext::codec)]
                #[decode_as_type(crate_path = ":: subxt :: ext :: scale_decode")]
                #[encode_as_type(crate_path = ":: subxt :: ext :: scale_encode")]
                pub struct SubmitExecutionHeader {
                    pub typed_chain_id: runtime_types::webb_proposals::header::TypedChainId,
                    pub block_header: runtime_types::eth_types::BlockHeader,
                }
                impl ::subxt::blocks::StaticExtrinsic for SubmitExecutionHeader {
                    const PALLET: &'static str = "Eth2Client";
                    const CALL: &'static str = "submit_execution_header";
                }
                #[derive(
                    ::subxt::ext::codec::Decode,
                    ::subxt::ext::codec::Encode,
                    ::subxt::ext::scale_decode::DecodeAsType,
                    ::subxt::ext::scale_encode::EncodeAsType,
                    Clone,
                    Debug,
                    Eq,
                    PartialEq
                )]
                #[codec(crate = ::subxt::ext::codec)]
                #[decode_as_type(crate_path = ":: subxt :: ext :: scale_decode")]
                #[encode_as_type(crate_path = ":: subxt :: ext :: scale_encode")]
                pub struct UpdateTrustedSigner {
                    pub trusted_signer: ::subxt::utils::AccountId32,
                }
                impl ::subxt::blocks::StaticExtrinsic for UpdateTrustedSigner {
                    const PALLET: &'static str = "Eth2Client";
                    const CALL: &'static str = "update_trusted_signer";
                }
            }
            pub struct TransactionApi;
            impl TransactionApi {
                pub fn init(
                    &self,
                    typed_chain_id: runtime_types::webb_proposals::header::TypedChainId,
                    args: runtime_types::eth_types::pallet::InitInput<
                        ::subxt::utils::AccountId32,
                    >,
                ) -> ::subxt::tx::Payload<types::Init> {
                    ::subxt::tx::Payload::new_static(
                        "Eth2Client",
                        "init",
                        types::Init {
                            typed_chain_id,
                            args: ::std::boxed::Box::new(args),
                        },
                        [
                            224u8,
                            172u8,
                            34u8,
                            87u8,
                            94u8,
                            27u8,
                            77u8,
                            137u8,
                            199u8,
                            116u8,
                            185u8,
                            165u8,
                            132u8,
                            142u8,
                            118u8,
                            110u8,
                            85u8,
                            138u8,
                            217u8,
                            166u8,
                            109u8,
                            37u8,
                            233u8,
                            224u8,
                            204u8,
                            88u8,
                            194u8,
                            87u8,
                            199u8,
                            145u8,
                            158u8,
                            195u8,
                        ],
                    )
                }
                pub fn register_submitter(
                    &self,
                    typed_chain_id: runtime_types::webb_proposals::header::TypedChainId,
                ) -> ::subxt::tx::Payload<types::RegisterSubmitter> {
                    ::subxt::tx::Payload::new_static(
                        "Eth2Client",
                        "register_submitter",
                        types::RegisterSubmitter {
                            typed_chain_id,
                        },
                        [
                            222u8,
                            7u8,
                            60u8,
                            184u8,
                            244u8,
                            96u8,
                            213u8,
                            235u8,
                            150u8,
                            244u8,
                            87u8,
                            155u8,
                            244u8,
                            201u8,
                            42u8,
                            234u8,
                            86u8,
                            150u8,
                            19u8,
                            116u8,
                            130u8,
                            62u8,
                            224u8,
                            153u8,
                            199u8,
                            0u8,
                            124u8,
                            226u8,
                            241u8,
                            87u8,
                            230u8,
                            48u8,
                        ],
                    )
                }
                pub fn unregister_submitter(
                    &self,
                    typed_chain_id: runtime_types::webb_proposals::header::TypedChainId,
                ) -> ::subxt::tx::Payload<types::UnregisterSubmitter> {
                    ::subxt::tx::Payload::new_static(
                        "Eth2Client",
                        "unregister_submitter",
                        types::UnregisterSubmitter {
                            typed_chain_id,
                        },
                        [
                            165u8,
                            108u8,
                            239u8,
                            19u8,
                            128u8,
                            122u8,
                            250u8,
                            180u8,
                            87u8,
                            236u8,
                            36u8,
                            175u8,
                            85u8,
                            5u8,
                            77u8,
                            129u8,
                            42u8,
                            63u8,
                            185u8,
                            116u8,
                            89u8,
                            246u8,
                            119u8,
                            72u8,
                            227u8,
                            132u8,
                            100u8,
                            216u8,
                            250u8,
                            120u8,
                            178u8,
                            128u8,
                        ],
                    )
                }
                pub fn submit_beacon_chain_light_client_update(
                    &self,
                    typed_chain_id: runtime_types::webb_proposals::header::TypedChainId,
                    light_client_update: runtime_types::eth_types::eth2::LightClientUpdate,
                ) -> ::subxt::tx::Payload<types::SubmitBeaconChainLightClientUpdate> {
                    ::subxt::tx::Payload::new_static(
                        "Eth2Client",
                        "submit_beacon_chain_light_client_update",
                        types::SubmitBeaconChainLightClientUpdate {
                            typed_chain_id,
                            light_client_update,
                        },
                        [
                            207u8,
                            203u8,
                            157u8,
                            86u8,
                            27u8,
                            194u8,
                            34u8,
                            239u8,
                            114u8,
                            53u8,
                            210u8,
                            164u8,
                            70u8,
                            34u8,
                            102u8,
                            183u8,
                            29u8,
                            120u8,
                            240u8,
                            191u8,
                            26u8,
                            33u8,
                            110u8,
                            129u8,
                            145u8,
                            239u8,
                            62u8,
                            18u8,
                            134u8,
                            190u8,
                            125u8,
                            137u8,
                        ],
                    )
                }
                pub fn submit_execution_header(
                    &self,
                    typed_chain_id: runtime_types::webb_proposals::header::TypedChainId,
                    block_header: runtime_types::eth_types::BlockHeader,
                ) -> ::subxt::tx::Payload<types::SubmitExecutionHeader> {
                    ::subxt::tx::Payload::new_static(
                        "Eth2Client",
                        "submit_execution_header",
                        types::SubmitExecutionHeader {
                            typed_chain_id,
                            block_header,
                        },
                        [
                            38u8,
                            118u8,
                            239u8,
                            79u8,
                            229u8,
                            71u8,
                            163u8,
                            234u8,
                            175u8,
                            198u8,
                            140u8,
                            174u8,
                            121u8,
                            139u8,
                            55u8,
                            0u8,
                            11u8,
                            133u8,
                            224u8,
                            31u8,
                            253u8,
                            178u8,
                            14u8,
                            233u8,
                            103u8,
                            208u8,
                            232u8,
                            211u8,
                            218u8,
                            68u8,
                            151u8,
                            26u8,
                        ],
                    )
                }
                pub fn update_trusted_signer(
                    &self,
                    trusted_signer: ::subxt::utils::AccountId32,
                ) -> ::subxt::tx::Payload<types::UpdateTrustedSigner> {
                    ::subxt::tx::Payload::new_static(
                        "Eth2Client",
                        "update_trusted_signer",
                        types::UpdateTrustedSigner {
                            trusted_signer,
                        },
                        [
                            135u8,
                            127u8,
                            171u8,
                            28u8,
                            199u8,
                            19u8,
                            175u8,
                            128u8,
                            88u8,
                            130u8,
                            38u8,
                            205u8,
                            75u8,
                            117u8,
                            25u8,
                            185u8,
                            27u8,
                            122u8,
                            93u8,
                            169u8,
                            210u8,
                            246u8,
                            87u8,
                            174u8,
                            15u8,
                            61u8,
                            152u8,
                            173u8,
                            27u8,
                            4u8,
                            172u8,
                            194u8,
                        ],
                    )
                }
            }
        }
        /**
			The [event](https://docs.substrate.io/main-docs/build/events-errors/) emitted
			by this pallet.
			*/
        pub type Event = runtime_types::pallet_eth2_light_client::pallet::Event;
        pub mod events {
            use super::runtime_types;
            #[derive(
                ::subxt::ext::codec::Decode,
                ::subxt::ext::codec::Encode,
                ::subxt::ext::scale_decode::DecodeAsType,
                ::subxt::ext::scale_encode::EncodeAsType,
                Clone,
                Debug,
                Eq,
                PartialEq
            )]
            #[codec(crate = ::subxt::ext::codec)]
            #[decode_as_type(crate_path = ":: subxt :: ext :: scale_decode")]
            #[encode_as_type(crate_path = ":: subxt :: ext :: scale_encode")]
            pub struct Init {
                pub typed_chain_id: runtime_types::webb_proposals::header::TypedChainId,
                pub header_info: runtime_types::eth_types::pallet::ExecutionHeaderInfo<
                    ::subxt::utils::AccountId32,
                >,
            }
            impl ::subxt::events::StaticEvent for Init {
                const PALLET: &'static str = "Eth2Client";
                const EVENT: &'static str = "Init";
            }
            #[derive(
                ::subxt::ext::codec::Decode,
                ::subxt::ext::codec::Encode,
                ::subxt::ext::scale_decode::DecodeAsType,
                ::subxt::ext::scale_encode::EncodeAsType,
                Clone,
                Debug,
                Eq,
                PartialEq
            )]
            #[codec(crate = ::subxt::ext::codec)]
            #[decode_as_type(crate_path = ":: subxt :: ext :: scale_decode")]
            #[encode_as_type(crate_path = ":: subxt :: ext :: scale_encode")]
            pub struct RegisterSubmitter {
                pub typed_chain_id: runtime_types::webb_proposals::header::TypedChainId,
                pub submitter: ::subxt::utils::AccountId32,
            }
            impl ::subxt::events::StaticEvent for RegisterSubmitter {
                const PALLET: &'static str = "Eth2Client";
                const EVENT: &'static str = "RegisterSubmitter";
            }
            #[derive(
                ::subxt::ext::codec::Decode,
                ::subxt::ext::codec::Encode,
                ::subxt::ext::scale_decode::DecodeAsType,
                ::subxt::ext::scale_encode::EncodeAsType,
                Clone,
                Debug,
                Eq,
                PartialEq
            )]
            #[codec(crate = ::subxt::ext::codec)]
            #[decode_as_type(crate_path = ":: subxt :: ext :: scale_decode")]
            #[encode_as_type(crate_path = ":: subxt :: ext :: scale_encode")]
            pub struct UnregisterSubmitter {
                pub typed_chain_id: runtime_types::webb_proposals::header::TypedChainId,
                pub submitter: ::subxt::utils::AccountId32,
            }
            impl ::subxt::events::StaticEvent for UnregisterSubmitter {
                const PALLET: &'static str = "Eth2Client";
                const EVENT: &'static str = "UnregisterSubmitter";
            }
            #[derive(
                ::subxt::ext::codec::Decode,
                ::subxt::ext::codec::Encode,
                ::subxt::ext::scale_decode::DecodeAsType,
                ::subxt::ext::scale_encode::EncodeAsType,
                Clone,
                Debug,
                Eq,
                PartialEq
            )]
            #[codec(crate = ::subxt::ext::codec)]
            #[decode_as_type(crate_path = ":: subxt :: ext :: scale_decode")]
            #[encode_as_type(crate_path = ":: subxt :: ext :: scale_encode")]
            pub struct SubmitBeaconChainLightClientUpdate {
                pub typed_chain_id: runtime_types::webb_proposals::header::TypedChainId,
                pub submitter: ::subxt::utils::AccountId32,
                pub beacon_block_header: runtime_types::eth_types::eth2::BeaconBlockHeader,
            }
            impl ::subxt::events::StaticEvent for SubmitBeaconChainLightClientUpdate {
                const PALLET: &'static str = "Eth2Client";
                const EVENT: &'static str = "SubmitBeaconChainLightClientUpdate";
            }
            #[derive(
                ::subxt::ext::codec::Decode,
                ::subxt::ext::codec::Encode,
                ::subxt::ext::scale_decode::DecodeAsType,
                ::subxt::ext::scale_encode::EncodeAsType,
                Clone,
                Debug,
                Eq,
                PartialEq
            )]
            #[codec(crate = ::subxt::ext::codec)]
            #[decode_as_type(crate_path = ":: subxt :: ext :: scale_decode")]
            #[encode_as_type(crate_path = ":: subxt :: ext :: scale_encode")]
            pub struct SubmitExecutionHeader {
                pub typed_chain_id: runtime_types::webb_proposals::header::TypedChainId,
                pub header_info: runtime_types::eth_types::pallet::ExecutionHeaderInfo<
                    ::subxt::utils::AccountId32,
                >,
            }
            impl ::subxt::events::StaticEvent for SubmitExecutionHeader {
                const PALLET: &'static str = "Eth2Client";
                const EVENT: &'static str = "SubmitExecutionHeader";
            }
            #[derive(
                ::subxt::ext::codec::Decode,
                ::subxt::ext::codec::Encode,
                ::subxt::ext::scale_decode::DecodeAsType,
                ::subxt::ext::scale_encode::EncodeAsType,
                Clone,
                Debug,
                Eq,
                PartialEq
            )]
            #[codec(crate = ::subxt::ext::codec)]
            #[decode_as_type(crate_path = ":: subxt :: ext :: scale_decode")]
            #[encode_as_type(crate_path = ":: subxt :: ext :: scale_encode")]
            pub struct UpdateTrustedSigner {
                pub trusted_signer: ::subxt::utils::AccountId32,
            }
            impl ::subxt::events::StaticEvent for UpdateTrustedSigner {
                const PALLET: &'static str = "Eth2Client";
                const EVENT: &'static str = "UpdateTrustedSigner";
            }
        }
        pub mod storage {
            use super::runtime_types;
            pub struct StorageApi;
            impl StorageApi {
                /// If set, only light client updates by the trusted signer will be accepted
                pub fn trusted_signer(
                    &self,
                ) -> ::subxt::storage::address::Address<
                    ::subxt::storage::address::StaticStorageMapKey,
                    ::subxt::utils::AccountId32,
                    ::subxt::storage::address::Yes,
                    (),
                    (),
                > {
                    ::subxt::storage::address::Address::new_static(
                        "Eth2Client",
                        "TrustedSigner",
                        vec![],
                        [
                            21u8,
                            189u8,
                            0u8,
                            45u8,
                            62u8,
                            32u8,
                            95u8,
                            123u8,
                            212u8,
                            22u8,
                            46u8,
                            86u8,
                            77u8,
                            59u8,
                            244u8,
                            58u8,
                            71u8,
                            37u8,
                            128u8,
                            236u8,
                            255u8,
                            63u8,
                            167u8,
                            111u8,
                            213u8,
                            109u8,
                            43u8,
                            161u8,
                            205u8,
                            37u8,
                            83u8,
                            187u8,
                        ],
                    )
                }
                /// Mask determining all paused functions
                pub fn paused(
                    &self,
                    _0: impl ::std::borrow::Borrow<
                        runtime_types::webb_proposals::header::TypedChainId,
                    >,
                ) -> ::subxt::storage::address::Address<
                    ::subxt::storage::address::StaticStorageMapKey,
                    ::core::primitive::bool,
                    ::subxt::storage::address::Yes,
                    ::subxt::storage::address::Yes,
                    ::subxt::storage::address::Yes,
                > {
                    ::subxt::storage::address::Address::new_static(
                        "Eth2Client",
                        "Paused",
                        vec![
                            ::subxt::storage::address::make_static_storage_map_key(_0
                            .borrow())
                        ],
                        [
                            67u8,
                            242u8,
                            157u8,
                            222u8,
                            138u8,
                            64u8,
                            225u8,
                            85u8,
                            198u8,
                            3u8,
                            14u8,
                            10u8,
                            177u8,
                            45u8,
                            252u8,
                            141u8,
                            51u8,
                            212u8,
                            73u8,
                            153u8,
                            205u8,
                            25u8,
                            83u8,
                            131u8,
                            39u8,
                            209u8,
                            51u8,
                            227u8,
                            14u8,
                            162u8,
                            151u8,
                            89u8,
                        ],
                    )
                }
                /// Mask determining all paused functions
                pub fn paused_root(
                    &self,
                ) -> ::subxt::storage::address::Address<
                    ::subxt::storage::address::StaticStorageMapKey,
                    ::core::primitive::bool,
                    (),
                    ::subxt::storage::address::Yes,
                    ::subxt::storage::address::Yes,
                > {
                    ::subxt::storage::address::Address::new_static(
                        "Eth2Client",
                        "Paused",
                        Vec::new(),
                        [
                            67u8,
                            242u8,
                            157u8,
                            222u8,
                            138u8,
                            64u8,
                            225u8,
                            85u8,
                            198u8,
                            3u8,
                            14u8,
                            10u8,
                            177u8,
                            45u8,
                            252u8,
                            141u8,
                            51u8,
                            212u8,
                            73u8,
                            153u8,
                            205u8,
                            25u8,
                            83u8,
                            131u8,
                            39u8,
                            209u8,
                            51u8,
                            227u8,
                            14u8,
                            162u8,
                            151u8,
                            89u8,
                        ],
                    )
                }
                /// Whether the client validates the updates.
                /// Should only be set to `false` for debugging, testing, and diagnostic purposes
                pub fn validate_updates(
                    &self,
                    _0: impl ::std::borrow::Borrow<
                        runtime_types::webb_proposals::header::TypedChainId,
                    >,
                ) -> ::subxt::storage::address::Address<
                    ::subxt::storage::address::StaticStorageMapKey,
                    ::core::primitive::bool,
                    ::subxt::storage::address::Yes,
                    ::subxt::storage::address::Yes,
                    ::subxt::storage::address::Yes,
                > {
                    ::subxt::storage::address::Address::new_static(
                        "Eth2Client",
                        "ValidateUpdates",
                        vec![
                            ::subxt::storage::address::make_static_storage_map_key(_0
                            .borrow())
                        ],
                        [
                            49u8,
                            117u8,
                            104u8,
                            75u8,
                            255u8,
                            224u8,
                            49u8,
                            241u8,
                            128u8,
                            105u8,
                            57u8,
                            193u8,
                            229u8,
                            15u8,
                            122u8,
                            6u8,
                            254u8,
                            88u8,
                            166u8,
                            175u8,
                            211u8,
                            54u8,
                            95u8,
                            204u8,
                            219u8,
                            147u8,
                            10u8,
                            114u8,
                            51u8,
                            13u8,
                            122u8,
                            139u8,
                        ],
                    )
                }
                /// Whether the client validates the updates.
                /// Should only be set to `false` for debugging, testing, and diagnostic purposes
                pub fn validate_updates_root(
                    &self,
                ) -> ::subxt::storage::address::Address<
                    ::subxt::storage::address::StaticStorageMapKey,
                    ::core::primitive::bool,
                    (),
                    ::subxt::storage::address::Yes,
                    ::subxt::storage::address::Yes,
                > {
                    ::subxt::storage::address::Address::new_static(
                        "Eth2Client",
                        "ValidateUpdates",
                        Vec::new(),
                        [
                            49u8,
                            117u8,
                            104u8,
                            75u8,
                            255u8,
                            224u8,
                            49u8,
                            241u8,
                            128u8,
                            105u8,
                            57u8,
                            193u8,
                            229u8,
                            15u8,
                            122u8,
                            6u8,
                            254u8,
                            88u8,
                            166u8,
                            175u8,
                            211u8,
                            54u8,
                            95u8,
                            204u8,
                            219u8,
                            147u8,
                            10u8,
                            114u8,
                            51u8,
                            13u8,
                            122u8,
                            139u8,
                        ],
                    )
                }
                /// Whether the client verifies BLS signatures.
                pub fn verify_bls_signatures(
                    &self,
                    _0: impl ::std::borrow::Borrow<
                        runtime_types::webb_proposals::header::TypedChainId,
                    >,
                ) -> ::subxt::storage::address::Address<
                    ::subxt::storage::address::StaticStorageMapKey,
                    ::core::primitive::bool,
                    ::subxt::storage::address::Yes,
                    ::subxt::storage::address::Yes,
                    ::subxt::storage::address::Yes,
                > {
                    ::subxt::storage::address::Address::new_static(
                        "Eth2Client",
                        "VerifyBlsSignatures",
                        vec![
                            ::subxt::storage::address::make_static_storage_map_key(_0
                            .borrow())
                        ],
                        [
                            5u8,
                            63u8,
                            177u8,
                            128u8,
                            97u8,
                            61u8,
                            181u8,
                            19u8,
                            96u8,
                            253u8,
                            208u8,
                            216u8,
                            145u8,
                            117u8,
                            73u8,
                            101u8,
                            103u8,
                            245u8,
                            155u8,
                            63u8,
                            18u8,
                            28u8,
                            237u8,
                            241u8,
                            129u8,
                            11u8,
                            128u8,
                            86u8,
                            181u8,
                            232u8,
                            172u8,
                            77u8,
                        ],
                    )
                }
                /// Whether the client verifies BLS signatures.
                pub fn verify_bls_signatures_root(
                    &self,
                ) -> ::subxt::storage::address::Address<
                    ::subxt::storage::address::StaticStorageMapKey,
                    ::core::primitive::bool,
                    (),
                    ::subxt::storage::address::Yes,
                    ::subxt::storage::address::Yes,
                > {
                    ::subxt::storage::address::Address::new_static(
                        "Eth2Client",
                        "VerifyBlsSignatures",
                        Vec::new(),
                        [
                            5u8,
                            63u8,
                            177u8,
                            128u8,
                            97u8,
                            61u8,
                            181u8,
                            19u8,
                            96u8,
                            253u8,
                            208u8,
                            216u8,
                            145u8,
                            117u8,
                            73u8,
                            101u8,
                            103u8,
                            245u8,
                            155u8,
                            63u8,
                            18u8,
                            28u8,
                            237u8,
                            241u8,
                            129u8,
                            11u8,
                            128u8,
                            86u8,
                            181u8,
                            232u8,
                            172u8,
                            77u8,
                        ],
                    )
                }
                /// We store the hashes of the blocks for the past `hashes_gc_threshold` headers.
                /// Events that happen past this threshold cannot be verified by the client.
                /// It is desirable that this number is larger than 7 days' worth of headers, which is roughly
                /// 51k Ethereum blocks. So this number should be 51k in production.
                pub fn hashes_gc_threshold(
                    &self,
                    _0: impl ::std::borrow::Borrow<
                        runtime_types::webb_proposals::header::TypedChainId,
                    >,
                ) -> ::subxt::storage::address::Address<
                    ::subxt::storage::address::StaticStorageMapKey,
                    ::core::primitive::u64,
                    ::subxt::storage::address::Yes,
                    ::subxt::storage::address::Yes,
                    ::subxt::storage::address::Yes,
                > {
                    ::subxt::storage::address::Address::new_static(
                        "Eth2Client",
                        "HashesGcThreshold",
                        vec![
                            ::subxt::storage::address::make_static_storage_map_key(_0
                            .borrow())
                        ],
                        [
                            124u8,
                            226u8,
                            124u8,
                            138u8,
                            247u8,
                            40u8,
                            139u8,
                            198u8,
                            245u8,
                            212u8,
                            132u8,
                            125u8,
                            120u8,
                            218u8,
                            56u8,
                            100u8,
                            227u8,
                            189u8,
                            165u8,
                            46u8,
                            145u8,
                            91u8,
                            159u8,
                            150u8,
                            145u8,
                            49u8,
                            125u8,
                            137u8,
                            118u8,
                            255u8,
                            71u8,
                            62u8,
                        ],
                    )
                }
                /// We store the hashes of the blocks for the past `hashes_gc_threshold` headers.
                /// Events that happen past this threshold cannot be verified by the client.
                /// It is desirable that this number is larger than 7 days' worth of headers, which is roughly
                /// 51k Ethereum blocks. So this number should be 51k in production.
                pub fn hashes_gc_threshold_root(
                    &self,
                ) -> ::subxt::storage::address::Address<
                    ::subxt::storage::address::StaticStorageMapKey,
                    ::core::primitive::u64,
                    (),
                    ::subxt::storage::address::Yes,
                    ::subxt::storage::address::Yes,
                > {
                    ::subxt::storage::address::Address::new_static(
                        "Eth2Client",
                        "HashesGcThreshold",
                        Vec::new(),
                        [
                            124u8,
                            226u8,
                            124u8,
                            138u8,
                            247u8,
                            40u8,
                            139u8,
                            198u8,
                            245u8,
                            212u8,
                            132u8,
                            125u8,
                            120u8,
                            218u8,
                            56u8,
                            100u8,
                            227u8,
                            189u8,
                            165u8,
                            46u8,
                            145u8,
                            91u8,
                            159u8,
                            150u8,
                            145u8,
                            49u8,
                            125u8,
                            137u8,
                            118u8,
                            255u8,
                            71u8,
                            62u8,
                        ],
                    )
                }
                /// Hashes of the finalized execution blocks mapped to their numbers. Stores up to
                /// `hashes_gc_threshold` entries. Execution block number -> execution block hash
                pub fn finalized_execution_blocks(
                    &self,
                    _0: impl ::std::borrow::Borrow<
                        runtime_types::webb_proposals::header::TypedChainId,
                    >,
                    _1: impl ::std::borrow::Borrow<::core::primitive::u64>,
                ) -> ::subxt::storage::address::Address<
                    ::subxt::storage::address::StaticStorageMapKey,
                    runtime_types::eth_types::H256,
                    ::subxt::storage::address::Yes,
                    (),
                    ::subxt::storage::address::Yes,
                > {
                    ::subxt::storage::address::Address::new_static(
                        "Eth2Client",
                        "FinalizedExecutionBlocks",
                        vec![
                            ::subxt::storage::address::make_static_storage_map_key(_0
                            .borrow()),
                            ::subxt::storage::address::make_static_storage_map_key(_1
                            .borrow())
                        ],
                        [
                            134u8,
                            41u8,
                            62u8,
                            140u8,
                            194u8,
                            61u8,
                            138u8,
                            61u8,
                            66u8,
                            103u8,
                            12u8,
                            216u8,
                            239u8,
                            109u8,
                            178u8,
                            34u8,
                            221u8,
                            93u8,
                            125u8,
                            37u8,
                            228u8,
                            53u8,
                            108u8,
                            201u8,
                            173u8,
                            246u8,
                            56u8,
                            150u8,
                            67u8,
                            233u8,
                            35u8,
                            27u8,
                        ],
                    )
                }
                /// Hashes of the finalized execution blocks mapped to their numbers. Stores up to
                /// `hashes_gc_threshold` entries. Execution block number -> execution block hash
                pub fn finalized_execution_blocks_root(
                    &self,
                ) -> ::subxt::storage::address::Address<
                    ::subxt::storage::address::StaticStorageMapKey,
                    runtime_types::eth_types::H256,
                    (),
                    (),
                    ::subxt::storage::address::Yes,
                > {
                    ::subxt::storage::address::Address::new_static(
                        "Eth2Client",
                        "FinalizedExecutionBlocks",
                        Vec::new(),
                        [
                            134u8,
                            41u8,
                            62u8,
                            140u8,
                            194u8,
                            61u8,
                            138u8,
                            61u8,
                            66u8,
                            103u8,
                            12u8,
                            216u8,
                            239u8,
                            109u8,
                            178u8,
                            34u8,
                            221u8,
                            93u8,
                            125u8,
                            37u8,
                            228u8,
                            53u8,
                            108u8,
                            201u8,
                            173u8,
                            246u8,
                            56u8,
                            150u8,
                            67u8,
                            233u8,
                            35u8,
                            27u8,
                        ],
                    )
                }
                /// All unfinalized execution blocks' headers hashes mapped to their `HeaderInfo`.
                /// Execution block hash -> ExecutionHeaderInfo object
                pub fn unfinalized_headers(
                    &self,
                    _0: impl ::std::borrow::Borrow<
                        runtime_types::webb_proposals::header::TypedChainId,
                    >,
                    _1: impl ::std::borrow::Borrow<runtime_types::eth_types::H256>,
                ) -> ::subxt::storage::address::Address<
                    ::subxt::storage::address::StaticStorageMapKey,
                    runtime_types::eth_types::pallet::ExecutionHeaderInfo<
                        ::subxt::utils::AccountId32,
                    >,
                    ::subxt::storage::address::Yes,
                    (),
                    ::subxt::storage::address::Yes,
                > {
                    ::subxt::storage::address::Address::new_static(
                        "Eth2Client",
                        "UnfinalizedHeaders",
                        vec![
                            ::subxt::storage::address::make_static_storage_map_key(_0
                            .borrow()),
                            ::subxt::storage::address::make_static_storage_map_key(_1
                            .borrow())
                        ],
                        [
                            129u8,
                            60u8,
                            100u8,
                            53u8,
                            242u8,
                            2u8,
                            223u8,
                            237u8,
                            18u8,
                            205u8,
                            47u8,
                            93u8,
                            193u8,
                            153u8,
                            25u8,
                            0u8,
                            149u8,
                            5u8,
                            165u8,
                            124u8,
                            2u8,
                            255u8,
                            108u8,
                            109u8,
                            196u8,
                            157u8,
                            183u8,
                            131u8,
                            178u8,
                            79u8,
                            94u8,
                            232u8,
                        ],
                    )
                }
                /// All unfinalized execution blocks' headers hashes mapped to their `HeaderInfo`.
                /// Execution block hash -> ExecutionHeaderInfo object
                pub fn unfinalized_headers_root(
                    &self,
                ) -> ::subxt::storage::address::Address<
                    ::subxt::storage::address::StaticStorageMapKey,
                    runtime_types::eth_types::pallet::ExecutionHeaderInfo<
                        ::subxt::utils::AccountId32,
                    >,
                    (),
                    (),
                    ::subxt::storage::address::Yes,
                > {
                    ::subxt::storage::address::Address::new_static(
                        "Eth2Client",
                        "UnfinalizedHeaders",
                        Vec::new(),
                        [
                            129u8,
                            60u8,
                            100u8,
                            53u8,
                            242u8,
                            2u8,
                            223u8,
                            237u8,
                            18u8,
                            205u8,
                            47u8,
                            93u8,
                            193u8,
                            153u8,
                            25u8,
                            0u8,
                            149u8,
                            5u8,
                            165u8,
                            124u8,
                            2u8,
                            255u8,
                            108u8,
                            109u8,
                            196u8,
                            157u8,
                            183u8,
                            131u8,
                            178u8,
                            79u8,
                            94u8,
                            232u8,
                        ],
                    )
                }
                /// `AccountId`s mapped to their number of submitted headers.
                /// Submitter account -> Num of submitted headers
                pub fn submitters(
                    &self,
                    _0: impl ::std::borrow::Borrow<
                        runtime_types::webb_proposals::header::TypedChainId,
                    >,
                    _1: impl ::std::borrow::Borrow<::subxt::utils::AccountId32>,
                ) -> ::subxt::storage::address::Address<
                    ::subxt::storage::address::StaticStorageMapKey,
                    ::core::primitive::u32,
                    ::subxt::storage::address::Yes,
                    (),
                    ::subxt::storage::address::Yes,
                > {
                    ::subxt::storage::address::Address::new_static(
                        "Eth2Client",
                        "Submitters",
                        vec![
                            ::subxt::storage::address::make_static_storage_map_key(_0
                            .borrow()),
                            ::subxt::storage::address::make_static_storage_map_key(_1
                            .borrow())
                        ],
                        [
                            59u8,
                            140u8,
                            198u8,
                            164u8,
                            176u8,
                            105u8,
                            237u8,
                            249u8,
                            77u8,
                            243u8,
                            29u8,
                            13u8,
                            152u8,
                            202u8,
                            158u8,
                            203u8,
                            81u8,
                            118u8,
                            248u8,
                            241u8,
                            89u8,
                            193u8,
                            70u8,
                            78u8,
                            56u8,
                            164u8,
                            40u8,
                            33u8,
                            103u8,
                            17u8,
                            250u8,
                            118u8,
                        ],
                    )
                }
                /// `AccountId`s mapped to their number of submitted headers.
                /// Submitter account -> Num of submitted headers
                pub fn submitters_root(
                    &self,
                ) -> ::subxt::storage::address::Address<
                    ::subxt::storage::address::StaticStorageMapKey,
                    ::core::primitive::u32,
                    (),
                    (),
                    ::subxt::storage::address::Yes,
                > {
                    ::subxt::storage::address::Address::new_static(
                        "Eth2Client",
                        "Submitters",
                        Vec::new(),
                        [
                            59u8,
                            140u8,
                            198u8,
                            164u8,
                            176u8,
                            105u8,
                            237u8,
                            249u8,
                            77u8,
                            243u8,
                            29u8,
                            13u8,
                            152u8,
                            202u8,
                            158u8,
                            203u8,
                            81u8,
                            118u8,
                            248u8,
                            241u8,
                            89u8,
                            193u8,
                            70u8,
                            78u8,
                            56u8,
                            164u8,
                            40u8,
                            33u8,
                            103u8,
                            17u8,
                            250u8,
                            118u8,
                        ],
                    )
                }
                /// Max number of unfinalized blocks allowed to be stored by one submitter account
                /// This value should be at least 32 blocks (1 epoch), but the recommended value is 1024 (32
                /// epochs
                pub fn max_unfinalized_blocks_per_submitter(
                    &self,
                    _0: impl ::std::borrow::Borrow<
                        runtime_types::webb_proposals::header::TypedChainId,
                    >,
                ) -> ::subxt::storage::address::Address<
                    ::subxt::storage::address::StaticStorageMapKey,
                    ::core::primitive::u32,
                    ::subxt::storage::address::Yes,
                    ::subxt::storage::address::Yes,
                    ::subxt::storage::address::Yes,
                > {
                    ::subxt::storage::address::Address::new_static(
                        "Eth2Client",
                        "MaxUnfinalizedBlocksPerSubmitter",
                        vec![
                            ::subxt::storage::address::make_static_storage_map_key(_0
                            .borrow())
                        ],
                        [
                            92u8,
                            16u8,
                            141u8,
                            155u8,
                            234u8,
                            201u8,
                            38u8,
                            45u8,
                            34u8,
                            90u8,
                            7u8,
                            82u8,
                            40u8,
                            224u8,
                            31u8,
                            135u8,
                            201u8,
                            205u8,
                            31u8,
                            193u8,
                            227u8,
                            1u8,
                            125u8,
                            32u8,
                            134u8,
                            43u8,
                            236u8,
                            224u8,
                            31u8,
                            12u8,
                            79u8,
                            75u8,
                        ],
                    )
                }
                /// Max number of unfinalized blocks allowed to be stored by one submitter account
                /// This value should be at least 32 blocks (1 epoch), but the recommended value is 1024 (32
                /// epochs
                pub fn max_unfinalized_blocks_per_submitter_root(
                    &self,
                ) -> ::subxt::storage::address::Address<
                    ::subxt::storage::address::StaticStorageMapKey,
                    ::core::primitive::u32,
                    (),
                    ::subxt::storage::address::Yes,
                    ::subxt::storage::address::Yes,
                > {
                    ::subxt::storage::address::Address::new_static(
                        "Eth2Client",
                        "MaxUnfinalizedBlocksPerSubmitter",
                        Vec::new(),
                        [
                            92u8,
                            16u8,
                            141u8,
                            155u8,
                            234u8,
                            201u8,
                            38u8,
                            45u8,
                            34u8,
                            90u8,
                            7u8,
                            82u8,
                            40u8,
                            224u8,
                            31u8,
                            135u8,
                            201u8,
                            205u8,
                            31u8,
                            193u8,
                            227u8,
                            1u8,
                            125u8,
                            32u8,
                            134u8,
                            43u8,
                            236u8,
                            224u8,
                            31u8,
                            12u8,
                            79u8,
                            75u8,
                        ],
                    )
                }
                /// The minimum balance that should be attached to register a new submitter account
                pub fn min_submitter_balance(
                    &self,
                    _0: impl ::std::borrow::Borrow<
                        runtime_types::webb_proposals::header::TypedChainId,
                    >,
                ) -> ::subxt::storage::address::Address<
                    ::subxt::storage::address::StaticStorageMapKey,
                    ::core::primitive::u128,
                    ::subxt::storage::address::Yes,
                    ::subxt::storage::address::Yes,
                    ::subxt::storage::address::Yes,
                > {
                    ::subxt::storage::address::Address::new_static(
                        "Eth2Client",
                        "MinSubmitterBalance",
                        vec![
                            ::subxt::storage::address::make_static_storage_map_key(_0
                            .borrow())
                        ],
                        [
                            235u8,
                            98u8,
                            223u8,
                            184u8,
                            115u8,
                            57u8,
                            22u8,
                            25u8,
                            38u8,
                            173u8,
                            108u8,
                            116u8,
                            37u8,
                            3u8,
                            16u8,
                            106u8,
                            32u8,
                            81u8,
                            121u8,
                            18u8,
                            49u8,
                            33u8,
                            19u8,
                            53u8,
                            41u8,
                            172u8,
                            99u8,
                            120u8,
                            231u8,
                            80u8,
                            238u8,
                            20u8,
                        ],
                    )
                }
                /// The minimum balance that should be attached to register a new submitter account
                pub fn min_submitter_balance_root(
                    &self,
                ) -> ::subxt::storage::address::Address<
                    ::subxt::storage::address::StaticStorageMapKey,
                    ::core::primitive::u128,
                    (),
                    ::subxt::storage::address::Yes,
                    ::subxt::storage::address::Yes,
                > {
                    ::subxt::storage::address::Address::new_static(
                        "Eth2Client",
                        "MinSubmitterBalance",
                        Vec::new(),
                        [
                            235u8,
                            98u8,
                            223u8,
                            184u8,
                            115u8,
                            57u8,
                            22u8,
                            25u8,
                            38u8,
                            173u8,
                            108u8,
                            116u8,
                            37u8,
                            3u8,
                            16u8,
                            106u8,
                            32u8,
                            81u8,
                            121u8,
                            18u8,
                            49u8,
                            33u8,
                            19u8,
                            53u8,
                            41u8,
                            172u8,
                            99u8,
                            120u8,
                            231u8,
                            80u8,
                            238u8,
                            20u8,
                        ],
                    )
                }
                /// Light client state
                pub fn finalized_beacon_header(
                    &self,
                    _0: impl ::std::borrow::Borrow<
                        runtime_types::webb_proposals::header::TypedChainId,
                    >,
                ) -> ::subxt::storage::address::Address<
                    ::subxt::storage::address::StaticStorageMapKey,
                    runtime_types::eth_types::eth2::ExtendedBeaconBlockHeader,
                    ::subxt::storage::address::Yes,
                    (),
                    ::subxt::storage::address::Yes,
                > {
                    ::subxt::storage::address::Address::new_static(
                        "Eth2Client",
                        "FinalizedBeaconHeader",
                        vec![
                            ::subxt::storage::address::make_static_storage_map_key(_0
                            .borrow())
                        ],
                        [
                            71u8,
                            146u8,
                            230u8,
                            183u8,
                            36u8,
                            170u8,
                            254u8,
                            126u8,
                            155u8,
                            247u8,
                            27u8,
                            104u8,
                            156u8,
                            119u8,
                            52u8,
                            51u8,
                            78u8,
                            136u8,
                            156u8,
                            79u8,
                            201u8,
                            177u8,
                            253u8,
                            118u8,
                            47u8,
                            17u8,
                            50u8,
                            195u8,
                            43u8,
                            177u8,
                            245u8,
                            127u8,
                        ],
                    )
                }
                /// Light client state
                pub fn finalized_beacon_header_root(
                    &self,
                ) -> ::subxt::storage::address::Address<
                    ::subxt::storage::address::StaticStorageMapKey,
                    runtime_types::eth_types::eth2::ExtendedBeaconBlockHeader,
                    (),
                    (),
                    ::subxt::storage::address::Yes,
                > {
                    ::subxt::storage::address::Address::new_static(
                        "Eth2Client",
                        "FinalizedBeaconHeader",
                        Vec::new(),
                        [
                            71u8,
                            146u8,
                            230u8,
                            183u8,
                            36u8,
                            170u8,
                            254u8,
                            126u8,
                            155u8,
                            247u8,
                            27u8,
                            104u8,
                            156u8,
                            119u8,
                            52u8,
                            51u8,
                            78u8,
                            136u8,
                            156u8,
                            79u8,
                            201u8,
                            177u8,
                            253u8,
                            118u8,
                            47u8,
                            17u8,
                            50u8,
                            195u8,
                            43u8,
                            177u8,
                            245u8,
                            127u8,
                        ],
                    )
                }
                pub fn finalized_execution_header(
                    &self,
                    _0: impl ::std::borrow::Borrow<
                        runtime_types::webb_proposals::header::TypedChainId,
                    >,
                ) -> ::subxt::storage::address::Address<
                    ::subxt::storage::address::StaticStorageMapKey,
                    runtime_types::eth_types::pallet::ExecutionHeaderInfo<
                        ::subxt::utils::AccountId32,
                    >,
                    ::subxt::storage::address::Yes,
                    (),
                    ::subxt::storage::address::Yes,
                > {
                    ::subxt::storage::address::Address::new_static(
                        "Eth2Client",
                        "FinalizedExecutionHeader",
                        vec![
                            ::subxt::storage::address::make_static_storage_map_key(_0
                            .borrow())
                        ],
                        [
                            134u8,
                            98u8,
                            58u8,
                            100u8,
                            221u8,
                            62u8,
                            31u8,
                            13u8,
                            224u8,
                            124u8,
                            10u8,
                            244u8,
                            135u8,
                            14u8,
                            29u8,
                            161u8,
                            64u8,
                            11u8,
                            104u8,
                            171u8,
                            25u8,
                            29u8,
                            178u8,
                            58u8,
                            87u8,
                            56u8,
                            48u8,
                            240u8,
                            105u8,
                            89u8,
                            25u8,
                            225u8,
                        ],
                    )
                }
                pub fn finalized_execution_header_root(
                    &self,
                ) -> ::subxt::storage::address::Address<
                    ::subxt::storage::address::StaticStorageMapKey,
                    runtime_types::eth_types::pallet::ExecutionHeaderInfo<
                        ::subxt::utils::AccountId32,
                    >,
                    (),
                    (),
                    ::subxt::storage::address::Yes,
                > {
                    ::subxt::storage::address::Address::new_static(
                        "Eth2Client",
                        "FinalizedExecutionHeader",
                        Vec::new(),
                        [
                            134u8,
                            98u8,
                            58u8,
                            100u8,
                            221u8,
                            62u8,
                            31u8,
                            13u8,
                            224u8,
                            124u8,
                            10u8,
                            244u8,
                            135u8,
                            14u8,
                            29u8,
                            161u8,
                            64u8,
                            11u8,
                            104u8,
                            171u8,
                            25u8,
                            29u8,
                            178u8,
                            58u8,
                            87u8,
                            56u8,
                            48u8,
                            240u8,
                            105u8,
                            89u8,
                            25u8,
                            225u8,
                        ],
                    )
                }
                pub fn current_sync_committee(
                    &self,
                    _0: impl ::std::borrow::Borrow<
                        runtime_types::webb_proposals::header::TypedChainId,
                    >,
                ) -> ::subxt::storage::address::Address<
                    ::subxt::storage::address::StaticStorageMapKey,
                    runtime_types::eth_types::eth2::SyncCommittee,
                    ::subxt::storage::address::Yes,
                    (),
                    ::subxt::storage::address::Yes,
                > {
                    ::subxt::storage::address::Address::new_static(
                        "Eth2Client",
                        "CurrentSyncCommittee",
                        vec![
                            ::subxt::storage::address::make_static_storage_map_key(_0
                            .borrow())
                        ],
                        [
                            229u8,
                            30u8,
                            180u8,
                            144u8,
                            244u8,
                            152u8,
                            206u8,
                            207u8,
                            99u8,
                            39u8,
                            220u8,
                            112u8,
                            140u8,
                            121u8,
                            252u8,
                            173u8,
                            109u8,
                            234u8,
                            41u8,
                            181u8,
                            138u8,
                            13u8,
                            224u8,
                            219u8,
                            59u8,
                            30u8,
                            88u8,
                            70u8,
                            131u8,
                            141u8,
                            18u8,
                            203u8,
                        ],
                    )
                }
                pub fn current_sync_committee_root(
                    &self,
                ) -> ::subxt::storage::address::Address<
                    ::subxt::storage::address::StaticStorageMapKey,
                    runtime_types::eth_types::eth2::SyncCommittee,
                    (),
                    (),
                    ::subxt::storage::address::Yes,
                > {
                    ::subxt::storage::address::Address::new_static(
                        "Eth2Client",
                        "CurrentSyncCommittee",
                        Vec::new(),
                        [
                            229u8,
                            30u8,
                            180u8,
                            144u8,
                            244u8,
                            152u8,
                            206u8,
                            207u8,
                            99u8,
                            39u8,
                            220u8,
                            112u8,
                            140u8,
                            121u8,
                            252u8,
                            173u8,
                            109u8,
                            234u8,
                            41u8,
                            181u8,
                            138u8,
                            13u8,
                            224u8,
                            219u8,
                            59u8,
                            30u8,
                            88u8,
                            70u8,
                            131u8,
                            141u8,
                            18u8,
                            203u8,
                        ],
                    )
                }
                pub fn next_sync_committee(
                    &self,
                    _0: impl ::std::borrow::Borrow<
                        runtime_types::webb_proposals::header::TypedChainId,
                    >,
                ) -> ::subxt::storage::address::Address<
                    ::subxt::storage::address::StaticStorageMapKey,
                    runtime_types::eth_types::eth2::SyncCommittee,
                    ::subxt::storage::address::Yes,
                    (),
                    ::subxt::storage::address::Yes,
                > {
                    ::subxt::storage::address::Address::new_static(
                        "Eth2Client",
                        "NextSyncCommittee",
                        vec![
                            ::subxt::storage::address::make_static_storage_map_key(_0
                            .borrow())
                        ],
                        [
                            151u8,
                            89u8,
                            52u8,
                            48u8,
                            128u8,
                            93u8,
                            9u8,
                            192u8,
                            208u8,
                            88u8,
                            82u8,
                            251u8,
                            28u8,
                            41u8,
                            206u8,
                            189u8,
                            124u8,
                            130u8,
                            169u8,
                            109u8,
                            156u8,
                            53u8,
                            245u8,
                            89u8,
                            39u8,
                            167u8,
                            204u8,
                            41u8,
                            20u8,
                            34u8,
                            114u8,
                            96u8,
                        ],
                    )
                }
                pub fn next_sync_committee_root(
                    &self,
                ) -> ::subxt::storage::address::Address<
                    ::subxt::storage::address::StaticStorageMapKey,
                    runtime_types::eth_types::eth2::SyncCommittee,
                    (),
                    (),
                    ::subxt::storage::address::Yes,
                > {
                    ::subxt::storage::address::Address::new_static(
                        "Eth2Client",
                        "NextSyncCommittee",
                        Vec::new(),
                        [
                            151u8,
                            89u8,
                            52u8,
                            48u8,
                            128u8,
                            93u8,
                            9u8,
                            192u8,
                            208u8,
                            88u8,
                            82u8,
                            251u8,
                            28u8,
                            41u8,
                            206u8,
                            189u8,
                            124u8,
                            130u8,
                            169u8,
                            109u8,
                            156u8,
                            53u8,
                            245u8,
                            89u8,
                            39u8,
                            167u8,
                            204u8,
                            41u8,
                            20u8,
                            34u8,
                            114u8,
                            96u8,
                        ],
                    )
                }
                pub fn genesis_validators_root(
                    &self,
                    _0: impl ::std::borrow::Borrow<
                        runtime_types::webb_proposals::header::TypedChainId,
                    >,
                ) -> ::subxt::storage::address::Address<
                    ::subxt::storage::address::StaticStorageMapKey,
                    [::core::primitive::u8; 32usize],
                    ::subxt::storage::address::Yes,
                    (),
                    ::subxt::storage::address::Yes,
                > {
                    ::subxt::storage::address::Address::new_static(
                        "Eth2Client",
                        "GenesisValidatorsRoot",
                        vec![
                            ::subxt::storage::address::make_static_storage_map_key(_0
                            .borrow())
                        ],
                        [
                            22u8,
                            246u8,
                            23u8,
                            170u8,
                            76u8,
                            154u8,
                            63u8,
                            7u8,
                            13u8,
                            138u8,
                            226u8,
                            165u8,
                            178u8,
                            249u8,
                            45u8,
                            181u8,
                            237u8,
                            145u8,
                            150u8,
                            47u8,
                            219u8,
                            108u8,
                            243u8,
                            192u8,
                            245u8,
                            82u8,
                            34u8,
                            85u8,
                            86u8,
                            234u8,
                            64u8,
                            181u8,
                        ],
                    )
                }
                pub fn genesis_validators_root_root(
                    &self,
                ) -> ::subxt::storage::address::Address<
                    ::subxt::storage::address::StaticStorageMapKey,
                    [::core::primitive::u8; 32usize],
                    (),
                    (),
                    ::subxt::storage::address::Yes,
                > {
                    ::subxt::storage::address::Address::new_static(
                        "Eth2Client",
                        "GenesisValidatorsRoot",
                        Vec::new(),
                        [
                            22u8,
                            246u8,
                            23u8,
                            170u8,
                            76u8,
                            154u8,
                            63u8,
                            7u8,
                            13u8,
                            138u8,
                            226u8,
                            165u8,
                            178u8,
                            249u8,
                            45u8,
                            181u8,
                            237u8,
                            145u8,
                            150u8,
                            47u8,
                            219u8,
                            108u8,
                            243u8,
                            192u8,
                            245u8,
                            82u8,
                            34u8,
                            85u8,
                            86u8,
                            234u8,
                            64u8,
                            181u8,
                        ],
                    )
                }
                pub fn bellatrix_fork_version(
                    &self,
                    _0: impl ::std::borrow::Borrow<
                        runtime_types::webb_proposals::header::TypedChainId,
                    >,
                ) -> ::subxt::storage::address::Address<
                    ::subxt::storage::address::StaticStorageMapKey,
                    [::core::primitive::u8; 4usize],
                    ::subxt::storage::address::Yes,
                    (),
                    ::subxt::storage::address::Yes,
                > {
                    ::subxt::storage::address::Address::new_static(
                        "Eth2Client",
                        "BellatrixForkVersion",
                        vec![
                            ::subxt::storage::address::make_static_storage_map_key(_0
                            .borrow())
                        ],
                        [
                            29u8,
                            130u8,
                            38u8,
                            233u8,
                            229u8,
                            221u8,
                            100u8,
                            210u8,
                            123u8,
                            131u8,
                            211u8,
                            94u8,
                            163u8,
                            66u8,
                            192u8,
                            210u8,
                            42u8,
                            6u8,
                            4u8,
                            166u8,
                            107u8,
                            176u8,
                            234u8,
                            117u8,
                            40u8,
                            178u8,
                            84u8,
                            136u8,
                            79u8,
                            201u8,
                            190u8,
                            6u8,
                        ],
                    )
                }
                pub fn bellatrix_fork_version_root(
                    &self,
                ) -> ::subxt::storage::address::Address<
                    ::subxt::storage::address::StaticStorageMapKey,
                    [::core::primitive::u8; 4usize],
                    (),
                    (),
                    ::subxt::storage::address::Yes,
                > {
                    ::subxt::storage::address::Address::new_static(
                        "Eth2Client",
                        "BellatrixForkVersion",
                        Vec::new(),
                        [
                            29u8,
                            130u8,
                            38u8,
                            233u8,
                            229u8,
                            221u8,
                            100u8,
                            210u8,
                            123u8,
                            131u8,
                            211u8,
                            94u8,
                            163u8,
                            66u8,
                            192u8,
                            210u8,
                            42u8,
                            6u8,
                            4u8,
                            166u8,
                            107u8,
                            176u8,
                            234u8,
                            117u8,
                            40u8,
                            178u8,
                            84u8,
                            136u8,
                            79u8,
                            201u8,
                            190u8,
                            6u8,
                        ],
                    )
                }
                pub fn bellatrix_fork_epoch(
                    &self,
                    _0: impl ::std::borrow::Borrow<
                        runtime_types::webb_proposals::header::TypedChainId,
                    >,
                ) -> ::subxt::storage::address::Address<
                    ::subxt::storage::address::StaticStorageMapKey,
                    ::core::primitive::u64,
                    ::subxt::storage::address::Yes,
                    (),
                    ::subxt::storage::address::Yes,
                > {
                    ::subxt::storage::address::Address::new_static(
                        "Eth2Client",
                        "BellatrixForkEpoch",
                        vec![
                            ::subxt::storage::address::make_static_storage_map_key(_0
                            .borrow())
                        ],
                        [
                            87u8,
                            55u8,
                            13u8,
                            246u8,
                            134u8,
                            53u8,
                            165u8,
                            86u8,
                            195u8,
                            249u8,
                            9u8,
                            47u8,
                            204u8,
                            189u8,
                            167u8,
                            159u8,
                            59u8,
                            44u8,
                            9u8,
                            84u8,
                            27u8,
                            107u8,
                            161u8,
                            171u8,
                            46u8,
                            110u8,
                            166u8,
                            199u8,
                            103u8,
                            47u8,
                            46u8,
                            174u8,
                        ],
                    )
                }
                pub fn bellatrix_fork_epoch_root(
                    &self,
                ) -> ::subxt::storage::address::Address<
                    ::subxt::storage::address::StaticStorageMapKey,
                    ::core::primitive::u64,
                    (),
                    (),
                    ::subxt::storage::address::Yes,
                > {
                    ::subxt::storage::address::Address::new_static(
                        "Eth2Client",
                        "BellatrixForkEpoch",
                        Vec::new(),
                        [
                            87u8,
                            55u8,
                            13u8,
                            246u8,
                            134u8,
                            53u8,
                            165u8,
                            86u8,
                            195u8,
                            249u8,
                            9u8,
                            47u8,
                            204u8,
                            189u8,
                            167u8,
                            159u8,
                            59u8,
                            44u8,
                            9u8,
                            84u8,
                            27u8,
                            107u8,
                            161u8,
                            171u8,
                            46u8,
                            110u8,
                            166u8,
                            199u8,
                            103u8,
                            47u8,
                            46u8,
                            174u8,
                        ],
                    )
                }
            }
        }
        pub mod constants {
            use super::runtime_types;
            pub struct ConstantsApi;
            impl ConstantsApi {
                pub fn pallet_id(
                    &self,
                ) -> ::subxt::constants::Address<
                    runtime_types::frame_support::PalletId,
                > {
                    ::subxt::constants::Address::new_static(
                        "Eth2Client",
                        "PalletId",
                        [
                            56u8,
                            243u8,
                            53u8,
                            83u8,
                            154u8,
                            179u8,
                            170u8,
                            80u8,
                            133u8,
                            173u8,
                            61u8,
                            161u8,
                            47u8,
                            225u8,
                            146u8,
                            21u8,
                            50u8,
                            229u8,
                            248u8,
                            27u8,
                            104u8,
                            58u8,
                            129u8,
                            197u8,
                            102u8,
                            160u8,
                            168u8,
                            205u8,
                            154u8,
                            42u8,
                            217u8,
                            53u8,
                        ],
                    )
                }
            }
        }
    }
    pub mod runtime_types {
        use super::runtime_types;
        pub mod bounded_collections {
            use super::runtime_types;
            pub mod bounded_btree_map {
                use super::runtime_types;
                #[derive(
                    ::subxt::ext::codec::Decode,
                    ::subxt::ext::codec::Encode,
                    ::subxt::ext::scale_decode::DecodeAsType,
                    ::subxt::ext::scale_encode::EncodeAsType,
                    Clone,
                    Debug,
                    Eq,
                    PartialEq
                )]
                #[codec(crate = ::subxt::ext::codec)]
                #[decode_as_type(crate_path = ":: subxt :: ext :: scale_decode")]
                #[encode_as_type(crate_path = ":: subxt :: ext :: scale_encode")]
                pub struct BoundedBTreeMap<_0, _1>(pub ::subxt::utils::KeyedVec<_0, _1>);
            }
            pub mod bounded_vec {
                use super::runtime_types;
                #[derive(
                    ::subxt::ext::codec::Decode,
                    ::subxt::ext::codec::Encode,
                    ::subxt::ext::scale_decode::DecodeAsType,
                    ::subxt::ext::scale_encode::EncodeAsType,
                    Clone,
                    Debug,
                    Eq,
                    PartialEq
                )]
                #[codec(crate = ::subxt::ext::codec)]
                #[decode_as_type(crate_path = ":: subxt :: ext :: scale_decode")]
                #[encode_as_type(crate_path = ":: subxt :: ext :: scale_encode")]
                pub struct BoundedVec<_0>(pub ::std::vec::Vec<_0>);
            }
            pub mod weak_bounded_vec {
                use super::runtime_types;
                #[derive(
                    ::subxt::ext::codec::Decode,
                    ::subxt::ext::codec::Encode,
                    ::subxt::ext::scale_decode::DecodeAsType,
                    ::subxt::ext::scale_encode::EncodeAsType,
                    Clone,
                    Debug,
                    Eq,
                    PartialEq
                )]
                #[codec(crate = ::subxt::ext::codec)]
                #[decode_as_type(crate_path = ":: subxt :: ext :: scale_decode")]
                #[encode_as_type(crate_path = ":: subxt :: ext :: scale_encode")]
                pub struct WeakBoundedVec<_0>(pub ::std::vec::Vec<_0>);
            }
        }
        pub mod dkg_runtime_primitives {
            use super::runtime_types;
            pub mod crypto {
                use super::runtime_types;
                #[derive(
                    ::subxt::ext::codec::Decode,
                    ::subxt::ext::codec::Encode,
                    ::subxt::ext::scale_decode::DecodeAsType,
                    ::subxt::ext::scale_encode::EncodeAsType,
                    Clone,
                    Debug,
                    Eq,
                    PartialEq
                )]
                #[codec(crate = ::subxt::ext::codec)]
                #[decode_as_type(crate_path = ":: subxt :: ext :: scale_decode")]
                #[encode_as_type(crate_path = ":: subxt :: ext :: scale_encode")]
                pub struct Public(pub runtime_types::sp_core::ecdsa::Public);
            }
            pub mod proposal {
                use super::runtime_types;
                #[derive(
                    ::subxt::ext::codec::Decode,
                    ::subxt::ext::codec::Encode,
                    ::subxt::ext::scale_decode::DecodeAsType,
                    ::subxt::ext::scale_encode::EncodeAsType,
                    Clone,
                    Debug,
                    Eq,
                    PartialEq
                )]
                #[codec(crate = ::subxt::ext::codec)]
                #[decode_as_type(crate_path = ":: subxt :: ext :: scale_decode")]
                #[encode_as_type(crate_path = ":: subxt :: ext :: scale_encode")]
                pub enum DKGPayloadKey {
                    #[codec(index = 0)]
                    EVMProposal(runtime_types::webb_proposals::nonce::Nonce),
                    #[codec(index = 1)]
                    RefreshProposal(runtime_types::webb_proposals::nonce::Nonce),
                    #[codec(index = 2)]
                    AnchorCreateProposal(runtime_types::webb_proposals::nonce::Nonce),
                    #[codec(index = 3)]
                    AnchorUpdateProposal(runtime_types::webb_proposals::nonce::Nonce),
                    #[codec(index = 4)]
                    TokenAddProposal(runtime_types::webb_proposals::nonce::Nonce),
                    #[codec(index = 5)]
                    TokenRemoveProposal(runtime_types::webb_proposals::nonce::Nonce),
                    #[codec(index = 6)]
                    WrappingFeeUpdateProposal(
                        runtime_types::webb_proposals::nonce::Nonce,
                    ),
                    #[codec(index = 7)]
                    ResourceIdUpdateProposal(
                        runtime_types::webb_proposals::nonce::Nonce,
                    ),
                    #[codec(index = 8)]
                    RescueTokensProposal(runtime_types::webb_proposals::nonce::Nonce),
                    #[codec(index = 9)]
                    MaxDepositLimitUpdateProposal(
                        runtime_types::webb_proposals::nonce::Nonce,
                    ),
                    #[codec(index = 10)]
                    MinWithdrawalLimitUpdateProposal(
                        runtime_types::webb_proposals::nonce::Nonce,
                    ),
                    #[codec(index = 11)]
                    SetVerifierProposal(runtime_types::webb_proposals::nonce::Nonce),
                    #[codec(index = 12)]
                    SetTreasuryHandlerProposal(
                        runtime_types::webb_proposals::nonce::Nonce,
                    ),
                    #[codec(index = 13)]
                    FeeRecipientUpdateProposal(
                        runtime_types::webb_proposals::nonce::Nonce,
                    ),
                }
                #[derive(
                    ::subxt::ext::codec::Decode,
                    ::subxt::ext::codec::Encode,
                    ::subxt::ext::scale_decode::DecodeAsType,
                    ::subxt::ext::scale_encode::EncodeAsType,
                    Clone,
                    Debug,
                    Eq,
                    PartialEq
                )]
                #[codec(crate = ::subxt::ext::codec)]
                #[decode_as_type(crate_path = ":: subxt :: ext :: scale_decode")]
                #[encode_as_type(crate_path = ":: subxt :: ext :: scale_encode")]
                pub struct RefreshProposal {
                    pub voter_merkle_root: [::core::primitive::u8; 32usize],
                    pub session_length: ::core::primitive::u64,
                    pub voter_count: ::core::primitive::u32,
                    pub nonce: runtime_types::webb_proposals::nonce::Nonce,
                    pub pub_key: ::std::vec::Vec<::core::primitive::u8>,
                }
                #[derive(
                    ::subxt::ext::codec::Decode,
                    ::subxt::ext::codec::Encode,
                    ::subxt::ext::scale_decode::DecodeAsType,
                    ::subxt::ext::scale_encode::EncodeAsType,
                    Clone,
                    Debug,
                    Eq,
                    PartialEq
                )]
                #[codec(crate = ::subxt::ext::codec)]
                #[decode_as_type(crate_path = ":: subxt :: ext :: scale_decode")]
                #[encode_as_type(crate_path = ":: subxt :: ext :: scale_encode")]
                pub struct SignedProposalBatch<_0, _1, _2, _3> {
                    pub batch_id: _0,
                    pub proposals: runtime_types::bounded_collections::bounded_vec::BoundedVec<
                        runtime_types::webb_proposals::proposal::Proposal<_1>,
                    >,
                    pub signature: runtime_types::bounded_collections::bounded_vec::BoundedVec<
                        ::core::primitive::u8,
                    >,
                    #[codec(skip)]
                    pub __subxt_unused_type_params: ::core::marker::PhantomData<
                        (_2, _3),
                    >,
                }
                #[derive(
                    ::subxt::ext::codec::Decode,
                    ::subxt::ext::codec::Encode,
                    ::subxt::ext::scale_decode::DecodeAsType,
                    ::subxt::ext::scale_encode::EncodeAsType,
                    Clone,
                    Debug,
                    Eq,
                    PartialEq
                )]
                #[codec(crate = ::subxt::ext::codec)]
                #[decode_as_type(crate_path = ":: subxt :: ext :: scale_decode")]
                #[encode_as_type(crate_path = ":: subxt :: ext :: scale_encode")]
                pub struct StoredUnsignedProposalBatch<_0, _1, _2, _3> {
                    pub batch_id: _0,
                    pub proposals: runtime_types::bounded_collections::bounded_vec::BoundedVec<
                        runtime_types::dkg_runtime_primitives::UnsignedProposal<_1>,
                    >,
                    pub timestamp: _0,
                    #[codec(skip)]
                    pub __subxt_unused_type_params: ::core::marker::PhantomData<
                        (_3, _2),
                    >,
                }
            }
            #[derive(
                ::subxt::ext::codec::Decode,
                ::subxt::ext::codec::Encode,
                ::subxt::ext::scale_decode::DecodeAsType,
                ::subxt::ext::scale_encode::EncodeAsType,
                Clone,
                Debug,
                Eq,
                PartialEq
            )]
            #[codec(crate = ::subxt::ext::codec)]
            #[decode_as_type(crate_path = ":: subxt :: ext :: scale_decode")]
            #[encode_as_type(crate_path = ":: subxt :: ext :: scale_encode")]
            pub struct AggregatedMisbehaviourReports<_0, _1, _2> {
                pub misbehaviour_type: runtime_types::dkg_runtime_primitives::MisbehaviourType,
                pub session_id: ::core::primitive::u64,
                pub offender: _0,
                pub reporters: runtime_types::bounded_collections::bounded_vec::BoundedVec<
                    _0,
                >,
                pub signatures: runtime_types::bounded_collections::bounded_vec::BoundedVec<
                    runtime_types::bounded_collections::bounded_vec::BoundedVec<
                        ::core::primitive::u8,
                    >,
                >,
                #[codec(skip)]
                pub __subxt_unused_type_params: ::core::marker::PhantomData<(_1, _2)>,
            }
            #[derive(
                ::subxt::ext::codec::Decode,
                ::subxt::ext::codec::Encode,
                ::subxt::ext::scale_decode::DecodeAsType,
                ::subxt::ext::scale_encode::EncodeAsType,
                Clone,
                Debug,
                Eq,
                PartialEq
            )]
            #[codec(crate = ::subxt::ext::codec)]
            #[decode_as_type(crate_path = ":: subxt :: ext :: scale_decode")]
            #[encode_as_type(crate_path = ":: subxt :: ext :: scale_encode")]
            pub struct AggregatedPublicKeys {
                pub keys_and_signatures: ::std::vec::Vec<
                    (
                        ::std::vec::Vec<::core::primitive::u8>,
                        ::std::vec::Vec<::core::primitive::u8>,
                    ),
                >,
            }
            #[derive(
                ::subxt::ext::codec::Decode,
                ::subxt::ext::codec::Encode,
                ::subxt::ext::scale_decode::DecodeAsType,
                ::subxt::ext::scale_encode::EncodeAsType,
                Clone,
                Debug,
                Eq,
                PartialEq
            )]
            #[codec(crate = ::subxt::ext::codec)]
            #[decode_as_type(crate_path = ":: subxt :: ext :: scale_decode")]
            #[encode_as_type(crate_path = ":: subxt :: ext :: scale_encode")]
            pub struct CustomU32Getter;
            #[derive(
                ::subxt::ext::codec::Decode,
                ::subxt::ext::codec::Encode,
                ::subxt::ext::scale_decode::DecodeAsType,
                ::subxt::ext::scale_encode::EncodeAsType,
                Clone,
                Debug,
                Eq,
                PartialEq
            )]
            #[codec(crate = ::subxt::ext::codec)]
            #[decode_as_type(crate_path = ":: subxt :: ext :: scale_decode")]
            #[encode_as_type(crate_path = ":: subxt :: ext :: scale_encode")]
            pub struct CustomU32Getter2;
            #[derive(
                ::subxt::ext::codec::Decode,
                ::subxt::ext::codec::Encode,
                ::subxt::ext::scale_decode::DecodeAsType,
                ::subxt::ext::scale_encode::EncodeAsType,
                Clone,
                Debug,
                Eq,
                PartialEq
            )]
            #[codec(crate = ::subxt::ext::codec)]
            #[decode_as_type(crate_path = ":: subxt :: ext :: scale_decode")]
            #[encode_as_type(crate_path = ":: subxt :: ext :: scale_encode")]
            pub struct CustomU32Getter3;
            #[derive(
                ::subxt::ext::codec::Decode,
                ::subxt::ext::codec::Encode,
                ::subxt::ext::scale_decode::DecodeAsType,
                ::subxt::ext::scale_encode::EncodeAsType,
                Clone,
                Debug,
                Eq,
                PartialEq
            )]
            #[codec(crate = ::subxt::ext::codec)]
            #[decode_as_type(crate_path = ":: subxt :: ext :: scale_decode")]
            #[encode_as_type(crate_path = ":: subxt :: ext :: scale_encode")]
            pub struct CustomU32Getter4;
            #[derive(
                ::subxt::ext::codec::Decode,
                ::subxt::ext::codec::Encode,
                ::subxt::ext::scale_decode::DecodeAsType,
                ::subxt::ext::scale_encode::EncodeAsType,
                Clone,
                Debug,
                Eq,
                PartialEq
            )]
            #[codec(crate = ::subxt::ext::codec)]
            #[decode_as_type(crate_path = ":: subxt :: ext :: scale_decode")]
            #[encode_as_type(crate_path = ":: subxt :: ext :: scale_encode")]
            pub enum MisbehaviourType {
                #[codec(index = 0)]
                Keygen,
                #[codec(index = 1)]
                Sign,
            }
            #[derive(
                ::subxt::ext::codec::Decode,
                ::subxt::ext::codec::Encode,
                ::subxt::ext::scale_decode::DecodeAsType,
                ::subxt::ext::scale_encode::EncodeAsType,
                Clone,
                Debug,
                Eq,
                PartialEq
            )]
            #[codec(crate = ::subxt::ext::codec)]
            #[decode_as_type(crate_path = ":: subxt :: ext :: scale_decode")]
            #[encode_as_type(crate_path = ":: subxt :: ext :: scale_encode")]
            pub struct UnsignedProposal<_0> {
                pub typed_chain_id: runtime_types::webb_proposals::header::TypedChainId,
                pub key: runtime_types::dkg_runtime_primitives::proposal::DKGPayloadKey,
                pub proposal: runtime_types::webb_proposals::proposal::Proposal<_0>,
            }
        }
        pub mod eth_types {
            use super::runtime_types;
            pub mod eth2 {
                use super::runtime_types;
                #[derive(
                    ::subxt::ext::codec::Decode,
                    ::subxt::ext::codec::Encode,
                    ::subxt::ext::scale_decode::DecodeAsType,
                    ::subxt::ext::scale_encode::EncodeAsType,
                    Clone,
                    Debug,
                    Eq,
                    PartialEq
                )]
                #[codec(crate = ::subxt::ext::codec)]
                #[decode_as_type(crate_path = ":: subxt :: ext :: scale_decode")]
                #[encode_as_type(crate_path = ":: subxt :: ext :: scale_encode")]
                pub struct BeaconBlockHeader {
                    pub slot: ::core::primitive::u64,
                    pub proposer_index: ::core::primitive::u64,
                    pub parent_root: runtime_types::eth_types::H256,
                    pub state_root: runtime_types::eth_types::H256,
                    pub body_root: runtime_types::eth_types::H256,
                }
                #[derive(
                    ::subxt::ext::codec::Decode,
                    ::subxt::ext::codec::Encode,
                    ::subxt::ext::scale_decode::DecodeAsType,
                    ::subxt::ext::scale_encode::EncodeAsType,
                    Clone,
                    Debug,
                    Eq,
                    PartialEq
                )]
                #[codec(crate = ::subxt::ext::codec)]
                #[decode_as_type(crate_path = ":: subxt :: ext :: scale_decode")]
                #[encode_as_type(crate_path = ":: subxt :: ext :: scale_encode")]
                pub struct ExtendedBeaconBlockHeader {
                    pub header: runtime_types::eth_types::eth2::BeaconBlockHeader,
                    pub beacon_block_root: runtime_types::eth_types::H256,
                    pub execution_block_hash: runtime_types::eth_types::H256,
                }
                #[derive(
                    ::subxt::ext::codec::Decode,
                    ::subxt::ext::codec::Encode,
                    ::subxt::ext::scale_decode::DecodeAsType,
                    ::subxt::ext::scale_encode::EncodeAsType,
                    Clone,
                    Debug,
                    Eq,
                    PartialEq
                )]
                #[codec(crate = ::subxt::ext::codec)]
                #[decode_as_type(crate_path = ":: subxt :: ext :: scale_decode")]
                #[encode_as_type(crate_path = ":: subxt :: ext :: scale_encode")]
                pub struct FinalizedHeaderUpdate {
                    pub header_update: runtime_types::eth_types::eth2::HeaderUpdate,
                    pub finality_branch: ::std::vec::Vec<runtime_types::eth_types::H256>,
                }
                #[derive(
                    ::subxt::ext::codec::Decode,
                    ::subxt::ext::codec::Encode,
                    ::subxt::ext::scale_decode::DecodeAsType,
                    ::subxt::ext::scale_encode::EncodeAsType,
                    Clone,
                    Debug,
                    Eq,
                    PartialEq
                )]
                #[codec(crate = ::subxt::ext::codec)]
                #[decode_as_type(crate_path = ":: subxt :: ext :: scale_decode")]
                #[encode_as_type(crate_path = ":: subxt :: ext :: scale_encode")]
                pub struct HeaderUpdate {
                    pub beacon_header: runtime_types::eth_types::eth2::BeaconBlockHeader,
                    pub execution_block_hash: runtime_types::eth_types::H256,
                    pub execution_hash_branch: ::std::vec::Vec<
                        runtime_types::eth_types::H256,
                    >,
                }
                #[derive(
                    ::subxt::ext::codec::Decode,
                    ::subxt::ext::codec::Encode,
                    ::subxt::ext::scale_decode::DecodeAsType,
                    ::subxt::ext::scale_encode::EncodeAsType,
                    Clone,
                    Debug,
                    Eq,
                    PartialEq
                )]
                #[codec(crate = ::subxt::ext::codec)]
                #[decode_as_type(crate_path = ":: subxt :: ext :: scale_decode")]
                #[encode_as_type(crate_path = ":: subxt :: ext :: scale_encode")]
                pub struct LightClientUpdate {
                    pub attested_beacon_header: runtime_types::eth_types::eth2::BeaconBlockHeader,
                    pub sync_aggregate: runtime_types::eth_types::eth2::SyncAggregate,
                    pub signature_slot: ::core::primitive::u64,
                    pub finality_update: runtime_types::eth_types::eth2::FinalizedHeaderUpdate,
                    pub sync_committee_update: ::core::option::Option<
                        runtime_types::eth_types::eth2::SyncCommitteeUpdate,
                    >,
                }
                #[derive(
                    ::subxt::ext::codec::Decode,
                    ::subxt::ext::codec::Encode,
                    ::subxt::ext::scale_decode::DecodeAsType,
                    ::subxt::ext::scale_encode::EncodeAsType,
                    Clone,
                    Debug,
                    Eq,
                    PartialEq
                )]
                #[codec(crate = ::subxt::ext::codec)]
                #[decode_as_type(crate_path = ":: subxt :: ext :: scale_decode")]
                #[encode_as_type(crate_path = ":: subxt :: ext :: scale_encode")]
                pub struct PublicKeyBytes(pub [::core::primitive::u8; 48usize]);
                #[derive(
                    ::subxt::ext::codec::Decode,
                    ::subxt::ext::codec::Encode,
                    ::subxt::ext::scale_decode::DecodeAsType,
                    ::subxt::ext::scale_encode::EncodeAsType,
                    Clone,
                    Debug,
                    Eq,
                    PartialEq
                )]
                #[codec(crate = ::subxt::ext::codec)]
                #[decode_as_type(crate_path = ":: subxt :: ext :: scale_decode")]
                #[encode_as_type(crate_path = ":: subxt :: ext :: scale_encode")]
                pub struct SignatureBytes(pub [::core::primitive::u8; 96usize]);
                #[derive(
                    ::subxt::ext::codec::Decode,
                    ::subxt::ext::codec::Encode,
                    ::subxt::ext::scale_decode::DecodeAsType,
                    ::subxt::ext::scale_encode::EncodeAsType,
                    Clone,
                    Debug,
                    Eq,
                    PartialEq
                )]
                #[codec(crate = ::subxt::ext::codec)]
                #[decode_as_type(crate_path = ":: subxt :: ext :: scale_decode")]
                #[encode_as_type(crate_path = ":: subxt :: ext :: scale_encode")]
                pub struct SyncAggregate {
                    pub sync_committee_bits: runtime_types::eth_types::eth2::SyncCommitteeBits,
                    pub sync_committee_signature: runtime_types::eth_types::eth2::SignatureBytes,
                }
                #[derive(
                    ::subxt::ext::codec::Decode,
                    ::subxt::ext::codec::Encode,
                    ::subxt::ext::scale_decode::DecodeAsType,
                    ::subxt::ext::scale_encode::EncodeAsType,
                    Clone,
                    Debug,
                    Eq,
                    PartialEq
                )]
                #[codec(crate = ::subxt::ext::codec)]
                #[decode_as_type(crate_path = ":: subxt :: ext :: scale_decode")]
                #[encode_as_type(crate_path = ":: subxt :: ext :: scale_encode")]
                pub struct SyncCommittee {
                    pub pubkeys: runtime_types::eth_types::eth2::SyncCommitteePublicKeys,
                    pub aggregate_pubkey: runtime_types::eth_types::eth2::PublicKeyBytes,
                }
                #[derive(
                    ::subxt::ext::codec::Decode,
                    ::subxt::ext::codec::Encode,
                    ::subxt::ext::scale_decode::DecodeAsType,
                    ::subxt::ext::scale_encode::EncodeAsType,
                    Clone,
                    Debug,
                    Eq,
                    PartialEq
                )]
                #[codec(crate = ::subxt::ext::codec)]
                #[decode_as_type(crate_path = ":: subxt :: ext :: scale_decode")]
                #[encode_as_type(crate_path = ":: subxt :: ext :: scale_encode")]
                pub struct SyncCommitteeBits(pub [::core::primitive::u8; 64usize]);
                #[derive(
                    ::subxt::ext::codec::Decode,
                    ::subxt::ext::codec::Encode,
                    ::subxt::ext::scale_decode::DecodeAsType,
                    ::subxt::ext::scale_encode::EncodeAsType,
                    Clone,
                    Debug,
                    Eq,
                    PartialEq
                )]
                #[codec(crate = ::subxt::ext::codec)]
                #[decode_as_type(crate_path = ":: subxt :: ext :: scale_decode")]
                #[encode_as_type(crate_path = ":: subxt :: ext :: scale_encode")]
                pub struct SyncCommitteePublicKeys(
                    pub ::std::vec::Vec<runtime_types::eth_types::eth2::PublicKeyBytes>,
                );
                #[derive(
                    ::subxt::ext::codec::Decode,
                    ::subxt::ext::codec::Encode,
                    ::subxt::ext::scale_decode::DecodeAsType,
                    ::subxt::ext::scale_encode::EncodeAsType,
                    Clone,
                    Debug,
                    Eq,
                    PartialEq
                )]
                #[codec(crate = ::subxt::ext::codec)]
                #[decode_as_type(crate_path = ":: subxt :: ext :: scale_decode")]
                #[encode_as_type(crate_path = ":: subxt :: ext :: scale_encode")]
                pub struct SyncCommitteeUpdate {
                    pub next_sync_committee: runtime_types::eth_types::eth2::SyncCommittee,
                    pub next_sync_committee_branch: ::std::vec::Vec<
                        runtime_types::eth_types::H256,
                    >,
                }
            }
            pub mod pallet {
                use super::runtime_types;
                #[derive(
                    ::subxt::ext::codec::Decode,
                    ::subxt::ext::codec::Encode,
                    ::subxt::ext::scale_decode::DecodeAsType,
                    ::subxt::ext::scale_encode::EncodeAsType,
                    Clone,
                    Debug,
                    Eq,
                    PartialEq
                )]
                #[codec(crate = ::subxt::ext::codec)]
                #[decode_as_type(crate_path = ":: subxt :: ext :: scale_decode")]
                #[encode_as_type(crate_path = ":: subxt :: ext :: scale_encode")]
                pub struct ExecutionHeaderInfo<_0> {
                    pub parent_hash: ::subxt::utils::H256,
                    pub block_number: ::core::primitive::u64,
                    pub submitter: _0,
                }
                #[derive(
                    ::subxt::ext::codec::Decode,
                    ::subxt::ext::codec::Encode,
                    ::subxt::ext::scale_decode::DecodeAsType,
                    ::subxt::ext::scale_encode::EncodeAsType,
                    Clone,
                    Debug,
                    Eq,
                    PartialEq
                )]
                #[codec(crate = ::subxt::ext::codec)]
                #[decode_as_type(crate_path = ":: subxt :: ext :: scale_decode")]
                #[encode_as_type(crate_path = ":: subxt :: ext :: scale_encode")]
                pub struct InitInput<_0> {
                    pub finalized_execution_header: runtime_types::eth_types::BlockHeader,
                    pub finalized_beacon_header: runtime_types::eth_types::eth2::ExtendedBeaconBlockHeader,
                    pub current_sync_committee: runtime_types::eth_types::eth2::SyncCommittee,
                    pub next_sync_committee: runtime_types::eth_types::eth2::SyncCommittee,
                    pub validate_updates: ::core::primitive::bool,
                    pub verify_bls_signatures: ::core::primitive::bool,
                    pub hashes_gc_threshold: ::core::primitive::u64,
                    pub max_submitted_blocks_by_account: ::core::primitive::u32,
                    pub trusted_signer: ::core::option::Option<_0>,
                }
            }
            #[derive(
                ::subxt::ext::codec::Decode,
                ::subxt::ext::codec::Encode,
                ::subxt::ext::scale_decode::DecodeAsType,
                ::subxt::ext::scale_encode::EncodeAsType,
                Clone,
                Debug,
                Eq,
                PartialEq
            )]
            #[codec(crate = ::subxt::ext::codec)]
            #[decode_as_type(crate_path = ":: subxt :: ext :: scale_decode")]
            #[encode_as_type(crate_path = ":: subxt :: ext :: scale_encode")]
            pub struct BlockHeader {
                pub parent_hash: runtime_types::eth_types::H256,
                pub uncles_hash: runtime_types::eth_types::H256,
                pub author: runtime_types::eth_types::H160,
                pub state_root: runtime_types::eth_types::H256,
                pub transactions_root: runtime_types::eth_types::H256,
                pub receipts_root: runtime_types::eth_types::H256,
                pub log_bloom: runtime_types::eth_types::Bloom,
                pub difficulty: runtime_types::eth_types::U256,
                pub number: ::core::primitive::u64,
                pub gas_limit: runtime_types::eth_types::U256,
                pub gas_used: runtime_types::eth_types::U256,
                pub timestamp: ::core::primitive::u64,
                pub extra_data: ::std::vec::Vec<::core::primitive::u8>,
                pub mix_hash: runtime_types::eth_types::H256,
                pub nonce: runtime_types::eth_types::H64,
                pub base_fee_per_gas: ::core::primitive::u64,
                pub hash: ::core::option::Option<runtime_types::eth_types::H256>,
                pub partial_hash: ::core::option::Option<runtime_types::eth_types::H256>,
            }
            #[derive(
                ::subxt::ext::codec::Decode,
                ::subxt::ext::codec::Encode,
                ::subxt::ext::scale_decode::DecodeAsType,
                ::subxt::ext::scale_encode::EncodeAsType,
                Clone,
                Debug,
                Eq,
                PartialEq
            )]
            #[codec(crate = ::subxt::ext::codec)]
            #[decode_as_type(crate_path = ":: subxt :: ext :: scale_decode")]
            #[encode_as_type(crate_path = ":: subxt :: ext :: scale_encode")]
            pub struct Bloom(pub runtime_types::ethbloom::Bloom);
            #[derive(
                ::subxt::ext::codec::Decode,
                ::subxt::ext::codec::Encode,
                ::subxt::ext::scale_decode::DecodeAsType,
                ::subxt::ext::scale_encode::EncodeAsType,
                Clone,
                Debug,
                Eq,
                PartialEq
            )]
            #[codec(crate = ::subxt::ext::codec)]
            #[decode_as_type(crate_path = ":: subxt :: ext :: scale_decode")]
            #[encode_as_type(crate_path = ":: subxt :: ext :: scale_encode")]
            pub struct H160(pub ::subxt::utils::H160);
            #[derive(
                ::subxt::ext::codec::Decode,
                ::subxt::ext::codec::Encode,
                ::subxt::ext::scale_decode::DecodeAsType,
                ::subxt::ext::scale_encode::EncodeAsType,
                Clone,
                Debug,
                Eq,
                PartialEq
            )]
            #[codec(crate = ::subxt::ext::codec)]
            #[decode_as_type(crate_path = ":: subxt :: ext :: scale_decode")]
            #[encode_as_type(crate_path = ":: subxt :: ext :: scale_encode")]
            pub struct H256(pub ::subxt::utils::H256);
            #[derive(
                ::subxt::ext::codec::Decode,
                ::subxt::ext::codec::Encode,
                ::subxt::ext::scale_decode::DecodeAsType,
                ::subxt::ext::scale_encode::EncodeAsType,
                Clone,
                Debug,
                Eq,
                PartialEq
            )]
            #[codec(crate = ::subxt::ext::codec)]
            #[decode_as_type(crate_path = ":: subxt :: ext :: scale_decode")]
            #[encode_as_type(crate_path = ":: subxt :: ext :: scale_encode")]
            pub struct H64(pub runtime_types::ethereum_types::hash::H64);
            #[derive(
                ::subxt::ext::codec::Decode,
                ::subxt::ext::codec::Encode,
                ::subxt::ext::scale_decode::DecodeAsType,
                ::subxt::ext::scale_encode::EncodeAsType,
                Clone,
                Debug,
                Eq,
                PartialEq
            )]
            #[codec(crate = ::subxt::ext::codec)]
            #[decode_as_type(crate_path = ":: subxt :: ext :: scale_decode")]
            #[encode_as_type(crate_path = ":: subxt :: ext :: scale_encode")]
            pub struct U256(pub runtime_types::primitive_types::U256);
        }
        pub mod ethbloom {
            use super::runtime_types;
            #[derive(
                ::subxt::ext::codec::Decode,
                ::subxt::ext::codec::Encode,
                ::subxt::ext::scale_decode::DecodeAsType,
                ::subxt::ext::scale_encode::EncodeAsType,
                Clone,
                Debug,
                Eq,
                PartialEq
            )]
            #[codec(crate = ::subxt::ext::codec)]
            #[decode_as_type(crate_path = ":: subxt :: ext :: scale_decode")]
            #[encode_as_type(crate_path = ":: subxt :: ext :: scale_encode")]
            pub struct Bloom(pub [::core::primitive::u8; 256usize]);
        }
        pub mod ethereum {
            use super::runtime_types;
            pub mod block {
                use super::runtime_types;
                #[derive(
                    ::subxt::ext::codec::Decode,
                    ::subxt::ext::codec::Encode,
                    ::subxt::ext::scale_decode::DecodeAsType,
                    ::subxt::ext::scale_encode::EncodeAsType,
                    Clone,
                    Debug,
                    Eq,
                    PartialEq
                )]
                #[codec(crate = ::subxt::ext::codec)]
                #[decode_as_type(crate_path = ":: subxt :: ext :: scale_decode")]
                #[encode_as_type(crate_path = ":: subxt :: ext :: scale_encode")]
                pub struct Block<_0> {
                    pub header: runtime_types::ethereum::header::Header,
                    pub transactions: ::std::vec::Vec<_0>,
                    pub ommers: ::std::vec::Vec<runtime_types::ethereum::header::Header>,
                }
            }
            pub mod header {
                use super::runtime_types;
                #[derive(
                    ::subxt::ext::codec::Decode,
                    ::subxt::ext::codec::Encode,
                    ::subxt::ext::scale_decode::DecodeAsType,
                    ::subxt::ext::scale_encode::EncodeAsType,
                    Clone,
                    Debug,
                    Eq,
                    PartialEq
                )]
                #[codec(crate = ::subxt::ext::codec)]
                #[decode_as_type(crate_path = ":: subxt :: ext :: scale_decode")]
                #[encode_as_type(crate_path = ":: subxt :: ext :: scale_encode")]
                pub struct Header {
                    pub parent_hash: ::subxt::utils::H256,
                    pub ommers_hash: ::subxt::utils::H256,
                    pub beneficiary: ::subxt::utils::H160,
                    pub state_root: ::subxt::utils::H256,
                    pub transactions_root: ::subxt::utils::H256,
                    pub receipts_root: ::subxt::utils::H256,
                    pub logs_bloom: runtime_types::ethbloom::Bloom,
                    pub difficulty: runtime_types::primitive_types::U256,
                    pub number: runtime_types::primitive_types::U256,
                    pub gas_limit: runtime_types::primitive_types::U256,
                    pub gas_used: runtime_types::primitive_types::U256,
                    pub timestamp: ::core::primitive::u64,
                    pub extra_data: ::std::vec::Vec<::core::primitive::u8>,
                    pub mix_hash: ::subxt::utils::H256,
                    pub nonce: runtime_types::ethereum_types::hash::H64,
                }
            }
            pub mod log {
                use super::runtime_types;
                #[derive(
                    ::subxt::ext::codec::Decode,
                    ::subxt::ext::codec::Encode,
                    ::subxt::ext::scale_decode::DecodeAsType,
                    ::subxt::ext::scale_encode::EncodeAsType,
                    Clone,
                    Debug,
                    Eq,
                    PartialEq
                )]
                #[codec(crate = ::subxt::ext::codec)]
                #[decode_as_type(crate_path = ":: subxt :: ext :: scale_decode")]
                #[encode_as_type(crate_path = ":: subxt :: ext :: scale_encode")]
                pub struct Log {
                    pub address: ::subxt::utils::H160,
                    pub topics: ::std::vec::Vec<::subxt::utils::H256>,
                    pub data: ::std::vec::Vec<::core::primitive::u8>,
                }
            }
            pub mod receipt {
                use super::runtime_types;
                #[derive(
                    ::subxt::ext::codec::Decode,
                    ::subxt::ext::codec::Encode,
                    ::subxt::ext::scale_decode::DecodeAsType,
                    ::subxt::ext::scale_encode::EncodeAsType,
                    Clone,
                    Debug,
                    Eq,
                    PartialEq
                )]
                #[codec(crate = ::subxt::ext::codec)]
                #[decode_as_type(crate_path = ":: subxt :: ext :: scale_decode")]
                #[encode_as_type(crate_path = ":: subxt :: ext :: scale_encode")]
                pub struct EIP658ReceiptData {
                    pub status_code: ::core::primitive::u8,
                    pub used_gas: runtime_types::primitive_types::U256,
                    pub logs_bloom: runtime_types::ethbloom::Bloom,
                    pub logs: ::std::vec::Vec<runtime_types::ethereum::log::Log>,
                }
                #[derive(
                    ::subxt::ext::codec::Decode,
                    ::subxt::ext::codec::Encode,
                    ::subxt::ext::scale_decode::DecodeAsType,
                    ::subxt::ext::scale_encode::EncodeAsType,
                    Clone,
                    Debug,
                    Eq,
                    PartialEq
                )]
                #[codec(crate = ::subxt::ext::codec)]
                #[decode_as_type(crate_path = ":: subxt :: ext :: scale_decode")]
                #[encode_as_type(crate_path = ":: subxt :: ext :: scale_encode")]
                pub enum ReceiptV3 {
                    #[codec(index = 0)]
                    Legacy(runtime_types::ethereum::receipt::EIP658ReceiptData),
                    #[codec(index = 1)]
                    EIP2930(runtime_types::ethereum::receipt::EIP658ReceiptData),
                    #[codec(index = 2)]
                    EIP1559(runtime_types::ethereum::receipt::EIP658ReceiptData),
                }
            }
            pub mod transaction {
                use super::runtime_types;
                #[derive(
                    ::subxt::ext::codec::Decode,
                    ::subxt::ext::codec::Encode,
                    ::subxt::ext::scale_decode::DecodeAsType,
                    ::subxt::ext::scale_encode::EncodeAsType,
                    Clone,
                    Debug,
                    Eq,
                    PartialEq
                )]
                #[codec(crate = ::subxt::ext::codec)]
                #[decode_as_type(crate_path = ":: subxt :: ext :: scale_decode")]
                #[encode_as_type(crate_path = ":: subxt :: ext :: scale_encode")]
                pub struct AccessListItem {
                    pub address: ::subxt::utils::H160,
                    pub storage_keys: ::std::vec::Vec<::subxt::utils::H256>,
                }
                #[derive(
                    ::subxt::ext::codec::Decode,
                    ::subxt::ext::codec::Encode,
                    ::subxt::ext::scale_decode::DecodeAsType,
                    ::subxt::ext::scale_encode::EncodeAsType,
                    Clone,
                    Debug,
                    Eq,
                    PartialEq
                )]
                #[codec(crate = ::subxt::ext::codec)]
                #[decode_as_type(crate_path = ":: subxt :: ext :: scale_decode")]
                #[encode_as_type(crate_path = ":: subxt :: ext :: scale_encode")]
                pub struct EIP1559Transaction {
                    pub chain_id: ::core::primitive::u64,
                    pub nonce: runtime_types::primitive_types::U256,
                    pub max_priority_fee_per_gas: runtime_types::primitive_types::U256,
                    pub max_fee_per_gas: runtime_types::primitive_types::U256,
                    pub gas_limit: runtime_types::primitive_types::U256,
                    pub action: runtime_types::ethereum::transaction::TransactionAction,
                    pub value: runtime_types::primitive_types::U256,
                    pub input: ::std::vec::Vec<::core::primitive::u8>,
                    pub access_list: ::std::vec::Vec<
                        runtime_types::ethereum::transaction::AccessListItem,
                    >,
                    pub odd_y_parity: ::core::primitive::bool,
                    pub r: ::subxt::utils::H256,
                    pub s: ::subxt::utils::H256,
                }
                #[derive(
                    ::subxt::ext::codec::Decode,
                    ::subxt::ext::codec::Encode,
                    ::subxt::ext::scale_decode::DecodeAsType,
                    ::subxt::ext::scale_encode::EncodeAsType,
                    Clone,
                    Debug,
                    Eq,
                    PartialEq
                )]
                #[codec(crate = ::subxt::ext::codec)]
                #[decode_as_type(crate_path = ":: subxt :: ext :: scale_decode")]
                #[encode_as_type(crate_path = ":: subxt :: ext :: scale_encode")]
                pub struct EIP2930Transaction {
                    pub chain_id: ::core::primitive::u64,
                    pub nonce: runtime_types::primitive_types::U256,
                    pub gas_price: runtime_types::primitive_types::U256,
                    pub gas_limit: runtime_types::primitive_types::U256,
                    pub action: runtime_types::ethereum::transaction::TransactionAction,
                    pub value: runtime_types::primitive_types::U256,
                    pub input: ::std::vec::Vec<::core::primitive::u8>,
                    pub access_list: ::std::vec::Vec<
                        runtime_types::ethereum::transaction::AccessListItem,
                    >,
                    pub odd_y_parity: ::core::primitive::bool,
                    pub r: ::subxt::utils::H256,
                    pub s: ::subxt::utils::H256,
                }
                #[derive(
                    ::subxt::ext::codec::Decode,
                    ::subxt::ext::codec::Encode,
                    ::subxt::ext::scale_decode::DecodeAsType,
                    ::subxt::ext::scale_encode::EncodeAsType,
                    Clone,
                    Debug,
                    Eq,
                    PartialEq
                )]
                #[codec(crate = ::subxt::ext::codec)]
                #[decode_as_type(crate_path = ":: subxt :: ext :: scale_decode")]
                #[encode_as_type(crate_path = ":: subxt :: ext :: scale_encode")]
                pub struct LegacyTransaction {
                    pub nonce: runtime_types::primitive_types::U256,
                    pub gas_price: runtime_types::primitive_types::U256,
                    pub gas_limit: runtime_types::primitive_types::U256,
                    pub action: runtime_types::ethereum::transaction::TransactionAction,
                    pub value: runtime_types::primitive_types::U256,
                    pub input: ::std::vec::Vec<::core::primitive::u8>,
                    pub signature: runtime_types::ethereum::transaction::TransactionSignature,
                }
                #[derive(
                    ::subxt::ext::codec::Decode,
                    ::subxt::ext::codec::Encode,
                    ::subxt::ext::scale_decode::DecodeAsType,
                    ::subxt::ext::scale_encode::EncodeAsType,
                    Clone,
                    Debug,
                    Eq,
                    PartialEq
                )]
                #[codec(crate = ::subxt::ext::codec)]
                #[decode_as_type(crate_path = ":: subxt :: ext :: scale_decode")]
                #[encode_as_type(crate_path = ":: subxt :: ext :: scale_encode")]
                pub enum TransactionAction {
                    #[codec(index = 0)]
                    Call(::subxt::utils::H160),
                    #[codec(index = 1)]
                    Create,
                }
                #[derive(
                    ::subxt::ext::codec::CompactAs,
                    ::subxt::ext::codec::Decode,
                    ::subxt::ext::codec::Encode,
                    ::subxt::ext::scale_decode::DecodeAsType,
                    ::subxt::ext::scale_encode::EncodeAsType,
                    Clone,
                    Debug,
                    Eq,
                    PartialEq
                )]
                #[codec(crate = ::subxt::ext::codec)]
                #[decode_as_type(crate_path = ":: subxt :: ext :: scale_decode")]
                #[encode_as_type(crate_path = ":: subxt :: ext :: scale_encode")]
                pub struct TransactionRecoveryId(pub ::core::primitive::u64);
                #[derive(
                    ::subxt::ext::codec::Decode,
                    ::subxt::ext::codec::Encode,
                    ::subxt::ext::scale_decode::DecodeAsType,
                    ::subxt::ext::scale_encode::EncodeAsType,
                    Clone,
                    Debug,
                    Eq,
                    PartialEq
                )]
                #[codec(crate = ::subxt::ext::codec)]
                #[decode_as_type(crate_path = ":: subxt :: ext :: scale_decode")]
                #[encode_as_type(crate_path = ":: subxt :: ext :: scale_encode")]
                pub struct TransactionSignature {
                    pub v: runtime_types::ethereum::transaction::TransactionRecoveryId,
                    pub r: ::subxt::utils::H256,
                    pub s: ::subxt::utils::H256,
                }
                #[derive(
                    ::subxt::ext::codec::Decode,
                    ::subxt::ext::codec::Encode,
                    ::subxt::ext::scale_decode::DecodeAsType,
                    ::subxt::ext::scale_encode::EncodeAsType,
                    Clone,
                    Debug,
                    Eq,
                    PartialEq
                )]
                #[codec(crate = ::subxt::ext::codec)]
                #[decode_as_type(crate_path = ":: subxt :: ext :: scale_decode")]
                #[encode_as_type(crate_path = ":: subxt :: ext :: scale_encode")]
                pub enum TransactionV2 {
                    #[codec(index = 0)]
                    Legacy(runtime_types::ethereum::transaction::LegacyTransaction),
                    #[codec(index = 1)]
                    EIP2930(runtime_types::ethereum::transaction::EIP2930Transaction),
                    #[codec(index = 2)]
                    EIP1559(runtime_types::ethereum::transaction::EIP1559Transaction),
                }
            }
        }
        pub mod ethereum_types {
            use super::runtime_types;
            pub mod hash {
                use super::runtime_types;
                #[derive(
                    ::subxt::ext::codec::Decode,
                    ::subxt::ext::codec::Encode,
                    ::subxt::ext::scale_decode::DecodeAsType,
                    ::subxt::ext::scale_encode::EncodeAsType,
                    Clone,
                    Debug,
                    Eq,
                    PartialEq
                )]
                #[codec(crate = ::subxt::ext::codec)]
                #[decode_as_type(crate_path = ":: subxt :: ext :: scale_decode")]
                #[encode_as_type(crate_path = ":: subxt :: ext :: scale_encode")]
                pub struct H64(pub [::core::primitive::u8; 8usize]);
            }
        }
        pub mod evm_core {
            use super::runtime_types;
            pub mod error {
                use super::runtime_types;
                #[derive(
                    ::subxt::ext::codec::Decode,
                    ::subxt::ext::codec::Encode,
                    ::subxt::ext::scale_decode::DecodeAsType,
                    ::subxt::ext::scale_encode::EncodeAsType,
                    Clone,
                    Debug,
                    Eq,
                    PartialEq
                )]
                #[codec(crate = ::subxt::ext::codec)]
                #[decode_as_type(crate_path = ":: subxt :: ext :: scale_decode")]
                #[encode_as_type(crate_path = ":: subxt :: ext :: scale_encode")]
                pub enum ExitError {
                    #[codec(index = 0)]
                    StackUnderflow,
                    #[codec(index = 1)]
                    StackOverflow,
                    #[codec(index = 2)]
                    InvalidJump,
                    #[codec(index = 3)]
                    InvalidRange,
                    #[codec(index = 4)]
                    DesignatedInvalid,
                    #[codec(index = 5)]
                    CallTooDeep,
                    #[codec(index = 6)]
                    CreateCollision,
                    #[codec(index = 7)]
                    CreateContractLimit,
                    #[codec(index = 15)]
                    InvalidCode(runtime_types::evm_core::opcode::Opcode),
                    #[codec(index = 8)]
                    OutOfOffset,
                    #[codec(index = 9)]
                    OutOfGas,
                    #[codec(index = 10)]
                    OutOfFund,
                    #[codec(index = 11)]
                    PCUnderflow,
                    #[codec(index = 12)]
                    CreateEmpty,
                    #[codec(index = 13)]
                    Other(::std::string::String),
                    #[codec(index = 14)]
                    MaxNonce,
                }
                #[derive(
                    ::subxt::ext::codec::Decode,
                    ::subxt::ext::codec::Encode,
                    ::subxt::ext::scale_decode::DecodeAsType,
                    ::subxt::ext::scale_encode::EncodeAsType,
                    Clone,
                    Debug,
                    Eq,
                    PartialEq
                )]
                #[codec(crate = ::subxt::ext::codec)]
                #[decode_as_type(crate_path = ":: subxt :: ext :: scale_decode")]
                #[encode_as_type(crate_path = ":: subxt :: ext :: scale_encode")]
                pub enum ExitFatal {
                    #[codec(index = 0)]
                    NotSupported,
                    #[codec(index = 1)]
                    UnhandledInterrupt,
                    #[codec(index = 2)]
                    CallErrorAsFatal(runtime_types::evm_core::error::ExitError),
                    #[codec(index = 3)]
                    Other(::std::string::String),
                }
                #[derive(
                    ::subxt::ext::codec::Decode,
                    ::subxt::ext::codec::Encode,
                    ::subxt::ext::scale_decode::DecodeAsType,
                    ::subxt::ext::scale_encode::EncodeAsType,
                    Clone,
                    Debug,
                    Eq,
                    PartialEq
                )]
                #[codec(crate = ::subxt::ext::codec)]
                #[decode_as_type(crate_path = ":: subxt :: ext :: scale_decode")]
                #[encode_as_type(crate_path = ":: subxt :: ext :: scale_encode")]
                pub enum ExitReason {
                    #[codec(index = 0)]
                    Succeed(runtime_types::evm_core::error::ExitSucceed),
                    #[codec(index = 1)]
                    Error(runtime_types::evm_core::error::ExitError),
                    #[codec(index = 2)]
                    Revert(runtime_types::evm_core::error::ExitRevert),
                    #[codec(index = 3)]
                    Fatal(runtime_types::evm_core::error::ExitFatal),
                }
                #[derive(
                    ::subxt::ext::codec::Decode,
                    ::subxt::ext::codec::Encode,
                    ::subxt::ext::scale_decode::DecodeAsType,
                    ::subxt::ext::scale_encode::EncodeAsType,
                    Clone,
                    Debug,
                    Eq,
                    PartialEq
                )]
                #[codec(crate = ::subxt::ext::codec)]
                #[decode_as_type(crate_path = ":: subxt :: ext :: scale_decode")]
                #[encode_as_type(crate_path = ":: subxt :: ext :: scale_encode")]
                pub enum ExitRevert {
                    #[codec(index = 0)]
                    Reverted,
                }
                #[derive(
                    ::subxt::ext::codec::Decode,
                    ::subxt::ext::codec::Encode,
                    ::subxt::ext::scale_decode::DecodeAsType,
                    ::subxt::ext::scale_encode::EncodeAsType,
                    Clone,
                    Debug,
                    Eq,
                    PartialEq
                )]
                #[codec(crate = ::subxt::ext::codec)]
                #[decode_as_type(crate_path = ":: subxt :: ext :: scale_decode")]
                #[encode_as_type(crate_path = ":: subxt :: ext :: scale_encode")]
                pub enum ExitSucceed {
                    #[codec(index = 0)]
                    Stopped,
                    #[codec(index = 1)]
                    Returned,
                    #[codec(index = 2)]
                    Suicided,
                }
            }
            pub mod opcode {
                use super::runtime_types;
                #[derive(
                    ::subxt::ext::codec::CompactAs,
                    ::subxt::ext::codec::Decode,
                    ::subxt::ext::codec::Encode,
                    ::subxt::ext::scale_decode::DecodeAsType,
                    ::subxt::ext::scale_encode::EncodeAsType,
                    Clone,
                    Debug,
                    Eq,
                    PartialEq
                )]
                #[codec(crate = ::subxt::ext::codec)]
                #[decode_as_type(crate_path = ":: subxt :: ext :: scale_decode")]
                #[encode_as_type(crate_path = ":: subxt :: ext :: scale_encode")]
                pub struct Opcode(pub ::core::primitive::u8);
            }
        }
        pub mod finality_grandpa {
            use super::runtime_types;
            #[derive(
                ::subxt::ext::codec::Decode,
                ::subxt::ext::codec::Encode,
                ::subxt::ext::scale_decode::DecodeAsType,
                ::subxt::ext::scale_encode::EncodeAsType,
                Clone,
                Debug,
                Eq,
                PartialEq
            )]
            #[codec(crate = ::subxt::ext::codec)]
            #[decode_as_type(crate_path = ":: subxt :: ext :: scale_decode")]
            #[encode_as_type(crate_path = ":: subxt :: ext :: scale_encode")]
            pub struct Equivocation<_0, _1, _2> {
                pub round_number: ::core::primitive::u64,
                pub identity: _0,
                pub first: (_1, _2),
                pub second: (_1, _2),
            }
            #[derive(
                ::subxt::ext::codec::Decode,
                ::subxt::ext::codec::Encode,
                ::subxt::ext::scale_decode::DecodeAsType,
                ::subxt::ext::scale_encode::EncodeAsType,
                Clone,
                Debug,
                Eq,
                PartialEq
            )]
            #[codec(crate = ::subxt::ext::codec)]
            #[decode_as_type(crate_path = ":: subxt :: ext :: scale_decode")]
            #[encode_as_type(crate_path = ":: subxt :: ext :: scale_encode")]
            pub struct Precommit<_0, _1> {
                pub target_hash: _0,
                pub target_number: _1,
            }
            #[derive(
                ::subxt::ext::codec::Decode,
                ::subxt::ext::codec::Encode,
                ::subxt::ext::scale_decode::DecodeAsType,
                ::subxt::ext::scale_encode::EncodeAsType,
                Clone,
                Debug,
                Eq,
                PartialEq
            )]
            #[codec(crate = ::subxt::ext::codec)]
            #[decode_as_type(crate_path = ":: subxt :: ext :: scale_decode")]
            #[encode_as_type(crate_path = ":: subxt :: ext :: scale_encode")]
            pub struct Prevote<_0, _1> {
                pub target_hash: _0,
                pub target_number: _1,
            }
        }
        pub mod fp_rpc {
            use super::runtime_types;
            #[derive(
                ::subxt::ext::codec::Decode,
                ::subxt::ext::codec::Encode,
                ::subxt::ext::scale_decode::DecodeAsType,
                ::subxt::ext::scale_encode::EncodeAsType,
                Clone,
                Debug,
                Eq,
                PartialEq
            )]
            #[codec(crate = ::subxt::ext::codec)]
            #[decode_as_type(crate_path = ":: subxt :: ext :: scale_decode")]
            #[encode_as_type(crate_path = ":: subxt :: ext :: scale_encode")]
            pub struct TransactionStatus {
                pub transaction_hash: ::subxt::utils::H256,
                pub transaction_index: ::core::primitive::u32,
                pub from: ::subxt::utils::H160,
                pub to: ::core::option::Option<::subxt::utils::H160>,
                pub contract_address: ::core::option::Option<::subxt::utils::H160>,
                pub logs: ::std::vec::Vec<runtime_types::ethereum::log::Log>,
                pub logs_bloom: runtime_types::ethbloom::Bloom,
            }
        }
        pub mod fp_self_contained {
            use super::runtime_types;
            pub mod unchecked_extrinsic {
                use super::runtime_types;
                #[derive(
                    ::subxt::ext::codec::Decode,
                    ::subxt::ext::codec::Encode,
                    ::subxt::ext::scale_decode::DecodeAsType,
                    ::subxt::ext::scale_encode::EncodeAsType,
                    Clone,
                    Debug,
                    Eq,
                    PartialEq
                )]
                #[codec(crate = ::subxt::ext::codec)]
                #[decode_as_type(crate_path = ":: subxt :: ext :: scale_decode")]
                #[encode_as_type(crate_path = ":: subxt :: ext :: scale_encode")]
                pub struct UncheckedExtrinsic<_0, _1, _2, _3>(
                    pub runtime_types::sp_runtime::generic::unchecked_extrinsic::UncheckedExtrinsic<
                        _0,
                        _1,
                        _2,
                        _3,
                    >,
                );
            }
        }
        pub mod frame_support {
            use super::runtime_types;
            pub mod dispatch {
                use super::runtime_types;
                #[derive(
                    ::subxt::ext::codec::Decode,
                    ::subxt::ext::codec::Encode,
                    ::subxt::ext::scale_decode::DecodeAsType,
                    ::subxt::ext::scale_encode::EncodeAsType,
                    Clone,
                    Debug,
                    Eq,
                    PartialEq
                )]
                #[codec(crate = ::subxt::ext::codec)]
                #[decode_as_type(crate_path = ":: subxt :: ext :: scale_decode")]
                #[encode_as_type(crate_path = ":: subxt :: ext :: scale_encode")]
                pub enum DispatchClass {
                    #[codec(index = 0)]
                    Normal,
                    #[codec(index = 1)]
                    Operational,
                    #[codec(index = 2)]
                    Mandatory,
                }
                #[derive(
                    ::subxt::ext::codec::Decode,
                    ::subxt::ext::codec::Encode,
                    ::subxt::ext::scale_decode::DecodeAsType,
                    ::subxt::ext::scale_encode::EncodeAsType,
                    Clone,
                    Debug,
                    Eq,
                    PartialEq
                )]
                #[codec(crate = ::subxt::ext::codec)]
                #[decode_as_type(crate_path = ":: subxt :: ext :: scale_decode")]
                #[encode_as_type(crate_path = ":: subxt :: ext :: scale_encode")]
                pub struct DispatchInfo {
                    pub weight: runtime_types::sp_weights::weight_v2::Weight,
                    pub class: runtime_types::frame_support::dispatch::DispatchClass,
                    pub pays_fee: runtime_types::frame_support::dispatch::Pays,
                }
                #[derive(
                    ::subxt::ext::codec::Decode,
                    ::subxt::ext::codec::Encode,
                    ::subxt::ext::scale_decode::DecodeAsType,
                    ::subxt::ext::scale_encode::EncodeAsType,
                    Clone,
                    Debug,
                    Eq,
                    PartialEq
                )]
                #[codec(crate = ::subxt::ext::codec)]
                #[decode_as_type(crate_path = ":: subxt :: ext :: scale_decode")]
                #[encode_as_type(crate_path = ":: subxt :: ext :: scale_encode")]
                pub enum Pays {
                    #[codec(index = 0)]
                    Yes,
                    #[codec(index = 1)]
                    No,
                }
                #[derive(
                    ::subxt::ext::codec::Decode,
                    ::subxt::ext::codec::Encode,
                    ::subxt::ext::scale_decode::DecodeAsType,
                    ::subxt::ext::scale_encode::EncodeAsType,
                    Clone,
                    Debug,
                    Eq,
                    PartialEq
                )]
                #[codec(crate = ::subxt::ext::codec)]
                #[decode_as_type(crate_path = ":: subxt :: ext :: scale_decode")]
                #[encode_as_type(crate_path = ":: subxt :: ext :: scale_encode")]
                pub struct PerDispatchClass<_0> {
                    pub normal: _0,
                    pub operational: _0,
                    pub mandatory: _0,
                }
                #[derive(
                    ::subxt::ext::codec::Decode,
                    ::subxt::ext::codec::Encode,
                    ::subxt::ext::scale_decode::DecodeAsType,
                    ::subxt::ext::scale_encode::EncodeAsType,
                    Clone,
                    Debug,
                    Eq,
                    PartialEq
                )]
                #[codec(crate = ::subxt::ext::codec)]
                #[decode_as_type(crate_path = ":: subxt :: ext :: scale_decode")]
                #[encode_as_type(crate_path = ":: subxt :: ext :: scale_encode")]
                pub enum RawOrigin<_0> {
                    #[codec(index = 0)]
                    Root,
                    #[codec(index = 1)]
                    Signed(_0),
                    #[codec(index = 2)]
                    None,
                }
            }
            pub mod traits {
                use super::runtime_types;
                pub mod misc {
                    use super::runtime_types;
                    #[derive(
                        ::subxt::ext::codec::Decode,
                        ::subxt::ext::codec::Encode,
                        ::subxt::ext::scale_decode::DecodeAsType,
                        ::subxt::ext::scale_encode::EncodeAsType,
                        Clone,
                        Debug,
                        Eq,
                        PartialEq
                    )]
                    #[codec(crate = ::subxt::ext::codec)]
                    #[decode_as_type(crate_path = ":: subxt :: ext :: scale_decode")]
                    #[encode_as_type(crate_path = ":: subxt :: ext :: scale_encode")]
                    pub struct WrapperOpaque<_0>(
                        #[codec(compact)]
                        pub ::core::primitive::u32,
                        pub _0,
                    );
                }
                pub mod preimages {
                    use super::runtime_types;
                    #[derive(
                        ::subxt::ext::codec::Decode,
                        ::subxt::ext::codec::Encode,
                        ::subxt::ext::scale_decode::DecodeAsType,
                        ::subxt::ext::scale_encode::EncodeAsType,
                        Clone,
                        Debug,
                        Eq,
                        PartialEq
                    )]
                    #[codec(crate = ::subxt::ext::codec)]
                    #[decode_as_type(crate_path = ":: subxt :: ext :: scale_decode")]
                    #[encode_as_type(crate_path = ":: subxt :: ext :: scale_encode")]
                    pub enum Bounded<_0> {
                        #[codec(index = 0)]
                        Legacy { hash: ::subxt::utils::H256 },
                        #[codec(index = 1)]
                        Inline(
                            runtime_types::bounded_collections::bounded_vec::BoundedVec<
                                ::core::primitive::u8,
                            >,
                        ),
                        #[codec(index = 2)]
                        Lookup {
                            hash: ::subxt::utils::H256,
                            len: ::core::primitive::u32,
                        },
                        __Ignore(::core::marker::PhantomData<_0>),
                    }
                }
                pub mod tokens {
                    use super::runtime_types;
                    pub mod misc {
                        use super::runtime_types;
                        #[derive(
                            ::subxt::ext::codec::Decode,
                            ::subxt::ext::codec::Encode,
                            ::subxt::ext::scale_decode::DecodeAsType,
                            ::subxt::ext::scale_encode::EncodeAsType,
                            Clone,
                            Debug,
                            Eq,
                            PartialEq
                        )]
                        #[codec(crate = ::subxt::ext::codec)]
                        #[decode_as_type(crate_path = ":: subxt :: ext :: scale_decode")]
                        #[encode_as_type(crate_path = ":: subxt :: ext :: scale_encode")]
                        pub enum BalanceStatus {
                            #[codec(index = 0)]
                            Free,
                            #[codec(index = 1)]
                            Reserved,
                        }
                    }
                }
            }
            #[derive(
                ::subxt::ext::codec::Decode,
                ::subxt::ext::codec::Encode,
                ::subxt::ext::scale_decode::DecodeAsType,
                ::subxt::ext::scale_encode::EncodeAsType,
                Clone,
                Debug,
                Eq,
                PartialEq
            )]
            #[codec(crate = ::subxt::ext::codec)]
            #[decode_as_type(crate_path = ":: subxt :: ext :: scale_decode")]
            #[encode_as_type(crate_path = ":: subxt :: ext :: scale_encode")]
            pub struct PalletId(pub [::core::primitive::u8; 8usize]);
        }
        pub mod frame_system {
            use super::runtime_types;
            pub mod extensions {
                use super::runtime_types;
                pub mod check_genesis {
                    use super::runtime_types;
                    #[derive(
                        ::subxt::ext::codec::Decode,
                        ::subxt::ext::codec::Encode,
                        ::subxt::ext::scale_decode::DecodeAsType,
                        ::subxt::ext::scale_encode::EncodeAsType,
                        Clone,
                        Debug,
                        Eq,
                        PartialEq
                    )]
                    #[codec(crate = ::subxt::ext::codec)]
                    #[decode_as_type(crate_path = ":: subxt :: ext :: scale_decode")]
                    #[encode_as_type(crate_path = ":: subxt :: ext :: scale_encode")]
                    pub struct CheckGenesis;
                }
                pub mod check_mortality {
                    use super::runtime_types;
                    #[derive(
                        ::subxt::ext::codec::Decode,
                        ::subxt::ext::codec::Encode,
                        ::subxt::ext::scale_decode::DecodeAsType,
                        ::subxt::ext::scale_encode::EncodeAsType,
                        Clone,
                        Debug,
                        Eq,
                        PartialEq
                    )]
                    #[codec(crate = ::subxt::ext::codec)]
                    #[decode_as_type(crate_path = ":: subxt :: ext :: scale_decode")]
                    #[encode_as_type(crate_path = ":: subxt :: ext :: scale_encode")]
                    pub struct CheckMortality(
                        pub runtime_types::sp_runtime::generic::era::Era,
                    );
                }
                pub mod check_non_zero_sender {
                    use super::runtime_types;
                    #[derive(
                        ::subxt::ext::codec::Decode,
                        ::subxt::ext::codec::Encode,
                        ::subxt::ext::scale_decode::DecodeAsType,
                        ::subxt::ext::scale_encode::EncodeAsType,
                        Clone,
                        Debug,
                        Eq,
                        PartialEq
                    )]
                    #[codec(crate = ::subxt::ext::codec)]
                    #[decode_as_type(crate_path = ":: subxt :: ext :: scale_decode")]
                    #[encode_as_type(crate_path = ":: subxt :: ext :: scale_encode")]
                    pub struct CheckNonZeroSender;
                }
                pub mod check_nonce {
                    use super::runtime_types;
                    #[derive(
                        ::subxt::ext::codec::Decode,
                        ::subxt::ext::codec::Encode,
                        ::subxt::ext::scale_decode::DecodeAsType,
                        ::subxt::ext::scale_encode::EncodeAsType,
                        Clone,
                        Debug,
                        Eq,
                        PartialEq
                    )]
                    #[codec(crate = ::subxt::ext::codec)]
                    #[decode_as_type(crate_path = ":: subxt :: ext :: scale_decode")]
                    #[encode_as_type(crate_path = ":: subxt :: ext :: scale_encode")]
                    pub struct CheckNonce(#[codec(compact)] pub ::core::primitive::u32);
                }
                pub mod check_spec_version {
                    use super::runtime_types;
                    #[derive(
                        ::subxt::ext::codec::Decode,
                        ::subxt::ext::codec::Encode,
                        ::subxt::ext::scale_decode::DecodeAsType,
                        ::subxt::ext::scale_encode::EncodeAsType,
                        Clone,
                        Debug,
                        Eq,
                        PartialEq
                    )]
                    #[codec(crate = ::subxt::ext::codec)]
                    #[decode_as_type(crate_path = ":: subxt :: ext :: scale_decode")]
                    #[encode_as_type(crate_path = ":: subxt :: ext :: scale_encode")]
                    pub struct CheckSpecVersion;
                }
                pub mod check_tx_version {
                    use super::runtime_types;
                    #[derive(
                        ::subxt::ext::codec::Decode,
                        ::subxt::ext::codec::Encode,
                        ::subxt::ext::scale_decode::DecodeAsType,
                        ::subxt::ext::scale_encode::EncodeAsType,
                        Clone,
                        Debug,
                        Eq,
                        PartialEq
                    )]
                    #[codec(crate = ::subxt::ext::codec)]
                    #[decode_as_type(crate_path = ":: subxt :: ext :: scale_decode")]
                    #[encode_as_type(crate_path = ":: subxt :: ext :: scale_encode")]
                    pub struct CheckTxVersion;
                }
                pub mod check_weight {
                    use super::runtime_types;
                    #[derive(
                        ::subxt::ext::codec::Decode,
                        ::subxt::ext::codec::Encode,
                        ::subxt::ext::scale_decode::DecodeAsType,
                        ::subxt::ext::scale_encode::EncodeAsType,
                        Clone,
                        Debug,
                        Eq,
                        PartialEq
                    )]
                    #[codec(crate = ::subxt::ext::codec)]
                    #[decode_as_type(crate_path = ":: subxt :: ext :: scale_decode")]
                    #[encode_as_type(crate_path = ":: subxt :: ext :: scale_encode")]
                    pub struct CheckWeight;
                }
            }
            pub mod limits {
                use super::runtime_types;
                #[derive(
                    ::subxt::ext::codec::Decode,
                    ::subxt::ext::codec::Encode,
                    ::subxt::ext::scale_decode::DecodeAsType,
                    ::subxt::ext::scale_encode::EncodeAsType,
                    Clone,
                    Debug,
                    Eq,
                    PartialEq
                )]
                #[codec(crate = ::subxt::ext::codec)]
                #[decode_as_type(crate_path = ":: subxt :: ext :: scale_decode")]
                #[encode_as_type(crate_path = ":: subxt :: ext :: scale_encode")]
                pub struct BlockLength {
                    pub max: runtime_types::frame_support::dispatch::PerDispatchClass<
                        ::core::primitive::u32,
                    >,
                }
                #[derive(
                    ::subxt::ext::codec::Decode,
                    ::subxt::ext::codec::Encode,
                    ::subxt::ext::scale_decode::DecodeAsType,
                    ::subxt::ext::scale_encode::EncodeAsType,
                    Clone,
                    Debug,
                    Eq,
                    PartialEq
                )]
                #[codec(crate = ::subxt::ext::codec)]
                #[decode_as_type(crate_path = ":: subxt :: ext :: scale_decode")]
                #[encode_as_type(crate_path = ":: subxt :: ext :: scale_encode")]
                pub struct BlockWeights {
                    pub base_block: runtime_types::sp_weights::weight_v2::Weight,
                    pub max_block: runtime_types::sp_weights::weight_v2::Weight,
                    pub per_class: runtime_types::frame_support::dispatch::PerDispatchClass<
                        runtime_types::frame_system::limits::WeightsPerClass,
                    >,
                }
                #[derive(
                    ::subxt::ext::codec::Decode,
                    ::subxt::ext::codec::Encode,
                    ::subxt::ext::scale_decode::DecodeAsType,
                    ::subxt::ext::scale_encode::EncodeAsType,
                    Clone,
                    Debug,
                    Eq,
                    PartialEq
                )]
                #[codec(crate = ::subxt::ext::codec)]
                #[decode_as_type(crate_path = ":: subxt :: ext :: scale_decode")]
                #[encode_as_type(crate_path = ":: subxt :: ext :: scale_encode")]
                pub struct WeightsPerClass {
                    pub base_extrinsic: runtime_types::sp_weights::weight_v2::Weight,
                    pub max_extrinsic: ::core::option::Option<
                        runtime_types::sp_weights::weight_v2::Weight,
                    >,
                    pub max_total: ::core::option::Option<
                        runtime_types::sp_weights::weight_v2::Weight,
                    >,
                    pub reserved: ::core::option::Option<
                        runtime_types::sp_weights::weight_v2::Weight,
                    >,
                }
            }
            pub mod pallet {
                use super::runtime_types;
                #[derive(
                    ::subxt::ext::codec::Decode,
                    ::subxt::ext::codec::Encode,
                    ::subxt::ext::scale_decode::DecodeAsType,
                    ::subxt::ext::scale_encode::EncodeAsType,
                    Clone,
                    Debug,
                    Eq,
                    PartialEq
                )]
                #[codec(crate = ::subxt::ext::codec)]
                #[decode_as_type(crate_path = ":: subxt :: ext :: scale_decode")]
                #[encode_as_type(crate_path = ":: subxt :: ext :: scale_encode")]
                ///Contains one variant per dispatchable that can be called by an extrinsic.
                pub enum Call {
                    #[codec(index = 0)]
                    ///Make some on-chain remark.
                    ///
                    ///- `O(1)`
                    remark { remark: ::std::vec::Vec<::core::primitive::u8> },
                    #[codec(index = 1)]
                    ///Set the number of pages in the WebAssembly environment's heap.
                    set_heap_pages { pages: ::core::primitive::u64 },
                    #[codec(index = 2)]
                    ///Set the new runtime code.
                    set_code { code: ::std::vec::Vec<::core::primitive::u8> },
                    #[codec(index = 3)]
                    ///Set the new runtime code without doing any checks of the given `code`.
                    set_code_without_checks {
                        code: ::std::vec::Vec<::core::primitive::u8>,
                    },
                    #[codec(index = 4)]
                    ///Set some items of storage.
                    set_storage {
                        items: ::std::vec::Vec<
                            (
                                ::std::vec::Vec<::core::primitive::u8>,
                                ::std::vec::Vec<::core::primitive::u8>,
                            ),
                        >,
                    },
                    #[codec(index = 5)]
                    ///Kill some items from storage.
                    kill_storage {
                        keys: ::std::vec::Vec<::std::vec::Vec<::core::primitive::u8>>,
                    },
                    #[codec(index = 6)]
                    ///Kill all storage items with a key that starts with the given prefix.
                    ///
                    ///**NOTE:** We rely on the Root origin to provide us the number of subkeys under
                    ///the prefix we are removing to accurately calculate the weight of this function.
                    kill_prefix {
                        prefix: ::std::vec::Vec<::core::primitive::u8>,
                        subkeys: ::core::primitive::u32,
                    },
                    #[codec(index = 7)]
                    ///Make some on-chain remark and emit event.
                    remark_with_event { remark: ::std::vec::Vec<::core::primitive::u8> },
                }
                #[derive(
                    ::subxt::ext::codec::Decode,
                    ::subxt::ext::codec::Encode,
                    ::subxt::ext::scale_decode::DecodeAsType,
                    ::subxt::ext::scale_encode::EncodeAsType,
                    Clone,
                    Debug,
                    Eq,
                    PartialEq
                )]
                #[codec(crate = ::subxt::ext::codec)]
                #[decode_as_type(crate_path = ":: subxt :: ext :: scale_decode")]
                #[encode_as_type(crate_path = ":: subxt :: ext :: scale_encode")]
                ///Error for the System pallet
                pub enum Error {
                    #[codec(index = 0)]
                    ///The name of specification does not match between the current runtime
                    ///and the new runtime.
                    InvalidSpecName,
                    #[codec(index = 1)]
                    ///The specification version is not allowed to decrease between the current runtime
                    ///and the new runtime.
                    SpecVersionNeedsToIncrease,
                    #[codec(index = 2)]
                    ///Failed to extract the runtime version from the new runtime.
                    ///
                    ///Either calling `Core_version` or decoding `RuntimeVersion` failed.
                    FailedToExtractRuntimeVersion,
                    #[codec(index = 3)]
                    ///Suicide called when the account has non-default composite data.
                    NonDefaultComposite,
                    #[codec(index = 4)]
                    ///There is a non-zero reference count preventing the account from being purged.
                    NonZeroRefCount,
                    #[codec(index = 5)]
                    ///The origin filter prevent the call to be dispatched.
                    CallFiltered,
                }
                #[derive(
                    ::subxt::ext::codec::Decode,
                    ::subxt::ext::codec::Encode,
                    ::subxt::ext::scale_decode::DecodeAsType,
                    ::subxt::ext::scale_encode::EncodeAsType,
                    Clone,
                    Debug,
                    Eq,
                    PartialEq
                )]
                #[codec(crate = ::subxt::ext::codec)]
                #[decode_as_type(crate_path = ":: subxt :: ext :: scale_decode")]
                #[encode_as_type(crate_path = ":: subxt :: ext :: scale_encode")]
                ///Event for the System pallet.
                pub enum Event {
                    #[codec(index = 0)]
                    ///An extrinsic completed successfully.
                    ExtrinsicSuccess {
                        dispatch_info: runtime_types::frame_support::dispatch::DispatchInfo,
                    },
                    #[codec(index = 1)]
                    ///An extrinsic failed.
                    ExtrinsicFailed {
                        dispatch_error: runtime_types::sp_runtime::DispatchError,
                        dispatch_info: runtime_types::frame_support::dispatch::DispatchInfo,
                    },
                    #[codec(index = 2)]
                    ///`:code` was updated.
                    CodeUpdated,
                    #[codec(index = 3)]
                    ///A new account was created.
                    NewAccount { account: ::subxt::utils::AccountId32 },
                    #[codec(index = 4)]
                    ///An account was reaped.
                    KilledAccount { account: ::subxt::utils::AccountId32 },
                    #[codec(index = 5)]
                    ///On on-chain remark happened.
                    Remarked {
                        sender: ::subxt::utils::AccountId32,
                        hash: ::subxt::utils::H256,
                    },
                }
            }
            #[derive(
                ::subxt::ext::codec::Decode,
                ::subxt::ext::codec::Encode,
                ::subxt::ext::scale_decode::DecodeAsType,
                ::subxt::ext::scale_encode::EncodeAsType,
                Clone,
                Debug,
                Eq,
                PartialEq
            )]
            #[codec(crate = ::subxt::ext::codec)]
            #[decode_as_type(crate_path = ":: subxt :: ext :: scale_decode")]
            #[encode_as_type(crate_path = ":: subxt :: ext :: scale_encode")]
            pub struct AccountInfo<_0, _1> {
                pub nonce: _0,
                pub consumers: _0,
                pub providers: _0,
                pub sufficients: _0,
                pub data: _1,
            }
            #[derive(
                ::subxt::ext::codec::Decode,
                ::subxt::ext::codec::Encode,
                ::subxt::ext::scale_decode::DecodeAsType,
                ::subxt::ext::scale_encode::EncodeAsType,
                Clone,
                Debug,
                Eq,
                PartialEq
            )]
            #[codec(crate = ::subxt::ext::codec)]
            #[decode_as_type(crate_path = ":: subxt :: ext :: scale_decode")]
            #[encode_as_type(crate_path = ":: subxt :: ext :: scale_encode")]
            pub struct EventRecord<_0, _1> {
                pub phase: runtime_types::frame_system::Phase,
                pub event: _0,
                pub topics: ::std::vec::Vec<_1>,
            }
            #[derive(
                ::subxt::ext::codec::Decode,
                ::subxt::ext::codec::Encode,
                ::subxt::ext::scale_decode::DecodeAsType,
                ::subxt::ext::scale_encode::EncodeAsType,
                Clone,
                Debug,
                Eq,
                PartialEq
            )]
            #[codec(crate = ::subxt::ext::codec)]
            #[decode_as_type(crate_path = ":: subxt :: ext :: scale_decode")]
            #[encode_as_type(crate_path = ":: subxt :: ext :: scale_encode")]
            pub struct LastRuntimeUpgradeInfo {
                #[codec(compact)]
                pub spec_version: ::core::primitive::u32,
                pub spec_name: ::std::string::String,
            }
            #[derive(
                ::subxt::ext::codec::Decode,
                ::subxt::ext::codec::Encode,
                ::subxt::ext::scale_decode::DecodeAsType,
                ::subxt::ext::scale_encode::EncodeAsType,
                Clone,
                Debug,
                Eq,
                PartialEq
            )]
            #[codec(crate = ::subxt::ext::codec)]
            #[decode_as_type(crate_path = ":: subxt :: ext :: scale_decode")]
            #[encode_as_type(crate_path = ":: subxt :: ext :: scale_encode")]
            pub enum Phase {
                #[codec(index = 0)]
                ApplyExtrinsic(::core::primitive::u32),
                #[codec(index = 1)]
                Finalization,
                #[codec(index = 2)]
                Initialization,
            }
        }
        pub mod pallet_bags_list {
            use super::runtime_types;
            pub mod list {
                use super::runtime_types;
                #[derive(
                    ::subxt::ext::codec::Decode,
                    ::subxt::ext::codec::Encode,
                    ::subxt::ext::scale_decode::DecodeAsType,
                    ::subxt::ext::scale_encode::EncodeAsType,
                    Clone,
                    Debug,
                    Eq,
                    PartialEq
                )]
                #[codec(crate = ::subxt::ext::codec)]
                #[decode_as_type(crate_path = ":: subxt :: ext :: scale_decode")]
                #[encode_as_type(crate_path = ":: subxt :: ext :: scale_encode")]
                pub struct Bag {
                    pub head: ::core::option::Option<::subxt::utils::AccountId32>,
                    pub tail: ::core::option::Option<::subxt::utils::AccountId32>,
                }
                #[derive(
                    ::subxt::ext::codec::Decode,
                    ::subxt::ext::codec::Encode,
                    ::subxt::ext::scale_decode::DecodeAsType,
                    ::subxt::ext::scale_encode::EncodeAsType,
                    Clone,
                    Debug,
                    Eq,
                    PartialEq
                )]
                #[codec(crate = ::subxt::ext::codec)]
                #[decode_as_type(crate_path = ":: subxt :: ext :: scale_decode")]
                #[encode_as_type(crate_path = ":: subxt :: ext :: scale_encode")]
                pub enum ListError {
                    #[codec(index = 0)]
                    Duplicate,
                    #[codec(index = 1)]
                    NotHeavier,
                    #[codec(index = 2)]
                    NotInSameBag,
                    #[codec(index = 3)]
                    NodeNotFound,
                }
                #[derive(
                    ::subxt::ext::codec::Decode,
                    ::subxt::ext::codec::Encode,
                    ::subxt::ext::scale_decode::DecodeAsType,
                    ::subxt::ext::scale_encode::EncodeAsType,
                    Clone,
                    Debug,
                    Eq,
                    PartialEq
                )]
                #[codec(crate = ::subxt::ext::codec)]
                #[decode_as_type(crate_path = ":: subxt :: ext :: scale_decode")]
                #[encode_as_type(crate_path = ":: subxt :: ext :: scale_encode")]
                pub struct Node {
                    pub id: ::subxt::utils::AccountId32,
                    pub prev: ::core::option::Option<::subxt::utils::AccountId32>,
                    pub next: ::core::option::Option<::subxt::utils::AccountId32>,
                    pub bag_upper: ::core::primitive::u64,
                    pub score: ::core::primitive::u64,
                }
            }
            pub mod pallet {
                use super::runtime_types;
                #[derive(
                    ::subxt::ext::codec::Decode,
                    ::subxt::ext::codec::Encode,
                    ::subxt::ext::scale_decode::DecodeAsType,
                    ::subxt::ext::scale_encode::EncodeAsType,
                    Clone,
                    Debug,
                    Eq,
                    PartialEq
                )]
                #[codec(crate = ::subxt::ext::codec)]
                #[decode_as_type(crate_path = ":: subxt :: ext :: scale_decode")]
                #[encode_as_type(crate_path = ":: subxt :: ext :: scale_encode")]
                ///Contains one variant per dispatchable that can be called by an extrinsic.
                pub enum Call {
                    #[codec(index = 0)]
                    ///Declare that some `dislocated` account has, through rewards or penalties, sufficiently
                    ///changed its score that it should properly fall into a different bag than its current
                    ///one.
                    ///
                    ///Anyone can call this function about any potentially dislocated account.
                    ///
                    ///Will always update the stored score of `dislocated` to the correct score, based on
                    ///`ScoreProvider`.
                    ///
                    ///If `dislocated` does not exists, it returns an error.
                    rebag {
                        dislocated: ::subxt::utils::MultiAddress<
                            ::subxt::utils::AccountId32,
                            ::core::primitive::u32,
                        >,
                    },
                    #[codec(index = 1)]
                    ///Move the caller's Id directly in front of `lighter`.
                    ///
                    ///The dispatch origin for this call must be _Signed_ and can only be called by the Id of
                    ///the account going in front of `lighter`.
                    ///
                    ///Only works if
                    ///- both nodes are within the same bag,
                    ///- and `origin` has a greater `Score` than `lighter`.
                    put_in_front_of {
                        lighter: ::subxt::utils::MultiAddress<
                            ::subxt::utils::AccountId32,
                            ::core::primitive::u32,
                        >,
                    },
                }
                #[derive(
                    ::subxt::ext::codec::Decode,
                    ::subxt::ext::codec::Encode,
                    ::subxt::ext::scale_decode::DecodeAsType,
                    ::subxt::ext::scale_encode::EncodeAsType,
                    Clone,
                    Debug,
                    Eq,
                    PartialEq
                )]
                #[codec(crate = ::subxt::ext::codec)]
                #[decode_as_type(crate_path = ":: subxt :: ext :: scale_decode")]
                #[encode_as_type(crate_path = ":: subxt :: ext :: scale_encode")]
                /**
			Custom [dispatch errors](https://docs.substrate.io/main-docs/build/events-errors/)
			of this pallet.
			*/
                pub enum Error {
                    #[codec(index = 0)]
                    ///A error in the list interface implementation.
                    List(runtime_types::pallet_bags_list::list::ListError),
                }
                #[derive(
                    ::subxt::ext::codec::Decode,
                    ::subxt::ext::codec::Encode,
                    ::subxt::ext::scale_decode::DecodeAsType,
                    ::subxt::ext::scale_encode::EncodeAsType,
                    Clone,
                    Debug,
                    Eq,
                    PartialEq
                )]
                #[codec(crate = ::subxt::ext::codec)]
                #[decode_as_type(crate_path = ":: subxt :: ext :: scale_decode")]
                #[encode_as_type(crate_path = ":: subxt :: ext :: scale_encode")]
                /**
			The [event](https://docs.substrate.io/main-docs/build/events-errors/) emitted
			by this pallet.
			*/
                pub enum Event {
                    #[codec(index = 0)]
                    ///Moved an account from one bag to another.
                    Rebagged {
                        who: ::subxt::utils::AccountId32,
                        from: ::core::primitive::u64,
                        to: ::core::primitive::u64,
                    },
                    #[codec(index = 1)]
                    ///Updated the score of some account to the given amount.
                    ScoreUpdated {
                        who: ::subxt::utils::AccountId32,
                        new_score: ::core::primitive::u64,
                    },
                }
            }
        }
        pub mod pallet_balances {
            use super::runtime_types;
            pub mod pallet {
                use super::runtime_types;
                #[derive(
                    ::subxt::ext::codec::Decode,
                    ::subxt::ext::codec::Encode,
                    ::subxt::ext::scale_decode::DecodeAsType,
                    ::subxt::ext::scale_encode::EncodeAsType,
                    Clone,
                    Debug,
                    Eq,
                    PartialEq
                )]
                #[codec(crate = ::subxt::ext::codec)]
                #[decode_as_type(crate_path = ":: subxt :: ext :: scale_decode")]
                #[encode_as_type(crate_path = ":: subxt :: ext :: scale_encode")]
                ///Contains one variant per dispatchable that can be called by an extrinsic.
                pub enum Call {
                    #[codec(index = 0)]
                    ///Transfer some liquid free balance to another account.
                    ///
                    ///`transfer_allow_death` will set the `FreeBalance` of the sender and receiver.
                    ///If the sender's account is below the existential deposit as a result
                    ///of the transfer, the account will be reaped.
                    ///
                    ///The dispatch origin for this call must be `Signed` by the transactor.
                    transfer_allow_death {
                        dest: ::subxt::utils::MultiAddress<
                            ::subxt::utils::AccountId32,
                            ::core::primitive::u32,
                        >,
                        #[codec(compact)]
                        value: ::core::primitive::u128,
                    },
                    #[codec(index = 1)]
                    ///Set the regular balance of a given account; it also takes a reserved balance but this
                    ///must be the same as the account's current reserved balance.
                    ///
                    ///The dispatch origin for this call is `root`.
                    ///
                    ///WARNING: This call is DEPRECATED! Use `force_set_balance` instead.
                    set_balance_deprecated {
                        who: ::subxt::utils::MultiAddress<
                            ::subxt::utils::AccountId32,
                            ::core::primitive::u32,
                        >,
                        #[codec(compact)]
                        new_free: ::core::primitive::u128,
                        #[codec(compact)]
                        old_reserved: ::core::primitive::u128,
                    },
                    #[codec(index = 2)]
                    ///Exactly as `transfer_allow_death`, except the origin must be root and the source account
                    ///may be specified.
                    force_transfer {
                        source: ::subxt::utils::MultiAddress<
                            ::subxt::utils::AccountId32,
                            ::core::primitive::u32,
                        >,
                        dest: ::subxt::utils::MultiAddress<
                            ::subxt::utils::AccountId32,
                            ::core::primitive::u32,
                        >,
                        #[codec(compact)]
                        value: ::core::primitive::u128,
                    },
                    #[codec(index = 3)]
                    ///Same as the [`transfer_allow_death`] call, but with a check that the transfer will not
                    ///kill the origin account.
                    ///
                    ///99% of the time you want [`transfer_allow_death`] instead.
                    ///
                    ///[`transfer_allow_death`]: struct.Pallet.html#method.transfer
                    transfer_keep_alive {
                        dest: ::subxt::utils::MultiAddress<
                            ::subxt::utils::AccountId32,
                            ::core::primitive::u32,
                        >,
                        #[codec(compact)]
                        value: ::core::primitive::u128,
                    },
                    #[codec(index = 4)]
                    ///Transfer the entire transferable balance from the caller account.
                    ///
                    ///NOTE: This function only attempts to transfer _transferable_ balances. This means that
                    ///any locked, reserved, or existential deposits (when `keep_alive` is `true`), will not be
                    ///transferred by this function. To ensure that this function results in a killed account,
                    ///you might need to prepare the account by removing any reference counters, storage
                    ///deposits, etc...
                    ///
                    ///The dispatch origin of this call must be Signed.
                    ///
                    ///- `dest`: The recipient of the transfer.
                    ///- `keep_alive`: A boolean to determine if the `transfer_all` operation should send all
                    ///  of the funds the account has, causing the sender account to be killed (false), or
                    ///  transfer everything except at least the existential deposit, which will guarantee to
                    ///  keep the sender account alive (true).
                    transfer_all {
                        dest: ::subxt::utils::MultiAddress<
                            ::subxt::utils::AccountId32,
                            ::core::primitive::u32,
                        >,
                        keep_alive: ::core::primitive::bool,
                    },
                    #[codec(index = 5)]
                    ///Unreserve some balance from a user by force.
                    ///
                    ///Can only be called by ROOT.
                    force_unreserve {
                        who: ::subxt::utils::MultiAddress<
                            ::subxt::utils::AccountId32,
                            ::core::primitive::u32,
                        >,
                        amount: ::core::primitive::u128,
                    },
                    #[codec(index = 6)]
                    ///Upgrade a specified account.
                    ///
                    ///- `origin`: Must be `Signed`.
                    ///- `who`: The account to be upgraded.
                    ///
                    ///This will waive the transaction fee if at least all but 10% of the accounts needed to
                    ///be upgraded. (We let some not have to be upgraded just in order to allow for the
                    ///possibililty of churn).
                    upgrade_accounts {
                        who: ::std::vec::Vec<::subxt::utils::AccountId32>,
                    },
                    #[codec(index = 7)]
                    ///Alias for `transfer_allow_death`, provided only for name-wise compatibility.
                    ///
                    ///WARNING: DEPRECATED! Will be released in approximately 3 months.
                    transfer {
                        dest: ::subxt::utils::MultiAddress<
                            ::subxt::utils::AccountId32,
                            ::core::primitive::u32,
                        >,
                        #[codec(compact)]
                        value: ::core::primitive::u128,
                    },
                    #[codec(index = 8)]
                    ///Set the regular balance of a given account.
                    ///
                    ///The dispatch origin for this call is `root`.
                    force_set_balance {
                        who: ::subxt::utils::MultiAddress<
                            ::subxt::utils::AccountId32,
                            ::core::primitive::u32,
                        >,
                        #[codec(compact)]
                        new_free: ::core::primitive::u128,
                    },
                }
                #[derive(
                    ::subxt::ext::codec::Decode,
                    ::subxt::ext::codec::Encode,
                    ::subxt::ext::scale_decode::DecodeAsType,
                    ::subxt::ext::scale_encode::EncodeAsType,
                    Clone,
                    Debug,
                    Eq,
                    PartialEq
                )]
                #[codec(crate = ::subxt::ext::codec)]
                #[decode_as_type(crate_path = ":: subxt :: ext :: scale_decode")]
                #[encode_as_type(crate_path = ":: subxt :: ext :: scale_encode")]
                /**
			Custom [dispatch errors](https://docs.substrate.io/main-docs/build/events-errors/)
			of this pallet.
			*/
                pub enum Error {
                    #[codec(index = 0)]
                    ///Vesting balance too high to send value.
                    VestingBalance,
                    #[codec(index = 1)]
                    ///Account liquidity restrictions prevent withdrawal.
                    LiquidityRestrictions,
                    #[codec(index = 2)]
                    ///Balance too low to send value.
                    InsufficientBalance,
                    #[codec(index = 3)]
                    ///Value too low to create account due to existential deposit.
                    ExistentialDeposit,
                    #[codec(index = 4)]
                    ///Transfer/payment would kill account.
                    Expendability,
                    #[codec(index = 5)]
                    ///A vesting schedule already exists for this account.
                    ExistingVestingSchedule,
                    #[codec(index = 6)]
                    ///Beneficiary account must pre-exist.
                    DeadAccount,
                    #[codec(index = 7)]
                    ///Number of named reserves exceed `MaxReserves`.
                    TooManyReserves,
                    #[codec(index = 8)]
                    ///Number of holds exceed `MaxHolds`.
                    TooManyHolds,
                    #[codec(index = 9)]
                    ///Number of freezes exceed `MaxFreezes`.
                    TooManyFreezes,
                }
                #[derive(
                    ::subxt::ext::codec::Decode,
                    ::subxt::ext::codec::Encode,
                    ::subxt::ext::scale_decode::DecodeAsType,
                    ::subxt::ext::scale_encode::EncodeAsType,
                    Clone,
                    Debug,
                    Eq,
                    PartialEq
                )]
                #[codec(crate = ::subxt::ext::codec)]
                #[decode_as_type(crate_path = ":: subxt :: ext :: scale_decode")]
                #[encode_as_type(crate_path = ":: subxt :: ext :: scale_encode")]
                /**
			The [event](https://docs.substrate.io/main-docs/build/events-errors/) emitted
			by this pallet.
			*/
                pub enum Event {
                    #[codec(index = 0)]
                    ///An account was created with some free balance.
                    Endowed {
                        account: ::subxt::utils::AccountId32,
                        free_balance: ::core::primitive::u128,
                    },
                    #[codec(index = 1)]
                    ///An account was removed whose balance was non-zero but below ExistentialDeposit,
                    ///resulting in an outright loss.
                    DustLost {
                        account: ::subxt::utils::AccountId32,
                        amount: ::core::primitive::u128,
                    },
                    #[codec(index = 2)]
                    ///Transfer succeeded.
                    Transfer {
                        from: ::subxt::utils::AccountId32,
                        to: ::subxt::utils::AccountId32,
                        amount: ::core::primitive::u128,
                    },
                    #[codec(index = 3)]
                    ///A balance was set by root.
                    BalanceSet {
                        who: ::subxt::utils::AccountId32,
                        free: ::core::primitive::u128,
                    },
                    #[codec(index = 4)]
                    ///Some balance was reserved (moved from free to reserved).
                    Reserved {
                        who: ::subxt::utils::AccountId32,
                        amount: ::core::primitive::u128,
                    },
                    #[codec(index = 5)]
                    ///Some balance was unreserved (moved from reserved to free).
                    Unreserved {
                        who: ::subxt::utils::AccountId32,
                        amount: ::core::primitive::u128,
                    },
                    #[codec(index = 6)]
                    ///Some balance was moved from the reserve of the first account to the second account.
                    ///Final argument indicates the destination balance type.
                    ReserveRepatriated {
                        from: ::subxt::utils::AccountId32,
                        to: ::subxt::utils::AccountId32,
                        amount: ::core::primitive::u128,
                        destination_status: runtime_types::frame_support::traits::tokens::misc::BalanceStatus,
                    },
                    #[codec(index = 7)]
                    ///Some amount was deposited (e.g. for transaction fees).
                    Deposit {
                        who: ::subxt::utils::AccountId32,
                        amount: ::core::primitive::u128,
                    },
                    #[codec(index = 8)]
                    ///Some amount was withdrawn from the account (e.g. for transaction fees).
                    Withdraw {
                        who: ::subxt::utils::AccountId32,
                        amount: ::core::primitive::u128,
                    },
                    #[codec(index = 9)]
                    ///Some amount was removed from the account (e.g. for misbehavior).
                    Slashed {
                        who: ::subxt::utils::AccountId32,
                        amount: ::core::primitive::u128,
                    },
                    #[codec(index = 10)]
                    ///Some amount was minted into an account.
                    Minted {
                        who: ::subxt::utils::AccountId32,
                        amount: ::core::primitive::u128,
                    },
                    #[codec(index = 11)]
                    ///Some amount was burned from an account.
                    Burned {
                        who: ::subxt::utils::AccountId32,
                        amount: ::core::primitive::u128,
                    },
                    #[codec(index = 12)]
                    ///Some amount was suspended from an account (it can be restored later).
                    Suspended {
                        who: ::subxt::utils::AccountId32,
                        amount: ::core::primitive::u128,
                    },
                    #[codec(index = 13)]
                    ///Some amount was restored into an account.
                    Restored {
                        who: ::subxt::utils::AccountId32,
                        amount: ::core::primitive::u128,
                    },
                    #[codec(index = 14)]
                    ///An account was upgraded.
                    Upgraded { who: ::subxt::utils::AccountId32 },
                    #[codec(index = 15)]
                    ///Total issuance was increased by `amount`, creating a credit to be balanced.
                    Issued { amount: ::core::primitive::u128 },
                    #[codec(index = 16)]
                    ///Total issuance was decreased by `amount`, creating a debt to be balanced.
                    Rescinded { amount: ::core::primitive::u128 },
                    #[codec(index = 17)]
                    ///Some balance was locked.
                    Locked {
                        who: ::subxt::utils::AccountId32,
                        amount: ::core::primitive::u128,
                    },
                    #[codec(index = 18)]
                    ///Some balance was unlocked.
                    Unlocked {
                        who: ::subxt::utils::AccountId32,
                        amount: ::core::primitive::u128,
                    },
                    #[codec(index = 19)]
                    ///Some balance was frozen.
                    Frozen {
                        who: ::subxt::utils::AccountId32,
                        amount: ::core::primitive::u128,
                    },
                    #[codec(index = 20)]
                    ///Some balance was thawed.
                    Thawed {
                        who: ::subxt::utils::AccountId32,
                        amount: ::core::primitive::u128,
                    },
                }
            }
            pub mod types {
                use super::runtime_types;
                #[derive(
                    ::subxt::ext::codec::Decode,
                    ::subxt::ext::codec::Encode,
                    ::subxt::ext::scale_decode::DecodeAsType,
                    ::subxt::ext::scale_encode::EncodeAsType,
                    Clone,
                    Debug,
                    Eq,
                    PartialEq
                )]
                #[codec(crate = ::subxt::ext::codec)]
                #[decode_as_type(crate_path = ":: subxt :: ext :: scale_decode")]
                #[encode_as_type(crate_path = ":: subxt :: ext :: scale_encode")]
                pub struct AccountData<_0> {
                    pub free: _0,
                    pub reserved: _0,
                    pub frozen: _0,
                    pub flags: runtime_types::pallet_balances::types::ExtraFlags,
                }
                #[derive(
                    ::subxt::ext::codec::Decode,
                    ::subxt::ext::codec::Encode,
                    ::subxt::ext::scale_decode::DecodeAsType,
                    ::subxt::ext::scale_encode::EncodeAsType,
                    Clone,
                    Debug,
                    Eq,
                    PartialEq
                )]
                #[codec(crate = ::subxt::ext::codec)]
                #[decode_as_type(crate_path = ":: subxt :: ext :: scale_decode")]
                #[encode_as_type(crate_path = ":: subxt :: ext :: scale_encode")]
                pub struct BalanceLock<_0> {
                    pub id: [::core::primitive::u8; 8usize],
                    pub amount: _0,
                    pub reasons: runtime_types::pallet_balances::types::Reasons,
                }
                #[derive(
                    ::subxt::ext::codec::CompactAs,
                    ::subxt::ext::codec::Decode,
                    ::subxt::ext::codec::Encode,
                    ::subxt::ext::scale_decode::DecodeAsType,
                    ::subxt::ext::scale_encode::EncodeAsType,
                    Clone,
                    Debug,
                    Eq,
                    PartialEq
                )]
                #[codec(crate = ::subxt::ext::codec)]
                #[decode_as_type(crate_path = ":: subxt :: ext :: scale_decode")]
                #[encode_as_type(crate_path = ":: subxt :: ext :: scale_encode")]
                pub struct ExtraFlags(pub ::core::primitive::u128);
                #[derive(
                    ::subxt::ext::codec::Decode,
                    ::subxt::ext::codec::Encode,
                    ::subxt::ext::scale_decode::DecodeAsType,
                    ::subxt::ext::scale_encode::EncodeAsType,
                    Clone,
                    Debug,
                    Eq,
                    PartialEq
                )]
                #[codec(crate = ::subxt::ext::codec)]
                #[decode_as_type(crate_path = ":: subxt :: ext :: scale_decode")]
                #[encode_as_type(crate_path = ":: subxt :: ext :: scale_encode")]
                pub struct IdAmount<_0, _1> {
                    pub id: _0,
                    pub amount: _1,
                }
                #[derive(
                    ::subxt::ext::codec::Decode,
                    ::subxt::ext::codec::Encode,
                    ::subxt::ext::scale_decode::DecodeAsType,
                    ::subxt::ext::scale_encode::EncodeAsType,
                    Clone,
                    Debug,
                    Eq,
                    PartialEq
                )]
                #[codec(crate = ::subxt::ext::codec)]
                #[decode_as_type(crate_path = ":: subxt :: ext :: scale_decode")]
                #[encode_as_type(crate_path = ":: subxt :: ext :: scale_encode")]
                pub enum Reasons {
                    #[codec(index = 0)]
                    Fee,
                    #[codec(index = 1)]
                    Misc,
                    #[codec(index = 2)]
                    All,
                }
                #[derive(
                    ::subxt::ext::codec::Decode,
                    ::subxt::ext::codec::Encode,
                    ::subxt::ext::scale_decode::DecodeAsType,
                    ::subxt::ext::scale_encode::EncodeAsType,
                    Clone,
                    Debug,
                    Eq,
                    PartialEq
                )]
                #[codec(crate = ::subxt::ext::codec)]
                #[decode_as_type(crate_path = ":: subxt :: ext :: scale_decode")]
                #[encode_as_type(crate_path = ":: subxt :: ext :: scale_encode")]
                pub struct ReserveData<_0, _1> {
                    pub id: _0,
                    pub amount: _1,
                }
            }
        }
        pub mod pallet_base_fee {
            use super::runtime_types;
            pub mod pallet {
                use super::runtime_types;
                #[derive(
                    ::subxt::ext::codec::Decode,
                    ::subxt::ext::codec::Encode,
                    ::subxt::ext::scale_decode::DecodeAsType,
                    ::subxt::ext::scale_encode::EncodeAsType,
                    Clone,
                    Debug,
                    Eq,
                    PartialEq
                )]
                #[codec(crate = ::subxt::ext::codec)]
                #[decode_as_type(crate_path = ":: subxt :: ext :: scale_decode")]
                #[encode_as_type(crate_path = ":: subxt :: ext :: scale_encode")]
                ///Contains one variant per dispatchable that can be called by an extrinsic.
                pub enum Call {
                    #[codec(index = 0)]
                    set_base_fee_per_gas { fee: runtime_types::primitive_types::U256 },
                    #[codec(index = 1)]
                    set_elasticity {
                        elasticity: runtime_types::sp_arithmetic::per_things::Permill,
                    },
                }
                #[derive(
                    ::subxt::ext::codec::Decode,
                    ::subxt::ext::codec::Encode,
                    ::subxt::ext::scale_decode::DecodeAsType,
                    ::subxt::ext::scale_encode::EncodeAsType,
                    Clone,
                    Debug,
                    Eq,
                    PartialEq
                )]
                #[codec(crate = ::subxt::ext::codec)]
                #[decode_as_type(crate_path = ":: subxt :: ext :: scale_decode")]
                #[encode_as_type(crate_path = ":: subxt :: ext :: scale_encode")]
                /**
			The [event](https://docs.substrate.io/main-docs/build/events-errors/) emitted
			by this pallet.
			*/
                pub enum Event {
                    #[codec(index = 0)]
                    NewBaseFeePerGas { fee: runtime_types::primitive_types::U256 },
                    #[codec(index = 1)]
                    BaseFeeOverflow,
                    #[codec(index = 2)]
                    NewElasticity {
                        elasticity: runtime_types::sp_arithmetic::per_things::Permill,
                    },
                }
            }
        }
        pub mod pallet_bounties {
            use super::runtime_types;
            pub mod pallet {
                use super::runtime_types;
                #[derive(
                    ::subxt::ext::codec::Decode,
                    ::subxt::ext::codec::Encode,
                    ::subxt::ext::scale_decode::DecodeAsType,
                    ::subxt::ext::scale_encode::EncodeAsType,
                    Clone,
                    Debug,
                    Eq,
                    PartialEq
                )]
                #[codec(crate = ::subxt::ext::codec)]
                #[decode_as_type(crate_path = ":: subxt :: ext :: scale_decode")]
                #[encode_as_type(crate_path = ":: subxt :: ext :: scale_encode")]
                ///Contains one variant per dispatchable that can be called by an extrinsic.
                pub enum Call {
                    #[codec(index = 0)]
                    ///Propose a new bounty.
                    ///
                    ///The dispatch origin for this call must be _Signed_.
                    ///
                    ///Payment: `TipReportDepositBase` will be reserved from the origin account, as well as
                    ///`DataDepositPerByte` for each byte in `reason`. It will be unreserved upon approval,
                    ///or slashed when rejected.
                    ///
                    ///- `curator`: The curator account whom will manage this bounty.
                    ///- `fee`: The curator fee.
                    ///- `value`: The total payment amount of this bounty, curator fee included.
                    ///- `description`: The description of this bounty.
                    propose_bounty {
                        #[codec(compact)]
                        value: ::core::primitive::u128,
                        description: ::std::vec::Vec<::core::primitive::u8>,
                    },
                    #[codec(index = 1)]
                    ///Approve a bounty proposal. At a later time, the bounty will be funded and become active
                    ///and the original deposit will be returned.
                    ///
                    ///May only be called from `T::SpendOrigin`.
                    ///
                    ///## Complexity
                    ///- O(1).
                    approve_bounty {
                        #[codec(compact)]
                        bounty_id: ::core::primitive::u32,
                    },
                    #[codec(index = 2)]
                    ///Assign a curator to a funded bounty.
                    ///
                    ///May only be called from `T::SpendOrigin`.
                    ///
                    ///## Complexity
                    ///- O(1).
                    propose_curator {
                        #[codec(compact)]
                        bounty_id: ::core::primitive::u32,
                        curator: ::subxt::utils::MultiAddress<
                            ::subxt::utils::AccountId32,
                            ::core::primitive::u32,
                        >,
                        #[codec(compact)]
                        fee: ::core::primitive::u128,
                    },
                    #[codec(index = 3)]
                    ///Unassign curator from a bounty.
                    ///
                    ///This function can only be called by the `RejectOrigin` a signed origin.
                    ///
                    ///If this function is called by the `RejectOrigin`, we assume that the curator is
                    ///malicious or inactive. As a result, we will slash the curator when possible.
                    ///
                    ///If the origin is the curator, we take this as a sign they are unable to do their job and
                    ///they willingly give up. We could slash them, but for now we allow them to recover their
                    ///deposit and exit without issue. (We may want to change this if it is abused.)
                    ///
                    ///Finally, the origin can be anyone if and only if the curator is "inactive". This allows
                    ///anyone in the community to call out that a curator is not doing their due diligence, and
                    ///we should pick a new curator. In this case the curator should also be slashed.
                    ///
                    ///## Complexity
                    ///- O(1).
                    unassign_curator {
                        #[codec(compact)]
                        bounty_id: ::core::primitive::u32,
                    },
                    #[codec(index = 4)]
                    ///Accept the curator role for a bounty.
                    ///A deposit will be reserved from curator and refund upon successful payout.
                    ///
                    ///May only be called from the curator.
                    ///
                    ///## Complexity
                    ///- O(1).
                    accept_curator {
                        #[codec(compact)]
                        bounty_id: ::core::primitive::u32,
                    },
                    #[codec(index = 5)]
                    ///Award bounty to a beneficiary account. The beneficiary will be able to claim the funds
                    ///after a delay.
                    ///
                    ///The dispatch origin for this call must be the curator of this bounty.
                    ///
                    ///- `bounty_id`: Bounty ID to award.
                    ///- `beneficiary`: The beneficiary account whom will receive the payout.
                    ///
                    ///## Complexity
                    ///- O(1).
                    award_bounty {
                        #[codec(compact)]
                        bounty_id: ::core::primitive::u32,
                        beneficiary: ::subxt::utils::MultiAddress<
                            ::subxt::utils::AccountId32,
                            ::core::primitive::u32,
                        >,
                    },
                    #[codec(index = 6)]
                    ///Claim the payout from an awarded bounty after payout delay.
                    ///
                    ///The dispatch origin for this call must be the beneficiary of this bounty.
                    ///
                    ///- `bounty_id`: Bounty ID to claim.
                    ///
                    ///## Complexity
                    ///- O(1).
                    claim_bounty { #[codec(compact)] bounty_id: ::core::primitive::u32 },
                    #[codec(index = 7)]
                    ///Cancel a proposed or active bounty. All the funds will be sent to treasury and
                    ///the curator deposit will be unreserved if possible.
                    ///
                    ///Only `T::RejectOrigin` is able to cancel a bounty.
                    ///
                    ///- `bounty_id`: Bounty ID to cancel.
                    ///
                    ///## Complexity
                    ///- O(1).
                    close_bounty { #[codec(compact)] bounty_id: ::core::primitive::u32 },
                    #[codec(index = 8)]
                    ///Extend the expiry time of an active bounty.
                    ///
                    ///The dispatch origin for this call must be the curator of this bounty.
                    ///
                    ///- `bounty_id`: Bounty ID to extend.
                    ///- `remark`: additional information.
                    ///
                    ///## Complexity
                    ///- O(1).
                    extend_bounty_expiry {
                        #[codec(compact)]
                        bounty_id: ::core::primitive::u32,
                        remark: ::std::vec::Vec<::core::primitive::u8>,
                    },
                }
                #[derive(
                    ::subxt::ext::codec::Decode,
                    ::subxt::ext::codec::Encode,
                    ::subxt::ext::scale_decode::DecodeAsType,
                    ::subxt::ext::scale_encode::EncodeAsType,
                    Clone,
                    Debug,
                    Eq,
                    PartialEq
                )]
                #[codec(crate = ::subxt::ext::codec)]
                #[decode_as_type(crate_path = ":: subxt :: ext :: scale_decode")]
                #[encode_as_type(crate_path = ":: subxt :: ext :: scale_encode")]
                /**
			Custom [dispatch errors](https://docs.substrate.io/main-docs/build/events-errors/)
			of this pallet.
			*/
                pub enum Error {
                    #[codec(index = 0)]
                    ///Proposer's balance is too low.
                    InsufficientProposersBalance,
                    #[codec(index = 1)]
                    ///No proposal or bounty at that index.
                    InvalidIndex,
                    #[codec(index = 2)]
                    ///The reason given is just too big.
                    ReasonTooBig,
                    #[codec(index = 3)]
                    ///The bounty status is unexpected.
                    UnexpectedStatus,
                    #[codec(index = 4)]
                    ///Require bounty curator.
                    RequireCurator,
                    #[codec(index = 5)]
                    ///Invalid bounty value.
                    InvalidValue,
                    #[codec(index = 6)]
                    ///Invalid bounty fee.
                    InvalidFee,
                    #[codec(index = 7)]
                    ///A bounty payout is pending.
                    ///To cancel the bounty, you must unassign and slash the curator.
                    PendingPayout,
                    #[codec(index = 8)]
                    ///The bounties cannot be claimed/closed because it's still in the countdown period.
                    Premature,
                    #[codec(index = 9)]
                    ///The bounty cannot be closed because it has active child bounties.
                    HasActiveChildBounty,
                    #[codec(index = 10)]
                    ///Too many approvals are already queued.
                    TooManyQueued,
                }
                #[derive(
                    ::subxt::ext::codec::Decode,
                    ::subxt::ext::codec::Encode,
                    ::subxt::ext::scale_decode::DecodeAsType,
                    ::subxt::ext::scale_encode::EncodeAsType,
                    Clone,
                    Debug,
                    Eq,
                    PartialEq
                )]
                #[codec(crate = ::subxt::ext::codec)]
                #[decode_as_type(crate_path = ":: subxt :: ext :: scale_decode")]
                #[encode_as_type(crate_path = ":: subxt :: ext :: scale_encode")]
                /**
			The [event](https://docs.substrate.io/main-docs/build/events-errors/) emitted
			by this pallet.
			*/
                pub enum Event {
                    #[codec(index = 0)]
                    ///New bounty proposal.
                    BountyProposed { index: ::core::primitive::u32 },
                    #[codec(index = 1)]
                    ///A bounty proposal was rejected; funds were slashed.
                    BountyRejected {
                        index: ::core::primitive::u32,
                        bond: ::core::primitive::u128,
                    },
                    #[codec(index = 2)]
                    ///A bounty proposal is funded and became active.
                    BountyBecameActive { index: ::core::primitive::u32 },
                    #[codec(index = 3)]
                    ///A bounty is awarded to a beneficiary.
                    BountyAwarded {
                        index: ::core::primitive::u32,
                        beneficiary: ::subxt::utils::AccountId32,
                    },
                    #[codec(index = 4)]
                    ///A bounty is claimed by beneficiary.
                    BountyClaimed {
                        index: ::core::primitive::u32,
                        payout: ::core::primitive::u128,
                        beneficiary: ::subxt::utils::AccountId32,
                    },
                    #[codec(index = 5)]
                    ///A bounty is cancelled.
                    BountyCanceled { index: ::core::primitive::u32 },
                    #[codec(index = 6)]
                    ///A bounty expiry is extended.
                    BountyExtended { index: ::core::primitive::u32 },
                }
            }
            #[derive(
                ::subxt::ext::codec::Decode,
                ::subxt::ext::codec::Encode,
                ::subxt::ext::scale_decode::DecodeAsType,
                ::subxt::ext::scale_encode::EncodeAsType,
                Clone,
                Debug,
                Eq,
                PartialEq
            )]
            #[codec(crate = ::subxt::ext::codec)]
            #[decode_as_type(crate_path = ":: subxt :: ext :: scale_decode")]
            #[encode_as_type(crate_path = ":: subxt :: ext :: scale_encode")]
            pub struct Bounty<_0, _1, _2> {
                pub proposer: _0,
                pub value: _1,
                pub fee: _1,
                pub curator_deposit: _1,
                pub bond: _1,
                pub status: runtime_types::pallet_bounties::BountyStatus<_0, _2>,
            }
            #[derive(
                ::subxt::ext::codec::Decode,
                ::subxt::ext::codec::Encode,
                ::subxt::ext::scale_decode::DecodeAsType,
                ::subxt::ext::scale_encode::EncodeAsType,
                Clone,
                Debug,
                Eq,
                PartialEq
            )]
            #[codec(crate = ::subxt::ext::codec)]
            #[decode_as_type(crate_path = ":: subxt :: ext :: scale_decode")]
            #[encode_as_type(crate_path = ":: subxt :: ext :: scale_encode")]
            pub enum BountyStatus<_0, _1> {
                #[codec(index = 0)]
                Proposed,
                #[codec(index = 1)]
                Approved,
                #[codec(index = 2)]
                Funded,
                #[codec(index = 3)]
                CuratorProposed { curator: _0 },
                #[codec(index = 4)]
                Active { curator: _0, update_due: _1 },
                #[codec(index = 5)]
                PendingPayout { curator: _0, beneficiary: _0, unlock_at: _1 },
            }
        }
        pub mod pallet_bridge_registry {
            use super::runtime_types;
            pub mod pallet {
                use super::runtime_types;
                #[derive(
                    ::subxt::ext::codec::Decode,
                    ::subxt::ext::codec::Encode,
                    ::subxt::ext::scale_decode::DecodeAsType,
                    ::subxt::ext::scale_encode::EncodeAsType,
                    Clone,
                    Debug,
                    Eq,
                    PartialEq
                )]
                #[codec(crate = ::subxt::ext::codec)]
                #[decode_as_type(crate_path = ":: subxt :: ext :: scale_decode")]
                #[encode_as_type(crate_path = ":: subxt :: ext :: scale_encode")]
                ///Contains one variant per dispatchable that can be called by an extrinsic.
                pub enum Call {
                    #[codec(index = 0)]
                    ///Set an account's identity information and reserve the appropriate deposit.
                    ///
                    ///If the account already has identity information, the deposit is taken as part payment
                    ///for the new deposit.
                    ///
                    ///The dispatch origin for this call must be _Signed_.
                    ///
                    ///- `info`: The identity information.
                    ///
                    ///Emits `ResourceSet` if successful.
                    set_metadata {
                        bridge_index: ::core::primitive::u32,
                        info: runtime_types::pallet_bridge_registry::types::BridgeInfo,
                    },
                    #[codec(index = 1)]
                    force_reset_indices {
                        resource_ids: ::std::vec::Vec<
                            runtime_types::webb_proposals::header::ResourceId,
                        >,
                        bridge_index: ::core::primitive::u32,
                    },
                }
                #[derive(
                    ::subxt::ext::codec::Decode,
                    ::subxt::ext::codec::Encode,
                    ::subxt::ext::scale_decode::DecodeAsType,
                    ::subxt::ext::scale_encode::EncodeAsType,
                    Clone,
                    Debug,
                    Eq,
                    PartialEq
                )]
                #[codec(crate = ::subxt::ext::codec)]
                #[decode_as_type(crate_path = ":: subxt :: ext :: scale_decode")]
                #[encode_as_type(crate_path = ":: subxt :: ext :: scale_encode")]
                /**
			Custom [dispatch errors](https://docs.substrate.io/main-docs/build/events-errors/)
			of this pallet.
			*/
                pub enum Error {
                    #[codec(index = 0)]
                    ///Parameters haven't been initialized
                    ParametersNotInitialized,
                    #[codec(index = 1)]
                    ///Error during verification
                    VerifyError,
                    #[codec(index = 2)]
                    ///Proposal is not signed and should not be processed
                    ProposalNotSigned,
                    #[codec(index = 3)]
                    ///Resources map to different bridge indices
                    BridgeIndexError,
                    #[codec(index = 4)]
                    ///Too many additional fields.
                    TooManyFields,
                    #[codec(index = 5)]
                    ///Bridge does not exist.
                    BridgeNotFound,
                    #[codec(index = 6)]
                    ///Too many resources.
                    TooManyResources,
                    #[codec(index = 7)]
                    ///Input out of bounds
                    OutOfBounds,
                }
                #[derive(
                    ::subxt::ext::codec::Decode,
                    ::subxt::ext::codec::Encode,
                    ::subxt::ext::scale_decode::DecodeAsType,
                    ::subxt::ext::scale_encode::EncodeAsType,
                    Clone,
                    Debug,
                    Eq,
                    PartialEq
                )]
                #[codec(crate = ::subxt::ext::codec)]
                #[decode_as_type(crate_path = ":: subxt :: ext :: scale_decode")]
                #[encode_as_type(crate_path = ":: subxt :: ext :: scale_encode")]
                /**
			The [event](https://docs.substrate.io/main-docs/build/events-errors/) emitted
			by this pallet.
			*/
                pub enum Event {}
            }
            pub mod types {
                use super::runtime_types;
                #[derive(
                    ::subxt::ext::codec::Decode,
                    ::subxt::ext::codec::Encode,
                    ::subxt::ext::scale_decode::DecodeAsType,
                    ::subxt::ext::scale_encode::EncodeAsType,
                    Clone,
                    Debug,
                    Eq,
                    PartialEq
                )]
                #[codec(crate = ::subxt::ext::codec)]
                #[decode_as_type(crate_path = ":: subxt :: ext :: scale_decode")]
                #[encode_as_type(crate_path = ":: subxt :: ext :: scale_encode")]
                pub struct BridgeInfo {
                    pub additional: runtime_types::bounded_collections::bounded_vec::BoundedVec<
                        (
                            runtime_types::pallet_bridge_registry::types::SerdeData,
                            runtime_types::pallet_bridge_registry::types::SerdeData,
                        ),
                    >,
                    pub display: runtime_types::pallet_bridge_registry::types::SerdeData,
                }
                #[derive(
                    ::subxt::ext::codec::Decode,
                    ::subxt::ext::codec::Encode,
                    ::subxt::ext::scale_decode::DecodeAsType,
                    ::subxt::ext::scale_encode::EncodeAsType,
                    Clone,
                    Debug,
                    Eq,
                    PartialEq
                )]
                #[codec(crate = ::subxt::ext::codec)]
                #[decode_as_type(crate_path = ":: subxt :: ext :: scale_decode")]
                #[encode_as_type(crate_path = ":: subxt :: ext :: scale_encode")]
                pub struct BridgeMetadata {
                    pub resource_ids: runtime_types::bounded_collections::bounded_vec::BoundedVec<
                        runtime_types::webb_proposals::header::ResourceId,
                    >,
                    pub info: runtime_types::pallet_bridge_registry::types::BridgeInfo,
                }
                #[derive(
                    ::subxt::ext::codec::Decode,
                    ::subxt::ext::codec::Encode,
                    ::subxt::ext::scale_decode::DecodeAsType,
                    ::subxt::ext::scale_encode::EncodeAsType,
                    Clone,
                    Debug,
                    Eq,
                    PartialEq
                )]
                #[codec(crate = ::subxt::ext::codec)]
                #[decode_as_type(crate_path = ":: subxt :: ext :: scale_decode")]
                #[encode_as_type(crate_path = ":: subxt :: ext :: scale_encode")]
                pub struct SerdeData(pub runtime_types::pallet_identity::types::Data);
            }
        }
        pub mod pallet_child_bounties {
            use super::runtime_types;
            pub mod pallet {
                use super::runtime_types;
                #[derive(
                    ::subxt::ext::codec::Decode,
                    ::subxt::ext::codec::Encode,
                    ::subxt::ext::scale_decode::DecodeAsType,
                    ::subxt::ext::scale_encode::EncodeAsType,
                    Clone,
                    Debug,
                    Eq,
                    PartialEq
                )]
                #[codec(crate = ::subxt::ext::codec)]
                #[decode_as_type(crate_path = ":: subxt :: ext :: scale_decode")]
                #[encode_as_type(crate_path = ":: subxt :: ext :: scale_encode")]
                ///Contains one variant per dispatchable that can be called by an extrinsic.
                pub enum Call {
                    #[codec(index = 0)]
                    ///Add a new child-bounty.
                    ///
                    ///The dispatch origin for this call must be the curator of parent
                    ///bounty and the parent bounty must be in "active" state.
                    ///
                    ///Child-bounty gets added successfully & fund gets transferred from
                    ///parent bounty to child-bounty account, if parent bounty has enough
                    ///funds, else the call fails.
                    ///
                    ///Upper bound to maximum number of active  child bounties that can be
                    ///added are managed via runtime trait config
                    ///[`Config::MaxActiveChildBountyCount`].
                    ///
                    ///If the call is success, the status of child-bounty is updated to
                    ///"Added".
                    ///
                    ///- `parent_bounty_id`: Index of parent bounty for which child-bounty is being added.
                    ///- `value`: Value for executing the proposal.
                    ///- `description`: Text description for the child-bounty.
                    add_child_bounty {
                        #[codec(compact)]
                        parent_bounty_id: ::core::primitive::u32,
                        #[codec(compact)]
                        value: ::core::primitive::u128,
                        description: ::std::vec::Vec<::core::primitive::u8>,
                    },
                    #[codec(index = 1)]
                    ///Propose curator for funded child-bounty.
                    ///
                    ///The dispatch origin for this call must be curator of parent bounty.
                    ///
                    ///Parent bounty must be in active state, for this child-bounty call to
                    ///work.
                    ///
                    ///Child-bounty must be in "Added" state, for processing the call. And
                    ///state of child-bounty is moved to "CuratorProposed" on successful
                    ///call completion.
                    ///
                    ///- `parent_bounty_id`: Index of parent bounty.
                    ///- `child_bounty_id`: Index of child bounty.
                    ///- `curator`: Address of child-bounty curator.
                    ///- `fee`: payment fee to child-bounty curator for execution.
                    propose_curator {
                        #[codec(compact)]
                        parent_bounty_id: ::core::primitive::u32,
                        #[codec(compact)]
                        child_bounty_id: ::core::primitive::u32,
                        curator: ::subxt::utils::MultiAddress<
                            ::subxt::utils::AccountId32,
                            ::core::primitive::u32,
                        >,
                        #[codec(compact)]
                        fee: ::core::primitive::u128,
                    },
                    #[codec(index = 2)]
                    ///Accept the curator role for the child-bounty.
                    ///
                    ///The dispatch origin for this call must be the curator of this
                    ///child-bounty.
                    ///
                    ///A deposit will be reserved from the curator and refund upon
                    ///successful payout or cancellation.
                    ///
                    ///Fee for curator is deducted from curator fee of parent bounty.
                    ///
                    ///Parent bounty must be in active state, for this child-bounty call to
                    ///work.
                    ///
                    ///Child-bounty must be in "CuratorProposed" state, for processing the
                    ///call. And state of child-bounty is moved to "Active" on successful
                    ///call completion.
                    ///
                    ///- `parent_bounty_id`: Index of parent bounty.
                    ///- `child_bounty_id`: Index of child bounty.
                    accept_curator {
                        #[codec(compact)]
                        parent_bounty_id: ::core::primitive::u32,
                        #[codec(compact)]
                        child_bounty_id: ::core::primitive::u32,
                    },
                    #[codec(index = 3)]
                    ///Unassign curator from a child-bounty.
                    ///
                    ///The dispatch origin for this call can be either `RejectOrigin`, or
                    ///the curator of the parent bounty, or any signed origin.
                    ///
                    ///For the origin other than T::RejectOrigin and the child-bounty
                    ///curator, parent bounty must be in active state, for this call to
                    ///work. We allow child-bounty curator and T::RejectOrigin to execute
                    ///this call irrespective of the parent bounty state.
                    ///
                    ///If this function is called by the `RejectOrigin` or the
                    ///parent bounty curator, we assume that the child-bounty curator is
                    ///malicious or inactive. As a result, child-bounty curator deposit is
                    ///slashed.
                    ///
                    ///If the origin is the child-bounty curator, we take this as a sign
                    ///that they are unable to do their job, and are willingly giving up.
                    ///We could slash the deposit, but for now we allow them to unreserve
                    ///their deposit and exit without issue. (We may want to change this if
                    ///it is abused.)
                    ///
                    ///Finally, the origin can be anyone iff the child-bounty curator is
                    ///"inactive". Expiry update due of parent bounty is used to estimate
                    ///inactive state of child-bounty curator.
                    ///
                    ///This allows anyone in the community to call out that a child-bounty
                    ///curator is not doing their due diligence, and we should pick a new
                    ///one. In this case the child-bounty curator deposit is slashed.
                    ///
                    ///State of child-bounty is moved to Added state on successful call
                    ///completion.
                    ///
                    ///- `parent_bounty_id`: Index of parent bounty.
                    ///- `child_bounty_id`: Index of child bounty.
                    unassign_curator {
                        #[codec(compact)]
                        parent_bounty_id: ::core::primitive::u32,
                        #[codec(compact)]
                        child_bounty_id: ::core::primitive::u32,
                    },
                    #[codec(index = 4)]
                    ///Award child-bounty to a beneficiary.
                    ///
                    ///The beneficiary will be able to claim the funds after a delay.
                    ///
                    ///The dispatch origin for this call must be the parent curator or
                    ///curator of this child-bounty.
                    ///
                    ///Parent bounty must be in active state, for this child-bounty call to
                    ///work.
                    ///
                    ///Child-bounty must be in active state, for processing the call. And
                    ///state of child-bounty is moved to "PendingPayout" on successful call
                    ///completion.
                    ///
                    ///- `parent_bounty_id`: Index of parent bounty.
                    ///- `child_bounty_id`: Index of child bounty.
                    ///- `beneficiary`: Beneficiary account.
                    award_child_bounty {
                        #[codec(compact)]
                        parent_bounty_id: ::core::primitive::u32,
                        #[codec(compact)]
                        child_bounty_id: ::core::primitive::u32,
                        beneficiary: ::subxt::utils::MultiAddress<
                            ::subxt::utils::AccountId32,
                            ::core::primitive::u32,
                        >,
                    },
                    #[codec(index = 5)]
                    ///Claim the payout from an awarded child-bounty after payout delay.
                    ///
                    ///The dispatch origin for this call may be any signed origin.
                    ///
                    ///Call works independent of parent bounty state, No need for parent
                    ///bounty to be in active state.
                    ///
                    ///The Beneficiary is paid out with agreed bounty value. Curator fee is
                    ///paid & curator deposit is unreserved.
                    ///
                    ///Child-bounty must be in "PendingPayout" state, for processing the
                    ///call. And instance of child-bounty is removed from the state on
                    ///successful call completion.
                    ///
                    ///- `parent_bounty_id`: Index of parent bounty.
                    ///- `child_bounty_id`: Index of child bounty.
                    claim_child_bounty {
                        #[codec(compact)]
                        parent_bounty_id: ::core::primitive::u32,
                        #[codec(compact)]
                        child_bounty_id: ::core::primitive::u32,
                    },
                    #[codec(index = 6)]
                    ///Cancel a proposed or active child-bounty. Child-bounty account funds
                    ///are transferred to parent bounty account. The child-bounty curator
                    ///deposit may be unreserved if possible.
                    ///
                    ///The dispatch origin for this call must be either parent curator or
                    ///`T::RejectOrigin`.
                    ///
                    ///If the state of child-bounty is `Active`, curator deposit is
                    ///unreserved.
                    ///
                    ///If the state of child-bounty is `PendingPayout`, call fails &
                    ///returns `PendingPayout` error.
                    ///
                    ///For the origin other than T::RejectOrigin, parent bounty must be in
                    ///active state, for this child-bounty call to work. For origin
                    ///T::RejectOrigin execution is forced.
                    ///
                    ///Instance of child-bounty is removed from the state on successful
                    ///call completion.
                    ///
                    ///- `parent_bounty_id`: Index of parent bounty.
                    ///- `child_bounty_id`: Index of child bounty.
                    close_child_bounty {
                        #[codec(compact)]
                        parent_bounty_id: ::core::primitive::u32,
                        #[codec(compact)]
                        child_bounty_id: ::core::primitive::u32,
                    },
                }
                #[derive(
                    ::subxt::ext::codec::Decode,
                    ::subxt::ext::codec::Encode,
                    ::subxt::ext::scale_decode::DecodeAsType,
                    ::subxt::ext::scale_encode::EncodeAsType,
                    Clone,
                    Debug,
                    Eq,
                    PartialEq
                )]
                #[codec(crate = ::subxt::ext::codec)]
                #[decode_as_type(crate_path = ":: subxt :: ext :: scale_decode")]
                #[encode_as_type(crate_path = ":: subxt :: ext :: scale_encode")]
                /**
			Custom [dispatch errors](https://docs.substrate.io/main-docs/build/events-errors/)
			of this pallet.
			*/
                pub enum Error {
                    #[codec(index = 0)]
                    ///The parent bounty is not in active state.
                    ParentBountyNotActive,
                    #[codec(index = 1)]
                    ///The bounty balance is not enough to add new child-bounty.
                    InsufficientBountyBalance,
                    #[codec(index = 2)]
                    ///Number of child bounties exceeds limit `MaxActiveChildBountyCount`.
                    TooManyChildBounties,
                }
                #[derive(
                    ::subxt::ext::codec::Decode,
                    ::subxt::ext::codec::Encode,
                    ::subxt::ext::scale_decode::DecodeAsType,
                    ::subxt::ext::scale_encode::EncodeAsType,
                    Clone,
                    Debug,
                    Eq,
                    PartialEq
                )]
                #[codec(crate = ::subxt::ext::codec)]
                #[decode_as_type(crate_path = ":: subxt :: ext :: scale_decode")]
                #[encode_as_type(crate_path = ":: subxt :: ext :: scale_encode")]
                /**
			The [event](https://docs.substrate.io/main-docs/build/events-errors/) emitted
			by this pallet.
			*/
                pub enum Event {
                    #[codec(index = 0)]
                    ///A child-bounty is added.
                    Added {
                        index: ::core::primitive::u32,
                        child_index: ::core::primitive::u32,
                    },
                    #[codec(index = 1)]
                    ///A child-bounty is awarded to a beneficiary.
                    Awarded {
                        index: ::core::primitive::u32,
                        child_index: ::core::primitive::u32,
                        beneficiary: ::subxt::utils::AccountId32,
                    },
                    #[codec(index = 2)]
                    ///A child-bounty is claimed by beneficiary.
                    Claimed {
                        index: ::core::primitive::u32,
                        child_index: ::core::primitive::u32,
                        payout: ::core::primitive::u128,
                        beneficiary: ::subxt::utils::AccountId32,
                    },
                    #[codec(index = 3)]
                    ///A child-bounty is cancelled.
                    Canceled {
                        index: ::core::primitive::u32,
                        child_index: ::core::primitive::u32,
                    },
                }
            }
            #[derive(
                ::subxt::ext::codec::Decode,
                ::subxt::ext::codec::Encode,
                ::subxt::ext::scale_decode::DecodeAsType,
                ::subxt::ext::scale_encode::EncodeAsType,
                Clone,
                Debug,
                Eq,
                PartialEq
            )]
            #[codec(crate = ::subxt::ext::codec)]
            #[decode_as_type(crate_path = ":: subxt :: ext :: scale_decode")]
            #[encode_as_type(crate_path = ":: subxt :: ext :: scale_encode")]
            pub struct ChildBounty<_0, _1, _2> {
                pub parent_bounty: _2,
                pub value: _1,
                pub fee: _1,
                pub curator_deposit: _1,
                pub status: runtime_types::pallet_child_bounties::ChildBountyStatus<
                    _0,
                    _2,
                >,
            }
            #[derive(
                ::subxt::ext::codec::Decode,
                ::subxt::ext::codec::Encode,
                ::subxt::ext::scale_decode::DecodeAsType,
                ::subxt::ext::scale_encode::EncodeAsType,
                Clone,
                Debug,
                Eq,
                PartialEq
            )]
            #[codec(crate = ::subxt::ext::codec)]
            #[decode_as_type(crate_path = ":: subxt :: ext :: scale_decode")]
            #[encode_as_type(crate_path = ":: subxt :: ext :: scale_encode")]
            pub enum ChildBountyStatus<_0, _1> {
                #[codec(index = 0)]
                Added,
                #[codec(index = 1)]
                CuratorProposed { curator: _0 },
                #[codec(index = 2)]
                Active { curator: _0 },
                #[codec(index = 3)]
                PendingPayout { curator: _0, beneficiary: _0, unlock_at: _1 },
            }
        }
        pub mod pallet_collective {
            use super::runtime_types;
            pub mod pallet {
                use super::runtime_types;
                #[derive(
                    ::subxt::ext::codec::Decode,
                    ::subxt::ext::codec::Encode,
                    ::subxt::ext::scale_decode::DecodeAsType,
                    ::subxt::ext::scale_encode::EncodeAsType,
                    Clone,
                    Debug,
                    Eq,
                    PartialEq
                )]
                #[codec(crate = ::subxt::ext::codec)]
                #[decode_as_type(crate_path = ":: subxt :: ext :: scale_decode")]
                #[encode_as_type(crate_path = ":: subxt :: ext :: scale_encode")]
                ///Contains one variant per dispatchable that can be called by an extrinsic.
                pub enum Call {
                    #[codec(index = 0)]
                    ///Set the collective's membership.
                    ///
                    ///- `new_members`: The new member list. Be nice to the chain and provide it sorted.
                    ///- `prime`: The prime member whose vote sets the default.
                    ///- `old_count`: The upper bound for the previous number of members in storage. Used for
                    ///  weight estimation.
                    ///
                    ///The dispatch of this call must be `SetMembersOrigin`.
                    ///
                    ///NOTE: Does not enforce the expected `MaxMembers` limit on the amount of members, but
                    ///      the weight estimations rely on it to estimate dispatchable weight.
                    ///
                    ///# WARNING:
                    ///
                    ///The `pallet-collective` can also be managed by logic outside of the pallet through the
                    ///implementation of the trait [`ChangeMembers`].
                    ///Any call to `set_members` must be careful that the member set doesn't get out of sync
                    ///with other logic managing the member set.
                    ///
                    ///## Complexity:
                    ///- `O(MP + N)` where:
                    ///  - `M` old-members-count (code- and governance-bounded)
                    ///  - `N` new-members-count (code- and governance-bounded)
                    ///  - `P` proposals-count (code-bounded)
                    set_members {
                        new_members: ::std::vec::Vec<::subxt::utils::AccountId32>,
                        prime: ::core::option::Option<::subxt::utils::AccountId32>,
                        old_count: ::core::primitive::u32,
                    },
                    #[codec(index = 1)]
                    ///Dispatch a proposal from a member using the `Member` origin.
                    ///
                    ///Origin must be a member of the collective.
                    ///
                    ///## Complexity:
                    ///- `O(B + M + P)` where:
                    ///- `B` is `proposal` size in bytes (length-fee-bounded)
                    ///- `M` members-count (code-bounded)
                    ///- `P` complexity of dispatching `proposal`
                    execute {
                        proposal: ::std::boxed::Box<
                            runtime_types::tangle_standalone_runtime::RuntimeCall,
                        >,
                        #[codec(compact)]
                        length_bound: ::core::primitive::u32,
                    },
                    #[codec(index = 2)]
                    ///Add a new proposal to either be voted on or executed directly.
                    ///
                    ///Requires the sender to be member.
                    ///
                    ///`threshold` determines whether `proposal` is executed directly (`threshold < 2`)
                    ///or put up for voting.
                    ///
                    ///## Complexity
                    ///- `O(B + M + P1)` or `O(B + M + P2)` where:
                    ///  - `B` is `proposal` size in bytes (length-fee-bounded)
                    ///  - `M` is members-count (code- and governance-bounded)
                    ///  - branching is influenced by `threshold` where:
                    ///    - `P1` is proposal execution complexity (`threshold < 2`)
                    ///    - `P2` is proposals-count (code-bounded) (`threshold >= 2`)
                    propose {
                        #[codec(compact)]
                        threshold: ::core::primitive::u32,
                        proposal: ::std::boxed::Box<
                            runtime_types::tangle_standalone_runtime::RuntimeCall,
                        >,
                        #[codec(compact)]
                        length_bound: ::core::primitive::u32,
                    },
                    #[codec(index = 3)]
                    ///Add an aye or nay vote for the sender to the given proposal.
                    ///
                    ///Requires the sender to be a member.
                    ///
                    ///Transaction fees will be waived if the member is voting on any particular proposal
                    ///for the first time and the call is successful. Subsequent vote changes will charge a
                    ///fee.
                    ///## Complexity
                    ///- `O(M)` where `M` is members-count (code- and governance-bounded)
                    vote {
                        proposal: ::subxt::utils::H256,
                        #[codec(compact)]
                        index: ::core::primitive::u32,
                        approve: ::core::primitive::bool,
                    },
                    #[codec(index = 5)]
                    ///Disapprove a proposal, close, and remove it from the system, regardless of its current
                    ///state.
                    ///
                    ///Must be called by the Root origin.
                    ///
                    ///Parameters:
                    ///* `proposal_hash`: The hash of the proposal that should be disapproved.
                    ///
                    ///## Complexity
                    ///O(P) where P is the number of max proposals
                    disapprove_proposal { proposal_hash: ::subxt::utils::H256 },
                    #[codec(index = 6)]
                    ///Close a vote that is either approved, disapproved or whose voting period has ended.
                    ///
                    ///May be called by any signed account in order to finish voting and close the proposal.
                    ///
                    ///If called before the end of the voting period it will only close the vote if it is
                    ///has enough votes to be approved or disapproved.
                    ///
                    ///If called after the end of the voting period abstentions are counted as rejections
                    ///unless there is a prime member set and the prime member cast an approval.
                    ///
                    ///If the close operation completes successfully with disapproval, the transaction fee will
                    ///be waived. Otherwise execution of the approved operation will be charged to the caller.
                    ///
                    ///+ `proposal_weight_bound`: The maximum amount of weight consumed by executing the closed
                    ///proposal.
                    ///+ `length_bound`: The upper bound for the length of the proposal in storage. Checked via
                    ///`storage::read` so it is `size_of::<u32>() == 4` larger than the pure length.
                    ///
                    ///## Complexity
                    ///- `O(B + M + P1 + P2)` where:
                    ///  - `B` is `proposal` size in bytes (length-fee-bounded)
                    ///  - `M` is members-count (code- and governance-bounded)
                    ///  - `P1` is the complexity of `proposal` preimage.
                    ///  - `P2` is proposal-count (code-bounded)
                    close {
                        proposal_hash: ::subxt::utils::H256,
                        #[codec(compact)]
                        index: ::core::primitive::u32,
                        proposal_weight_bound: runtime_types::sp_weights::weight_v2::Weight,
                        #[codec(compact)]
                        length_bound: ::core::primitive::u32,
                    },
                }
                #[derive(
                    ::subxt::ext::codec::Decode,
                    ::subxt::ext::codec::Encode,
                    ::subxt::ext::scale_decode::DecodeAsType,
                    ::subxt::ext::scale_encode::EncodeAsType,
                    Clone,
                    Debug,
                    Eq,
                    PartialEq
                )]
                #[codec(crate = ::subxt::ext::codec)]
                #[decode_as_type(crate_path = ":: subxt :: ext :: scale_decode")]
                #[encode_as_type(crate_path = ":: subxt :: ext :: scale_encode")]
                /**
			Custom [dispatch errors](https://docs.substrate.io/main-docs/build/events-errors/)
			of this pallet.
			*/
                pub enum Error {
                    #[codec(index = 0)]
                    ///Account is not a member
                    NotMember,
                    #[codec(index = 1)]
                    ///Duplicate proposals not allowed
                    DuplicateProposal,
                    #[codec(index = 2)]
                    ///Proposal must exist
                    ProposalMissing,
                    #[codec(index = 3)]
                    ///Mismatched index
                    WrongIndex,
                    #[codec(index = 4)]
                    ///Duplicate vote ignored
                    DuplicateVote,
                    #[codec(index = 5)]
                    ///Members are already initialized!
                    AlreadyInitialized,
                    #[codec(index = 6)]
                    ///The close call was made too early, before the end of the voting.
                    TooEarly,
                    #[codec(index = 7)]
                    ///There can only be a maximum of `MaxProposals` active proposals.
                    TooManyProposals,
                    #[codec(index = 8)]
                    ///The given weight bound for the proposal was too low.
                    WrongProposalWeight,
                    #[codec(index = 9)]
                    ///The given length bound for the proposal was too low.
                    WrongProposalLength,
                }
                #[derive(
                    ::subxt::ext::codec::Decode,
                    ::subxt::ext::codec::Encode,
                    ::subxt::ext::scale_decode::DecodeAsType,
                    ::subxt::ext::scale_encode::EncodeAsType,
                    Clone,
                    Debug,
                    Eq,
                    PartialEq
                )]
                #[codec(crate = ::subxt::ext::codec)]
                #[decode_as_type(crate_path = ":: subxt :: ext :: scale_decode")]
                #[encode_as_type(crate_path = ":: subxt :: ext :: scale_encode")]
                /**
			The [event](https://docs.substrate.io/main-docs/build/events-errors/) emitted
			by this pallet.
			*/
                pub enum Event {
                    #[codec(index = 0)]
                    ///A motion (given hash) has been proposed (by given account) with a threshold (given
                    ///`MemberCount`).
                    Proposed {
                        account: ::subxt::utils::AccountId32,
                        proposal_index: ::core::primitive::u32,
                        proposal_hash: ::subxt::utils::H256,
                        threshold: ::core::primitive::u32,
                    },
                    #[codec(index = 1)]
                    ///A motion (given hash) has been voted on by given account, leaving
                    ///a tally (yes votes and no votes given respectively as `MemberCount`).
                    Voted {
                        account: ::subxt::utils::AccountId32,
                        proposal_hash: ::subxt::utils::H256,
                        voted: ::core::primitive::bool,
                        yes: ::core::primitive::u32,
                        no: ::core::primitive::u32,
                    },
                    #[codec(index = 2)]
                    ///A motion was approved by the required threshold.
                    Approved { proposal_hash: ::subxt::utils::H256 },
                    #[codec(index = 3)]
                    ///A motion was not approved by the required threshold.
                    Disapproved { proposal_hash: ::subxt::utils::H256 },
                    #[codec(index = 4)]
                    ///A motion was executed; result will be `Ok` if it returned without error.
                    Executed {
                        proposal_hash: ::subxt::utils::H256,
                        result: ::core::result::Result<
                            (),
                            runtime_types::sp_runtime::DispatchError,
                        >,
                    },
                    #[codec(index = 5)]
                    ///A single member did some action; result will be `Ok` if it returned without error.
                    MemberExecuted {
                        proposal_hash: ::subxt::utils::H256,
                        result: ::core::result::Result<
                            (),
                            runtime_types::sp_runtime::DispatchError,
                        >,
                    },
                    #[codec(index = 6)]
                    ///A proposal was closed because its threshold was reached or after its duration was up.
                    Closed {
                        proposal_hash: ::subxt::utils::H256,
                        yes: ::core::primitive::u32,
                        no: ::core::primitive::u32,
                    },
                }
            }
            #[derive(
                ::subxt::ext::codec::Decode,
                ::subxt::ext::codec::Encode,
                ::subxt::ext::scale_decode::DecodeAsType,
                ::subxt::ext::scale_encode::EncodeAsType,
                Clone,
                Debug,
                Eq,
                PartialEq
            )]
            #[codec(crate = ::subxt::ext::codec)]
            #[decode_as_type(crate_path = ":: subxt :: ext :: scale_decode")]
            #[encode_as_type(crate_path = ":: subxt :: ext :: scale_encode")]
            pub enum RawOrigin<_0> {
                #[codec(index = 0)]
                Members(::core::primitive::u32, ::core::primitive::u32),
                #[codec(index = 1)]
                Member(_0),
                #[codec(index = 2)]
                _Phantom,
            }
            #[derive(
                ::subxt::ext::codec::Decode,
                ::subxt::ext::codec::Encode,
                ::subxt::ext::scale_decode::DecodeAsType,
                ::subxt::ext::scale_encode::EncodeAsType,
                Clone,
                Debug,
                Eq,
                PartialEq
            )]
            #[codec(crate = ::subxt::ext::codec)]
            #[decode_as_type(crate_path = ":: subxt :: ext :: scale_decode")]
            #[encode_as_type(crate_path = ":: subxt :: ext :: scale_encode")]
            pub struct Votes<_0, _1> {
                pub index: _1,
                pub threshold: _1,
                pub ayes: ::std::vec::Vec<_0>,
                pub nays: ::std::vec::Vec<_0>,
                pub end: _1,
            }
        }
        pub mod pallet_democracy {
            use super::runtime_types;
            pub mod conviction {
                use super::runtime_types;
                #[derive(
                    ::subxt::ext::codec::Decode,
                    ::subxt::ext::codec::Encode,
                    ::subxt::ext::scale_decode::DecodeAsType,
                    ::subxt::ext::scale_encode::EncodeAsType,
                    Clone,
                    Debug,
                    Eq,
                    PartialEq
                )]
                #[codec(crate = ::subxt::ext::codec)]
                #[decode_as_type(crate_path = ":: subxt :: ext :: scale_decode")]
                #[encode_as_type(crate_path = ":: subxt :: ext :: scale_encode")]
                pub enum Conviction {
                    #[codec(index = 0)]
                    None,
                    #[codec(index = 1)]
                    Locked1x,
                    #[codec(index = 2)]
                    Locked2x,
                    #[codec(index = 3)]
                    Locked3x,
                    #[codec(index = 4)]
                    Locked4x,
                    #[codec(index = 5)]
                    Locked5x,
                    #[codec(index = 6)]
                    Locked6x,
                }
            }
            pub mod pallet {
                use super::runtime_types;
                #[derive(
                    ::subxt::ext::codec::Decode,
                    ::subxt::ext::codec::Encode,
                    ::subxt::ext::scale_decode::DecodeAsType,
                    ::subxt::ext::scale_encode::EncodeAsType,
                    Clone,
                    Debug,
                    Eq,
                    PartialEq
                )]
                #[codec(crate = ::subxt::ext::codec)]
                #[decode_as_type(crate_path = ":: subxt :: ext :: scale_decode")]
                #[encode_as_type(crate_path = ":: subxt :: ext :: scale_encode")]
                ///Contains one variant per dispatchable that can be called by an extrinsic.
                pub enum Call {
                    #[codec(index = 0)]
                    ///Propose a sensitive action to be taken.
                    ///
                    ///The dispatch origin of this call must be _Signed_ and the sender must
                    ///have funds to cover the deposit.
                    ///
                    ///- `proposal_hash`: The hash of the proposal preimage.
                    ///- `value`: The amount of deposit (must be at least `MinimumDeposit`).
                    ///
                    ///Emits `Proposed`.
                    propose {
                        proposal: runtime_types::frame_support::traits::preimages::Bounded<
                            runtime_types::tangle_standalone_runtime::RuntimeCall,
                        >,
                        #[codec(compact)]
                        value: ::core::primitive::u128,
                    },
                    #[codec(index = 1)]
                    ///Signals agreement with a particular proposal.
                    ///
                    ///The dispatch origin of this call must be _Signed_ and the sender
                    ///must have funds to cover the deposit, equal to the original deposit.
                    ///
                    ///- `proposal`: The index of the proposal to second.
                    second { #[codec(compact)] proposal: ::core::primitive::u32 },
                    #[codec(index = 2)]
                    ///Vote in a referendum. If `vote.is_aye()`, the vote is to enact the proposal;
                    ///otherwise it is a vote to keep the status quo.
                    ///
                    ///The dispatch origin of this call must be _Signed_.
                    ///
                    ///- `ref_index`: The index of the referendum to vote for.
                    ///- `vote`: The vote configuration.
                    vote {
                        #[codec(compact)]
                        ref_index: ::core::primitive::u32,
                        vote: runtime_types::pallet_democracy::vote::AccountVote<
                            ::core::primitive::u128,
                        >,
                    },
                    #[codec(index = 3)]
                    ///Schedule an emergency cancellation of a referendum. Cannot happen twice to the same
                    ///referendum.
                    ///
                    ///The dispatch origin of this call must be `CancellationOrigin`.
                    ///
                    ///-`ref_index`: The index of the referendum to cancel.
                    ///
                    ///Weight: `O(1)`.
                    emergency_cancel { ref_index: ::core::primitive::u32 },
                    #[codec(index = 4)]
                    ///Schedule a referendum to be tabled once it is legal to schedule an external
                    ///referendum.
                    ///
                    ///The dispatch origin of this call must be `ExternalOrigin`.
                    ///
                    ///- `proposal_hash`: The preimage hash of the proposal.
                    external_propose {
                        proposal: runtime_types::frame_support::traits::preimages::Bounded<
                            runtime_types::tangle_standalone_runtime::RuntimeCall,
                        >,
                    },
                    #[codec(index = 5)]
                    ///Schedule a majority-carries referendum to be tabled next once it is legal to schedule
                    ///an external referendum.
                    ///
                    ///The dispatch of this call must be `ExternalMajorityOrigin`.
                    ///
                    ///- `proposal_hash`: The preimage hash of the proposal.
                    ///
                    ///Unlike `external_propose`, blacklisting has no effect on this and it may replace a
                    ///pre-scheduled `external_propose` call.
                    ///
                    ///Weight: `O(1)`
                    external_propose_majority {
                        proposal: runtime_types::frame_support::traits::preimages::Bounded<
                            runtime_types::tangle_standalone_runtime::RuntimeCall,
                        >,
                    },
                    #[codec(index = 6)]
                    ///Schedule a negative-turnout-bias referendum to be tabled next once it is legal to
                    ///schedule an external referendum.
                    ///
                    ///The dispatch of this call must be `ExternalDefaultOrigin`.
                    ///
                    ///- `proposal_hash`: The preimage hash of the proposal.
                    ///
                    ///Unlike `external_propose`, blacklisting has no effect on this and it may replace a
                    ///pre-scheduled `external_propose` call.
                    ///
                    ///Weight: `O(1)`
                    external_propose_default {
                        proposal: runtime_types::frame_support::traits::preimages::Bounded<
                            runtime_types::tangle_standalone_runtime::RuntimeCall,
                        >,
                    },
                    #[codec(index = 7)]
                    ///Schedule the currently externally-proposed majority-carries referendum to be tabled
                    ///immediately. If there is no externally-proposed referendum currently, or if there is one
                    ///but it is not a majority-carries referendum then it fails.
                    ///
                    ///The dispatch of this call must be `FastTrackOrigin`.
                    ///
                    ///- `proposal_hash`: The hash of the current external proposal.
                    ///- `voting_period`: The period that is allowed for voting on this proposal. Increased to
                    ///	Must be always greater than zero.
                    ///	For `FastTrackOrigin` must be equal or greater than `FastTrackVotingPeriod`.
                    ///- `delay`: The number of block after voting has ended in approval and this should be
                    ///  enacted. This doesn't have a minimum amount.
                    ///
                    ///Emits `Started`.
                    ///
                    ///Weight: `O(1)`
                    fast_track {
                        proposal_hash: ::subxt::utils::H256,
                        voting_period: ::core::primitive::u32,
                        delay: ::core::primitive::u32,
                    },
                    #[codec(index = 8)]
                    ///Veto and blacklist the external proposal hash.
                    ///
                    ///The dispatch origin of this call must be `VetoOrigin`.
                    ///
                    ///- `proposal_hash`: The preimage hash of the proposal to veto and blacklist.
                    ///
                    ///Emits `Vetoed`.
                    ///
                    ///Weight: `O(V + log(V))` where V is number of `existing vetoers`
                    veto_external { proposal_hash: ::subxt::utils::H256 },
                    #[codec(index = 9)]
                    ///Remove a referendum.
                    ///
                    ///The dispatch origin of this call must be _Root_.
                    ///
                    ///- `ref_index`: The index of the referendum to cancel.
                    ///
                    ///# Weight: `O(1)`.
                    cancel_referendum {
                        #[codec(compact)]
                        ref_index: ::core::primitive::u32,
                    },
                    #[codec(index = 10)]
                    ///Delegate the voting power (with some given conviction) of the sending account.
                    ///
                    ///The balance delegated is locked for as long as it's delegated, and thereafter for the
                    ///time appropriate for the conviction's lock period.
                    ///
                    ///The dispatch origin of this call must be _Signed_, and the signing account must either:
                    ///  - be delegating already; or
                    ///  - have no voting activity (if there is, then it will need to be removed/consolidated
                    ///    through `reap_vote` or `unvote`).
                    ///
                    ///- `to`: The account whose voting the `target` account's voting power will follow.
                    ///- `conviction`: The conviction that will be attached to the delegated votes. When the
                    ///  account is undelegated, the funds will be locked for the corresponding period.
                    ///- `balance`: The amount of the account's balance to be used in delegating. This must not
                    ///  be more than the account's current balance.
                    ///
                    ///Emits `Delegated`.
                    ///
                    ///Weight: `O(R)` where R is the number of referendums the voter delegating to has
                    ///  voted on. Weight is charged as if maximum votes.
                    delegate {
                        to: ::subxt::utils::MultiAddress<
                            ::subxt::utils::AccountId32,
                            ::core::primitive::u32,
                        >,
                        conviction: runtime_types::pallet_democracy::conviction::Conviction,
                        balance: ::core::primitive::u128,
                    },
                    #[codec(index = 11)]
                    ///Undelegate the voting power of the sending account.
                    ///
                    ///Tokens may be unlocked following once an amount of time consistent with the lock period
                    ///of the conviction with which the delegation was issued.
                    ///
                    ///The dispatch origin of this call must be _Signed_ and the signing account must be
                    ///currently delegating.
                    ///
                    ///Emits `Undelegated`.
                    ///
                    ///Weight: `O(R)` where R is the number of referendums the voter delegating to has
                    ///  voted on. Weight is charged as if maximum votes.
                    undelegate,
                    #[codec(index = 12)]
                    ///Clears all public proposals.
                    ///
                    ///The dispatch origin of this call must be _Root_.
                    ///
                    ///Weight: `O(1)`.
                    clear_public_proposals,
                    #[codec(index = 13)]
                    ///Unlock tokens that have an expired lock.
                    ///
                    ///The dispatch origin of this call must be _Signed_.
                    ///
                    ///- `target`: The account to remove the lock on.
                    ///
                    ///Weight: `O(R)` with R number of vote of target.
                    unlock {
                        target: ::subxt::utils::MultiAddress<
                            ::subxt::utils::AccountId32,
                            ::core::primitive::u32,
                        >,
                    },
                    #[codec(index = 14)]
                    ///Remove a vote for a referendum.
                    ///
                    ///If:
                    ///- the referendum was cancelled, or
                    ///- the referendum is ongoing, or
                    ///- the referendum has ended such that
                    ///  - the vote of the account was in opposition to the result; or
                    ///  - there was no conviction to the account's vote; or
                    ///  - the account made a split vote
                    ///...then the vote is removed cleanly and a following call to `unlock` may result in more
                    ///funds being available.
                    ///
                    ///If, however, the referendum has ended and:
                    ///- it finished corresponding to the vote of the account, and
                    ///- the account made a standard vote with conviction, and
                    ///- the lock period of the conviction is not over
                    ///...then the lock will be aggregated into the overall account's lock, which may involve
                    ///*overlocking* (where the two locks are combined into a single lock that is the maximum
                    ///of both the amount locked and the time is it locked for).
                    ///
                    ///The dispatch origin of this call must be _Signed_, and the signer must have a vote
                    ///registered for referendum `index`.
                    ///
                    ///- `index`: The index of referendum of the vote to be removed.
                    ///
                    ///Weight: `O(R + log R)` where R is the number of referenda that `target` has voted on.
                    ///  Weight is calculated for the maximum number of vote.
                    remove_vote { index: ::core::primitive::u32 },
                    #[codec(index = 15)]
                    ///Remove a vote for a referendum.
                    ///
                    ///If the `target` is equal to the signer, then this function is exactly equivalent to
                    ///`remove_vote`. If not equal to the signer, then the vote must have expired,
                    ///either because the referendum was cancelled, because the voter lost the referendum or
                    ///because the conviction period is over.
                    ///
                    ///The dispatch origin of this call must be _Signed_.
                    ///
                    ///- `target`: The account of the vote to be removed; this account must have voted for
                    ///  referendum `index`.
                    ///- `index`: The index of referendum of the vote to be removed.
                    ///
                    ///Weight: `O(R + log R)` where R is the number of referenda that `target` has voted on.
                    ///  Weight is calculated for the maximum number of vote.
                    remove_other_vote {
                        target: ::subxt::utils::MultiAddress<
                            ::subxt::utils::AccountId32,
                            ::core::primitive::u32,
                        >,
                        index: ::core::primitive::u32,
                    },
                    #[codec(index = 16)]
                    ///Permanently place a proposal into the blacklist. This prevents it from ever being
                    ///proposed again.
                    ///
                    ///If called on a queued public or external proposal, then this will result in it being
                    ///removed. If the `ref_index` supplied is an active referendum with the proposal hash,
                    ///then it will be cancelled.
                    ///
                    ///The dispatch origin of this call must be `BlacklistOrigin`.
                    ///
                    ///- `proposal_hash`: The proposal hash to blacklist permanently.
                    ///- `ref_index`: An ongoing referendum whose hash is `proposal_hash`, which will be
                    ///cancelled.
                    ///
                    ///Weight: `O(p)` (though as this is an high-privilege dispatch, we assume it has a
                    ///  reasonable value).
                    blacklist {
                        proposal_hash: ::subxt::utils::H256,
                        maybe_ref_index: ::core::option::Option<::core::primitive::u32>,
                    },
                    #[codec(index = 17)]
                    ///Remove a proposal.
                    ///
                    ///The dispatch origin of this call must be `CancelProposalOrigin`.
                    ///
                    ///- `prop_index`: The index of the proposal to cancel.
                    ///
                    ///Weight: `O(p)` where `p = PublicProps::<T>::decode_len()`
                    cancel_proposal {
                        #[codec(compact)]
                        prop_index: ::core::primitive::u32,
                    },
                    #[codec(index = 18)]
                    ///Set or clear a metadata of a proposal or a referendum.
                    ///
                    ///Parameters:
                    ///- `origin`: Must correspond to the `MetadataOwner`.
                    ///    - `ExternalOrigin` for an external proposal with the `SuperMajorityApprove`
                    ///      threshold.
                    ///    - `ExternalDefaultOrigin` for an external proposal with the `SuperMajorityAgainst`
                    ///      threshold.
                    ///    - `ExternalMajorityOrigin` for an external proposal with the `SimpleMajority`
                    ///      threshold.
                    ///    - `Signed` by a creator for a public proposal.
                    ///    - `Signed` to clear a metadata for a finished referendum.
                    ///    - `Root` to set a metadata for an ongoing referendum.
                    ///- `owner`: an identifier of a metadata owner.
                    ///- `maybe_hash`: The hash of an on-chain stored preimage. `None` to clear a metadata.
                    set_metadata {
                        owner: runtime_types::pallet_democracy::types::MetadataOwner,
                        maybe_hash: ::core::option::Option<::subxt::utils::H256>,
                    },
                }
                #[derive(
                    ::subxt::ext::codec::Decode,
                    ::subxt::ext::codec::Encode,
                    ::subxt::ext::scale_decode::DecodeAsType,
                    ::subxt::ext::scale_encode::EncodeAsType,
                    Clone,
                    Debug,
                    Eq,
                    PartialEq
                )]
                #[codec(crate = ::subxt::ext::codec)]
                #[decode_as_type(crate_path = ":: subxt :: ext :: scale_decode")]
                #[encode_as_type(crate_path = ":: subxt :: ext :: scale_encode")]
                /**
			Custom [dispatch errors](https://docs.substrate.io/main-docs/build/events-errors/)
			of this pallet.
			*/
                pub enum Error {
                    #[codec(index = 0)]
                    ///Value too low
                    ValueLow,
                    #[codec(index = 1)]
                    ///Proposal does not exist
                    ProposalMissing,
                    #[codec(index = 2)]
                    ///Cannot cancel the same proposal twice
                    AlreadyCanceled,
                    #[codec(index = 3)]
                    ///Proposal already made
                    DuplicateProposal,
                    #[codec(index = 4)]
                    ///Proposal still blacklisted
                    ProposalBlacklisted,
                    #[codec(index = 5)]
                    ///Next external proposal not simple majority
                    NotSimpleMajority,
                    #[codec(index = 6)]
                    ///Invalid hash
                    InvalidHash,
                    #[codec(index = 7)]
                    ///No external proposal
                    NoProposal,
                    #[codec(index = 8)]
                    ///Identity may not veto a proposal twice
                    AlreadyVetoed,
                    #[codec(index = 9)]
                    ///Vote given for invalid referendum
                    ReferendumInvalid,
                    #[codec(index = 10)]
                    ///No proposals waiting
                    NoneWaiting,
                    #[codec(index = 11)]
                    ///The given account did not vote on the referendum.
                    NotVoter,
                    #[codec(index = 12)]
                    ///The actor has no permission to conduct the action.
                    NoPermission,
                    #[codec(index = 13)]
                    ///The account is already delegating.
                    AlreadyDelegating,
                    #[codec(index = 14)]
                    ///Too high a balance was provided that the account cannot afford.
                    InsufficientFunds,
                    #[codec(index = 15)]
                    ///The account is not currently delegating.
                    NotDelegating,
                    #[codec(index = 16)]
                    ///The account currently has votes attached to it and the operation cannot succeed until
                    ///these are removed, either through `unvote` or `reap_vote`.
                    VotesExist,
                    #[codec(index = 17)]
                    ///The instant referendum origin is currently disallowed.
                    InstantNotAllowed,
                    #[codec(index = 18)]
                    ///Delegation to oneself makes no sense.
                    Nonsense,
                    #[codec(index = 19)]
                    ///Invalid upper bound.
                    WrongUpperBound,
                    #[codec(index = 20)]
                    ///Maximum number of votes reached.
                    MaxVotesReached,
                    #[codec(index = 21)]
                    ///Maximum number of items reached.
                    TooMany,
                    #[codec(index = 22)]
                    ///Voting period too low
                    VotingPeriodLow,
                    #[codec(index = 23)]
                    ///The preimage does not exist.
                    PreimageNotExist,
                }
                #[derive(
                    ::subxt::ext::codec::Decode,
                    ::subxt::ext::codec::Encode,
                    ::subxt::ext::scale_decode::DecodeAsType,
                    ::subxt::ext::scale_encode::EncodeAsType,
                    Clone,
                    Debug,
                    Eq,
                    PartialEq
                )]
                #[codec(crate = ::subxt::ext::codec)]
                #[decode_as_type(crate_path = ":: subxt :: ext :: scale_decode")]
                #[encode_as_type(crate_path = ":: subxt :: ext :: scale_encode")]
                /**
			The [event](https://docs.substrate.io/main-docs/build/events-errors/) emitted
			by this pallet.
			*/
                pub enum Event {
                    #[codec(index = 0)]
                    ///A motion has been proposed by a public account.
                    Proposed {
                        proposal_index: ::core::primitive::u32,
                        deposit: ::core::primitive::u128,
                    },
                    #[codec(index = 1)]
                    ///A public proposal has been tabled for referendum vote.
                    Tabled {
                        proposal_index: ::core::primitive::u32,
                        deposit: ::core::primitive::u128,
                    },
                    #[codec(index = 2)]
                    ///An external proposal has been tabled.
                    ExternalTabled,
                    #[codec(index = 3)]
                    ///A referendum has begun.
                    Started {
                        ref_index: ::core::primitive::u32,
                        threshold: runtime_types::pallet_democracy::vote_threshold::VoteThreshold,
                    },
                    #[codec(index = 4)]
                    ///A proposal has been approved by referendum.
                    Passed { ref_index: ::core::primitive::u32 },
                    #[codec(index = 5)]
                    ///A proposal has been rejected by referendum.
                    NotPassed { ref_index: ::core::primitive::u32 },
                    #[codec(index = 6)]
                    ///A referendum has been cancelled.
                    Cancelled { ref_index: ::core::primitive::u32 },
                    #[codec(index = 7)]
                    ///An account has delegated their vote to another account.
                    Delegated {
                        who: ::subxt::utils::AccountId32,
                        target: ::subxt::utils::AccountId32,
                    },
                    #[codec(index = 8)]
                    ///An account has cancelled a previous delegation operation.
                    Undelegated { account: ::subxt::utils::AccountId32 },
                    #[codec(index = 9)]
                    ///An external proposal has been vetoed.
                    Vetoed {
                        who: ::subxt::utils::AccountId32,
                        proposal_hash: ::subxt::utils::H256,
                        until: ::core::primitive::u32,
                    },
                    #[codec(index = 10)]
                    ///A proposal_hash has been blacklisted permanently.
                    Blacklisted { proposal_hash: ::subxt::utils::H256 },
                    #[codec(index = 11)]
                    ///An account has voted in a referendum
                    Voted {
                        voter: ::subxt::utils::AccountId32,
                        ref_index: ::core::primitive::u32,
                        vote: runtime_types::pallet_democracy::vote::AccountVote<
                            ::core::primitive::u128,
                        >,
                    },
                    #[codec(index = 12)]
                    ///An account has secconded a proposal
                    Seconded {
                        seconder: ::subxt::utils::AccountId32,
                        prop_index: ::core::primitive::u32,
                    },
                    #[codec(index = 13)]
                    ///A proposal got canceled.
                    ProposalCanceled { prop_index: ::core::primitive::u32 },
                    #[codec(index = 14)]
                    ///Metadata for a proposal or a referendum has been set.
                    MetadataSet {
                        owner: runtime_types::pallet_democracy::types::MetadataOwner,
                        hash: ::subxt::utils::H256,
                    },
                    #[codec(index = 15)]
                    ///Metadata for a proposal or a referendum has been cleared.
                    MetadataCleared {
                        owner: runtime_types::pallet_democracy::types::MetadataOwner,
                        hash: ::subxt::utils::H256,
                    },
                    #[codec(index = 16)]
                    ///Metadata has been transferred to new owner.
                    MetadataTransferred {
                        prev_owner: runtime_types::pallet_democracy::types::MetadataOwner,
                        owner: runtime_types::pallet_democracy::types::MetadataOwner,
                        hash: ::subxt::utils::H256,
                    },
                }
            }
            pub mod types {
                use super::runtime_types;
                #[derive(
                    ::subxt::ext::codec::Decode,
                    ::subxt::ext::codec::Encode,
                    ::subxt::ext::scale_decode::DecodeAsType,
                    ::subxt::ext::scale_encode::EncodeAsType,
                    Clone,
                    Debug,
                    Eq,
                    PartialEq
                )]
                #[codec(crate = ::subxt::ext::codec)]
                #[decode_as_type(crate_path = ":: subxt :: ext :: scale_decode")]
                #[encode_as_type(crate_path = ":: subxt :: ext :: scale_encode")]
                pub struct Delegations<_0> {
                    pub votes: _0,
                    pub capital: _0,
                }
                #[derive(
                    ::subxt::ext::codec::Decode,
                    ::subxt::ext::codec::Encode,
                    ::subxt::ext::scale_decode::DecodeAsType,
                    ::subxt::ext::scale_encode::EncodeAsType,
                    Clone,
                    Debug,
                    Eq,
                    PartialEq
                )]
                #[codec(crate = ::subxt::ext::codec)]
                #[decode_as_type(crate_path = ":: subxt :: ext :: scale_decode")]
                #[encode_as_type(crate_path = ":: subxt :: ext :: scale_encode")]
                pub enum MetadataOwner {
                    #[codec(index = 0)]
                    External,
                    #[codec(index = 1)]
                    Proposal(::core::primitive::u32),
                    #[codec(index = 2)]
                    Referendum(::core::primitive::u32),
                }
                #[derive(
                    ::subxt::ext::codec::Decode,
                    ::subxt::ext::codec::Encode,
                    ::subxt::ext::scale_decode::DecodeAsType,
                    ::subxt::ext::scale_encode::EncodeAsType,
                    Clone,
                    Debug,
                    Eq,
                    PartialEq
                )]
                #[codec(crate = ::subxt::ext::codec)]
                #[decode_as_type(crate_path = ":: subxt :: ext :: scale_decode")]
                #[encode_as_type(crate_path = ":: subxt :: ext :: scale_encode")]
                pub enum ReferendumInfo<_0, _1, _2> {
                    #[codec(index = 0)]
                    Ongoing(
                        runtime_types::pallet_democracy::types::ReferendumStatus<
                            _0,
                            _1,
                            _2,
                        >,
                    ),
                    #[codec(index = 1)]
                    Finished { approved: ::core::primitive::bool, end: _0 },
                }
                #[derive(
                    ::subxt::ext::codec::Decode,
                    ::subxt::ext::codec::Encode,
                    ::subxt::ext::scale_decode::DecodeAsType,
                    ::subxt::ext::scale_encode::EncodeAsType,
                    Clone,
                    Debug,
                    Eq,
                    PartialEq
                )]
                #[codec(crate = ::subxt::ext::codec)]
                #[decode_as_type(crate_path = ":: subxt :: ext :: scale_decode")]
                #[encode_as_type(crate_path = ":: subxt :: ext :: scale_encode")]
                pub struct ReferendumStatus<_0, _1, _2> {
                    pub end: _0,
                    pub proposal: _1,
                    pub threshold: runtime_types::pallet_democracy::vote_threshold::VoteThreshold,
                    pub delay: _0,
                    pub tally: runtime_types::pallet_democracy::types::Tally<_2>,
                }
                #[derive(
                    ::subxt::ext::codec::Decode,
                    ::subxt::ext::codec::Encode,
                    ::subxt::ext::scale_decode::DecodeAsType,
                    ::subxt::ext::scale_encode::EncodeAsType,
                    Clone,
                    Debug,
                    Eq,
                    PartialEq
                )]
                #[codec(crate = ::subxt::ext::codec)]
                #[decode_as_type(crate_path = ":: subxt :: ext :: scale_decode")]
                #[encode_as_type(crate_path = ":: subxt :: ext :: scale_encode")]
                pub struct Tally<_0> {
                    pub ayes: _0,
                    pub nays: _0,
                    pub turnout: _0,
                }
            }
            pub mod vote {
                use super::runtime_types;
                #[derive(
                    ::subxt::ext::codec::Decode,
                    ::subxt::ext::codec::Encode,
                    ::subxt::ext::scale_decode::DecodeAsType,
                    ::subxt::ext::scale_encode::EncodeAsType,
                    Clone,
                    Debug,
                    Eq,
                    PartialEq
                )]
                #[codec(crate = ::subxt::ext::codec)]
                #[decode_as_type(crate_path = ":: subxt :: ext :: scale_decode")]
                #[encode_as_type(crate_path = ":: subxt :: ext :: scale_encode")]
                pub enum AccountVote<_0> {
                    #[codec(index = 0)]
                    Standard {
                        vote: runtime_types::pallet_democracy::vote::Vote,
                        balance: _0,
                    },
                    #[codec(index = 1)]
                    Split { aye: _0, nay: _0 },
                }
                #[derive(
                    ::subxt::ext::codec::Decode,
                    ::subxt::ext::codec::Encode,
                    ::subxt::ext::scale_decode::DecodeAsType,
                    ::subxt::ext::scale_encode::EncodeAsType,
                    Clone,
                    Debug,
                    Eq,
                    PartialEq
                )]
                #[codec(crate = ::subxt::ext::codec)]
                #[decode_as_type(crate_path = ":: subxt :: ext :: scale_decode")]
                #[encode_as_type(crate_path = ":: subxt :: ext :: scale_encode")]
                pub struct PriorLock<_0, _1>(pub _0, pub _1);
                #[derive(
                    ::subxt::ext::codec::CompactAs,
                    ::subxt::ext::codec::Decode,
                    ::subxt::ext::codec::Encode,
                    ::subxt::ext::scale_decode::DecodeAsType,
                    ::subxt::ext::scale_encode::EncodeAsType,
                    Clone,
                    Debug,
                    Eq,
                    PartialEq
                )]
                #[codec(crate = ::subxt::ext::codec)]
                #[decode_as_type(crate_path = ":: subxt :: ext :: scale_decode")]
                #[encode_as_type(crate_path = ":: subxt :: ext :: scale_encode")]
                pub struct Vote(pub ::core::primitive::u8);
                #[derive(
                    ::subxt::ext::codec::Decode,
                    ::subxt::ext::codec::Encode,
                    ::subxt::ext::scale_decode::DecodeAsType,
                    ::subxt::ext::scale_encode::EncodeAsType,
                    Clone,
                    Debug,
                    Eq,
                    PartialEq
                )]
                #[codec(crate = ::subxt::ext::codec)]
                #[decode_as_type(crate_path = ":: subxt :: ext :: scale_decode")]
                #[encode_as_type(crate_path = ":: subxt :: ext :: scale_encode")]
                pub enum Voting<_0, _1, _2> {
                    #[codec(index = 0)]
                    Direct {
                        votes: runtime_types::bounded_collections::bounded_vec::BoundedVec<
                            (_2, runtime_types::pallet_democracy::vote::AccountVote<_0>),
                        >,
                        delegations: runtime_types::pallet_democracy::types::Delegations<
                            _0,
                        >,
                        prior: runtime_types::pallet_democracy::vote::PriorLock<_2, _0>,
                    },
                    #[codec(index = 1)]
                    Delegating {
                        balance: _0,
                        target: _1,
                        conviction: runtime_types::pallet_democracy::conviction::Conviction,
                        delegations: runtime_types::pallet_democracy::types::Delegations<
                            _0,
                        >,
                        prior: runtime_types::pallet_democracy::vote::PriorLock<_2, _0>,
                    },
                }
            }
            pub mod vote_threshold {
                use super::runtime_types;
                #[derive(
                    ::subxt::ext::codec::Decode,
                    ::subxt::ext::codec::Encode,
                    ::subxt::ext::scale_decode::DecodeAsType,
                    ::subxt::ext::scale_encode::EncodeAsType,
                    Clone,
                    Debug,
                    Eq,
                    PartialEq
                )]
                #[codec(crate = ::subxt::ext::codec)]
                #[decode_as_type(crate_path = ":: subxt :: ext :: scale_decode")]
                #[encode_as_type(crate_path = ":: subxt :: ext :: scale_encode")]
                pub enum VoteThreshold {
                    #[codec(index = 0)]
                    SuperMajorityApprove,
                    #[codec(index = 1)]
                    SuperMajorityAgainst,
                    #[codec(index = 2)]
                    SimpleMajority,
                }
            }
        }
        pub mod pallet_dkg_metadata {
            use super::runtime_types;
            pub mod pallet {
                use super::runtime_types;
                #[derive(
                    ::subxt::ext::codec::Decode,
                    ::subxt::ext::codec::Encode,
                    ::subxt::ext::scale_decode::DecodeAsType,
                    ::subxt::ext::scale_encode::EncodeAsType,
                    Clone,
                    Debug,
                    Eq,
                    PartialEq
                )]
                #[codec(crate = ::subxt::ext::codec)]
                #[decode_as_type(crate_path = ":: subxt :: ext :: scale_decode")]
                #[encode_as_type(crate_path = ":: subxt :: ext :: scale_encode")]
                ///Contains one variant per dispatchable that can be called by an extrinsic.
                pub enum Call {
                    #[codec(index = 0)]
                    ///Set the pending signature threshold for the session following the next session.
                    ///
                    ///We cannot assume that the next DKG has not already completed keygen.
                    ///After all, if we are in a new session the next DKG may have already completed.
                    ///Therefore, when we update the thresholds we are updating a threshold
                    ///that will become the next threshold after the next session update.
                    ///
                    ///* `origin` - The account origin.
                    ///* `new_threshold` - The new signature threshold for the DKG.
                    set_signature_threshold { new_threshold: ::core::primitive::u16 },
                    #[codec(index = 1)]
                    ///Set the pending keygen threshold for the session following the next session.
                    ///
                    ///We cannot assume that the next DKG has not already completed keygen.
                    ///After all, if we are in a new session the next DKG may have already completed.
                    ///Therefore, when we update the thresholds we are updating a threshold
                    ///that will become the next threshold after the next session update.
                    ///
                    ///* `origin` - The account origin.
                    ///* `new_threshold` - The new keygen threshold for the DKG.
                    set_keygen_threshold { new_threshold: ::core::primitive::u16 },
                    #[codec(index = 2)]
                    ///Submits and stores the active public key for the genesis session into the on-chain
                    ///storage. This is primarily used to separate the genesis public key submission from
                    ///non-genesis rounds.
                    ///
                    ///Can only be submitted by the current authorities. It is also required that a
                    ///`SignatureThreshold` of submissions is reached in order to successfully
                    ///store the public key on-chain.
                    ///
                    ///* `origin` - The account origin.
                    ///* `keys_and_signatures` - The aggregated public keys and signatures for possible current
                    ///  DKG public keys.
                    submit_public_key {
                        keys_and_signatures: runtime_types::dkg_runtime_primitives::AggregatedPublicKeys,
                    },
                    #[codec(index = 3)]
                    ///Submits and stores the next public key for the next session into the on-chain storage.
                    ///
                    ///Can only be submitted by the next authorities. It is also required that a
                    ///`NextSignatureThreshold` of submissions is reached in order to successfully
                    ///store the public key on-chain.
                    ///
                    ///* `origin` - The account origin.
                    ///* `keys_and_signatures` - The aggregated public keys and signatures for possible next
                    ///  DKG public keys.
                    submit_next_public_key {
                        keys_and_signatures: runtime_types::dkg_runtime_primitives::AggregatedPublicKeys,
                    },
                    #[codec(index = 5)]
                    ///Submits misbehaviour reports on chain. Signatures of the offending authority are
                    ///verified against the current or next authorities depending on the type of misbehaviour.
                    ///- Keygen: Verifies against the next authorities, since they are doing keygen.
                    ///- Signing: Verifies against the current authorities, since they are doing signing.
                    ///
                    ///Verifies the reports against the respective thresholds and if enough reports are met
                    ///begins to jail and decrease the reputation of the offending authority.
                    ///
                    ///The misbehaviour reputation update is:
                    ///	AUTHORITY_REPUTATION = DECAY_PERCENTAGE * AUTHORITY_REPUTATION
                    ///
                    ///If there are not enough unjailed keygen authorities to perform a keygen after the next
                    ///session, then we deduct the pending keygen threshold (and pending signing threshold)
                    ///accordingly.
                    ///
                    ///* `origin` - The account origin.
                    ///* `reports` - The aggregated misbehaviour reports containing signatures of an offending
                    ///  authority
                    submit_misbehaviour_reports {
                        reports: runtime_types::dkg_runtime_primitives::AggregatedMisbehaviourReports<
                            runtime_types::dkg_runtime_primitives::crypto::Public,
                            runtime_types::dkg_runtime_primitives::CustomU32Getter3,
                            runtime_types::dkg_runtime_primitives::CustomU32Getter4,
                        >,
                    },
                    #[codec(index = 6)]
                    ///Attempts to remove an authority from all possible jails (keygen & signing).
                    ///This can only be called by the controller of the authority in jail. The
                    ///origin must map directly to the authority in jail.
                    ///
                    ///The authority's jail sentence for either keygen or signing must be elapsed
                    ///for the authority to be removed from the jail.
                    ///
                    ///* `origin` - The account origin.
                    unjail,
                    #[codec(index = 7)]
                    ///Force removes an authority from keygen jail.
                    ///
                    ///Can only be called by DKG
                    ///* `origin` - The account origin.
                    ///* `authority` - The authority to be removed from the keygen jail.
                    force_unjail_keygen {
                        authority: runtime_types::dkg_runtime_primitives::crypto::Public,
                    },
                    #[codec(index = 8)]
                    ///Force removes an authority from signing jail.
                    ///
                    ///Can only be called by the root origin.
                    ///
                    ///* `origin` - The account origin.
                    ///* `authority` - The authority to be removed from the signing jail.
                    force_unjail_signing {
                        authority: runtime_types::dkg_runtime_primitives::crypto::Public,
                    },
                    #[codec(index = 9)]
                    ///Forcefully rotate the DKG
                    ///
                    ///This forces the next authorities into the current authority spot and
                    ///automatically increments the authority ID. It uses `change_authorities`
                    ///to execute the rotation forcefully.
                    force_change_authorities,
                    #[codec(index = 10)]
                    ///Triggers an Emergency Keygen Protocol.
                    ///
                    ///The keygen protocol will then be executed and the result will be stored in the off chain
                    ///storage, which will be picked up by the on chain worker and stored on chain.
                    ///
                    ///Note that, this will clear the next public key and its signature, if any.
                    trigger_emergency_keygen,
                }
                #[derive(
                    ::subxt::ext::codec::Decode,
                    ::subxt::ext::codec::Encode,
                    ::subxt::ext::scale_decode::DecodeAsType,
                    ::subxt::ext::scale_encode::EncodeAsType,
                    Clone,
                    Debug,
                    Eq,
                    PartialEq
                )]
                #[codec(crate = ::subxt::ext::codec)]
                #[decode_as_type(crate_path = ":: subxt :: ext :: scale_decode")]
                #[encode_as_type(crate_path = ":: subxt :: ext :: scale_encode")]
                /**
			Custom [dispatch errors](https://docs.substrate.io/main-docs/build/events-errors/)
			of this pallet.
			*/
                pub enum Error {
                    #[codec(index = 0)]
                    ///No mapped account to authority
                    NoMappedAccount,
                    #[codec(index = 1)]
                    ///Invalid threshold
                    InvalidThreshold,
                    #[codec(index = 2)]
                    ///Must be queued  to become an authority
                    MustBeAQueuedAuthority,
                    #[codec(index = 3)]
                    ///Must be an an authority
                    MustBeAnActiveAuthority,
                    #[codec(index = 4)]
                    ///Invalid public key submission
                    InvalidPublicKeys,
                    #[codec(index = 5)]
                    ///Already submitted a public key
                    AlreadySubmittedPublicKey,
                    #[codec(index = 6)]
                    ///Already submitted a public key signature
                    AlreadySubmittedSignature,
                    #[codec(index = 7)]
                    ///Used signature from past sessions
                    UsedSignature,
                    #[codec(index = 8)]
                    ///Invalid public key signature submission
                    InvalidSignature,
                    #[codec(index = 9)]
                    ///Invalid Nonece used, must be greater than [`refresh_nonce`].
                    InvalidNonce,
                    #[codec(index = 10)]
                    ///Invalid misbehaviour reports
                    InvalidMisbehaviourReports,
                    #[codec(index = 11)]
                    ///DKG Refresh is already in progress.
                    RefreshInProgress,
                    #[codec(index = 12)]
                    ///No current refresh active
                    NoRefreshProposal,
                    #[codec(index = 13)]
                    ///Invalid refresh proposal data
                    InvalidRefreshProposal,
                    #[codec(index = 14)]
                    ///No NextPublicKey stored on-chain.
                    NoNextPublicKey,
                    #[codec(index = 15)]
                    ///Must be calling from the controller account
                    InvalidControllerAccount,
                    #[codec(index = 16)]
                    ///Input is out of bounds
                    OutOfBounds,
                    #[codec(index = 17)]
                    ///Cannot retreive signer from ecdsa signature
                    CannotRetreiveSigner,
                    #[codec(index = 18)]
                    ///Proposal is not signed and should not be processed
                    ProposalNotSigned,
                    #[codec(index = 19)]
                    ///Reported misbehaviour against a non authority
                    OffenderNotAuthority,
                    #[codec(index = 20)]
                    ///Authority is already jailed
                    AlreadyJailed,
                    #[codec(index = 21)]
                    ///We do not have authorities to jail
                    NotEnoughAuthoritiesToJail,
                }
                #[derive(
                    ::subxt::ext::codec::Decode,
                    ::subxt::ext::codec::Encode,
                    ::subxt::ext::scale_decode::DecodeAsType,
                    ::subxt::ext::scale_encode::EncodeAsType,
                    Clone,
                    Debug,
                    Eq,
                    PartialEq
                )]
                #[codec(crate = ::subxt::ext::codec)]
                #[decode_as_type(crate_path = ":: subxt :: ext :: scale_decode")]
                #[encode_as_type(crate_path = ":: subxt :: ext :: scale_encode")]
                /**
			The [event](https://docs.substrate.io/main-docs/build/events-errors/) emitted
			by this pallet.
			*/
                pub enum Event {
                    #[codec(index = 0)]
                    ///Current public key submitted
                    PublicKeySubmitted {
                        compressed_pub_key: ::std::vec::Vec<::core::primitive::u8>,
                    },
                    #[codec(index = 1)]
                    ///Next public key submitted
                    NextPublicKeySubmitted {
                        compressed_pub_key: ::std::vec::Vec<::core::primitive::u8>,
                    },
                    #[codec(index = 2)]
                    ///Next public key signature submitted
                    NextPublicKeySignatureSubmitted {
                        voter_merkle_root: [::core::primitive::u8; 32usize],
                        session_length: ::core::primitive::u64,
                        voter_count: ::core::primitive::u32,
                        nonce: runtime_types::webb_proposals::nonce::Nonce,
                        pub_key: ::std::vec::Vec<::core::primitive::u8>,
                        signature: ::std::vec::Vec<::core::primitive::u8>,
                    },
                    #[codec(index = 3)]
                    ///Current Public Key Changed.
                    PublicKeyChanged {
                        compressed_pub_key: ::std::vec::Vec<::core::primitive::u8>,
                    },
                    #[codec(index = 4)]
                    ///Current Public Key Signature Changed.
                    PublicKeySignatureChanged {
                        voter_merkle_root: [::core::primitive::u8; 32usize],
                        session_length: ::core::primitive::u64,
                        voter_count: ::core::primitive::u32,
                        nonce: runtime_types::webb_proposals::nonce::Nonce,
                        pub_key: ::std::vec::Vec<::core::primitive::u8>,
                        signature: ::std::vec::Vec<::core::primitive::u8>,
                    },
                    #[codec(index = 5)]
                    ///Misbehaviour reports submitted
                    MisbehaviourReportsSubmitted {
                        misbehaviour_type: runtime_types::dkg_runtime_primitives::MisbehaviourType,
                        reporters: ::std::vec::Vec<
                            runtime_types::dkg_runtime_primitives::crypto::Public,
                        >,
                        offender: runtime_types::dkg_runtime_primitives::crypto::Public,
                    },
                    #[codec(index = 6)]
                    ///Proposer votes submitted
                    ProposerSetVotesSubmitted {
                        voters: ::std::vec::Vec<
                            runtime_types::dkg_runtime_primitives::crypto::Public,
                        >,
                        signatures: ::std::vec::Vec<
                            ::std::vec::Vec<::core::primitive::u8>,
                        >,
                        vote: ::std::vec::Vec<::core::primitive::u8>,
                    },
                    #[codec(index = 7)]
                    ///Refresh DKG Keys Finished (forcefully).
                    RefreshKeysFinished {
                        next_authority_set_id: ::core::primitive::u64,
                    },
                    #[codec(index = 8)]
                    ///NextKeygenThreshold updated
                    NextKeygenThresholdUpdated {
                        next_keygen_threshold: ::core::primitive::u16,
                    },
                    #[codec(index = 9)]
                    ///NextSignatureThreshold updated
                    NextSignatureThresholdUpdated {
                        next_signature_threshold: ::core::primitive::u16,
                    },
                    #[codec(index = 10)]
                    ///PendingKeygenThreshold updated
                    PendingKeygenThresholdUpdated {
                        pending_keygen_threshold: ::core::primitive::u16,
                    },
                    #[codec(index = 11)]
                    ///PendingSignatureThreshold updated
                    PendingSignatureThresholdUpdated {
                        pending_signature_threshold: ::core::primitive::u16,
                    },
                    #[codec(index = 12)]
                    ///An Emergency Keygen Protocol was triggered.
                    EmergencyKeygenTriggered,
                    #[codec(index = 13)]
                    ///An authority has been jailed for misbehaviour
                    AuthorityJailed {
                        misbehaviour_type: runtime_types::dkg_runtime_primitives::MisbehaviourType,
                        authority: runtime_types::dkg_runtime_primitives::crypto::Public,
                    },
                    #[codec(index = 14)]
                    ///An authority has been unjailed
                    AuthorityUnJailed {
                        authority: runtime_types::dkg_runtime_primitives::crypto::Public,
                    },
                }
            }
            pub mod types {
                use super::runtime_types;
                #[derive(
                    ::subxt::ext::codec::Decode,
                    ::subxt::ext::codec::Encode,
                    ::subxt::ext::scale_decode::DecodeAsType,
                    ::subxt::ext::scale_encode::EncodeAsType,
                    Clone,
                    Debug,
                    Eq,
                    PartialEq
                )]
                #[codec(crate = ::subxt::ext::codec)]
                #[decode_as_type(crate_path = ":: subxt :: ext :: scale_decode")]
                #[encode_as_type(crate_path = ":: subxt :: ext :: scale_encode")]
                pub struct RoundMetadata<_0, _1> {
                    pub curr_round_pub_key: runtime_types::bounded_collections::bounded_vec::BoundedVec<
                        ::core::primitive::u8,
                    >,
                    pub next_round_pub_key: runtime_types::bounded_collections::bounded_vec::BoundedVec<
                        ::core::primitive::u8,
                    >,
                    pub refresh_signature: runtime_types::bounded_collections::bounded_vec::BoundedVec<
                        ::core::primitive::u8,
                    >,
                    #[codec(skip)]
                    pub __subxt_unused_type_params: ::core::marker::PhantomData<
                        (_0, _1),
                    >,
                }
            }
        }
        pub mod pallet_dkg_proposal_handler {
            use super::runtime_types;
            pub mod pallet {
                use super::runtime_types;
                #[derive(
                    ::subxt::ext::codec::Decode,
                    ::subxt::ext::codec::Encode,
                    ::subxt::ext::scale_decode::DecodeAsType,
                    ::subxt::ext::scale_encode::EncodeAsType,
                    Clone,
                    Debug,
                    Eq,
                    PartialEq
                )]
                #[codec(crate = ::subxt::ext::codec)]
                #[decode_as_type(crate_path = ":: subxt :: ext :: scale_decode")]
                #[encode_as_type(crate_path = ":: subxt :: ext :: scale_encode")]
                ///Contains one variant per dispatchable that can be called by an extrinsic.
                pub enum Call {
                    #[codec(index = 0)]
                    submit_signed_proposals {
                        props: ::std::vec::Vec<
                            runtime_types::dkg_runtime_primitives::proposal::SignedProposalBatch<
                                ::core::primitive::u32,
                                runtime_types::dkg_runtime_primitives::CustomU32Getter,
                                runtime_types::dkg_runtime_primitives::CustomU32Getter2,
                                runtime_types::dkg_runtime_primitives::CustomU32Getter3,
                            >,
                        >,
                    },
                    #[codec(index = 1)]
                    ///Force submit an unsigned proposal to the DKG
                    ///
                    ///There are certain proposals we'd like to be proposable only
                    ///through root actions. The currently supported proposals are
                    ///	1. Updating
                    force_submit_unsigned_proposal {
                        prop: runtime_types::webb_proposals::proposal::Proposal<
                            runtime_types::dkg_runtime_primitives::CustomU32Getter,
                        >,
                    },
                }
                #[derive(
                    ::subxt::ext::codec::Decode,
                    ::subxt::ext::codec::Encode,
                    ::subxt::ext::scale_decode::DecodeAsType,
                    ::subxt::ext::scale_encode::EncodeAsType,
                    Clone,
                    Debug,
                    Eq,
                    PartialEq
                )]
                #[codec(crate = ::subxt::ext::codec)]
                #[decode_as_type(crate_path = ":: subxt :: ext :: scale_decode")]
                #[encode_as_type(crate_path = ":: subxt :: ext :: scale_encode")]
                /**
			Custom [dispatch errors](https://docs.substrate.io/main-docs/build/events-errors/)
			of this pallet.
			*/
                pub enum Error {
                    #[codec(index = 0)]
                    ///Error names should be descriptive.
                    NoneValue,
                    #[codec(index = 1)]
                    ///Errors should have helpful documentation associated with them.
                    StorageOverflow,
                    #[codec(index = 2)]
                    ///Proposal format is invalid
                    ProposalFormatInvalid,
                    #[codec(index = 3)]
                    ///Proposal must be unsigned
                    ProposalMustBeUnsigned,
                    #[codec(index = 4)]
                    ///Proposal bytes length is invalid
                    InvalidProposalBytesLength,
                    #[codec(index = 5)]
                    ///Proposal signature is invalid
                    ProposalSignatureInvalid,
                    #[codec(index = 6)]
                    ///No proposal with the ID was found
                    ProposalDoesNotExists,
                    #[codec(index = 7)]
                    ///Proposal with the ID has already been submitted
                    ProposalAlreadyExists,
                    #[codec(index = 8)]
                    ///Chain id is invalid
                    ChainIdInvalid,
                    #[codec(index = 9)]
                    ///Proposal length exceeds max allowed per batch
                    ProposalsLengthOverflow,
                    #[codec(index = 10)]
                    ///Proposal out of bounds
                    ProposalOutOfBounds,
                    #[codec(index = 11)]
                    ///Duplicate signed proposal
                    CannotOverwriteSignedProposal,
                    #[codec(index = 12)]
                    ///Unable to accept new unsigned proposal
                    UnsignedProposalQueueOverflow,
                    #[codec(index = 13)]
                    ///Math overflow
                    ArithmeticOverflow,
                    #[codec(index = 14)]
                    ///Batch does not contain proposals
                    EmptyBatch,
                }
                #[derive(
                    ::subxt::ext::codec::Decode,
                    ::subxt::ext::codec::Encode,
                    ::subxt::ext::scale_decode::DecodeAsType,
                    ::subxt::ext::scale_encode::EncodeAsType,
                    Clone,
                    Debug,
                    Eq,
                    PartialEq
                )]
                #[codec(crate = ::subxt::ext::codec)]
                #[decode_as_type(crate_path = ":: subxt :: ext :: scale_decode")]
                #[encode_as_type(crate_path = ":: subxt :: ext :: scale_encode")]
                /**
			The [event](https://docs.substrate.io/main-docs/build/events-errors/) emitted
			by this pallet.
			*/
                pub enum Event {
                    #[codec(index = 0)]
                    ///RuntimeEvent Emitted when we encounter a Proposal with invalid Signature.
                    InvalidProposalBatchSignature {
                        proposals: runtime_types::dkg_runtime_primitives::proposal::SignedProposalBatch<
                            ::core::primitive::u32,
                            runtime_types::dkg_runtime_primitives::CustomU32Getter,
                            runtime_types::dkg_runtime_primitives::CustomU32Getter2,
                            runtime_types::dkg_runtime_primitives::CustomU32Getter3,
                        >,
                        data: ::std::vec::Vec<::core::primitive::u8>,
                        invalid_signature: ::std::vec::Vec<::core::primitive::u8>,
                        expected_public_key: ::core::option::Option<
                            ::std::vec::Vec<::core::primitive::u8>,
                        >,
                        actual_public_key: ::core::option::Option<
                            ::std::vec::Vec<::core::primitive::u8>,
                        >,
                    },
                    #[codec(index = 1)]
                    ///RuntimeEvent When a Proposal is added to UnsignedProposalQueue.
                    ProposalAdded {
                        key: runtime_types::dkg_runtime_primitives::proposal::DKGPayloadKey,
                        target_chain: runtime_types::webb_proposals::header::TypedChainId,
                        data: ::std::vec::Vec<::core::primitive::u8>,
                    },
                    #[codec(index = 2)]
                    ///RuntimeEvent When a Proposal is removed from UnsignedProposalQueue.
                    ProposalRemoved {
                        key: runtime_types::dkg_runtime_primitives::proposal::DKGPayloadKey,
                        target_chain: runtime_types::webb_proposals::header::TypedChainId,
                        expired: ::core::primitive::bool,
                    },
                    #[codec(index = 3)]
                    ///RuntimeEvent When a Proposal Gets Signed by DKG.
                    ProposalBatchSigned {
                        target_chain: runtime_types::webb_proposals::header::TypedChainId,
                        batch_id: ::core::primitive::u32,
                        proposals: ::std::vec::Vec<
                            runtime_types::pallet_dkg_proposal_handler::pallet::SignedProposalEventData,
                        >,
                        signature: ::std::vec::Vec<::core::primitive::u8>,
                    },
                }
                #[derive(
                    ::subxt::ext::codec::Decode,
                    ::subxt::ext::codec::Encode,
                    ::subxt::ext::scale_decode::DecodeAsType,
                    ::subxt::ext::scale_encode::EncodeAsType,
                    Clone,
                    Debug,
                    Eq,
                    PartialEq
                )]
                #[codec(crate = ::subxt::ext::codec)]
                #[decode_as_type(crate_path = ":: subxt :: ext :: scale_decode")]
                #[encode_as_type(crate_path = ":: subxt :: ext :: scale_encode")]
                pub struct SignedProposalEventData {
                    pub kind: runtime_types::webb_proposals::proposal::ProposalKind,
                    pub data: ::std::vec::Vec<::core::primitive::u8>,
                }
            }
        }
        pub mod pallet_dkg_proposals {
            use super::runtime_types;
            pub mod pallet {
                use super::runtime_types;
                #[derive(
                    ::subxt::ext::codec::Decode,
                    ::subxt::ext::codec::Encode,
                    ::subxt::ext::scale_decode::DecodeAsType,
                    ::subxt::ext::scale_encode::EncodeAsType,
                    Clone,
                    Debug,
                    Eq,
                    PartialEq
                )]
                #[codec(crate = ::subxt::ext::codec)]
                #[decode_as_type(crate_path = ":: subxt :: ext :: scale_decode")]
                #[encode_as_type(crate_path = ":: subxt :: ext :: scale_encode")]
                ///Contains one variant per dispatchable that can be called by an extrinsic.
                pub enum Call {
                    #[codec(index = 0)]
                    ///Sets the vote threshold for proposals.
                    ///
                    ///This threshold is used to determine how many votes are required
                    ///before a proposal is executed.
                    ///
                    ///# <weight>
                    ///- O(1) lookup and insert
                    ///# </weight>
                    set_threshold { threshold: ::core::primitive::u32 },
                    #[codec(index = 1)]
                    ///Stores a method name on chain under an associated resource ID.
                    ///
                    ///# <weight>
                    ///- O(1) write
                    ///# </weight>
                    set_resource {
                        id: runtime_types::webb_proposals::header::ResourceId,
                        method: ::std::vec::Vec<::core::primitive::u8>,
                    },
                    #[codec(index = 2)]
                    ///Removes a resource ID from the resource mapping.
                    ///
                    ///After this call, bridge transfers with the associated resource ID
                    ///will be rejected.
                    ///
                    ///# <weight>
                    ///- O(1) removal
                    ///# </weight>
                    remove_resource {
                        id: runtime_types::webb_proposals::header::ResourceId,
                    },
                    #[codec(index = 3)]
                    ///Enables a chain ID as a source or destination for a bridge transfer.
                    ///
                    ///# <weight>
                    ///- O(1) lookup and insert
                    ///# </weight>
                    whitelist_chain {
                        chain_id: runtime_types::webb_proposals::header::TypedChainId,
                    },
                    #[codec(index = 4)]
                    ///Commits a vote in favour of the provided proposal.
                    ///
                    ///If a proposal with the given nonce and source chain ID does not
                    ///already exist, it will be created with an initial vote in favour
                    ///from the caller.
                    ///
                    ///# <weight>
                    ///- weight of proposed call, regardless of whether execution is performed
                    ///# </weight>
                    acknowledge_proposal {
                        prop: runtime_types::webb_proposals::proposal::Proposal<
                            runtime_types::dkg_runtime_primitives::CustomU32Getter,
                        >,
                    },
                    #[codec(index = 5)]
                    ///Commits a vote against a provided proposal.
                    ///
                    ///# <weight>
                    ///- Fixed, since execution of proposal should not be included
                    ///# </weight>
                    reject_proposal {
                        prop: runtime_types::webb_proposals::proposal::Proposal<
                            runtime_types::dkg_runtime_primitives::CustomU32Getter,
                        >,
                    },
                    #[codec(index = 6)]
                    ///Evaluate the state of a proposal given the current vote threshold.
                    ///
                    ///A proposal with enough votes will be either executed or cancelled,
                    ///and the status will be updated accordingly.
                    ///
                    ///# <weight>
                    ///- weight of proposed call, regardless of whether execution is performed
                    ///# </weight>
                    eval_vote_state {
                        nonce: runtime_types::webb_proposals::nonce::Nonce,
                        src_chain_id: runtime_types::webb_proposals::header::TypedChainId,
                        prop: runtime_types::webb_proposals::proposal::Proposal<
                            runtime_types::dkg_runtime_primitives::CustomU32Getter,
                        >,
                    },
                }
                #[derive(
                    ::subxt::ext::codec::Decode,
                    ::subxt::ext::codec::Encode,
                    ::subxt::ext::scale_decode::DecodeAsType,
                    ::subxt::ext::scale_encode::EncodeAsType,
                    Clone,
                    Debug,
                    Eq,
                    PartialEq
                )]
                #[codec(crate = ::subxt::ext::codec)]
                #[decode_as_type(crate_path = ":: subxt :: ext :: scale_decode")]
                #[encode_as_type(crate_path = ":: subxt :: ext :: scale_encode")]
                /**
			Custom [dispatch errors](https://docs.substrate.io/main-docs/build/events-errors/)
			of this pallet.
			*/
                pub enum Error {
                    #[codec(index = 0)]
                    ///Account does not have correct permissions
                    InvalidPermissions,
                    #[codec(index = 1)]
                    ///Proposer threshold not set
                    ThresholdNotSet,
                    #[codec(index = 2)]
                    ///Provided chain Id is not valid
                    InvalidChainId,
                    #[codec(index = 3)]
                    ///Proposer threshold cannot be 0
                    InvalidThreshold,
                    #[codec(index = 4)]
                    ///Interactions with this chain is not permitted
                    ChainNotWhitelisted,
                    #[codec(index = 5)]
                    ///Chain has already been enabled
                    ChainAlreadyWhitelisted,
                    #[codec(index = 6)]
                    ///Resource ID provided isn't mapped to anything
                    ResourceDoesNotExist,
                    #[codec(index = 7)]
                    ///Proposer already in set
                    ProposerAlreadyExists,
                    #[codec(index = 8)]
                    ///Provided accountId is not a proposer
                    ProposerInvalid,
                    #[codec(index = 9)]
                    ///Protected operation, must be performed by proposer
                    MustBeProposer,
                    #[codec(index = 10)]
                    ///Proposer has already submitted some vote for this proposal
                    ProposerAlreadyVoted,
                    #[codec(index = 11)]
                    ///A proposal with these parameters has already been submitted
                    ProposalAlreadyExists,
                    #[codec(index = 12)]
                    ///No proposal with the ID was found
                    ProposalDoesNotExist,
                    #[codec(index = 13)]
                    ///Cannot complete proposal, needs more votes
                    ProposalNotComplete,
                    #[codec(index = 14)]
                    ///Proposal has either failed or succeeded
                    ProposalAlreadyComplete,
                    #[codec(index = 15)]
                    ///Lifetime of proposal has been exceeded
                    ProposalExpired,
                    #[codec(index = 16)]
                    ///Proposer Count is Zero
                    ProposerCountIsZero,
                    #[codec(index = 17)]
                    ///Input is out of bounds
                    OutOfBounds,
                    #[codec(index = 18)]
                    ///Invalid proposal
                    InvalidProposal,
                }
                #[derive(
                    ::subxt::ext::codec::Decode,
                    ::subxt::ext::codec::Encode,
                    ::subxt::ext::scale_decode::DecodeAsType,
                    ::subxt::ext::scale_encode::EncodeAsType,
                    Clone,
                    Debug,
                    Eq,
                    PartialEq
                )]
                #[codec(crate = ::subxt::ext::codec)]
                #[decode_as_type(crate_path = ":: subxt :: ext :: scale_decode")]
                #[encode_as_type(crate_path = ":: subxt :: ext :: scale_encode")]
                /**
			The [event](https://docs.substrate.io/main-docs/build/events-errors/) emitted
			by this pallet.
			*/
                pub enum Event {
                    #[codec(index = 0)]
                    ///Vote threshold has changed (new_threshold)
                    ProposerThresholdChanged { new_threshold: ::core::primitive::u32 },
                    #[codec(index = 1)]
                    ///Chain now available for transfers (chain_id)
                    ChainWhitelisted {
                        chain_id: runtime_types::webb_proposals::header::TypedChainId,
                    },
                    #[codec(index = 2)]
                    ///Vote submitted in favour of proposal
                    VoteFor {
                        kind: runtime_types::webb_proposals::proposal::ProposalKind,
                        src_chain_id: runtime_types::webb_proposals::header::TypedChainId,
                        proposal_nonce: runtime_types::webb_proposals::nonce::Nonce,
                        who: ::subxt::utils::AccountId32,
                    },
                    #[codec(index = 3)]
                    ///Vot submitted against proposal
                    VoteAgainst {
                        kind: runtime_types::webb_proposals::proposal::ProposalKind,
                        src_chain_id: runtime_types::webb_proposals::header::TypedChainId,
                        proposal_nonce: runtime_types::webb_proposals::nonce::Nonce,
                        who: ::subxt::utils::AccountId32,
                    },
                    #[codec(index = 4)]
                    ///Voting successful for a proposal
                    ProposalApproved {
                        kind: runtime_types::webb_proposals::proposal::ProposalKind,
                        src_chain_id: runtime_types::webb_proposals::header::TypedChainId,
                        proposal_nonce: runtime_types::webb_proposals::nonce::Nonce,
                    },
                    #[codec(index = 5)]
                    ///Voting rejected a proposal
                    ProposalRejected {
                        kind: runtime_types::webb_proposals::proposal::ProposalKind,
                        src_chain_id: runtime_types::webb_proposals::header::TypedChainId,
                        proposal_nonce: runtime_types::webb_proposals::nonce::Nonce,
                    },
                    #[codec(index = 6)]
                    ///Execution of call succeeded
                    ProposalSucceeded {
                        kind: runtime_types::webb_proposals::proposal::ProposalKind,
                        src_chain_id: runtime_types::webb_proposals::header::TypedChainId,
                        proposal_nonce: runtime_types::webb_proposals::nonce::Nonce,
                    },
                    #[codec(index = 7)]
                    ///Execution of call failed
                    ProposalFailed {
                        kind: runtime_types::webb_proposals::proposal::ProposalKind,
                        src_chain_id: runtime_types::webb_proposals::header::TypedChainId,
                        proposal_nonce: runtime_types::webb_proposals::nonce::Nonce,
                    },
                    #[codec(index = 8)]
                    ///Proposers have been reset
                    ProposersReset {
                        proposers: ::std::vec::Vec<::subxt::utils::AccountId32>,
                    },
                }
            }
            pub mod types {
                use super::runtime_types;
                #[derive(
                    ::subxt::ext::codec::Decode,
                    ::subxt::ext::codec::Encode,
                    ::subxt::ext::scale_decode::DecodeAsType,
                    ::subxt::ext::scale_encode::EncodeAsType,
                    Clone,
                    Debug,
                    Eq,
                    PartialEq
                )]
                #[codec(crate = ::subxt::ext::codec)]
                #[decode_as_type(crate_path = ":: subxt :: ext :: scale_decode")]
                #[encode_as_type(crate_path = ":: subxt :: ext :: scale_encode")]
                pub enum ProposalStatus {
                    #[codec(index = 0)]
                    Initiated,
                    #[codec(index = 1)]
                    Approved,
                    #[codec(index = 2)]
                    Rejected,
                }
                #[derive(
                    ::subxt::ext::codec::Decode,
                    ::subxt::ext::codec::Encode,
                    ::subxt::ext::scale_decode::DecodeAsType,
                    ::subxt::ext::scale_encode::EncodeAsType,
                    Clone,
                    Debug,
                    Eq,
                    PartialEq
                )]
                #[codec(crate = ::subxt::ext::codec)]
                #[decode_as_type(crate_path = ":: subxt :: ext :: scale_decode")]
                #[encode_as_type(crate_path = ":: subxt :: ext :: scale_encode")]
                pub struct ProposalVotes<_0, _1, _2> {
                    pub votes_for: runtime_types::bounded_collections::bounded_vec::BoundedVec<
                        _0,
                    >,
                    pub votes_against: runtime_types::bounded_collections::bounded_vec::BoundedVec<
                        _0,
                    >,
                    pub status: runtime_types::pallet_dkg_proposals::types::ProposalStatus,
                    pub expiry: _1,
                    #[codec(skip)]
                    pub __subxt_unused_type_params: ::core::marker::PhantomData<_2>,
                }
            }
        }
        pub mod pallet_dynamic_fee {
            use super::runtime_types;
            pub mod pallet {
                use super::runtime_types;
                #[derive(
                    ::subxt::ext::codec::Decode,
                    ::subxt::ext::codec::Encode,
                    ::subxt::ext::scale_decode::DecodeAsType,
                    ::subxt::ext::scale_encode::EncodeAsType,
                    Clone,
                    Debug,
                    Eq,
                    PartialEq
                )]
                #[codec(crate = ::subxt::ext::codec)]
                #[decode_as_type(crate_path = ":: subxt :: ext :: scale_decode")]
                #[encode_as_type(crate_path = ":: subxt :: ext :: scale_encode")]
                ///Contains one variant per dispatchable that can be called by an extrinsic.
                pub enum Call {
                    #[codec(index = 0)]
                    note_min_gas_price_target {
                        target: runtime_types::primitive_types::U256,
                    },
                }
            }
        }
        pub mod pallet_ecdsa_claims {
            use super::runtime_types;
            pub mod pallet {
                use super::runtime_types;
                #[derive(
                    ::subxt::ext::codec::Decode,
                    ::subxt::ext::codec::Encode,
                    ::subxt::ext::scale_decode::DecodeAsType,
                    ::subxt::ext::scale_encode::EncodeAsType,
                    Clone,
                    Debug,
                    Eq,
                    PartialEq
                )]
                #[codec(crate = ::subxt::ext::codec)]
                #[decode_as_type(crate_path = ":: subxt :: ext :: scale_decode")]
                #[encode_as_type(crate_path = ":: subxt :: ext :: scale_encode")]
                ///Contains one variant per dispatchable that can be called by an extrinsic.
                pub enum Call {
                    #[codec(index = 0)]
                    ///Make a claim to collect your WEBBs.
                    ///
                    ///The dispatch origin for this call must be _None_.
                    ///
                    ///Unsigned Validation:
                    ///A call to claim is deemed valid if the signature provided matches
                    ///the expected signed message of:
                    ///
                    ///> Ethereum Signed Message:
                    ///> (configured prefix string)(address)
                    ///
                    ///and `address` matches the `dest` account.
                    ///
                    ///Parameters:
                    ///- `dest`: The destination account to payout the claim.
                    ///- `ethereum_signature`: The signature of an ethereum signed message matching the format
                    ///  described above.
                    ///
                    ///<weight>
                    ///The weight of this call is invariant over the input parameters.
                    ///Weight includes logic to validate unsigned `claim` call.
                    ///
                    ///Total Complexity: O(1)
                    ///</weight>
                    claim {
                        dest: ::subxt::utils::AccountId32,
                        ethereum_signature: runtime_types::pallet_ecdsa_claims::EcdsaSignature,
                    },
                    #[codec(index = 1)]
                    ///Mint a new claim to collect WEBBs.
                    ///
                    ///The dispatch origin for this call must be _Root_.
                    ///
                    ///Parameters:
                    ///- `who`: The Ethereum address allowed to collect this claim.
                    ///- `value`: The number of WEBBs that will be claimed.
                    ///- `vesting_schedule`: An optional vesting schedule for these WEBBs.
                    ///
                    ///<weight>
                    ///The weight of this call is invariant over the input parameters.
                    ///We assume worst case that both vesting and statement is being inserted.
                    ///
                    ///Total Complexity: O(1)
                    ///</weight>
                    mint_claim {
                        who: runtime_types::pallet_ecdsa_claims::EthereumAddress,
                        value: ::core::primitive::u128,
                        vesting_schedule: ::core::option::Option<
                            (
                                ::core::primitive::u128,
                                ::core::primitive::u128,
                                ::core::primitive::u32,
                            ),
                        >,
                        statement: ::core::option::Option<
                            runtime_types::pallet_ecdsa_claims::StatementKind,
                        >,
                    },
                    #[codec(index = 2)]
                    ///Make a claim to collect your WEBBs by signing a statement.
                    ///
                    ///The dispatch origin for this call must be _None_.
                    ///
                    ///Unsigned Validation:
                    ///A call to `claim_attest` is deemed valid if the signature provided matches
                    ///the expected signed message of:
                    ///
                    ///> Ethereum Signed Message:
                    ///> (configured prefix string)(address)(statement)
                    ///
                    ///and `address` matches the `dest` account; the `statement` must match that which is
                    ///expected according to your purchase arrangement.
                    ///
                    ///Parameters:
                    ///- `dest`: The destination account to payout the claim.
                    ///- `ethereum_signature`: The signature of an ethereum signed message matching the format
                    ///  described above.
                    ///- `statement`: The identity of the statement which is being attested to in the
                    ///  signature.
                    ///
                    ///<weight>
                    ///The weight of this call is invariant over the input parameters.
                    ///Weight includes logic to validate unsigned `claim_attest` call.
                    ///
                    ///Total Complexity: O(1)
                    ///</weight>
                    claim_attest {
                        dest: ::subxt::utils::AccountId32,
                        ethereum_signature: runtime_types::pallet_ecdsa_claims::EcdsaSignature,
                        statement: ::std::vec::Vec<::core::primitive::u8>,
                    },
                    #[codec(index = 3)]
                    ///Attest to a statement, needed to finalize the claims process.
                    ///
                    ///WARNING: Insecure unless your chain includes `PrevalidateAttests` as a
                    ///`SignedExtension`.
                    ///
                    ///Unsigned Validation:
                    ///A call to attest is deemed valid if the sender has a `Preclaim` registered
                    ///and provides a `statement` which is expected for the account.
                    ///
                    ///Parameters:
                    ///- `statement`: The identity of the statement which is being attested to in the
                    ///  signature.
                    ///
                    ///<weight>
                    ///The weight of this call is invariant over the input parameters.
                    ///Weight includes logic to do pre-validation on `attest` call.
                    ///
                    ///Total Complexity: O(1)
                    ///</weight>
                    attest { statement: ::std::vec::Vec<::core::primitive::u8> },
                    #[codec(index = 4)]
                    move_claim {
                        old: runtime_types::pallet_ecdsa_claims::EthereumAddress,
                        new: runtime_types::pallet_ecdsa_claims::EthereumAddress,
                        maybe_preclaim: ::core::option::Option<
                            ::subxt::utils::AccountId32,
                        >,
                    },
                    #[codec(index = 5)]
                    ///Set the value for expiryconfig
                    ///Can only be called by ForceOrigin
                    force_set_expiry_config {
                        expiry_block: ::core::primitive::u32,
                        dest: ::subxt::utils::AccountId32,
                    },
                }
                #[derive(
                    ::subxt::ext::codec::Decode,
                    ::subxt::ext::codec::Encode,
                    ::subxt::ext::scale_decode::DecodeAsType,
                    ::subxt::ext::scale_encode::EncodeAsType,
                    Clone,
                    Debug,
                    Eq,
                    PartialEq
                )]
                #[codec(crate = ::subxt::ext::codec)]
                #[decode_as_type(crate_path = ":: subxt :: ext :: scale_decode")]
                #[encode_as_type(crate_path = ":: subxt :: ext :: scale_encode")]
                /**
			Custom [dispatch errors](https://docs.substrate.io/main-docs/build/events-errors/)
			of this pallet.
			*/
                pub enum Error {
                    #[codec(index = 0)]
                    ///Invalid Ethereum signature.
                    InvalidEthereumSignature,
                    #[codec(index = 1)]
                    ///Ethereum address has no claim.
                    SignerHasNoClaim,
                    #[codec(index = 2)]
                    ///Account ID sending transaction has no claim.
                    SenderHasNoClaim,
                    #[codec(index = 3)]
                    ///There's not enough in the pot to pay out some unvested amount. Generally implies a
                    ///logic error.
                    PotUnderflow,
                    #[codec(index = 4)]
                    ///A needed statement was not included.
                    InvalidStatement,
                    #[codec(index = 5)]
                    ///The account already has a vested balance.
                    VestedBalanceExists,
                }
                #[derive(
                    ::subxt::ext::codec::Decode,
                    ::subxt::ext::codec::Encode,
                    ::subxt::ext::scale_decode::DecodeAsType,
                    ::subxt::ext::scale_encode::EncodeAsType,
                    Clone,
                    Debug,
                    Eq,
                    PartialEq
                )]
                #[codec(crate = ::subxt::ext::codec)]
                #[decode_as_type(crate_path = ":: subxt :: ext :: scale_decode")]
                #[encode_as_type(crate_path = ":: subxt :: ext :: scale_encode")]
                /**
			The [event](https://docs.substrate.io/main-docs/build/events-errors/) emitted
			by this pallet.
			*/
                pub enum Event {
                    #[codec(index = 0)]
                    ///Someone claimed some WEBBs.
                    Claimed {
                        who: ::subxt::utils::AccountId32,
                        ethereum_address: runtime_types::pallet_ecdsa_claims::EthereumAddress,
                        amount: ::core::primitive::u128,
                    },
                }
            }
            #[derive(
                ::subxt::ext::codec::Decode,
                ::subxt::ext::codec::Encode,
                ::subxt::ext::scale_decode::DecodeAsType,
                ::subxt::ext::scale_encode::EncodeAsType,
                Clone,
                Debug,
                Eq,
                PartialEq
            )]
            #[codec(crate = ::subxt::ext::codec)]
            #[decode_as_type(crate_path = ":: subxt :: ext :: scale_decode")]
            #[encode_as_type(crate_path = ":: subxt :: ext :: scale_encode")]
            pub struct EcdsaSignature(pub [::core::primitive::u8; 65usize]);
            #[derive(
                ::subxt::ext::codec::Decode,
                ::subxt::ext::codec::Encode,
                ::subxt::ext::scale_decode::DecodeAsType,
                ::subxt::ext::scale_encode::EncodeAsType,
                Clone,
                Debug,
                Eq,
                PartialEq
            )]
            #[codec(crate = ::subxt::ext::codec)]
            #[decode_as_type(crate_path = ":: subxt :: ext :: scale_decode")]
            #[encode_as_type(crate_path = ":: subxt :: ext :: scale_encode")]
            pub struct EthereumAddress(pub [::core::primitive::u8; 20usize]);
            #[derive(
                ::subxt::ext::codec::Decode,
                ::subxt::ext::codec::Encode,
                ::subxt::ext::scale_decode::DecodeAsType,
                ::subxt::ext::scale_encode::EncodeAsType,
                Clone,
                Debug,
                Eq,
                PartialEq
            )]
            #[codec(crate = ::subxt::ext::codec)]
            #[decode_as_type(crate_path = ":: subxt :: ext :: scale_decode")]
            #[encode_as_type(crate_path = ":: subxt :: ext :: scale_encode")]
            pub enum StatementKind {
                #[codec(index = 0)]
                Regular,
                #[codec(index = 1)]
                Saft,
            }
        }
        pub mod pallet_election_provider_multi_phase {
            use super::runtime_types;
            pub mod pallet {
                use super::runtime_types;
                #[derive(
                    ::subxt::ext::codec::Decode,
                    ::subxt::ext::codec::Encode,
                    ::subxt::ext::scale_decode::DecodeAsType,
                    ::subxt::ext::scale_encode::EncodeAsType,
                    Clone,
                    Debug,
                    Eq,
                    PartialEq
                )]
                #[codec(crate = ::subxt::ext::codec)]
                #[decode_as_type(crate_path = ":: subxt :: ext :: scale_decode")]
                #[encode_as_type(crate_path = ":: subxt :: ext :: scale_encode")]
                ///Contains one variant per dispatchable that can be called by an extrinsic.
                pub enum Call {
                    #[codec(index = 0)]
                    ///Submit a solution for the unsigned phase.
                    ///
                    ///The dispatch origin fo this call must be __none__.
                    ///
                    ///This submission is checked on the fly. Moreover, this unsigned solution is only
                    ///validated when submitted to the pool from the **local** node. Effectively, this means
                    ///that only active validators can submit this transaction when authoring a block (similar
                    ///to an inherent).
                    ///
                    ///To prevent any incorrect solution (and thus wasted time/weight), this transaction will
                    ///panic if the solution submitted by the validator is invalid in any way, effectively
                    ///putting their authoring reward at risk.
                    ///
                    ///No deposit or reward is associated with this submission.
                    submit_unsigned {
                        raw_solution: ::std::boxed::Box<
                            runtime_types::pallet_election_provider_multi_phase::RawSolution<
                                runtime_types::tangle_standalone_runtime::NposSolution16,
                            >,
                        >,
                        witness: runtime_types::pallet_election_provider_multi_phase::SolutionOrSnapshotSize,
                    },
                    #[codec(index = 1)]
                    ///Set a new value for `MinimumUntrustedScore`.
                    ///
                    ///Dispatch origin must be aligned with `T::ForceOrigin`.
                    ///
                    ///This check can be turned off by setting the value to `None`.
                    set_minimum_untrusted_score {
                        maybe_next_score: ::core::option::Option<
                            runtime_types::sp_npos_elections::ElectionScore,
                        >,
                    },
                    #[codec(index = 2)]
                    ///Set a solution in the queue, to be handed out to the client of this pallet in the next
                    ///call to `ElectionProvider::elect`.
                    ///
                    ///This can only be set by `T::ForceOrigin`, and only when the phase is `Emergency`.
                    ///
                    ///The solution is not checked for any feasibility and is assumed to be trustworthy, as any
                    ///feasibility check itself can in principle cause the election process to fail (due to
                    ///memory/weight constrains).
                    set_emergency_election_result {
                        supports: ::std::vec::Vec<
                            (
                                ::subxt::utils::AccountId32,
                                runtime_types::sp_npos_elections::Support<
                                    ::subxt::utils::AccountId32,
                                >,
                            ),
                        >,
                    },
                    #[codec(index = 3)]
                    ///Submit a solution for the signed phase.
                    ///
                    ///The dispatch origin fo this call must be __signed__.
                    ///
                    ///The solution is potentially queued, based on the claimed score and processed at the end
                    ///of the signed phase.
                    ///
                    ///A deposit is reserved and recorded for the solution. Based on the outcome, the solution
                    ///might be rewarded, slashed, or get all or a part of the deposit back.
                    submit {
                        raw_solution: ::std::boxed::Box<
                            runtime_types::pallet_election_provider_multi_phase::RawSolution<
                                runtime_types::tangle_standalone_runtime::NposSolution16,
                            >,
                        >,
                    },
                    #[codec(index = 4)]
                    ///Trigger the governance fallback.
                    ///
                    ///This can only be called when [`Phase::Emergency`] is enabled, as an alternative to
                    ///calling [`Call::set_emergency_election_result`].
                    governance_fallback {
                        maybe_max_voters: ::core::option::Option<::core::primitive::u32>,
                        maybe_max_targets: ::core::option::Option<::core::primitive::u32>,
                    },
                }
                #[derive(
                    ::subxt::ext::codec::Decode,
                    ::subxt::ext::codec::Encode,
                    ::subxt::ext::scale_decode::DecodeAsType,
                    ::subxt::ext::scale_encode::EncodeAsType,
                    Clone,
                    Debug,
                    Eq,
                    PartialEq
                )]
                #[codec(crate = ::subxt::ext::codec)]
                #[decode_as_type(crate_path = ":: subxt :: ext :: scale_decode")]
                #[encode_as_type(crate_path = ":: subxt :: ext :: scale_encode")]
                ///Error of the pallet that can be returned in response to dispatches.
                pub enum Error {
                    #[codec(index = 0)]
                    ///Submission was too early.
                    PreDispatchEarlySubmission,
                    #[codec(index = 1)]
                    ///Wrong number of winners presented.
                    PreDispatchWrongWinnerCount,
                    #[codec(index = 2)]
                    ///Submission was too weak, score-wise.
                    PreDispatchWeakSubmission,
                    #[codec(index = 3)]
                    ///The queue was full, and the solution was not better than any of the existing ones.
                    SignedQueueFull,
                    #[codec(index = 4)]
                    ///The origin failed to pay the deposit.
                    SignedCannotPayDeposit,
                    #[codec(index = 5)]
                    ///Witness data to dispatchable is invalid.
                    SignedInvalidWitness,
                    #[codec(index = 6)]
                    ///The signed submission consumes too much weight
                    SignedTooMuchWeight,
                    #[codec(index = 7)]
                    ///OCW submitted solution for wrong round
                    OcwCallWrongEra,
                    #[codec(index = 8)]
                    ///Snapshot metadata should exist but didn't.
                    MissingSnapshotMetadata,
                    #[codec(index = 9)]
                    ///`Self::insert_submission` returned an invalid index.
                    InvalidSubmissionIndex,
                    #[codec(index = 10)]
                    ///The call is not allowed at this point.
                    CallNotAllowed,
                    #[codec(index = 11)]
                    ///The fallback failed
                    FallbackFailed,
                    #[codec(index = 12)]
                    ///Some bound not met
                    BoundNotMet,
                    #[codec(index = 13)]
                    ///Submitted solution has too many winners
                    TooManyWinners,
                }
                #[derive(
                    ::subxt::ext::codec::Decode,
                    ::subxt::ext::codec::Encode,
                    ::subxt::ext::scale_decode::DecodeAsType,
                    ::subxt::ext::scale_encode::EncodeAsType,
                    Clone,
                    Debug,
                    Eq,
                    PartialEq
                )]
                #[codec(crate = ::subxt::ext::codec)]
                #[decode_as_type(crate_path = ":: subxt :: ext :: scale_decode")]
                #[encode_as_type(crate_path = ":: subxt :: ext :: scale_encode")]
                /**
			The [event](https://docs.substrate.io/main-docs/build/events-errors/) emitted
			by this pallet.
			*/
                pub enum Event {
                    #[codec(index = 0)]
                    ///A solution was stored with the given compute.
                    ///
                    ///The `origin` indicates the origin of the solution. If `origin` is `Some(AccountId)`,
                    ///the stored solution was submited in the signed phase by a miner with the `AccountId`.
                    ///Otherwise, the solution was stored either during the unsigned phase or by
                    ///`T::ForceOrigin`. The `bool` is `true` when a previous solution was ejected to make
                    ///room for this one.
                    SolutionStored {
                        compute: runtime_types::pallet_election_provider_multi_phase::ElectionCompute,
                        origin: ::core::option::Option<::subxt::utils::AccountId32>,
                        prev_ejected: ::core::primitive::bool,
                    },
                    #[codec(index = 1)]
                    ///The election has been finalized, with the given computation and score.
                    ElectionFinalized {
                        compute: runtime_types::pallet_election_provider_multi_phase::ElectionCompute,
                        score: runtime_types::sp_npos_elections::ElectionScore,
                    },
                    #[codec(index = 2)]
                    ///An election failed.
                    ///
                    ///Not much can be said about which computes failed in the process.
                    ElectionFailed,
                    #[codec(index = 3)]
                    ///An account has been rewarded for their signed submission being finalized.
                    Rewarded {
                        account: ::subxt::utils::AccountId32,
                        value: ::core::primitive::u128,
                    },
                    #[codec(index = 4)]
                    ///An account has been slashed for submitting an invalid signed submission.
                    Slashed {
                        account: ::subxt::utils::AccountId32,
                        value: ::core::primitive::u128,
                    },
                    #[codec(index = 5)]
                    ///There was a phase transition in a given round.
                    PhaseTransitioned {
                        from: runtime_types::pallet_election_provider_multi_phase::Phase<
                            ::core::primitive::u32,
                        >,
                        to: runtime_types::pallet_election_provider_multi_phase::Phase<
                            ::core::primitive::u32,
                        >,
                        round: ::core::primitive::u32,
                    },
                }
            }
            pub mod signed {
                use super::runtime_types;
                #[derive(
                    ::subxt::ext::codec::Decode,
                    ::subxt::ext::codec::Encode,
                    ::subxt::ext::scale_decode::DecodeAsType,
                    ::subxt::ext::scale_encode::EncodeAsType,
                    Clone,
                    Debug,
                    Eq,
                    PartialEq
                )]
                #[codec(crate = ::subxt::ext::codec)]
                #[decode_as_type(crate_path = ":: subxt :: ext :: scale_decode")]
                #[encode_as_type(crate_path = ":: subxt :: ext :: scale_encode")]
                pub struct SignedSubmission<_0, _1, _2> {
                    pub who: _0,
                    pub deposit: _1,
                    pub raw_solution: runtime_types::pallet_election_provider_multi_phase::RawSolution<
                        _2,
                    >,
                    pub call_fee: _1,
                }
            }
            #[derive(
                ::subxt::ext::codec::Decode,
                ::subxt::ext::codec::Encode,
                ::subxt::ext::scale_decode::DecodeAsType,
                ::subxt::ext::scale_encode::EncodeAsType,
                Clone,
                Debug,
                Eq,
                PartialEq
            )]
            #[codec(crate = ::subxt::ext::codec)]
            #[decode_as_type(crate_path = ":: subxt :: ext :: scale_decode")]
            #[encode_as_type(crate_path = ":: subxt :: ext :: scale_encode")]
            pub enum ElectionCompute {
                #[codec(index = 0)]
                OnChain,
                #[codec(index = 1)]
                Signed,
                #[codec(index = 2)]
                Unsigned,
                #[codec(index = 3)]
                Fallback,
                #[codec(index = 4)]
                Emergency,
            }
            #[derive(
                ::subxt::ext::codec::Decode,
                ::subxt::ext::codec::Encode,
                ::subxt::ext::scale_decode::DecodeAsType,
                ::subxt::ext::scale_encode::EncodeAsType,
                Clone,
                Debug,
                Eq,
                PartialEq
            )]
            #[codec(crate = ::subxt::ext::codec)]
            #[decode_as_type(crate_path = ":: subxt :: ext :: scale_decode")]
            #[encode_as_type(crate_path = ":: subxt :: ext :: scale_encode")]
            pub enum Phase<_0> {
                #[codec(index = 0)]
                Off,
                #[codec(index = 1)]
                Signed,
                #[codec(index = 2)]
                Unsigned((::core::primitive::bool, _0)),
                #[codec(index = 3)]
                Emergency,
            }
            #[derive(
                ::subxt::ext::codec::Decode,
                ::subxt::ext::codec::Encode,
                ::subxt::ext::scale_decode::DecodeAsType,
                ::subxt::ext::scale_encode::EncodeAsType,
                Clone,
                Debug,
                Eq,
                PartialEq
            )]
            #[codec(crate = ::subxt::ext::codec)]
            #[decode_as_type(crate_path = ":: subxt :: ext :: scale_decode")]
            #[encode_as_type(crate_path = ":: subxt :: ext :: scale_encode")]
            pub struct RawSolution<_0> {
                pub solution: _0,
                pub score: runtime_types::sp_npos_elections::ElectionScore,
                pub round: ::core::primitive::u32,
            }
            #[derive(
                ::subxt::ext::codec::Decode,
                ::subxt::ext::codec::Encode,
                ::subxt::ext::scale_decode::DecodeAsType,
                ::subxt::ext::scale_encode::EncodeAsType,
                Clone,
                Debug,
                Eq,
                PartialEq
            )]
            #[codec(crate = ::subxt::ext::codec)]
            #[decode_as_type(crate_path = ":: subxt :: ext :: scale_decode")]
            #[encode_as_type(crate_path = ":: subxt :: ext :: scale_encode")]
            pub struct ReadySolution {
                pub supports: runtime_types::bounded_collections::bounded_vec::BoundedVec<
                    (
                        ::subxt::utils::AccountId32,
                        runtime_types::sp_npos_elections::Support<
                            ::subxt::utils::AccountId32,
                        >,
                    ),
                >,
                pub score: runtime_types::sp_npos_elections::ElectionScore,
                pub compute: runtime_types::pallet_election_provider_multi_phase::ElectionCompute,
            }
            #[derive(
                ::subxt::ext::codec::Decode,
                ::subxt::ext::codec::Encode,
                ::subxt::ext::scale_decode::DecodeAsType,
                ::subxt::ext::scale_encode::EncodeAsType,
                Clone,
                Debug,
                Eq,
                PartialEq
            )]
            #[codec(crate = ::subxt::ext::codec)]
            #[decode_as_type(crate_path = ":: subxt :: ext :: scale_decode")]
            #[encode_as_type(crate_path = ":: subxt :: ext :: scale_encode")]
            pub struct RoundSnapshot<_0, _1> {
                pub voters: ::std::vec::Vec<_1>,
                pub targets: ::std::vec::Vec<_0>,
            }
            #[derive(
                ::subxt::ext::codec::Decode,
                ::subxt::ext::codec::Encode,
                ::subxt::ext::scale_decode::DecodeAsType,
                ::subxt::ext::scale_encode::EncodeAsType,
                Clone,
                Debug,
                Eq,
                PartialEq
            )]
            #[codec(crate = ::subxt::ext::codec)]
            #[decode_as_type(crate_path = ":: subxt :: ext :: scale_decode")]
            #[encode_as_type(crate_path = ":: subxt :: ext :: scale_encode")]
            pub struct SolutionOrSnapshotSize {
                #[codec(compact)]
                pub voters: ::core::primitive::u32,
                #[codec(compact)]
                pub targets: ::core::primitive::u32,
            }
        }
        pub mod pallet_elections_phragmen {
            use super::runtime_types;
            pub mod pallet {
                use super::runtime_types;
                #[derive(
                    ::subxt::ext::codec::Decode,
                    ::subxt::ext::codec::Encode,
                    ::subxt::ext::scale_decode::DecodeAsType,
                    ::subxt::ext::scale_encode::EncodeAsType,
                    Clone,
                    Debug,
                    Eq,
                    PartialEq
                )]
                #[codec(crate = ::subxt::ext::codec)]
                #[decode_as_type(crate_path = ":: subxt :: ext :: scale_decode")]
                #[encode_as_type(crate_path = ":: subxt :: ext :: scale_encode")]
                ///Contains one variant per dispatchable that can be called by an extrinsic.
                pub enum Call {
                    #[codec(index = 0)]
                    ///Vote for a set of candidates for the upcoming round of election. This can be called to
                    ///set the initial votes, or update already existing votes.
                    ///
                    ///Upon initial voting, `value` units of `who`'s balance is locked and a deposit amount is
                    ///reserved. The deposit is based on the number of votes and can be updated over time.
                    ///
                    ///The `votes` should:
                    ///  - not be empty.
                    ///  - be less than the number of possible candidates. Note that all current members and
                    ///    runners-up are also automatically candidates for the next round.
                    ///
                    ///If `value` is more than `who`'s free balance, then the maximum of the two is used.
                    ///
                    ///The dispatch origin of this call must be signed.
                    ///
                    ///### Warning
                    ///
                    ///It is the responsibility of the caller to **NOT** place all of their balance into the
                    ///lock and keep some for further operations.
                    vote {
                        votes: ::std::vec::Vec<::subxt::utils::AccountId32>,
                        #[codec(compact)]
                        value: ::core::primitive::u128,
                    },
                    #[codec(index = 1)]
                    ///Remove `origin` as a voter.
                    ///
                    ///This removes the lock and returns the deposit.
                    ///
                    ///The dispatch origin of this call must be signed and be a voter.
                    remove_voter,
                    #[codec(index = 2)]
                    ///Submit oneself for candidacy. A fixed amount of deposit is recorded.
                    ///
                    ///All candidates are wiped at the end of the term. They either become a member/runner-up,
                    ///or leave the system while their deposit is slashed.
                    ///
                    ///The dispatch origin of this call must be signed.
                    ///
                    ///### Warning
                    ///
                    ///Even if a candidate ends up being a member, they must call [`Call::renounce_candidacy`]
                    ///to get their deposit back. Losing the spot in an election will always lead to a slash.
                    ///
                    ///The number of current candidates must be provided as witness data.
                    ///## Complexity
                    ///O(C + log(C)) where C is candidate_count.
                    submit_candidacy {
                        #[codec(compact)]
                        candidate_count: ::core::primitive::u32,
                    },
                    #[codec(index = 3)]
                    ///Renounce one's intention to be a candidate for the next election round. 3 potential
                    ///outcomes exist:
                    ///
                    ///- `origin` is a candidate and not elected in any set. In this case, the deposit is
                    ///  unreserved, returned and origin is removed as a candidate.
                    ///- `origin` is a current runner-up. In this case, the deposit is unreserved, returned and
                    ///  origin is removed as a runner-up.
                    ///- `origin` is a current member. In this case, the deposit is unreserved and origin is
                    ///  removed as a member, consequently not being a candidate for the next round anymore.
                    ///  Similar to [`remove_member`](Self::remove_member), if replacement runners exists, they
                    ///  are immediately used. If the prime is renouncing, then no prime will exist until the
                    ///  next round.
                    ///
                    ///The dispatch origin of this call must be signed, and have one of the above roles.
                    ///The type of renouncing must be provided as witness data.
                    ///
                    ///## Complexity
                    ///  - Renouncing::Candidate(count): O(count + log(count))
                    ///  - Renouncing::Member: O(1)
                    ///  - Renouncing::RunnerUp: O(1)
                    renounce_candidacy {
                        renouncing: runtime_types::pallet_elections_phragmen::Renouncing,
                    },
                    #[codec(index = 4)]
                    ///Remove a particular member from the set. This is effective immediately and the bond of
                    ///the outgoing member is slashed.
                    ///
                    ///If a runner-up is available, then the best runner-up will be removed and replaces the
                    ///outgoing member. Otherwise, if `rerun_election` is `true`, a new phragmen election is
                    ///started, else, nothing happens.
                    ///
                    ///If `slash_bond` is set to true, the bond of the member being removed is slashed. Else,
                    ///it is returned.
                    ///
                    ///The dispatch origin of this call must be root.
                    ///
                    ///Note that this does not affect the designated block number of the next election.
                    ///
                    ///## Complexity
                    ///- Check details of remove_and_replace_member() and do_phragmen().
                    remove_member {
                        who: ::subxt::utils::MultiAddress<
                            ::subxt::utils::AccountId32,
                            ::core::primitive::u32,
                        >,
                        slash_bond: ::core::primitive::bool,
                        rerun_election: ::core::primitive::bool,
                    },
                    #[codec(index = 5)]
                    ///Clean all voters who are defunct (i.e. they do not serve any purpose at all). The
                    ///deposit of the removed voters are returned.
                    ///
                    ///This is an root function to be used only for cleaning the state.
                    ///
                    ///The dispatch origin of this call must be root.
                    ///
                    ///## Complexity
                    ///- Check is_defunct_voter() details.
                    clean_defunct_voters {
                        num_voters: ::core::primitive::u32,
                        num_defunct: ::core::primitive::u32,
                    },
                }
                #[derive(
                    ::subxt::ext::codec::Decode,
                    ::subxt::ext::codec::Encode,
                    ::subxt::ext::scale_decode::DecodeAsType,
                    ::subxt::ext::scale_encode::EncodeAsType,
                    Clone,
                    Debug,
                    Eq,
                    PartialEq
                )]
                #[codec(crate = ::subxt::ext::codec)]
                #[decode_as_type(crate_path = ":: subxt :: ext :: scale_decode")]
                #[encode_as_type(crate_path = ":: subxt :: ext :: scale_encode")]
                /**
			Custom [dispatch errors](https://docs.substrate.io/main-docs/build/events-errors/)
			of this pallet.
			*/
                pub enum Error {
                    #[codec(index = 0)]
                    ///Cannot vote when no candidates or members exist.
                    UnableToVote,
                    #[codec(index = 1)]
                    ///Must vote for at least one candidate.
                    NoVotes,
                    #[codec(index = 2)]
                    ///Cannot vote more than candidates.
                    TooManyVotes,
                    #[codec(index = 3)]
                    ///Cannot vote more than maximum allowed.
                    MaximumVotesExceeded,
                    #[codec(index = 4)]
                    ///Cannot vote with stake less than minimum balance.
                    LowBalance,
                    #[codec(index = 5)]
                    ///Voter can not pay voting bond.
                    UnableToPayBond,
                    #[codec(index = 6)]
                    ///Must be a voter.
                    MustBeVoter,
                    #[codec(index = 7)]
                    ///Duplicated candidate submission.
                    DuplicatedCandidate,
                    #[codec(index = 8)]
                    ///Too many candidates have been created.
                    TooManyCandidates,
                    #[codec(index = 9)]
                    ///Member cannot re-submit candidacy.
                    MemberSubmit,
                    #[codec(index = 10)]
                    ///Runner cannot re-submit candidacy.
                    RunnerUpSubmit,
                    #[codec(index = 11)]
                    ///Candidate does not have enough funds.
                    InsufficientCandidateFunds,
                    #[codec(index = 12)]
                    ///Not a member.
                    NotMember,
                    #[codec(index = 13)]
                    ///The provided count of number of candidates is incorrect.
                    InvalidWitnessData,
                    #[codec(index = 14)]
                    ///The provided count of number of votes is incorrect.
                    InvalidVoteCount,
                    #[codec(index = 15)]
                    ///The renouncing origin presented a wrong `Renouncing` parameter.
                    InvalidRenouncing,
                    #[codec(index = 16)]
                    ///Prediction regarding replacement after member removal is wrong.
                    InvalidReplacement,
                }
                #[derive(
                    ::subxt::ext::codec::Decode,
                    ::subxt::ext::codec::Encode,
                    ::subxt::ext::scale_decode::DecodeAsType,
                    ::subxt::ext::scale_encode::EncodeAsType,
                    Clone,
                    Debug,
                    Eq,
                    PartialEq
                )]
                #[codec(crate = ::subxt::ext::codec)]
                #[decode_as_type(crate_path = ":: subxt :: ext :: scale_decode")]
                #[encode_as_type(crate_path = ":: subxt :: ext :: scale_encode")]
                /**
			The [event](https://docs.substrate.io/main-docs/build/events-errors/) emitted
			by this pallet.
			*/
                pub enum Event {
                    #[codec(index = 0)]
                    ///A new term with new_members. This indicates that enough candidates existed to run
                    ///the election, not that enough have has been elected. The inner value must be examined
                    ///for this purpose. A `NewTerm(\[\])` indicates that some candidates got their bond
                    ///slashed and none were elected, whilst `EmptyTerm` means that no candidates existed to
                    ///begin with.
                    NewTerm {
                        new_members: ::std::vec::Vec<
                            (::subxt::utils::AccountId32, ::core::primitive::u128),
                        >,
                    },
                    #[codec(index = 1)]
                    ///No (or not enough) candidates existed for this round. This is different from
                    ///`NewTerm(\[\])`. See the description of `NewTerm`.
                    EmptyTerm,
                    #[codec(index = 2)]
                    ///Internal error happened while trying to perform election.
                    ElectionError,
                    #[codec(index = 3)]
                    ///A member has been removed. This should always be followed by either `NewTerm` or
                    ///`EmptyTerm`.
                    MemberKicked { member: ::subxt::utils::AccountId32 },
                    #[codec(index = 4)]
                    ///Someone has renounced their candidacy.
                    Renounced { candidate: ::subxt::utils::AccountId32 },
                    #[codec(index = 5)]
                    ///A candidate was slashed by amount due to failing to obtain a seat as member or
                    ///runner-up.
                    ///
                    ///Note that old members and runners-up are also candidates.
                    CandidateSlashed {
                        candidate: ::subxt::utils::AccountId32,
                        amount: ::core::primitive::u128,
                    },
                    #[codec(index = 6)]
                    ///A seat holder was slashed by amount by being forcefully removed from the set.
                    SeatHolderSlashed {
                        seat_holder: ::subxt::utils::AccountId32,
                        amount: ::core::primitive::u128,
                    },
                }
            }
            #[derive(
                ::subxt::ext::codec::Decode,
                ::subxt::ext::codec::Encode,
                ::subxt::ext::scale_decode::DecodeAsType,
                ::subxt::ext::scale_encode::EncodeAsType,
                Clone,
                Debug,
                Eq,
                PartialEq
            )]
            #[codec(crate = ::subxt::ext::codec)]
            #[decode_as_type(crate_path = ":: subxt :: ext :: scale_decode")]
            #[encode_as_type(crate_path = ":: subxt :: ext :: scale_encode")]
            pub enum Renouncing {
                #[codec(index = 0)]
                Member,
                #[codec(index = 1)]
                RunnerUp,
                #[codec(index = 2)]
                Candidate(#[codec(compact)] ::core::primitive::u32),
            }
            #[derive(
                ::subxt::ext::codec::Decode,
                ::subxt::ext::codec::Encode,
                ::subxt::ext::scale_decode::DecodeAsType,
                ::subxt::ext::scale_encode::EncodeAsType,
                Clone,
                Debug,
                Eq,
                PartialEq
            )]
            #[codec(crate = ::subxt::ext::codec)]
            #[decode_as_type(crate_path = ":: subxt :: ext :: scale_decode")]
            #[encode_as_type(crate_path = ":: subxt :: ext :: scale_encode")]
            pub struct SeatHolder<_0, _1> {
                pub who: _0,
                pub stake: _1,
                pub deposit: _1,
            }
            #[derive(
                ::subxt::ext::codec::Decode,
                ::subxt::ext::codec::Encode,
                ::subxt::ext::scale_decode::DecodeAsType,
                ::subxt::ext::scale_encode::EncodeAsType,
                Clone,
                Debug,
                Eq,
                PartialEq
            )]
            #[codec(crate = ::subxt::ext::codec)]
            #[decode_as_type(crate_path = ":: subxt :: ext :: scale_decode")]
            #[encode_as_type(crate_path = ":: subxt :: ext :: scale_encode")]
            pub struct Voter<_0, _1> {
                pub votes: ::std::vec::Vec<_0>,
                pub stake: _1,
                pub deposit: _1,
            }
        }
        pub mod pallet_eth2_light_client {
            use super::runtime_types;
            pub mod pallet {
                use super::runtime_types;
                #[derive(
                    ::subxt::ext::codec::Decode,
                    ::subxt::ext::codec::Encode,
                    ::subxt::ext::scale_decode::DecodeAsType,
                    ::subxt::ext::scale_encode::EncodeAsType,
                    Clone,
                    Debug,
                    Eq,
                    PartialEq
                )]
                #[codec(crate = ::subxt::ext::codec)]
                #[decode_as_type(crate_path = ":: subxt :: ext :: scale_decode")]
                #[encode_as_type(crate_path = ":: subxt :: ext :: scale_encode")]
                ///Contains one variant per dispatchable that can be called by an extrinsic.
                pub enum Call {
                    #[codec(index = 0)]
                    init {
                        typed_chain_id: runtime_types::webb_proposals::header::TypedChainId,
                        args: ::std::boxed::Box<
                            runtime_types::eth_types::pallet::InitInput<
                                ::subxt::utils::AccountId32,
                            >,
                        >,
                    },
                    #[codec(index = 1)]
                    register_submitter {
                        typed_chain_id: runtime_types::webb_proposals::header::TypedChainId,
                    },
                    #[codec(index = 2)]
                    unregister_submitter {
                        typed_chain_id: runtime_types::webb_proposals::header::TypedChainId,
                    },
                    #[codec(index = 3)]
                    submit_beacon_chain_light_client_update {
                        typed_chain_id: runtime_types::webb_proposals::header::TypedChainId,
                        light_client_update: runtime_types::eth_types::eth2::LightClientUpdate,
                    },
                    #[codec(index = 4)]
                    submit_execution_header {
                        typed_chain_id: runtime_types::webb_proposals::header::TypedChainId,
                        block_header: runtime_types::eth_types::BlockHeader,
                    },
                    #[codec(index = 5)]
                    update_trusted_signer {
                        trusted_signer: ::subxt::utils::AccountId32,
                    },
                }
                #[derive(
                    ::subxt::ext::codec::Decode,
                    ::subxt::ext::codec::Encode,
                    ::subxt::ext::scale_decode::DecodeAsType,
                    ::subxt::ext::scale_encode::EncodeAsType,
                    Clone,
                    Debug,
                    Eq,
                    PartialEq
                )]
                #[codec(crate = ::subxt::ext::codec)]
                #[decode_as_type(crate_path = ":: subxt :: ext :: scale_decode")]
                #[encode_as_type(crate_path = ":: subxt :: ext :: scale_encode")]
                /**
			Custom [dispatch errors](https://docs.substrate.io/main-docs/build/events-errors/)
			of this pallet.
			*/
                pub enum Error {
                    #[codec(index = 0)]
                    ///The light client is already initialized for the typed chain ID
                    AlreadyInitialized,
                    #[codec(index = 1)]
                    ///For attempting to register
                    SubmitterAlreadyRegistered,
                    #[codec(index = 2)]
                    ///For attempting to unregister
                    SubmitterNotRegistered,
                    #[codec(index = 3)]
                    ///For attempting to unregister
                    SubmitterHasUsedStorage,
                    #[codec(index = 4)]
                    ///For attempting to update the light client
                    LightClientUpdateNotAllowed,
                    #[codec(index = 5)]
                    ///Block already submitted
                    BlockAlreadySubmitted,
                    #[codec(index = 6)]
                    ///Unknown parent block header hash
                    UnknownParentHeader,
                    #[codec(index = 7)]
                    ///Self-explanatory
                    NotTrustedSigner,
                    #[codec(index = 8)]
                    ///The updates validation can't be disabled for mainnet
                    ValidateUpdatesParameterError,
                    #[codec(index = 9)]
                    ///The client can't be executed in the trustless mode without BLS sigs verification on
                    ///Mainnet
                    TrustlessModeError,
                    #[codec(index = 10)]
                    InvalidSyncCommitteeBitsSum,
                    #[codec(index = 11)]
                    SyncCommitteeBitsSumLessThanThreshold,
                    #[codec(index = 12)]
                    ForkVersionNotFound,
                    #[codec(index = 13)]
                    ForkEpochNotFound,
                    #[codec(index = 14)]
                    GenesisValidatorsRootNotFound,
                    #[codec(index = 15)]
                    InvalidBlsSignature,
                    #[codec(index = 16)]
                    InvalidExecutionBlock,
                    #[codec(index = 17)]
                    ActiveHeaderSlotNumberLessThanFinalizedSlot,
                    #[codec(index = 18)]
                    InvalidUpdatePeriod,
                    #[codec(index = 19)]
                    InvalidFinalityProof,
                    #[codec(index = 20)]
                    InvalidExecutionBlockHashProof,
                    #[codec(index = 21)]
                    NextSyncCommitteeNotPresent,
                    #[codec(index = 22)]
                    InvalidNextSyncCommitteeProof,
                    #[codec(index = 23)]
                    FinalizedExecutionHeaderNotPresent,
                    #[codec(index = 24)]
                    FinalizedBeaconHeaderNotPresent,
                    #[codec(index = 25)]
                    UnfinalizedHeaderNotPresent,
                    #[codec(index = 26)]
                    SyncCommitteeUpdateNotPresent,
                    #[codec(index = 27)]
                    SubmitterExhaustedLimit,
                    #[codec(index = 28)]
                    HeaderHashDoesNotExist,
                    #[codec(index = 29)]
                    BlockHashesDoNotMatch,
                    #[codec(index = 30)]
                    InvalidSignaturePeriod,
                    #[codec(index = 31)]
                    CurrentSyncCommitteeNotSet,
                    #[codec(index = 32)]
                    NextSyncCommitteeNotSet,
                }
                #[derive(
                    ::subxt::ext::codec::Decode,
                    ::subxt::ext::codec::Encode,
                    ::subxt::ext::scale_decode::DecodeAsType,
                    ::subxt::ext::scale_encode::EncodeAsType,
                    Clone,
                    Debug,
                    Eq,
                    PartialEq
                )]
                #[codec(crate = ::subxt::ext::codec)]
                #[decode_as_type(crate_path = ":: subxt :: ext :: scale_decode")]
                #[encode_as_type(crate_path = ":: subxt :: ext :: scale_encode")]
                /**
			The [event](https://docs.substrate.io/main-docs/build/events-errors/) emitted
			by this pallet.
			*/
                pub enum Event {
                    #[codec(index = 0)]
                    Init {
                        typed_chain_id: runtime_types::webb_proposals::header::TypedChainId,
                        header_info: runtime_types::eth_types::pallet::ExecutionHeaderInfo<
                            ::subxt::utils::AccountId32,
                        >,
                    },
                    #[codec(index = 1)]
                    RegisterSubmitter {
                        typed_chain_id: runtime_types::webb_proposals::header::TypedChainId,
                        submitter: ::subxt::utils::AccountId32,
                    },
                    #[codec(index = 2)]
                    UnregisterSubmitter {
                        typed_chain_id: runtime_types::webb_proposals::header::TypedChainId,
                        submitter: ::subxt::utils::AccountId32,
                    },
                    #[codec(index = 3)]
                    SubmitBeaconChainLightClientUpdate {
                        typed_chain_id: runtime_types::webb_proposals::header::TypedChainId,
                        submitter: ::subxt::utils::AccountId32,
                        beacon_block_header: runtime_types::eth_types::eth2::BeaconBlockHeader,
                    },
                    #[codec(index = 4)]
                    SubmitExecutionHeader {
                        typed_chain_id: runtime_types::webb_proposals::header::TypedChainId,
                        header_info: runtime_types::eth_types::pallet::ExecutionHeaderInfo<
                            ::subxt::utils::AccountId32,
                        >,
                    },
                    #[codec(index = 5)]
                    UpdateTrustedSigner { trusted_signer: ::subxt::utils::AccountId32 },
                }
            }
        }
        pub mod pallet_ethereum {
            use super::runtime_types;
            pub mod pallet {
                use super::runtime_types;
                #[derive(
                    ::subxt::ext::codec::Decode,
                    ::subxt::ext::codec::Encode,
                    ::subxt::ext::scale_decode::DecodeAsType,
                    ::subxt::ext::scale_encode::EncodeAsType,
                    Clone,
                    Debug,
                    Eq,
                    PartialEq
                )]
                #[codec(crate = ::subxt::ext::codec)]
                #[decode_as_type(crate_path = ":: subxt :: ext :: scale_decode")]
                #[encode_as_type(crate_path = ":: subxt :: ext :: scale_encode")]
                ///Contains one variant per dispatchable that can be called by an extrinsic.
                pub enum Call {
                    #[codec(index = 0)]
                    ///Transact an Ethereum transaction.
                    transact {
                        transaction: runtime_types::ethereum::transaction::TransactionV2,
                    },
                }
                #[derive(
                    ::subxt::ext::codec::Decode,
                    ::subxt::ext::codec::Encode,
                    ::subxt::ext::scale_decode::DecodeAsType,
                    ::subxt::ext::scale_encode::EncodeAsType,
                    Clone,
                    Debug,
                    Eq,
                    PartialEq
                )]
                #[codec(crate = ::subxt::ext::codec)]
                #[decode_as_type(crate_path = ":: subxt :: ext :: scale_decode")]
                #[encode_as_type(crate_path = ":: subxt :: ext :: scale_encode")]
                /**
			Custom [dispatch errors](https://docs.substrate.io/main-docs/build/events-errors/)
			of this pallet.
			*/
                pub enum Error {
                    #[codec(index = 0)]
                    ///Signature is invalid.
                    InvalidSignature,
                    #[codec(index = 1)]
                    ///Pre-log is present, therefore transact is not allowed.
                    PreLogExists,
                }
                #[derive(
                    ::subxt::ext::codec::Decode,
                    ::subxt::ext::codec::Encode,
                    ::subxt::ext::scale_decode::DecodeAsType,
                    ::subxt::ext::scale_encode::EncodeAsType,
                    Clone,
                    Debug,
                    Eq,
                    PartialEq
                )]
                #[codec(crate = ::subxt::ext::codec)]
                #[decode_as_type(crate_path = ":: subxt :: ext :: scale_decode")]
                #[encode_as_type(crate_path = ":: subxt :: ext :: scale_encode")]
                /**
			The [event](https://docs.substrate.io/main-docs/build/events-errors/) emitted
			by this pallet.
			*/
                pub enum Event {
                    #[codec(index = 0)]
                    ///An ethereum transaction was successfully executed.
                    Executed {
                        from: ::subxt::utils::H160,
                        to: ::subxt::utils::H160,
                        transaction_hash: ::subxt::utils::H256,
                        exit_reason: runtime_types::evm_core::error::ExitReason,
                        extra_data: ::std::vec::Vec<::core::primitive::u8>,
                    },
                }
            }
            #[derive(
                ::subxt::ext::codec::Decode,
                ::subxt::ext::codec::Encode,
                ::subxt::ext::scale_decode::DecodeAsType,
                ::subxt::ext::scale_encode::EncodeAsType,
                Clone,
                Debug,
                Eq,
                PartialEq
            )]
            #[codec(crate = ::subxt::ext::codec)]
            #[decode_as_type(crate_path = ":: subxt :: ext :: scale_decode")]
            #[encode_as_type(crate_path = ":: subxt :: ext :: scale_encode")]
            pub enum RawOrigin {
                #[codec(index = 0)]
                EthereumTransaction(::subxt::utils::H160),
            }
        }
        pub mod pallet_evm {
            use super::runtime_types;
            pub mod pallet {
                use super::runtime_types;
                #[derive(
                    ::subxt::ext::codec::Decode,
                    ::subxt::ext::codec::Encode,
                    ::subxt::ext::scale_decode::DecodeAsType,
                    ::subxt::ext::scale_encode::EncodeAsType,
                    Clone,
                    Debug,
                    Eq,
                    PartialEq
                )]
                #[codec(crate = ::subxt::ext::codec)]
                #[decode_as_type(crate_path = ":: subxt :: ext :: scale_decode")]
                #[encode_as_type(crate_path = ":: subxt :: ext :: scale_encode")]
                ///Contains one variant per dispatchable that can be called by an extrinsic.
                pub enum Call {
                    #[codec(index = 0)]
                    ///Withdraw balance from EVM into currency/balances pallet.
                    withdraw {
                        address: ::subxt::utils::H160,
                        value: ::core::primitive::u128,
                    },
                    #[codec(index = 1)]
                    ///Issue an EVM call operation. This is similar to a message call transaction in Ethereum.
                    call {
                        source: ::subxt::utils::H160,
                        target: ::subxt::utils::H160,
                        input: ::std::vec::Vec<::core::primitive::u8>,
                        value: runtime_types::primitive_types::U256,
                        gas_limit: ::core::primitive::u64,
                        max_fee_per_gas: runtime_types::primitive_types::U256,
                        max_priority_fee_per_gas: ::core::option::Option<
                            runtime_types::primitive_types::U256,
                        >,
                        nonce: ::core::option::Option<
                            runtime_types::primitive_types::U256,
                        >,
                        access_list: ::std::vec::Vec<
                            (::subxt::utils::H160, ::std::vec::Vec<::subxt::utils::H256>),
                        >,
                    },
                    #[codec(index = 2)]
                    ///Issue an EVM create operation. This is similar to a contract creation transaction in
                    ///Ethereum.
                    create {
                        source: ::subxt::utils::H160,
                        init: ::std::vec::Vec<::core::primitive::u8>,
                        value: runtime_types::primitive_types::U256,
                        gas_limit: ::core::primitive::u64,
                        max_fee_per_gas: runtime_types::primitive_types::U256,
                        max_priority_fee_per_gas: ::core::option::Option<
                            runtime_types::primitive_types::U256,
                        >,
                        nonce: ::core::option::Option<
                            runtime_types::primitive_types::U256,
                        >,
                        access_list: ::std::vec::Vec<
                            (::subxt::utils::H160, ::std::vec::Vec<::subxt::utils::H256>),
                        >,
                    },
                    #[codec(index = 3)]
                    ///Issue an EVM create2 operation.
                    create2 {
                        source: ::subxt::utils::H160,
                        init: ::std::vec::Vec<::core::primitive::u8>,
                        salt: ::subxt::utils::H256,
                        value: runtime_types::primitive_types::U256,
                        gas_limit: ::core::primitive::u64,
                        max_fee_per_gas: runtime_types::primitive_types::U256,
                        max_priority_fee_per_gas: ::core::option::Option<
                            runtime_types::primitive_types::U256,
                        >,
                        nonce: ::core::option::Option<
                            runtime_types::primitive_types::U256,
                        >,
                        access_list: ::std::vec::Vec<
                            (::subxt::utils::H160, ::std::vec::Vec<::subxt::utils::H256>),
                        >,
                    },
                }
                #[derive(
                    ::subxt::ext::codec::Decode,
                    ::subxt::ext::codec::Encode,
                    ::subxt::ext::scale_decode::DecodeAsType,
                    ::subxt::ext::scale_encode::EncodeAsType,
                    Clone,
                    Debug,
                    Eq,
                    PartialEq
                )]
                #[codec(crate = ::subxt::ext::codec)]
                #[decode_as_type(crate_path = ":: subxt :: ext :: scale_decode")]
                #[encode_as_type(crate_path = ":: subxt :: ext :: scale_encode")]
                /**
			Custom [dispatch errors](https://docs.substrate.io/main-docs/build/events-errors/)
			of this pallet.
			*/
                pub enum Error {
                    #[codec(index = 0)]
                    ///Not enough balance to perform action
                    BalanceLow,
                    #[codec(index = 1)]
                    ///Calculating total fee overflowed
                    FeeOverflow,
                    #[codec(index = 2)]
                    ///Calculating total payment overflowed
                    PaymentOverflow,
                    #[codec(index = 3)]
                    ///Withdraw fee failed
                    WithdrawFailed,
                    #[codec(index = 4)]
                    ///Gas price is too low.
                    GasPriceTooLow,
                    #[codec(index = 5)]
                    ///Nonce is invalid
                    InvalidNonce,
                    #[codec(index = 6)]
                    ///Gas limit is too low.
                    GasLimitTooLow,
                    #[codec(index = 7)]
                    ///Gas limit is too high.
                    GasLimitTooHigh,
                    #[codec(index = 8)]
                    ///Undefined error.
                    Undefined,
                    #[codec(index = 9)]
                    ///EVM reentrancy
                    Reentrancy,
                    #[codec(index = 10)]
                    ///EIP-3607,
                    TransactionMustComeFromEOA,
                }
                #[derive(
                    ::subxt::ext::codec::Decode,
                    ::subxt::ext::codec::Encode,
                    ::subxt::ext::scale_decode::DecodeAsType,
                    ::subxt::ext::scale_encode::EncodeAsType,
                    Clone,
                    Debug,
                    Eq,
                    PartialEq
                )]
                #[codec(crate = ::subxt::ext::codec)]
                #[decode_as_type(crate_path = ":: subxt :: ext :: scale_decode")]
                #[encode_as_type(crate_path = ":: subxt :: ext :: scale_encode")]
                /**
			The [event](https://docs.substrate.io/main-docs/build/events-errors/) emitted
			by this pallet.
			*/
                pub enum Event {
                    #[codec(index = 0)]
                    ///Ethereum events from contracts.
                    Log { log: runtime_types::ethereum::log::Log },
                    #[codec(index = 1)]
                    ///A contract has been created at given address.
                    Created { address: ::subxt::utils::H160 },
                    #[codec(index = 2)]
                    ///A contract was attempted to be created, but the execution failed.
                    CreatedFailed { address: ::subxt::utils::H160 },
                    #[codec(index = 3)]
                    ///A contract has been executed successfully with states applied.
                    Executed { address: ::subxt::utils::H160 },
                    #[codec(index = 4)]
                    ///A contract has been executed with errors. States are reverted with only gas fees applied.
                    ExecutedFailed { address: ::subxt::utils::H160 },
                }
            }
            #[derive(
                ::subxt::ext::codec::Decode,
                ::subxt::ext::codec::Encode,
                ::subxt::ext::scale_decode::DecodeAsType,
                ::subxt::ext::scale_encode::EncodeAsType,
                Clone,
                Debug,
                Eq,
                PartialEq
            )]
            #[codec(crate = ::subxt::ext::codec)]
            #[decode_as_type(crate_path = ":: subxt :: ext :: scale_decode")]
            #[encode_as_type(crate_path = ":: subxt :: ext :: scale_encode")]
            pub struct CodeMetadata {
                pub size: ::core::primitive::u64,
                pub hash: ::subxt::utils::H256,
            }
        }
        pub mod pallet_grandpa {
            use super::runtime_types;
            pub mod pallet {
                use super::runtime_types;
                #[derive(
                    ::subxt::ext::codec::Decode,
                    ::subxt::ext::codec::Encode,
                    ::subxt::ext::scale_decode::DecodeAsType,
                    ::subxt::ext::scale_encode::EncodeAsType,
                    Clone,
                    Debug,
                    Eq,
                    PartialEq
                )]
                #[codec(crate = ::subxt::ext::codec)]
                #[decode_as_type(crate_path = ":: subxt :: ext :: scale_decode")]
                #[encode_as_type(crate_path = ":: subxt :: ext :: scale_encode")]
                ///Contains one variant per dispatchable that can be called by an extrinsic.
                pub enum Call {
                    #[codec(index = 0)]
                    ///Report voter equivocation/misbehavior. This method will verify the
                    ///equivocation proof and validate the given key ownership proof
                    ///against the extracted offender. If both are valid, the offence
                    ///will be reported.
                    report_equivocation {
                        equivocation_proof: ::std::boxed::Box<
                            runtime_types::sp_consensus_grandpa::EquivocationProof<
                                ::subxt::utils::H256,
                                ::core::primitive::u32,
                            >,
                        >,
                        key_owner_proof: runtime_types::sp_core::Void,
                    },
                    #[codec(index = 1)]
                    ///Report voter equivocation/misbehavior. This method will verify the
                    ///equivocation proof and validate the given key ownership proof
                    ///against the extracted offender. If both are valid, the offence
                    ///will be reported.
                    ///
                    ///This extrinsic must be called unsigned and it is expected that only
                    ///block authors will call it (validated in `ValidateUnsigned`), as such
                    ///if the block author is defined it will be defined as the equivocation
                    ///reporter.
                    report_equivocation_unsigned {
                        equivocation_proof: ::std::boxed::Box<
                            runtime_types::sp_consensus_grandpa::EquivocationProof<
                                ::subxt::utils::H256,
                                ::core::primitive::u32,
                            >,
                        >,
                        key_owner_proof: runtime_types::sp_core::Void,
                    },
                    #[codec(index = 2)]
                    ///Note that the current authority set of the GRANDPA finality gadget has stalled.
                    ///
                    ///This will trigger a forced authority set change at the beginning of the next session, to
                    ///be enacted `delay` blocks after that. The `delay` should be high enough to safely assume
                    ///that the block signalling the forced change will not be re-orged e.g. 1000 blocks.
                    ///The block production rate (which may be slowed down because of finality lagging) should
                    ///be taken into account when choosing the `delay`. The GRANDPA voters based on the new
                    ///authority will start voting on top of `best_finalized_block_number` for new finalized
                    ///blocks. `best_finalized_block_number` should be the highest of the latest finalized
                    ///block of all validators of the new authority set.
                    ///
                    ///Only callable by root.
                    note_stalled {
                        delay: ::core::primitive::u32,
                        best_finalized_block_number: ::core::primitive::u32,
                    },
                }
                #[derive(
                    ::subxt::ext::codec::Decode,
                    ::subxt::ext::codec::Encode,
                    ::subxt::ext::scale_decode::DecodeAsType,
                    ::subxt::ext::scale_encode::EncodeAsType,
                    Clone,
                    Debug,
                    Eq,
                    PartialEq
                )]
                #[codec(crate = ::subxt::ext::codec)]
                #[decode_as_type(crate_path = ":: subxt :: ext :: scale_decode")]
                #[encode_as_type(crate_path = ":: subxt :: ext :: scale_encode")]
                /**
			Custom [dispatch errors](https://docs.substrate.io/main-docs/build/events-errors/)
			of this pallet.
			*/
                pub enum Error {
                    #[codec(index = 0)]
                    ///Attempt to signal GRANDPA pause when the authority set isn't live
                    ///(either paused or already pending pause).
                    PauseFailed,
                    #[codec(index = 1)]
                    ///Attempt to signal GRANDPA resume when the authority set isn't paused
                    ///(either live or already pending resume).
                    ResumeFailed,
                    #[codec(index = 2)]
                    ///Attempt to signal GRANDPA change with one already pending.
                    ChangePending,
                    #[codec(index = 3)]
                    ///Cannot signal forced change so soon after last.
                    TooSoon,
                    #[codec(index = 4)]
                    ///A key ownership proof provided as part of an equivocation report is invalid.
                    InvalidKeyOwnershipProof,
                    #[codec(index = 5)]
                    ///An equivocation proof provided as part of an equivocation report is invalid.
                    InvalidEquivocationProof,
                    #[codec(index = 6)]
                    ///A given equivocation report is valid but already previously reported.
                    DuplicateOffenceReport,
                }
                #[derive(
                    ::subxt::ext::codec::Decode,
                    ::subxt::ext::codec::Encode,
                    ::subxt::ext::scale_decode::DecodeAsType,
                    ::subxt::ext::scale_encode::EncodeAsType,
                    Clone,
                    Debug,
                    Eq,
                    PartialEq
                )]
                #[codec(crate = ::subxt::ext::codec)]
                #[decode_as_type(crate_path = ":: subxt :: ext :: scale_decode")]
                #[encode_as_type(crate_path = ":: subxt :: ext :: scale_encode")]
                /**
			The [event](https://docs.substrate.io/main-docs/build/events-errors/) emitted
			by this pallet.
			*/
                pub enum Event {
                    #[codec(index = 0)]
                    ///New authority set has been applied.
                    NewAuthorities {
                        authority_set: ::std::vec::Vec<
                            (
                                runtime_types::sp_consensus_grandpa::app::Public,
                                ::core::primitive::u64,
                            ),
                        >,
                    },
                    #[codec(index = 1)]
                    ///Current authority set has been paused.
                    Paused,
                    #[codec(index = 2)]
                    ///Current authority set has been resumed.
                    Resumed,
                }
            }
            #[derive(
                ::subxt::ext::codec::Decode,
                ::subxt::ext::codec::Encode,
                ::subxt::ext::scale_decode::DecodeAsType,
                ::subxt::ext::scale_encode::EncodeAsType,
                Clone,
                Debug,
                Eq,
                PartialEq
            )]
            #[codec(crate = ::subxt::ext::codec)]
            #[decode_as_type(crate_path = ":: subxt :: ext :: scale_decode")]
            #[encode_as_type(crate_path = ":: subxt :: ext :: scale_encode")]
            pub struct StoredPendingChange<_0> {
                pub scheduled_at: _0,
                pub delay: _0,
                pub next_authorities: runtime_types::bounded_collections::weak_bounded_vec::WeakBoundedVec<
                    (
                        runtime_types::sp_consensus_grandpa::app::Public,
                        ::core::primitive::u64,
                    ),
                >,
                pub forced: ::core::option::Option<_0>,
            }
            #[derive(
                ::subxt::ext::codec::Decode,
                ::subxt::ext::codec::Encode,
                ::subxt::ext::scale_decode::DecodeAsType,
                ::subxt::ext::scale_encode::EncodeAsType,
                Clone,
                Debug,
                Eq,
                PartialEq
            )]
            #[codec(crate = ::subxt::ext::codec)]
            #[decode_as_type(crate_path = ":: subxt :: ext :: scale_decode")]
            #[encode_as_type(crate_path = ":: subxt :: ext :: scale_encode")]
            pub enum StoredState<_0> {
                #[codec(index = 0)]
                Live,
                #[codec(index = 1)]
                PendingPause { scheduled_at: _0, delay: _0 },
                #[codec(index = 2)]
                Paused,
                #[codec(index = 3)]
                PendingResume { scheduled_at: _0, delay: _0 },
            }
        }
        pub mod pallet_hotfix_sufficients {
            use super::runtime_types;
            pub mod pallet {
                use super::runtime_types;
                #[derive(
                    ::subxt::ext::codec::Decode,
                    ::subxt::ext::codec::Encode,
                    ::subxt::ext::scale_decode::DecodeAsType,
                    ::subxt::ext::scale_encode::EncodeAsType,
                    Clone,
                    Debug,
                    Eq,
                    PartialEq
                )]
                #[codec(crate = ::subxt::ext::codec)]
                #[decode_as_type(crate_path = ":: subxt :: ext :: scale_decode")]
                #[encode_as_type(crate_path = ":: subxt :: ext :: scale_encode")]
                ///Contains one variant per dispatchable that can be called by an extrinsic.
                pub enum Call {
                    #[codec(index = 0)]
                    ///Increment `sufficients` for existing accounts having a nonzero `nonce` but zero `sufficients`, `consumers` and `providers` value.
                    ///This state was caused by a previous bug in EVM create account dispatchable.
                    ///
                    ///Any accounts in the input list not satisfying the above condition will remain unaffected.
                    hotfix_inc_account_sufficients {
                        addresses: ::std::vec::Vec<::subxt::utils::H160>,
                    },
                }
                #[derive(
                    ::subxt::ext::codec::Decode,
                    ::subxt::ext::codec::Encode,
                    ::subxt::ext::scale_decode::DecodeAsType,
                    ::subxt::ext::scale_encode::EncodeAsType,
                    Clone,
                    Debug,
                    Eq,
                    PartialEq
                )]
                #[codec(crate = ::subxt::ext::codec)]
                #[decode_as_type(crate_path = ":: subxt :: ext :: scale_decode")]
                #[encode_as_type(crate_path = ":: subxt :: ext :: scale_encode")]
                /**
			Custom [dispatch errors](https://docs.substrate.io/main-docs/build/events-errors/)
			of this pallet.
			*/
                pub enum Error {
                    #[codec(index = 0)]
                    ///Maximum address count exceeded
                    MaxAddressCountExceeded,
                }
            }
        }
        pub mod pallet_identity {
            use super::runtime_types;
            pub mod pallet {
                use super::runtime_types;
                #[derive(
                    ::subxt::ext::codec::Decode,
                    ::subxt::ext::codec::Encode,
                    ::subxt::ext::scale_decode::DecodeAsType,
                    ::subxt::ext::scale_encode::EncodeAsType,
                    Clone,
                    Debug,
                    Eq,
                    PartialEq
                )]
                #[codec(crate = ::subxt::ext::codec)]
                #[decode_as_type(crate_path = ":: subxt :: ext :: scale_decode")]
                #[encode_as_type(crate_path = ":: subxt :: ext :: scale_encode")]
                ///Identity pallet declaration.
                pub enum Call {
                    #[codec(index = 0)]
                    ///Add a registrar to the system.
                    ///
                    ///The dispatch origin for this call must be `T::RegistrarOrigin`.
                    ///
                    ///- `account`: the account of the registrar.
                    ///
                    ///Emits `RegistrarAdded` if successful.
                    ///
                    ///## Complexity
                    ///- `O(R)` where `R` registrar-count (governance-bounded and code-bounded).
                    add_registrar {
                        account: ::subxt::utils::MultiAddress<
                            ::subxt::utils::AccountId32,
                            ::core::primitive::u32,
                        >,
                    },
                    #[codec(index = 1)]
                    ///Set an account's identity information and reserve the appropriate deposit.
                    ///
                    ///If the account already has identity information, the deposit is taken as part payment
                    ///for the new deposit.
                    ///
                    ///The dispatch origin for this call must be _Signed_.
                    ///
                    ///- `info`: The identity information.
                    ///
                    ///Emits `IdentitySet` if successful.
                    ///
                    ///## Complexity
                    ///- `O(X + X' + R)`
                    ///  - where `X` additional-field-count (deposit-bounded and code-bounded)
                    ///  - where `R` judgements-count (registrar-count-bounded)
                    set_identity {
                        info: ::std::boxed::Box<
                            runtime_types::pallet_identity::types::IdentityInfo,
                        >,
                    },
                    #[codec(index = 2)]
                    ///Set the sub-accounts of the sender.
                    ///
                    ///Payment: Any aggregate balance reserved by previous `set_subs` calls will be returned
                    ///and an amount `SubAccountDeposit` will be reserved for each item in `subs`.
                    ///
                    ///The dispatch origin for this call must be _Signed_ and the sender must have a registered
                    ///identity.
                    ///
                    ///- `subs`: The identity's (new) sub-accounts.
                    ///
                    ///## Complexity
                    ///- `O(P + S)`
                    ///  - where `P` old-subs-count (hard- and deposit-bounded).
                    ///  - where `S` subs-count (hard- and deposit-bounded).
                    set_subs {
                        subs: ::std::vec::Vec<
                            (
                                ::subxt::utils::AccountId32,
                                runtime_types::pallet_identity::types::Data,
                            ),
                        >,
                    },
                    #[codec(index = 3)]
                    ///Clear an account's identity info and all sub-accounts and return all deposits.
                    ///
                    ///Payment: All reserved balances on the account are returned.
                    ///
                    ///The dispatch origin for this call must be _Signed_ and the sender must have a registered
                    ///identity.
                    ///
                    ///Emits `IdentityCleared` if successful.
                    ///
                    ///## Complexity
                    ///- `O(R + S + X)`
                    ///  - where `R` registrar-count (governance-bounded).
                    ///  - where `S` subs-count (hard- and deposit-bounded).
                    ///  - where `X` additional-field-count (deposit-bounded and code-bounded).
                    clear_identity,
                    #[codec(index = 4)]
                    ///Request a judgement from a registrar.
                    ///
                    ///Payment: At most `max_fee` will be reserved for payment to the registrar if judgement
                    ///given.
                    ///
                    ///The dispatch origin for this call must be _Signed_ and the sender must have a
                    ///registered identity.
                    ///
                    ///- `reg_index`: The index of the registrar whose judgement is requested.
                    ///- `max_fee`: The maximum fee that may be paid. This should just be auto-populated as:
                    ///
                    ///```nocompile
                    ///Self::registrars().get(reg_index).unwrap().fee
                    ///```
                    ///
                    ///Emits `JudgementRequested` if successful.
                    ///
                    ///## Complexity
                    ///- `O(R + X)`.
                    ///  - where `R` registrar-count (governance-bounded).
                    ///  - where `X` additional-field-count (deposit-bounded and code-bounded).
                    request_judgement {
                        #[codec(compact)]
                        reg_index: ::core::primitive::u32,
                        #[codec(compact)]
                        max_fee: ::core::primitive::u128,
                    },
                    #[codec(index = 5)]
                    ///Cancel a previous request.
                    ///
                    ///Payment: A previously reserved deposit is returned on success.
                    ///
                    ///The dispatch origin for this call must be _Signed_ and the sender must have a
                    ///registered identity.
                    ///
                    ///- `reg_index`: The index of the registrar whose judgement is no longer requested.
                    ///
                    ///Emits `JudgementUnrequested` if successful.
                    ///
                    ///## Complexity
                    ///- `O(R + X)`.
                    ///  - where `R` registrar-count (governance-bounded).
                    ///  - where `X` additional-field-count (deposit-bounded and code-bounded).
                    cancel_request { reg_index: ::core::primitive::u32 },
                    #[codec(index = 6)]
                    ///Set the fee required for a judgement to be requested from a registrar.
                    ///
                    ///The dispatch origin for this call must be _Signed_ and the sender must be the account
                    ///of the registrar whose index is `index`.
                    ///
                    ///- `index`: the index of the registrar whose fee is to be set.
                    ///- `fee`: the new fee.
                    ///
                    ///## Complexity
                    ///- `O(R)`.
                    ///  - where `R` registrar-count (governance-bounded).
                    set_fee {
                        #[codec(compact)]
                        index: ::core::primitive::u32,
                        #[codec(compact)]
                        fee: ::core::primitive::u128,
                    },
                    #[codec(index = 7)]
                    ///Change the account associated with a registrar.
                    ///
                    ///The dispatch origin for this call must be _Signed_ and the sender must be the account
                    ///of the registrar whose index is `index`.
                    ///
                    ///- `index`: the index of the registrar whose fee is to be set.
                    ///- `new`: the new account ID.
                    ///
                    ///## Complexity
                    ///- `O(R)`.
                    ///  - where `R` registrar-count (governance-bounded).
                    set_account_id {
                        #[codec(compact)]
                        index: ::core::primitive::u32,
                        new: ::subxt::utils::MultiAddress<
                            ::subxt::utils::AccountId32,
                            ::core::primitive::u32,
                        >,
                    },
                    #[codec(index = 8)]
                    ///Set the field information for a registrar.
                    ///
                    ///The dispatch origin for this call must be _Signed_ and the sender must be the account
                    ///of the registrar whose index is `index`.
                    ///
                    ///- `index`: the index of the registrar whose fee is to be set.
                    ///- `fields`: the fields that the registrar concerns themselves with.
                    ///
                    ///## Complexity
                    ///- `O(R)`.
                    ///  - where `R` registrar-count (governance-bounded).
                    set_fields {
                        #[codec(compact)]
                        index: ::core::primitive::u32,
                        fields: runtime_types::pallet_identity::types::BitFlags<
                            runtime_types::pallet_identity::types::IdentityField,
                        >,
                    },
                    #[codec(index = 9)]
                    ///Provide a judgement for an account's identity.
                    ///
                    ///The dispatch origin for this call must be _Signed_ and the sender must be the account
                    ///of the registrar whose index is `reg_index`.
                    ///
                    ///- `reg_index`: the index of the registrar whose judgement is being made.
                    ///- `target`: the account whose identity the judgement is upon. This must be an account
                    ///  with a registered identity.
                    ///- `judgement`: the judgement of the registrar of index `reg_index` about `target`.
                    ///- `identity`: The hash of the [`IdentityInfo`] for that the judgement is provided.
                    ///
                    ///Emits `JudgementGiven` if successful.
                    ///
                    ///## Complexity
                    ///- `O(R + X)`.
                    ///  - where `R` registrar-count (governance-bounded).
                    ///  - where `X` additional-field-count (deposit-bounded and code-bounded).
                    provide_judgement {
                        #[codec(compact)]
                        reg_index: ::core::primitive::u32,
                        target: ::subxt::utils::MultiAddress<
                            ::subxt::utils::AccountId32,
                            ::core::primitive::u32,
                        >,
                        judgement: runtime_types::pallet_identity::types::Judgement<
                            ::core::primitive::u128,
                        >,
                        identity: ::subxt::utils::H256,
                    },
                    #[codec(index = 10)]
                    ///Remove an account's identity and sub-account information and slash the deposits.
                    ///
                    ///Payment: Reserved balances from `set_subs` and `set_identity` are slashed and handled by
                    ///`Slash`. Verification request deposits are not returned; they should be cancelled
                    ///manually using `cancel_request`.
                    ///
                    ///The dispatch origin for this call must match `T::ForceOrigin`.
                    ///
                    ///- `target`: the account whose identity the judgement is upon. This must be an account
                    ///  with a registered identity.
                    ///
                    ///Emits `IdentityKilled` if successful.
                    ///
                    ///## Complexity
                    ///- `O(R + S + X)`
                    ///  - where `R` registrar-count (governance-bounded).
                    ///  - where `S` subs-count (hard- and deposit-bounded).
                    ///  - where `X` additional-field-count (deposit-bounded and code-bounded).
                    kill_identity {
                        target: ::subxt::utils::MultiAddress<
                            ::subxt::utils::AccountId32,
                            ::core::primitive::u32,
                        >,
                    },
                    #[codec(index = 11)]
                    ///Add the given account to the sender's subs.
                    ///
                    ///Payment: Balance reserved by a previous `set_subs` call for one sub will be repatriated
                    ///to the sender.
                    ///
                    ///The dispatch origin for this call must be _Signed_ and the sender must have a registered
                    ///sub identity of `sub`.
                    add_sub {
                        sub: ::subxt::utils::MultiAddress<
                            ::subxt::utils::AccountId32,
                            ::core::primitive::u32,
                        >,
                        data: runtime_types::pallet_identity::types::Data,
                    },
                    #[codec(index = 12)]
                    ///Alter the associated name of the given sub-account.
                    ///
                    ///The dispatch origin for this call must be _Signed_ and the sender must have a registered
                    ///sub identity of `sub`.
                    rename_sub {
                        sub: ::subxt::utils::MultiAddress<
                            ::subxt::utils::AccountId32,
                            ::core::primitive::u32,
                        >,
                        data: runtime_types::pallet_identity::types::Data,
                    },
                    #[codec(index = 13)]
                    ///Remove the given account from the sender's subs.
                    ///
                    ///Payment: Balance reserved by a previous `set_subs` call for one sub will be repatriated
                    ///to the sender.
                    ///
                    ///The dispatch origin for this call must be _Signed_ and the sender must have a registered
                    ///sub identity of `sub`.
                    remove_sub {
                        sub: ::subxt::utils::MultiAddress<
                            ::subxt::utils::AccountId32,
                            ::core::primitive::u32,
                        >,
                    },
                    #[codec(index = 14)]
                    ///Remove the sender as a sub-account.
                    ///
                    ///Payment: Balance reserved by a previous `set_subs` call for one sub will be repatriated
                    ///to the sender (*not* the original depositor).
                    ///
                    ///The dispatch origin for this call must be _Signed_ and the sender must have a registered
                    ///super-identity.
                    ///
                    ///NOTE: This should not normally be used, but is provided in the case that the non-
                    ///controller of an account is maliciously registered as a sub-account.
                    quit_sub,
                }
                #[derive(
                    ::subxt::ext::codec::Decode,
                    ::subxt::ext::codec::Encode,
                    ::subxt::ext::scale_decode::DecodeAsType,
                    ::subxt::ext::scale_encode::EncodeAsType,
                    Clone,
                    Debug,
                    Eq,
                    PartialEq
                )]
                #[codec(crate = ::subxt::ext::codec)]
                #[decode_as_type(crate_path = ":: subxt :: ext :: scale_decode")]
                #[encode_as_type(crate_path = ":: subxt :: ext :: scale_encode")]
                /**
			Custom [dispatch errors](https://docs.substrate.io/main-docs/build/events-errors/)
			of this pallet.
			*/
                pub enum Error {
                    #[codec(index = 0)]
                    ///Too many subs-accounts.
                    TooManySubAccounts,
                    #[codec(index = 1)]
                    ///Account isn't found.
                    NotFound,
                    #[codec(index = 2)]
                    ///Account isn't named.
                    NotNamed,
                    #[codec(index = 3)]
                    ///Empty index.
                    EmptyIndex,
                    #[codec(index = 4)]
                    ///Fee is changed.
                    FeeChanged,
                    #[codec(index = 5)]
                    ///No identity found.
                    NoIdentity,
                    #[codec(index = 6)]
                    ///Sticky judgement.
                    StickyJudgement,
                    #[codec(index = 7)]
                    ///Judgement given.
                    JudgementGiven,
                    #[codec(index = 8)]
                    ///Invalid judgement.
                    InvalidJudgement,
                    #[codec(index = 9)]
                    ///The index is invalid.
                    InvalidIndex,
                    #[codec(index = 10)]
                    ///The target is invalid.
                    InvalidTarget,
                    #[codec(index = 11)]
                    ///Too many additional fields.
                    TooManyFields,
                    #[codec(index = 12)]
                    ///Maximum amount of registrars reached. Cannot add any more.
                    TooManyRegistrars,
                    #[codec(index = 13)]
                    ///Account ID is already named.
                    AlreadyClaimed,
                    #[codec(index = 14)]
                    ///Sender is not a sub-account.
                    NotSub,
                    #[codec(index = 15)]
                    ///Sub-account isn't owned by sender.
                    NotOwned,
                    #[codec(index = 16)]
                    ///The provided judgement was for a different identity.
                    JudgementForDifferentIdentity,
                    #[codec(index = 17)]
                    ///Error that occurs when there is an issue paying for judgement.
                    JudgementPaymentFailed,
                }
                #[derive(
                    ::subxt::ext::codec::Decode,
                    ::subxt::ext::codec::Encode,
                    ::subxt::ext::scale_decode::DecodeAsType,
                    ::subxt::ext::scale_encode::EncodeAsType,
                    Clone,
                    Debug,
                    Eq,
                    PartialEq
                )]
                #[codec(crate = ::subxt::ext::codec)]
                #[decode_as_type(crate_path = ":: subxt :: ext :: scale_decode")]
                #[encode_as_type(crate_path = ":: subxt :: ext :: scale_encode")]
                /**
			The [event](https://docs.substrate.io/main-docs/build/events-errors/) emitted
			by this pallet.
			*/
                pub enum Event {
                    #[codec(index = 0)]
                    ///A name was set or reset (which will remove all judgements).
                    IdentitySet { who: ::subxt::utils::AccountId32 },
                    #[codec(index = 1)]
                    ///A name was cleared, and the given balance returned.
                    IdentityCleared {
                        who: ::subxt::utils::AccountId32,
                        deposit: ::core::primitive::u128,
                    },
                    #[codec(index = 2)]
                    ///A name was removed and the given balance slashed.
                    IdentityKilled {
                        who: ::subxt::utils::AccountId32,
                        deposit: ::core::primitive::u128,
                    },
                    #[codec(index = 3)]
                    ///A judgement was asked from a registrar.
                    JudgementRequested {
                        who: ::subxt::utils::AccountId32,
                        registrar_index: ::core::primitive::u32,
                    },
                    #[codec(index = 4)]
                    ///A judgement request was retracted.
                    JudgementUnrequested {
                        who: ::subxt::utils::AccountId32,
                        registrar_index: ::core::primitive::u32,
                    },
                    #[codec(index = 5)]
                    ///A judgement was given by a registrar.
                    JudgementGiven {
                        target: ::subxt::utils::AccountId32,
                        registrar_index: ::core::primitive::u32,
                    },
                    #[codec(index = 6)]
                    ///A registrar was added.
                    RegistrarAdded { registrar_index: ::core::primitive::u32 },
                    #[codec(index = 7)]
                    ///A sub-identity was added to an identity and the deposit paid.
                    SubIdentityAdded {
                        sub: ::subxt::utils::AccountId32,
                        main: ::subxt::utils::AccountId32,
                        deposit: ::core::primitive::u128,
                    },
                    #[codec(index = 8)]
                    ///A sub-identity was removed from an identity and the deposit freed.
                    SubIdentityRemoved {
                        sub: ::subxt::utils::AccountId32,
                        main: ::subxt::utils::AccountId32,
                        deposit: ::core::primitive::u128,
                    },
                    #[codec(index = 9)]
                    ///A sub-identity was cleared, and the given deposit repatriated from the
                    ///main identity account to the sub-identity account.
                    SubIdentityRevoked {
                        sub: ::subxt::utils::AccountId32,
                        main: ::subxt::utils::AccountId32,
                        deposit: ::core::primitive::u128,
                    },
                }
            }
            pub mod types {
                use super::runtime_types;
                #[derive(
                    ::subxt::ext::codec::CompactAs,
                    ::subxt::ext::codec::Decode,
                    ::subxt::ext::codec::Encode,
                    ::subxt::ext::scale_decode::DecodeAsType,
                    ::subxt::ext::scale_encode::EncodeAsType,
                    Clone,
                    Debug,
                    Eq,
                    PartialEq
                )]
                #[codec(crate = ::subxt::ext::codec)]
                #[decode_as_type(crate_path = ":: subxt :: ext :: scale_decode")]
                #[encode_as_type(crate_path = ":: subxt :: ext :: scale_encode")]
                pub struct BitFlags<_0>(
                    pub ::core::primitive::u64,
                    #[codec(skip)]
                    pub ::core::marker::PhantomData<_0>,
                );
                #[derive(
                    ::subxt::ext::codec::Decode,
                    ::subxt::ext::codec::Encode,
                    ::subxt::ext::scale_decode::DecodeAsType,
                    ::subxt::ext::scale_encode::EncodeAsType,
                    Clone,
                    Debug,
                    Eq,
                    PartialEq
                )]
                #[codec(crate = ::subxt::ext::codec)]
                #[decode_as_type(crate_path = ":: subxt :: ext :: scale_decode")]
                #[encode_as_type(crate_path = ":: subxt :: ext :: scale_encode")]
                pub enum Data {
                    #[codec(index = 0)]
                    None,
                    #[codec(index = 1)]
                    Raw0([::core::primitive::u8; 0usize]),
                    #[codec(index = 2)]
                    Raw1([::core::primitive::u8; 1usize]),
                    #[codec(index = 3)]
                    Raw2([::core::primitive::u8; 2usize]),
                    #[codec(index = 4)]
                    Raw3([::core::primitive::u8; 3usize]),
                    #[codec(index = 5)]
                    Raw4([::core::primitive::u8; 4usize]),
                    #[codec(index = 6)]
                    Raw5([::core::primitive::u8; 5usize]),
                    #[codec(index = 7)]
                    Raw6([::core::primitive::u8; 6usize]),
                    #[codec(index = 8)]
                    Raw7([::core::primitive::u8; 7usize]),
                    #[codec(index = 9)]
                    Raw8([::core::primitive::u8; 8usize]),
                    #[codec(index = 10)]
                    Raw9([::core::primitive::u8; 9usize]),
                    #[codec(index = 11)]
                    Raw10([::core::primitive::u8; 10usize]),
                    #[codec(index = 12)]
                    Raw11([::core::primitive::u8; 11usize]),
                    #[codec(index = 13)]
                    Raw12([::core::primitive::u8; 12usize]),
                    #[codec(index = 14)]
                    Raw13([::core::primitive::u8; 13usize]),
                    #[codec(index = 15)]
                    Raw14([::core::primitive::u8; 14usize]),
                    #[codec(index = 16)]
                    Raw15([::core::primitive::u8; 15usize]),
                    #[codec(index = 17)]
                    Raw16([::core::primitive::u8; 16usize]),
                    #[codec(index = 18)]
                    Raw17([::core::primitive::u8; 17usize]),
                    #[codec(index = 19)]
                    Raw18([::core::primitive::u8; 18usize]),
                    #[codec(index = 20)]
                    Raw19([::core::primitive::u8; 19usize]),
                    #[codec(index = 21)]
                    Raw20([::core::primitive::u8; 20usize]),
                    #[codec(index = 22)]
                    Raw21([::core::primitive::u8; 21usize]),
                    #[codec(index = 23)]
                    Raw22([::core::primitive::u8; 22usize]),
                    #[codec(index = 24)]
                    Raw23([::core::primitive::u8; 23usize]),
                    #[codec(index = 25)]
                    Raw24([::core::primitive::u8; 24usize]),
                    #[codec(index = 26)]
                    Raw25([::core::primitive::u8; 25usize]),
                    #[codec(index = 27)]
                    Raw26([::core::primitive::u8; 26usize]),
                    #[codec(index = 28)]
                    Raw27([::core::primitive::u8; 27usize]),
                    #[codec(index = 29)]
                    Raw28([::core::primitive::u8; 28usize]),
                    #[codec(index = 30)]
                    Raw29([::core::primitive::u8; 29usize]),
                    #[codec(index = 31)]
                    Raw30([::core::primitive::u8; 30usize]),
                    #[codec(index = 32)]
                    Raw31([::core::primitive::u8; 31usize]),
                    #[codec(index = 33)]
                    Raw32([::core::primitive::u8; 32usize]),
                    #[codec(index = 34)]
                    BlakeTwo256([::core::primitive::u8; 32usize]),
                    #[codec(index = 35)]
                    Sha256([::core::primitive::u8; 32usize]),
                    #[codec(index = 36)]
                    Keccak256([::core::primitive::u8; 32usize]),
                    #[codec(index = 37)]
                    ShaThree256([::core::primitive::u8; 32usize]),
                }
                #[derive(
                    ::subxt::ext::codec::Decode,
                    ::subxt::ext::codec::Encode,
                    ::subxt::ext::scale_decode::DecodeAsType,
                    ::subxt::ext::scale_encode::EncodeAsType,
                    Clone,
                    Debug,
                    Eq,
                    PartialEq
                )]
                #[codec(crate = ::subxt::ext::codec)]
                #[decode_as_type(crate_path = ":: subxt :: ext :: scale_decode")]
                #[encode_as_type(crate_path = ":: subxt :: ext :: scale_encode")]
                pub enum IdentityField {
                    #[codec(index = 1)]
                    Display,
                    #[codec(index = 2)]
                    Legal,
                    #[codec(index = 4)]
                    Web,
                    #[codec(index = 8)]
                    Riot,
                    #[codec(index = 16)]
                    Email,
                    #[codec(index = 32)]
                    PgpFingerprint,
                    #[codec(index = 64)]
                    Image,
                    #[codec(index = 128)]
                    Twitter,
                }
                #[derive(
                    ::subxt::ext::codec::Decode,
                    ::subxt::ext::codec::Encode,
                    ::subxt::ext::scale_decode::DecodeAsType,
                    ::subxt::ext::scale_encode::EncodeAsType,
                    Clone,
                    Debug,
                    Eq,
                    PartialEq
                )]
                #[codec(crate = ::subxt::ext::codec)]
                #[decode_as_type(crate_path = ":: subxt :: ext :: scale_decode")]
                #[encode_as_type(crate_path = ":: subxt :: ext :: scale_encode")]
                pub struct IdentityInfo {
                    pub additional: runtime_types::bounded_collections::bounded_vec::BoundedVec<
                        (
                            runtime_types::pallet_identity::types::Data,
                            runtime_types::pallet_identity::types::Data,
                        ),
                    >,
                    pub display: runtime_types::pallet_identity::types::Data,
                    pub legal: runtime_types::pallet_identity::types::Data,
                    pub web: runtime_types::pallet_identity::types::Data,
                    pub riot: runtime_types::pallet_identity::types::Data,
                    pub email: runtime_types::pallet_identity::types::Data,
                    pub pgp_fingerprint: ::core::option::Option<
                        [::core::primitive::u8; 20usize],
                    >,
                    pub image: runtime_types::pallet_identity::types::Data,
                    pub twitter: runtime_types::pallet_identity::types::Data,
                }
                #[derive(
                    ::subxt::ext::codec::Decode,
                    ::subxt::ext::codec::Encode,
                    ::subxt::ext::scale_decode::DecodeAsType,
                    ::subxt::ext::scale_encode::EncodeAsType,
                    Clone,
                    Debug,
                    Eq,
                    PartialEq
                )]
                #[codec(crate = ::subxt::ext::codec)]
                #[decode_as_type(crate_path = ":: subxt :: ext :: scale_decode")]
                #[encode_as_type(crate_path = ":: subxt :: ext :: scale_encode")]
                pub enum Judgement<_0> {
                    #[codec(index = 0)]
                    Unknown,
                    #[codec(index = 1)]
                    FeePaid(_0),
                    #[codec(index = 2)]
                    Reasonable,
                    #[codec(index = 3)]
                    KnownGood,
                    #[codec(index = 4)]
                    OutOfDate,
                    #[codec(index = 5)]
                    LowQuality,
                    #[codec(index = 6)]
                    Erroneous,
                }
                #[derive(
                    ::subxt::ext::codec::Decode,
                    ::subxt::ext::codec::Encode,
                    ::subxt::ext::scale_decode::DecodeAsType,
                    ::subxt::ext::scale_encode::EncodeAsType,
                    Clone,
                    Debug,
                    Eq,
                    PartialEq
                )]
                #[codec(crate = ::subxt::ext::codec)]
                #[decode_as_type(crate_path = ":: subxt :: ext :: scale_decode")]
                #[encode_as_type(crate_path = ":: subxt :: ext :: scale_encode")]
                pub struct RegistrarInfo<_0, _1> {
                    pub account: _1,
                    pub fee: _0,
                    pub fields: runtime_types::pallet_identity::types::BitFlags<
                        runtime_types::pallet_identity::types::IdentityField,
                    >,
                }
                #[derive(
                    ::subxt::ext::codec::Decode,
                    ::subxt::ext::codec::Encode,
                    ::subxt::ext::scale_decode::DecodeAsType,
                    ::subxt::ext::scale_encode::EncodeAsType,
                    Clone,
                    Debug,
                    Eq,
                    PartialEq
                )]
                #[codec(crate = ::subxt::ext::codec)]
                #[decode_as_type(crate_path = ":: subxt :: ext :: scale_decode")]
                #[encode_as_type(crate_path = ":: subxt :: ext :: scale_encode")]
                pub struct Registration<_0> {
                    pub judgements: runtime_types::bounded_collections::bounded_vec::BoundedVec<
                        (
                            ::core::primitive::u32,
                            runtime_types::pallet_identity::types::Judgement<_0>,
                        ),
                    >,
                    pub deposit: _0,
                    pub info: runtime_types::pallet_identity::types::IdentityInfo,
                }
            }
        }
        pub mod pallet_im_online {
            use super::runtime_types;
            pub mod pallet {
                use super::runtime_types;
                #[derive(
                    ::subxt::ext::codec::Decode,
                    ::subxt::ext::codec::Encode,
                    ::subxt::ext::scale_decode::DecodeAsType,
                    ::subxt::ext::scale_encode::EncodeAsType,
                    Clone,
                    Debug,
                    Eq,
                    PartialEq
                )]
                #[codec(crate = ::subxt::ext::codec)]
                #[decode_as_type(crate_path = ":: subxt :: ext :: scale_decode")]
                #[encode_as_type(crate_path = ":: subxt :: ext :: scale_encode")]
                ///Contains one variant per dispatchable that can be called by an extrinsic.
                pub enum Call {
                    #[codec(index = 0)]
                    ///## Complexity:
                    ///- `O(K + E)` where K is length of `Keys` (heartbeat.validators_len) and E is length of
                    ///  `heartbeat.network_state.external_address`
                    ///  - `O(K)`: decoding of length `K`
                    ///  - `O(E)`: decoding/encoding of length `E`
                    heartbeat {
                        heartbeat: runtime_types::pallet_im_online::Heartbeat<
                            ::core::primitive::u32,
                        >,
                        signature: runtime_types::pallet_im_online::sr25519::app_sr25519::Signature,
                    },
                }
                #[derive(
                    ::subxt::ext::codec::Decode,
                    ::subxt::ext::codec::Encode,
                    ::subxt::ext::scale_decode::DecodeAsType,
                    ::subxt::ext::scale_encode::EncodeAsType,
                    Clone,
                    Debug,
                    Eq,
                    PartialEq
                )]
                #[codec(crate = ::subxt::ext::codec)]
                #[decode_as_type(crate_path = ":: subxt :: ext :: scale_decode")]
                #[encode_as_type(crate_path = ":: subxt :: ext :: scale_encode")]
                /**
			Custom [dispatch errors](https://docs.substrate.io/main-docs/build/events-errors/)
			of this pallet.
			*/
                pub enum Error {
                    #[codec(index = 0)]
                    ///Non existent public key.
                    InvalidKey,
                    #[codec(index = 1)]
                    ///Duplicated heartbeat.
                    DuplicatedHeartbeat,
                }
                #[derive(
                    ::subxt::ext::codec::Decode,
                    ::subxt::ext::codec::Encode,
                    ::subxt::ext::scale_decode::DecodeAsType,
                    ::subxt::ext::scale_encode::EncodeAsType,
                    Clone,
                    Debug,
                    Eq,
                    PartialEq
                )]
                #[codec(crate = ::subxt::ext::codec)]
                #[decode_as_type(crate_path = ":: subxt :: ext :: scale_decode")]
                #[encode_as_type(crate_path = ":: subxt :: ext :: scale_encode")]
                /**
			The [event](https://docs.substrate.io/main-docs/build/events-errors/) emitted
			by this pallet.
			*/
                pub enum Event {
                    #[codec(index = 0)]
                    ///A new heartbeat was received from `AuthorityId`.
                    HeartbeatReceived {
                        authority_id: runtime_types::pallet_im_online::sr25519::app_sr25519::Public,
                    },
                    #[codec(index = 1)]
                    ///At the end of the session, no offence was committed.
                    AllGood,
                    #[codec(index = 2)]
                    ///At the end of the session, at least one validator was found to be offline.
                    SomeOffline {
                        offline: ::std::vec::Vec<
                            (
                                ::subxt::utils::AccountId32,
                                runtime_types::pallet_staking::Exposure<
                                    ::subxt::utils::AccountId32,
                                    ::core::primitive::u128,
                                >,
                            ),
                        >,
                    },
                }
            }
            pub mod sr25519 {
                use super::runtime_types;
                pub mod app_sr25519 {
                    use super::runtime_types;
                    #[derive(
                        ::subxt::ext::codec::Decode,
                        ::subxt::ext::codec::Encode,
                        ::subxt::ext::scale_decode::DecodeAsType,
                        ::subxt::ext::scale_encode::EncodeAsType,
                        Clone,
                        Debug,
                        Eq,
                        PartialEq
                    )]
                    #[codec(crate = ::subxt::ext::codec)]
                    #[decode_as_type(crate_path = ":: subxt :: ext :: scale_decode")]
                    #[encode_as_type(crate_path = ":: subxt :: ext :: scale_encode")]
                    pub struct Public(pub runtime_types::sp_core::sr25519::Public);
                    #[derive(
                        ::subxt::ext::codec::Decode,
                        ::subxt::ext::codec::Encode,
                        ::subxt::ext::scale_decode::DecodeAsType,
                        ::subxt::ext::scale_encode::EncodeAsType,
                        Clone,
                        Debug,
                        Eq,
                        PartialEq
                    )]
                    #[codec(crate = ::subxt::ext::codec)]
                    #[decode_as_type(crate_path = ":: subxt :: ext :: scale_decode")]
                    #[encode_as_type(crate_path = ":: subxt :: ext :: scale_encode")]
                    pub struct Signature(pub runtime_types::sp_core::sr25519::Signature);
                }
            }
            #[derive(
                ::subxt::ext::codec::Decode,
                ::subxt::ext::codec::Encode,
                ::subxt::ext::scale_decode::DecodeAsType,
                ::subxt::ext::scale_encode::EncodeAsType,
                Clone,
                Debug,
                Eq,
                PartialEq
            )]
            #[codec(crate = ::subxt::ext::codec)]
            #[decode_as_type(crate_path = ":: subxt :: ext :: scale_decode")]
            #[encode_as_type(crate_path = ":: subxt :: ext :: scale_encode")]
            pub struct BoundedOpaqueNetworkState {
                pub peer_id: runtime_types::bounded_collections::weak_bounded_vec::WeakBoundedVec<
                    ::core::primitive::u8,
                >,
                pub external_addresses: runtime_types::bounded_collections::weak_bounded_vec::WeakBoundedVec<
                    runtime_types::bounded_collections::weak_bounded_vec::WeakBoundedVec<
                        ::core::primitive::u8,
                    >,
                >,
            }
            #[derive(
                ::subxt::ext::codec::Decode,
                ::subxt::ext::codec::Encode,
                ::subxt::ext::scale_decode::DecodeAsType,
                ::subxt::ext::scale_encode::EncodeAsType,
                Clone,
                Debug,
                Eq,
                PartialEq
            )]
            #[codec(crate = ::subxt::ext::codec)]
            #[decode_as_type(crate_path = ":: subxt :: ext :: scale_decode")]
            #[encode_as_type(crate_path = ":: subxt :: ext :: scale_encode")]
            pub struct Heartbeat<_0> {
                pub block_number: _0,
                pub network_state: runtime_types::sp_core::offchain::OpaqueNetworkState,
                pub session_index: _0,
                pub authority_index: _0,
                pub validators_len: _0,
            }
        }
        pub mod pallet_indices {
            use super::runtime_types;
            pub mod pallet {
                use super::runtime_types;
                #[derive(
                    ::subxt::ext::codec::Decode,
                    ::subxt::ext::codec::Encode,
                    ::subxt::ext::scale_decode::DecodeAsType,
                    ::subxt::ext::scale_encode::EncodeAsType,
                    Clone,
                    Debug,
                    Eq,
                    PartialEq
                )]
                #[codec(crate = ::subxt::ext::codec)]
                #[decode_as_type(crate_path = ":: subxt :: ext :: scale_decode")]
                #[encode_as_type(crate_path = ":: subxt :: ext :: scale_encode")]
                ///Contains one variant per dispatchable that can be called by an extrinsic.
                pub enum Call {
                    #[codec(index = 0)]
                    ///Assign an previously unassigned index.
                    ///
                    ///Payment: `Deposit` is reserved from the sender account.
                    ///
                    ///The dispatch origin for this call must be _Signed_.
                    ///
                    ///- `index`: the index to be claimed. This must not be in use.
                    ///
                    ///Emits `IndexAssigned` if successful.
                    ///
                    ///## Complexity
                    ///- `O(1)`.
                    claim { index: ::core::primitive::u32 },
                    #[codec(index = 1)]
                    ///Assign an index already owned by the sender to another account. The balance reservation
                    ///is effectively transferred to the new account.
                    ///
                    ///The dispatch origin for this call must be _Signed_.
                    ///
                    ///- `index`: the index to be re-assigned. This must be owned by the sender.
                    ///- `new`: the new owner of the index. This function is a no-op if it is equal to sender.
                    ///
                    ///Emits `IndexAssigned` if successful.
                    ///
                    ///## Complexity
                    ///- `O(1)`.
                    transfer {
                        new: ::subxt::utils::MultiAddress<
                            ::subxt::utils::AccountId32,
                            ::core::primitive::u32,
                        >,
                        index: ::core::primitive::u32,
                    },
                    #[codec(index = 2)]
                    ///Free up an index owned by the sender.
                    ///
                    ///Payment: Any previous deposit placed for the index is unreserved in the sender account.
                    ///
                    ///The dispatch origin for this call must be _Signed_ and the sender must own the index.
                    ///
                    ///- `index`: the index to be freed. This must be owned by the sender.
                    ///
                    ///Emits `IndexFreed` if successful.
                    ///
                    ///## Complexity
                    ///- `O(1)`.
                    free { index: ::core::primitive::u32 },
                    #[codec(index = 3)]
                    ///Force an index to an account. This doesn't require a deposit. If the index is already
                    ///held, then any deposit is reimbursed to its current owner.
                    ///
                    ///The dispatch origin for this call must be _Root_.
                    ///
                    ///- `index`: the index to be (re-)assigned.
                    ///- `new`: the new owner of the index. This function is a no-op if it is equal to sender.
                    ///- `freeze`: if set to `true`, will freeze the index so it cannot be transferred.
                    ///
                    ///Emits `IndexAssigned` if successful.
                    ///
                    ///## Complexity
                    ///- `O(1)`.
                    force_transfer {
                        new: ::subxt::utils::MultiAddress<
                            ::subxt::utils::AccountId32,
                            ::core::primitive::u32,
                        >,
                        index: ::core::primitive::u32,
                        freeze: ::core::primitive::bool,
                    },
                    #[codec(index = 4)]
                    ///Freeze an index so it will always point to the sender account. This consumes the
                    ///deposit.
                    ///
                    ///The dispatch origin for this call must be _Signed_ and the signing account must have a
                    ///non-frozen account `index`.
                    ///
                    ///- `index`: the index to be frozen in place.
                    ///
                    ///Emits `IndexFrozen` if successful.
                    ///
                    ///## Complexity
                    ///- `O(1)`.
                    freeze { index: ::core::primitive::u32 },
                }
                #[derive(
                    ::subxt::ext::codec::Decode,
                    ::subxt::ext::codec::Encode,
                    ::subxt::ext::scale_decode::DecodeAsType,
                    ::subxt::ext::scale_encode::EncodeAsType,
                    Clone,
                    Debug,
                    Eq,
                    PartialEq
                )]
                #[codec(crate = ::subxt::ext::codec)]
                #[decode_as_type(crate_path = ":: subxt :: ext :: scale_decode")]
                #[encode_as_type(crate_path = ":: subxt :: ext :: scale_encode")]
                /**
			Custom [dispatch errors](https://docs.substrate.io/main-docs/build/events-errors/)
			of this pallet.
			*/
                pub enum Error {
                    #[codec(index = 0)]
                    ///The index was not already assigned.
                    NotAssigned,
                    #[codec(index = 1)]
                    ///The index is assigned to another account.
                    NotOwner,
                    #[codec(index = 2)]
                    ///The index was not available.
                    InUse,
                    #[codec(index = 3)]
                    ///The source and destination accounts are identical.
                    NotTransfer,
                    #[codec(index = 4)]
                    ///The index is permanent and may not be freed/changed.
                    Permanent,
                }
                #[derive(
                    ::subxt::ext::codec::Decode,
                    ::subxt::ext::codec::Encode,
                    ::subxt::ext::scale_decode::DecodeAsType,
                    ::subxt::ext::scale_encode::EncodeAsType,
                    Clone,
                    Debug,
                    Eq,
                    PartialEq
                )]
                #[codec(crate = ::subxt::ext::codec)]
                #[decode_as_type(crate_path = ":: subxt :: ext :: scale_decode")]
                #[encode_as_type(crate_path = ":: subxt :: ext :: scale_encode")]
                /**
			The [event](https://docs.substrate.io/main-docs/build/events-errors/) emitted
			by this pallet.
			*/
                pub enum Event {
                    #[codec(index = 0)]
                    ///A account index was assigned.
                    IndexAssigned {
                        who: ::subxt::utils::AccountId32,
                        index: ::core::primitive::u32,
                    },
                    #[codec(index = 1)]
                    ///A account index has been freed up (unassigned).
                    IndexFreed { index: ::core::primitive::u32 },
                    #[codec(index = 2)]
                    ///A account index has been frozen to its current account ID.
                    IndexFrozen {
                        index: ::core::primitive::u32,
                        who: ::subxt::utils::AccountId32,
                    },
                }
            }
        }
        pub mod pallet_nomination_pools {
            use super::runtime_types;
            pub mod pallet {
                use super::runtime_types;
                #[derive(
                    ::subxt::ext::codec::Decode,
                    ::subxt::ext::codec::Encode,
                    ::subxt::ext::scale_decode::DecodeAsType,
                    ::subxt::ext::scale_encode::EncodeAsType,
                    Clone,
                    Debug,
                    Eq,
                    PartialEq
                )]
                #[codec(crate = ::subxt::ext::codec)]
                #[decode_as_type(crate_path = ":: subxt :: ext :: scale_decode")]
                #[encode_as_type(crate_path = ":: subxt :: ext :: scale_encode")]
                ///Contains one variant per dispatchable that can be called by an extrinsic.
                pub enum Call {
                    #[codec(index = 0)]
                    ///Stake funds with a pool. The amount to bond is transferred from the member to the
                    ///pools account and immediately increases the pools bond.
                    ///
                    ///# Note
                    ///
                    ///* An account can only be a member of a single pool.
                    ///* An account cannot join the same pool multiple times.
                    ///* This call will *not* dust the member account, so the member must have at least
                    ///  `existential deposit + amount` in their account.
                    ///* Only a pool with [`PoolState::Open`] can be joined
                    join {
                        #[codec(compact)]
                        amount: ::core::primitive::u128,
                        pool_id: ::core::primitive::u32,
                    },
                    #[codec(index = 1)]
                    ///Bond `extra` more funds from `origin` into the pool to which they already belong.
                    ///
                    ///Additional funds can come from either the free balance of the account, of from the
                    ///accumulated rewards, see [`BondExtra`].
                    ///
                    ///Bonding extra funds implies an automatic payout of all pending rewards as well.
                    ///See `bond_extra_other` to bond pending rewards of `other` members.
                    bond_extra {
                        extra: runtime_types::pallet_nomination_pools::BondExtra<
                            ::core::primitive::u128,
                        >,
                    },
                    #[codec(index = 2)]
                    ///A bonded member can use this to claim their payout based on the rewards that the pool
                    ///has accumulated since their last claimed payout (OR since joining if this is their first
                    ///time claiming rewards). The payout will be transferred to the member's account.
                    ///
                    ///The member will earn rewards pro rata based on the members stake vs the sum of the
                    ///members in the pools stake. Rewards do not "expire".
                    ///
                    ///See `claim_payout_other` to caim rewards on bahalf of some `other` pool member.
                    claim_payout,
                    #[codec(index = 3)]
                    ///Unbond up to `unbonding_points` of the `member_account`'s funds from the pool. It
                    ///implicitly collects the rewards one last time, since not doing so would mean some
                    ///rewards would be forfeited.
                    ///
                    ///Under certain conditions, this call can be dispatched permissionlessly (i.e. by any
                    ///account).
                    ///
                    ///# Conditions for a permissionless dispatch.
                    ///
                    ///* The pool is blocked and the caller is either the root or bouncer. This is refereed to
                    ///  as a kick.
                    ///* The pool is destroying and the member is not the depositor.
                    ///* The pool is destroying, the member is the depositor and no other members are in the
                    ///  pool.
                    ///
                    ///## Conditions for permissioned dispatch (i.e. the caller is also the
                    ///`member_account`):
                    ///
                    ///* The caller is not the depositor.
                    ///* The caller is the depositor, the pool is destroying and no other members are in the
                    ///  pool.
                    ///
                    ///# Note
                    ///
                    ///If there are too many unlocking chunks to unbond with the pool account,
                    ///[`Call::pool_withdraw_unbonded`] can be called to try and minimize unlocking chunks.
                    ///The [`StakingInterface::unbond`] will implicitly call [`Call::pool_withdraw_unbonded`]
                    ///to try to free chunks if necessary (ie. if unbound was called and no unlocking chunks
                    ///are available). However, it may not be possible to release the current unlocking chunks,
                    ///in which case, the result of this call will likely be the `NoMoreChunks` error from the
                    ///staking system.
                    unbond {
                        member_account: ::subxt::utils::MultiAddress<
                            ::subxt::utils::AccountId32,
                            ::core::primitive::u32,
                        >,
                        #[codec(compact)]
                        unbonding_points: ::core::primitive::u128,
                    },
                    #[codec(index = 4)]
                    ///Call `withdraw_unbonded` for the pools account. This call can be made by any account.
                    ///
                    ///This is useful if their are too many unlocking chunks to call `unbond`, and some
                    ///can be cleared by withdrawing. In the case there are too many unlocking chunks, the user
                    ///would probably see an error like `NoMoreChunks` emitted from the staking system when
                    ///they attempt to unbond.
                    pool_withdraw_unbonded {
                        pool_id: ::core::primitive::u32,
                        num_slashing_spans: ::core::primitive::u32,
                    },
                    #[codec(index = 5)]
                    ///Withdraw unbonded funds from `member_account`. If no bonded funds can be unbonded, an
                    ///error is returned.
                    ///
                    ///Under certain conditions, this call can be dispatched permissionlessly (i.e. by any
                    ///account).
                    ///
                    ///# Conditions for a permissionless dispatch
                    ///
                    ///* The pool is in destroy mode and the target is not the depositor.
                    ///* The target is the depositor and they are the only member in the sub pools.
                    ///* The pool is blocked and the caller is either the root or bouncer.
                    ///
                    ///# Conditions for permissioned dispatch
                    ///
                    ///* The caller is the target and they are not the depositor.
                    ///
                    ///# Note
                    ///
                    ///If the target is the depositor, the pool will be destroyed.
                    withdraw_unbonded {
                        member_account: ::subxt::utils::MultiAddress<
                            ::subxt::utils::AccountId32,
                            ::core::primitive::u32,
                        >,
                        num_slashing_spans: ::core::primitive::u32,
                    },
                    #[codec(index = 6)]
                    ///Create a new delegation pool.
                    ///
                    ///# Arguments
                    ///
                    ///* `amount` - The amount of funds to delegate to the pool. This also acts of a sort of
                    ///  deposit since the pools creator cannot fully unbond funds until the pool is being
                    ///  destroyed.
                    ///* `index` - A disambiguation index for creating the account. Likely only useful when
                    ///  creating multiple pools in the same extrinsic.
                    ///* `root` - The account to set as [`PoolRoles::root`].
                    ///* `nominator` - The account to set as the [`PoolRoles::nominator`].
                    ///* `bouncer` - The account to set as the [`PoolRoles::bouncer`].
                    ///
                    ///# Note
                    ///
                    ///In addition to `amount`, the caller will transfer the existential deposit; so the caller
                    ///needs at have at least `amount + existential_deposit` transferrable.
                    create {
                        #[codec(compact)]
                        amount: ::core::primitive::u128,
                        root: ::subxt::utils::MultiAddress<
                            ::subxt::utils::AccountId32,
                            ::core::primitive::u32,
                        >,
                        nominator: ::subxt::utils::MultiAddress<
                            ::subxt::utils::AccountId32,
                            ::core::primitive::u32,
                        >,
                        bouncer: ::subxt::utils::MultiAddress<
                            ::subxt::utils::AccountId32,
                            ::core::primitive::u32,
                        >,
                    },
                    #[codec(index = 7)]
                    ///Create a new delegation pool with a previously used pool id
                    ///
                    ///# Arguments
                    ///
                    ///same as `create` with the inclusion of
                    ///* `pool_id` - `A valid PoolId.
                    create_with_pool_id {
                        #[codec(compact)]
                        amount: ::core::primitive::u128,
                        root: ::subxt::utils::MultiAddress<
                            ::subxt::utils::AccountId32,
                            ::core::primitive::u32,
                        >,
                        nominator: ::subxt::utils::MultiAddress<
                            ::subxt::utils::AccountId32,
                            ::core::primitive::u32,
                        >,
                        bouncer: ::subxt::utils::MultiAddress<
                            ::subxt::utils::AccountId32,
                            ::core::primitive::u32,
                        >,
                        pool_id: ::core::primitive::u32,
                    },
                    #[codec(index = 8)]
                    ///Nominate on behalf of the pool.
                    ///
                    ///The dispatch origin of this call must be signed by the pool nominator or the pool
                    ///root role.
                    ///
                    ///This directly forward the call to the staking pallet, on behalf of the pool bonded
                    ///account.
                    nominate {
                        pool_id: ::core::primitive::u32,
                        validators: ::std::vec::Vec<::subxt::utils::AccountId32>,
                    },
                    #[codec(index = 9)]
                    ///Set a new state for the pool.
                    ///
                    ///If a pool is already in the `Destroying` state, then under no condition can its state
                    ///change again.
                    ///
                    ///The dispatch origin of this call must be either:
                    ///
                    ///1. signed by the bouncer, or the root role of the pool,
                    ///2. if the pool conditions to be open are NOT met (as described by `ok_to_be_open`), and
                    ///   then the state of the pool can be permissionlessly changed to `Destroying`.
                    set_state {
                        pool_id: ::core::primitive::u32,
                        state: runtime_types::pallet_nomination_pools::PoolState,
                    },
                    #[codec(index = 10)]
                    ///Set a new metadata for the pool.
                    ///
                    ///The dispatch origin of this call must be signed by the bouncer, or the root role of the
                    ///pool.
                    set_metadata {
                        pool_id: ::core::primitive::u32,
                        metadata: ::std::vec::Vec<::core::primitive::u8>,
                    },
                    #[codec(index = 11)]
                    ///Update configurations for the nomination pools. The origin for this call must be
                    ///Root.
                    ///
                    ///# Arguments
                    ///
                    ///* `min_join_bond` - Set [`MinJoinBond`].
                    ///* `min_create_bond` - Set [`MinCreateBond`].
                    ///* `max_pools` - Set [`MaxPools`].
                    ///* `max_members` - Set [`MaxPoolMembers`].
                    ///* `max_members_per_pool` - Set [`MaxPoolMembersPerPool`].
                    ///* `global_max_commission` - Set [`GlobalMaxCommission`].
                    set_configs {
                        min_join_bond: runtime_types::pallet_nomination_pools::ConfigOp<
                            ::core::primitive::u128,
                        >,
                        min_create_bond: runtime_types::pallet_nomination_pools::ConfigOp<
                            ::core::primitive::u128,
                        >,
                        max_pools: runtime_types::pallet_nomination_pools::ConfigOp<
                            ::core::primitive::u32,
                        >,
                        max_members: runtime_types::pallet_nomination_pools::ConfigOp<
                            ::core::primitive::u32,
                        >,
                        max_members_per_pool: runtime_types::pallet_nomination_pools::ConfigOp<
                            ::core::primitive::u32,
                        >,
                        global_max_commission: runtime_types::pallet_nomination_pools::ConfigOp<
                            runtime_types::sp_arithmetic::per_things::Perbill,
                        >,
                    },
                    #[codec(index = 12)]
                    ///Update the roles of the pool.
                    ///
                    ///The root is the only entity that can change any of the roles, including itself,
                    ///excluding the depositor, who can never change.
                    ///
                    ///It emits an event, notifying UIs of the role change. This event is quite relevant to
                    ///most pool members and they should be informed of changes to pool roles.
                    update_roles {
                        pool_id: ::core::primitive::u32,
                        new_root: runtime_types::pallet_nomination_pools::ConfigOp<
                            ::subxt::utils::AccountId32,
                        >,
                        new_nominator: runtime_types::pallet_nomination_pools::ConfigOp<
                            ::subxt::utils::AccountId32,
                        >,
                        new_bouncer: runtime_types::pallet_nomination_pools::ConfigOp<
                            ::subxt::utils::AccountId32,
                        >,
                    },
                    #[codec(index = 13)]
                    ///Chill on behalf of the pool.
                    ///
                    ///The dispatch origin of this call must be signed by the pool nominator or the pool
                    ///root role, same as [`Pallet::nominate`].
                    ///
                    ///This directly forward the call to the staking pallet, on behalf of the pool bonded
                    ///account.
                    chill { pool_id: ::core::primitive::u32 },
                    #[codec(index = 14)]
                    ///`origin` bonds funds from `extra` for some pool member `member` into their respective
                    ///pools.
                    ///
                    ///`origin` can bond extra funds from free balance or pending rewards when `origin ==
                    ///other`.
                    ///
                    ///In the case of `origin != other`, `origin` can only bond extra pending rewards of
                    ///`other` members assuming set_claim_permission for the given member is
                    ///`PermissionlessAll` or `PermissionlessCompound`.
                    bond_extra_other {
                        member: ::subxt::utils::MultiAddress<
                            ::subxt::utils::AccountId32,
                            ::core::primitive::u32,
                        >,
                        extra: runtime_types::pallet_nomination_pools::BondExtra<
                            ::core::primitive::u128,
                        >,
                    },
                    #[codec(index = 15)]
                    ///Allows a pool member to set a claim permission to allow or disallow permissionless
                    ///bonding and withdrawing.
                    ///
                    ///By default, this is `Permissioned`, which implies only the pool member themselves can
                    ///claim their pending rewards. If a pool member wishes so, they can set this to
                    ///`PermissionlessAll` to allow any account to claim their rewards and bond extra to the
                    ///pool.
                    ///
                    ///# Arguments
                    ///
                    ///* `origin` - Member of a pool.
                    ///* `actor` - Account to claim reward. // improve this
                    set_claim_permission {
                        permission: runtime_types::pallet_nomination_pools::ClaimPermission,
                    },
                    #[codec(index = 16)]
                    ///`origin` can claim payouts on some pool member `other`'s behalf.
                    ///
                    ///Pool member `other` must have a `PermissionlessAll` or `PermissionlessWithdraw` in order
                    ///for this call to be successful.
                    claim_payout_other { other: ::subxt::utils::AccountId32 },
                    #[codec(index = 17)]
                    ///Set the commission of a pool.
                    ///Both a commission percentage and a commission payee must be provided in the `current`
                    ///tuple. Where a `current` of `None` is provided, any current commission will be removed.
                    ///
                    ///- If a `None` is supplied to `new_commission`, existing commission will be removed.
                    set_commission {
                        pool_id: ::core::primitive::u32,
                        new_commission: ::core::option::Option<
                            (
                                runtime_types::sp_arithmetic::per_things::Perbill,
                                ::subxt::utils::AccountId32,
                            ),
                        >,
                    },
                    #[codec(index = 18)]
                    ///Set the maximum commission of a pool.
                    ///
                    ///- Initial max can be set to any `Perbill`, and only smaller values thereafter.
                    ///- Current commission will be lowered in the event it is higher than a new max
                    ///  commission.
                    set_commission_max {
                        pool_id: ::core::primitive::u32,
                        max_commission: runtime_types::sp_arithmetic::per_things::Perbill,
                    },
                    #[codec(index = 19)]
                    ///Set the commission change rate for a pool.
                    ///
                    ///Initial change rate is not bounded, whereas subsequent updates can only be more
                    ///restrictive than the current.
                    set_commission_change_rate {
                        pool_id: ::core::primitive::u32,
                        change_rate: runtime_types::pallet_nomination_pools::CommissionChangeRate<
                            ::core::primitive::u32,
                        >,
                    },
                    #[codec(index = 20)]
                    ///Claim pending commission.
                    ///
                    ///The dispatch origin of this call must be signed by the `root` role of the pool. Pending
                    ///commission is paid out and added to total claimed commission`. Total pending commission
                    ///is reset to zero. the current.
                    claim_commission { pool_id: ::core::primitive::u32 },
                }
                #[derive(
                    ::subxt::ext::codec::Decode,
                    ::subxt::ext::codec::Encode,
                    ::subxt::ext::scale_decode::DecodeAsType,
                    ::subxt::ext::scale_encode::EncodeAsType,
                    Clone,
                    Debug,
                    Eq,
                    PartialEq
                )]
                #[codec(crate = ::subxt::ext::codec)]
                #[decode_as_type(crate_path = ":: subxt :: ext :: scale_decode")]
                #[encode_as_type(crate_path = ":: subxt :: ext :: scale_encode")]
                pub enum DefensiveError {
                    #[codec(index = 0)]
                    NotEnoughSpaceInUnbondPool,
                    #[codec(index = 1)]
                    PoolNotFound,
                    #[codec(index = 2)]
                    RewardPoolNotFound,
                    #[codec(index = 3)]
                    SubPoolsNotFound,
                    #[codec(index = 4)]
                    BondedStashKilledPrematurely,
                }
                #[derive(
                    ::subxt::ext::codec::Decode,
                    ::subxt::ext::codec::Encode,
                    ::subxt::ext::scale_decode::DecodeAsType,
                    ::subxt::ext::scale_encode::EncodeAsType,
                    Clone,
                    Debug,
                    Eq,
                    PartialEq
                )]
                #[codec(crate = ::subxt::ext::codec)]
                #[decode_as_type(crate_path = ":: subxt :: ext :: scale_decode")]
                #[encode_as_type(crate_path = ":: subxt :: ext :: scale_encode")]
                /**
			Custom [dispatch errors](https://docs.substrate.io/main-docs/build/events-errors/)
			of this pallet.
			*/
                pub enum Error {
                    #[codec(index = 0)]
                    ///A (bonded) pool id does not exist.
                    PoolNotFound,
                    #[codec(index = 1)]
                    ///An account is not a member.
                    PoolMemberNotFound,
                    #[codec(index = 2)]
                    ///A reward pool does not exist. In all cases this is a system logic error.
                    RewardPoolNotFound,
                    #[codec(index = 3)]
                    ///A sub pool does not exist.
                    SubPoolsNotFound,
                    #[codec(index = 4)]
                    ///An account is already delegating in another pool. An account may only belong to one
                    ///pool at a time.
                    AccountBelongsToOtherPool,
                    #[codec(index = 5)]
                    ///The member is fully unbonded (and thus cannot access the bonded and reward pool
                    ///anymore to, for example, collect rewards).
                    FullyUnbonding,
                    #[codec(index = 6)]
                    ///The member cannot unbond further chunks due to reaching the limit.
                    MaxUnbondingLimit,
                    #[codec(index = 7)]
                    ///None of the funds can be withdrawn yet because the bonding duration has not passed.
                    CannotWithdrawAny,
                    #[codec(index = 8)]
                    ///The amount does not meet the minimum bond to either join or create a pool.
                    ///
                    ///The depositor can never unbond to a value less than
                    ///`Pallet::depositor_min_bond`. The caller does not have nominating
                    ///permissions for the pool. Members can never unbond to a value below `MinJoinBond`.
                    MinimumBondNotMet,
                    #[codec(index = 9)]
                    ///The transaction could not be executed due to overflow risk for the pool.
                    OverflowRisk,
                    #[codec(index = 10)]
                    ///A pool must be in [`PoolState::Destroying`] in order for the depositor to unbond or for
                    ///other members to be permissionlessly unbonded.
                    NotDestroying,
                    #[codec(index = 11)]
                    ///The caller does not have nominating permissions for the pool.
                    NotNominator,
                    #[codec(index = 12)]
                    ///Either a) the caller cannot make a valid kick or b) the pool is not destroying.
                    NotKickerOrDestroying,
                    #[codec(index = 13)]
                    ///The pool is not open to join
                    NotOpen,
                    #[codec(index = 14)]
                    ///The system is maxed out on pools.
                    MaxPools,
                    #[codec(index = 15)]
                    ///Too many members in the pool or system.
                    MaxPoolMembers,
                    #[codec(index = 16)]
                    ///The pools state cannot be changed.
                    CanNotChangeState,
                    #[codec(index = 17)]
                    ///The caller does not have adequate permissions.
                    DoesNotHavePermission,
                    #[codec(index = 18)]
                    ///Metadata exceeds [`Config::MaxMetadataLen`]
                    MetadataExceedsMaxLen,
                    #[codec(index = 19)]
                    ///Some error occurred that should never happen. This should be reported to the
                    ///maintainers.
                    Defensive(
                        runtime_types::pallet_nomination_pools::pallet::DefensiveError,
                    ),
                    #[codec(index = 20)]
                    ///Partial unbonding now allowed permissionlessly.
                    PartialUnbondNotAllowedPermissionlessly,
                    #[codec(index = 21)]
                    ///The pool's max commission cannot be set higher than the existing value.
                    MaxCommissionRestricted,
                    #[codec(index = 22)]
                    ///The supplied commission exceeds the max allowed commission.
                    CommissionExceedsMaximum,
                    #[codec(index = 23)]
                    ///Not enough blocks have surpassed since the last commission update.
                    CommissionChangeThrottled,
                    #[codec(index = 24)]
                    ///The submitted changes to commission change rate are not allowed.
                    CommissionChangeRateNotAllowed,
                    #[codec(index = 25)]
                    ///There is no pending commission to claim.
                    NoPendingCommission,
                    #[codec(index = 26)]
                    ///No commission current has been set.
                    NoCommissionCurrentSet,
                    #[codec(index = 27)]
                    ///Pool id currently in use.
                    PoolIdInUse,
                    #[codec(index = 28)]
                    ///Pool id provided is not correct/usable.
                    InvalidPoolId,
                    #[codec(index = 29)]
                    ///Bonding extra is restricted to the exact pending reward amount.
                    BondExtraRestricted,
                }
                #[derive(
                    ::subxt::ext::codec::Decode,
                    ::subxt::ext::codec::Encode,
                    ::subxt::ext::scale_decode::DecodeAsType,
                    ::subxt::ext::scale_encode::EncodeAsType,
                    Clone,
                    Debug,
                    Eq,
                    PartialEq
                )]
                #[codec(crate = ::subxt::ext::codec)]
                #[decode_as_type(crate_path = ":: subxt :: ext :: scale_decode")]
                #[encode_as_type(crate_path = ":: subxt :: ext :: scale_encode")]
                ///Events of this pallet.
                pub enum Event {
                    #[codec(index = 0)]
                    ///A pool has been created.
                    Created {
                        depositor: ::subxt::utils::AccountId32,
                        pool_id: ::core::primitive::u32,
                    },
                    #[codec(index = 1)]
                    ///A member has became bonded in a pool.
                    Bonded {
                        member: ::subxt::utils::AccountId32,
                        pool_id: ::core::primitive::u32,
                        bonded: ::core::primitive::u128,
                        joined: ::core::primitive::bool,
                    },
                    #[codec(index = 2)]
                    ///A payout has been made to a member.
                    PaidOut {
                        member: ::subxt::utils::AccountId32,
                        pool_id: ::core::primitive::u32,
                        payout: ::core::primitive::u128,
                    },
                    #[codec(index = 3)]
                    ///A member has unbonded from their pool.
                    ///
                    ///- `balance` is the corresponding balance of the number of points that has been
                    ///  requested to be unbonded (the argument of the `unbond` transaction) from the bonded
                    ///  pool.
                    ///- `points` is the number of points that are issued as a result of `balance` being
                    ///dissolved into the corresponding unbonding pool.
                    ///- `era` is the era in which the balance will be unbonded.
                    ///In the absence of slashing, these values will match. In the presence of slashing, the
                    ///number of points that are issued in the unbonding pool will be less than the amount
                    ///requested to be unbonded.
                    Unbonded {
                        member: ::subxt::utils::AccountId32,
                        pool_id: ::core::primitive::u32,
                        balance: ::core::primitive::u128,
                        points: ::core::primitive::u128,
                        era: ::core::primitive::u32,
                    },
                    #[codec(index = 4)]
                    ///A member has withdrawn from their pool.
                    ///
                    ///The given number of `points` have been dissolved in return of `balance`.
                    ///
                    ///Similar to `Unbonded` event, in the absence of slashing, the ratio of point to balance
                    ///will be 1.
                    Withdrawn {
                        member: ::subxt::utils::AccountId32,
                        pool_id: ::core::primitive::u32,
                        balance: ::core::primitive::u128,
                        points: ::core::primitive::u128,
                    },
                    #[codec(index = 5)]
                    ///A pool has been destroyed.
                    Destroyed { pool_id: ::core::primitive::u32 },
                    #[codec(index = 6)]
                    ///The state of a pool has changed
                    StateChanged {
                        pool_id: ::core::primitive::u32,
                        new_state: runtime_types::pallet_nomination_pools::PoolState,
                    },
                    #[codec(index = 7)]
                    ///A member has been removed from a pool.
                    ///
                    ///The removal can be voluntary (withdrawn all unbonded funds) or involuntary (kicked).
                    MemberRemoved {
                        pool_id: ::core::primitive::u32,
                        member: ::subxt::utils::AccountId32,
                    },
                    #[codec(index = 8)]
                    ///The roles of a pool have been updated to the given new roles. Note that the depositor
                    ///can never change.
                    RolesUpdated {
                        root: ::core::option::Option<::subxt::utils::AccountId32>,
                        bouncer: ::core::option::Option<::subxt::utils::AccountId32>,
                        nominator: ::core::option::Option<::subxt::utils::AccountId32>,
                    },
                    #[codec(index = 9)]
                    ///The active balance of pool `pool_id` has been slashed to `balance`.
                    PoolSlashed {
                        pool_id: ::core::primitive::u32,
                        balance: ::core::primitive::u128,
                    },
                    #[codec(index = 10)]
                    ///The unbond pool at `era` of pool `pool_id` has been slashed to `balance`.
                    UnbondingPoolSlashed {
                        pool_id: ::core::primitive::u32,
                        era: ::core::primitive::u32,
                        balance: ::core::primitive::u128,
                    },
                    #[codec(index = 11)]
                    ///A pool's commission setting has been changed.
                    PoolCommissionUpdated {
                        pool_id: ::core::primitive::u32,
                        current: ::core::option::Option<
                            (
                                runtime_types::sp_arithmetic::per_things::Perbill,
                                ::subxt::utils::AccountId32,
                            ),
                        >,
                    },
                    #[codec(index = 12)]
                    ///A pool's maximum commission setting has been changed.
                    PoolMaxCommissionUpdated {
                        pool_id: ::core::primitive::u32,
                        max_commission: runtime_types::sp_arithmetic::per_things::Perbill,
                    },
                    #[codec(index = 13)]
                    ///A pool's commission `change_rate` has been changed.
                    PoolCommissionChangeRateUpdated {
                        pool_id: ::core::primitive::u32,
                        change_rate: runtime_types::pallet_nomination_pools::CommissionChangeRate<
                            ::core::primitive::u32,
                        >,
                    },
                    #[codec(index = 14)]
                    ///Pool commission has been claimed.
                    PoolCommissionClaimed {
                        pool_id: ::core::primitive::u32,
                        commission: ::core::primitive::u128,
                    },
                }
            }
            #[derive(
                ::subxt::ext::codec::Decode,
                ::subxt::ext::codec::Encode,
                ::subxt::ext::scale_decode::DecodeAsType,
                ::subxt::ext::scale_encode::EncodeAsType,
                Clone,
                Debug,
                Eq,
                PartialEq
            )]
            #[codec(crate = ::subxt::ext::codec)]
            #[decode_as_type(crate_path = ":: subxt :: ext :: scale_decode")]
            #[encode_as_type(crate_path = ":: subxt :: ext :: scale_encode")]
            pub enum BondExtra<_0> {
                #[codec(index = 0)]
                FreeBalance(_0),
                #[codec(index = 1)]
                Rewards,
            }
            #[derive(
                ::subxt::ext::codec::Decode,
                ::subxt::ext::codec::Encode,
                ::subxt::ext::scale_decode::DecodeAsType,
                ::subxt::ext::scale_encode::EncodeAsType,
                Clone,
                Debug,
                Eq,
                PartialEq
            )]
            #[codec(crate = ::subxt::ext::codec)]
            #[decode_as_type(crate_path = ":: subxt :: ext :: scale_decode")]
            #[encode_as_type(crate_path = ":: subxt :: ext :: scale_encode")]
            pub struct BondedPoolInner {
                pub commission: runtime_types::pallet_nomination_pools::Commission,
                pub member_counter: ::core::primitive::u32,
                pub points: ::core::primitive::u128,
                pub roles: runtime_types::pallet_nomination_pools::PoolRoles<
                    ::subxt::utils::AccountId32,
                >,
                pub state: runtime_types::pallet_nomination_pools::PoolState,
            }
            #[derive(
                ::subxt::ext::codec::Decode,
                ::subxt::ext::codec::Encode,
                ::subxt::ext::scale_decode::DecodeAsType,
                ::subxt::ext::scale_encode::EncodeAsType,
                Clone,
                Debug,
                Eq,
                PartialEq
            )]
            #[codec(crate = ::subxt::ext::codec)]
            #[decode_as_type(crate_path = ":: subxt :: ext :: scale_decode")]
            #[encode_as_type(crate_path = ":: subxt :: ext :: scale_encode")]
            pub enum ClaimPermission {
                #[codec(index = 0)]
                Permissioned,
                #[codec(index = 1)]
                PermissionlessCompound,
                #[codec(index = 2)]
                PermissionlessWithdraw,
                #[codec(index = 3)]
                PermissionlessAll,
            }
            #[derive(
                ::subxt::ext::codec::Decode,
                ::subxt::ext::codec::Encode,
                ::subxt::ext::scale_decode::DecodeAsType,
                ::subxt::ext::scale_encode::EncodeAsType,
                Clone,
                Debug,
                Eq,
                PartialEq
            )]
            #[codec(crate = ::subxt::ext::codec)]
            #[decode_as_type(crate_path = ":: subxt :: ext :: scale_decode")]
            #[encode_as_type(crate_path = ":: subxt :: ext :: scale_encode")]
            pub struct Commission {
                pub current: ::core::option::Option<
                    (
                        runtime_types::sp_arithmetic::per_things::Perbill,
                        ::subxt::utils::AccountId32,
                    ),
                >,
                pub max: ::core::option::Option<
                    runtime_types::sp_arithmetic::per_things::Perbill,
                >,
                pub change_rate: ::core::option::Option<
                    runtime_types::pallet_nomination_pools::CommissionChangeRate<
                        ::core::primitive::u32,
                    >,
                >,
                pub throttle_from: ::core::option::Option<::core::primitive::u32>,
            }
            #[derive(
                ::subxt::ext::codec::Decode,
                ::subxt::ext::codec::Encode,
                ::subxt::ext::scale_decode::DecodeAsType,
                ::subxt::ext::scale_encode::EncodeAsType,
                Clone,
                Debug,
                Eq,
                PartialEq
            )]
            #[codec(crate = ::subxt::ext::codec)]
            #[decode_as_type(crate_path = ":: subxt :: ext :: scale_decode")]
            #[encode_as_type(crate_path = ":: subxt :: ext :: scale_encode")]
            pub struct CommissionChangeRate<_0> {
                pub max_increase: runtime_types::sp_arithmetic::per_things::Perbill,
                pub min_delay: _0,
            }
            #[derive(
                ::subxt::ext::codec::Decode,
                ::subxt::ext::codec::Encode,
                ::subxt::ext::scale_decode::DecodeAsType,
                ::subxt::ext::scale_encode::EncodeAsType,
                Clone,
                Debug,
                Eq,
                PartialEq
            )]
            #[codec(crate = ::subxt::ext::codec)]
            #[decode_as_type(crate_path = ":: subxt :: ext :: scale_decode")]
            #[encode_as_type(crate_path = ":: subxt :: ext :: scale_encode")]
            pub enum ConfigOp<_0> {
                #[codec(index = 0)]
                Noop,
                #[codec(index = 1)]
                Set(_0),
                #[codec(index = 2)]
                Remove,
            }
            #[derive(
                ::subxt::ext::codec::Decode,
                ::subxt::ext::codec::Encode,
                ::subxt::ext::scale_decode::DecodeAsType,
                ::subxt::ext::scale_encode::EncodeAsType,
                Clone,
                Debug,
                Eq,
                PartialEq
            )]
            #[codec(crate = ::subxt::ext::codec)]
            #[decode_as_type(crate_path = ":: subxt :: ext :: scale_decode")]
            #[encode_as_type(crate_path = ":: subxt :: ext :: scale_encode")]
            pub struct PoolMember {
                pub pool_id: ::core::primitive::u32,
                pub points: ::core::primitive::u128,
                pub last_recorded_reward_counter: runtime_types::sp_arithmetic::fixed_point::FixedU128,
                pub unbonding_eras: runtime_types::bounded_collections::bounded_btree_map::BoundedBTreeMap<
                    ::core::primitive::u32,
                    ::core::primitive::u128,
                >,
            }
            #[derive(
                ::subxt::ext::codec::Decode,
                ::subxt::ext::codec::Encode,
                ::subxt::ext::scale_decode::DecodeAsType,
                ::subxt::ext::scale_encode::EncodeAsType,
                Clone,
                Debug,
                Eq,
                PartialEq
            )]
            #[codec(crate = ::subxt::ext::codec)]
            #[decode_as_type(crate_path = ":: subxt :: ext :: scale_decode")]
            #[encode_as_type(crate_path = ":: subxt :: ext :: scale_encode")]
            pub struct PoolRoles<_0> {
                pub depositor: _0,
                pub root: ::core::option::Option<_0>,
                pub nominator: ::core::option::Option<_0>,
                pub bouncer: ::core::option::Option<_0>,
            }
            #[derive(
                ::subxt::ext::codec::Decode,
                ::subxt::ext::codec::Encode,
                ::subxt::ext::scale_decode::DecodeAsType,
                ::subxt::ext::scale_encode::EncodeAsType,
                Clone,
                Debug,
                Eq,
                PartialEq
            )]
            #[codec(crate = ::subxt::ext::codec)]
            #[decode_as_type(crate_path = ":: subxt :: ext :: scale_decode")]
            #[encode_as_type(crate_path = ":: subxt :: ext :: scale_encode")]
            pub enum PoolState {
                #[codec(index = 0)]
                Open,
                #[codec(index = 1)]
                Blocked,
                #[codec(index = 2)]
                Destroying,
            }
            #[derive(
                ::subxt::ext::codec::Decode,
                ::subxt::ext::codec::Encode,
                ::subxt::ext::scale_decode::DecodeAsType,
                ::subxt::ext::scale_encode::EncodeAsType,
                Clone,
                Debug,
                Eq,
                PartialEq
            )]
            #[codec(crate = ::subxt::ext::codec)]
            #[decode_as_type(crate_path = ":: subxt :: ext :: scale_decode")]
            #[encode_as_type(crate_path = ":: subxt :: ext :: scale_encode")]
            pub struct RewardPool {
                pub last_recorded_reward_counter: runtime_types::sp_arithmetic::fixed_point::FixedU128,
                pub last_recorded_total_payouts: ::core::primitive::u128,
                pub total_rewards_claimed: ::core::primitive::u128,
                pub total_commission_pending: ::core::primitive::u128,
                pub total_commission_claimed: ::core::primitive::u128,
            }
            #[derive(
                ::subxt::ext::codec::Decode,
                ::subxt::ext::codec::Encode,
                ::subxt::ext::scale_decode::DecodeAsType,
                ::subxt::ext::scale_encode::EncodeAsType,
                Clone,
                Debug,
                Eq,
                PartialEq
            )]
            #[codec(crate = ::subxt::ext::codec)]
            #[decode_as_type(crate_path = ":: subxt :: ext :: scale_decode")]
            #[encode_as_type(crate_path = ":: subxt :: ext :: scale_encode")]
            pub struct SubPools {
                pub no_era: runtime_types::pallet_nomination_pools::UnbondPool,
                pub with_era: runtime_types::bounded_collections::bounded_btree_map::BoundedBTreeMap<
                    ::core::primitive::u32,
                    runtime_types::pallet_nomination_pools::UnbondPool,
                >,
            }
            #[derive(
                ::subxt::ext::codec::Decode,
                ::subxt::ext::codec::Encode,
                ::subxt::ext::scale_decode::DecodeAsType,
                ::subxt::ext::scale_encode::EncodeAsType,
                Clone,
                Debug,
                Eq,
                PartialEq
            )]
            #[codec(crate = ::subxt::ext::codec)]
            #[decode_as_type(crate_path = ":: subxt :: ext :: scale_decode")]
            #[encode_as_type(crate_path = ":: subxt :: ext :: scale_encode")]
            pub struct UnbondPool {
                pub points: ::core::primitive::u128,
                pub balance: ::core::primitive::u128,
            }
        }
        pub mod pallet_offences {
            use super::runtime_types;
            pub mod pallet {
                use super::runtime_types;
                #[derive(
                    ::subxt::ext::codec::Decode,
                    ::subxt::ext::codec::Encode,
                    ::subxt::ext::scale_decode::DecodeAsType,
                    ::subxt::ext::scale_encode::EncodeAsType,
                    Clone,
                    Debug,
                    Eq,
                    PartialEq
                )]
                #[codec(crate = ::subxt::ext::codec)]
                #[decode_as_type(crate_path = ":: subxt :: ext :: scale_decode")]
                #[encode_as_type(crate_path = ":: subxt :: ext :: scale_encode")]
                ///Events type.
                pub enum Event {
                    #[codec(index = 0)]
                    ///There is an offence reported of the given `kind` happened at the `session_index` and
                    ///(kind-specific) time slot. This event is not deposited for duplicate slashes.
                    ///\[kind, timeslot\].
                    Offence {
                        kind: [::core::primitive::u8; 16usize],
                        timeslot: ::std::vec::Vec<::core::primitive::u8>,
                    },
                }
            }
        }
        pub mod pallet_preimage {
            use super::runtime_types;
            pub mod pallet {
                use super::runtime_types;
                #[derive(
                    ::subxt::ext::codec::Decode,
                    ::subxt::ext::codec::Encode,
                    ::subxt::ext::scale_decode::DecodeAsType,
                    ::subxt::ext::scale_encode::EncodeAsType,
                    Clone,
                    Debug,
                    Eq,
                    PartialEq
                )]
                #[codec(crate = ::subxt::ext::codec)]
                #[decode_as_type(crate_path = ":: subxt :: ext :: scale_decode")]
                #[encode_as_type(crate_path = ":: subxt :: ext :: scale_encode")]
                ///Contains one variant per dispatchable that can be called by an extrinsic.
                pub enum Call {
                    #[codec(index = 0)]
                    ///Register a preimage on-chain.
                    ///
                    ///If the preimage was previously requested, no fees or deposits are taken for providing
                    ///the preimage. Otherwise, a deposit is taken proportional to the size of the preimage.
                    note_preimage { bytes: ::std::vec::Vec<::core::primitive::u8> },
                    #[codec(index = 1)]
                    ///Clear an unrequested preimage from the runtime storage.
                    ///
                    ///If `len` is provided, then it will be a much cheaper operation.
                    ///
                    ///- `hash`: The hash of the preimage to be removed from the store.
                    ///- `len`: The length of the preimage of `hash`.
                    unnote_preimage { hash: ::subxt::utils::H256 },
                    #[codec(index = 2)]
                    ///Request a preimage be uploaded to the chain without paying any fees or deposits.
                    ///
                    ///If the preimage requests has already been provided on-chain, we unreserve any deposit
                    ///a user may have paid, and take the control of the preimage out of their hands.
                    request_preimage { hash: ::subxt::utils::H256 },
                    #[codec(index = 3)]
                    ///Clear a previously made request for a preimage.
                    ///
                    ///NOTE: THIS MUST NOT BE CALLED ON `hash` MORE TIMES THAN `request_preimage`.
                    unrequest_preimage { hash: ::subxt::utils::H256 },
                }
                #[derive(
                    ::subxt::ext::codec::Decode,
                    ::subxt::ext::codec::Encode,
                    ::subxt::ext::scale_decode::DecodeAsType,
                    ::subxt::ext::scale_encode::EncodeAsType,
                    Clone,
                    Debug,
                    Eq,
                    PartialEq
                )]
                #[codec(crate = ::subxt::ext::codec)]
                #[decode_as_type(crate_path = ":: subxt :: ext :: scale_decode")]
                #[encode_as_type(crate_path = ":: subxt :: ext :: scale_encode")]
                /**
			Custom [dispatch errors](https://docs.substrate.io/main-docs/build/events-errors/)
			of this pallet.
			*/
                pub enum Error {
                    #[codec(index = 0)]
                    ///Preimage is too large to store on-chain.
                    TooBig,
                    #[codec(index = 1)]
                    ///Preimage has already been noted on-chain.
                    AlreadyNoted,
                    #[codec(index = 2)]
                    ///The user is not authorized to perform this action.
                    NotAuthorized,
                    #[codec(index = 3)]
                    ///The preimage cannot be removed since it has not yet been noted.
                    NotNoted,
                    #[codec(index = 4)]
                    ///A preimage may not be removed when there are outstanding requests.
                    Requested,
                    #[codec(index = 5)]
                    ///The preimage request cannot be removed since no outstanding requests exist.
                    NotRequested,
                }
                #[derive(
                    ::subxt::ext::codec::Decode,
                    ::subxt::ext::codec::Encode,
                    ::subxt::ext::scale_decode::DecodeAsType,
                    ::subxt::ext::scale_encode::EncodeAsType,
                    Clone,
                    Debug,
                    Eq,
                    PartialEq
                )]
                #[codec(crate = ::subxt::ext::codec)]
                #[decode_as_type(crate_path = ":: subxt :: ext :: scale_decode")]
                #[encode_as_type(crate_path = ":: subxt :: ext :: scale_encode")]
                /**
			The [event](https://docs.substrate.io/main-docs/build/events-errors/) emitted
			by this pallet.
			*/
                pub enum Event {
                    #[codec(index = 0)]
                    ///A preimage has been noted.
                    Noted { hash: ::subxt::utils::H256 },
                    #[codec(index = 1)]
                    ///A preimage has been requested.
                    Requested { hash: ::subxt::utils::H256 },
                    #[codec(index = 2)]
                    ///A preimage has ben cleared.
                    Cleared { hash: ::subxt::utils::H256 },
                }
            }
            #[derive(
                ::subxt::ext::codec::Decode,
                ::subxt::ext::codec::Encode,
                ::subxt::ext::scale_decode::DecodeAsType,
                ::subxt::ext::scale_encode::EncodeAsType,
                Clone,
                Debug,
                Eq,
                PartialEq
            )]
            #[codec(crate = ::subxt::ext::codec)]
            #[decode_as_type(crate_path = ":: subxt :: ext :: scale_decode")]
            #[encode_as_type(crate_path = ":: subxt :: ext :: scale_encode")]
            pub enum RequestStatus<_0, _1> {
                #[codec(index = 0)]
                Unrequested { deposit: (_0, _1), len: ::core::primitive::u32 },
                #[codec(index = 1)]
                Requested {
                    deposit: ::core::option::Option<(_0, _1)>,
                    count: ::core::primitive::u32,
                    len: ::core::option::Option<::core::primitive::u32>,
                },
            }
        }
        pub mod pallet_scheduler {
            use super::runtime_types;
            pub mod pallet {
                use super::runtime_types;
                #[derive(
                    ::subxt::ext::codec::Decode,
                    ::subxt::ext::codec::Encode,
                    ::subxt::ext::scale_decode::DecodeAsType,
                    ::subxt::ext::scale_encode::EncodeAsType,
                    Clone,
                    Debug,
                    Eq,
                    PartialEq
                )]
                #[codec(crate = ::subxt::ext::codec)]
                #[decode_as_type(crate_path = ":: subxt :: ext :: scale_decode")]
                #[encode_as_type(crate_path = ":: subxt :: ext :: scale_encode")]
                ///Contains one variant per dispatchable that can be called by an extrinsic.
                pub enum Call {
                    #[codec(index = 0)]
                    ///Anonymously schedule a task.
                    schedule {
                        when: ::core::primitive::u32,
                        maybe_periodic: ::core::option::Option<
                            (::core::primitive::u32, ::core::primitive::u32),
                        >,
                        priority: ::core::primitive::u8,
                        call: ::std::boxed::Box<
                            runtime_types::tangle_standalone_runtime::RuntimeCall,
                        >,
                    },
                    #[codec(index = 1)]
                    ///Cancel an anonymously scheduled task.
                    cancel {
                        when: ::core::primitive::u32,
                        index: ::core::primitive::u32,
                    },
                    #[codec(index = 2)]
                    ///Schedule a named task.
                    schedule_named {
                        id: [::core::primitive::u8; 32usize],
                        when: ::core::primitive::u32,
                        maybe_periodic: ::core::option::Option<
                            (::core::primitive::u32, ::core::primitive::u32),
                        >,
                        priority: ::core::primitive::u8,
                        call: ::std::boxed::Box<
                            runtime_types::tangle_standalone_runtime::RuntimeCall,
                        >,
                    },
                    #[codec(index = 3)]
                    ///Cancel a named scheduled task.
                    cancel_named { id: [::core::primitive::u8; 32usize] },
                    #[codec(index = 4)]
                    ///Anonymously schedule a task after a delay.
                    schedule_after {
                        after: ::core::primitive::u32,
                        maybe_periodic: ::core::option::Option<
                            (::core::primitive::u32, ::core::primitive::u32),
                        >,
                        priority: ::core::primitive::u8,
                        call: ::std::boxed::Box<
                            runtime_types::tangle_standalone_runtime::RuntimeCall,
                        >,
                    },
                    #[codec(index = 5)]
                    ///Schedule a named task after a delay.
                    schedule_named_after {
                        id: [::core::primitive::u8; 32usize],
                        after: ::core::primitive::u32,
                        maybe_periodic: ::core::option::Option<
                            (::core::primitive::u32, ::core::primitive::u32),
                        >,
                        priority: ::core::primitive::u8,
                        call: ::std::boxed::Box<
                            runtime_types::tangle_standalone_runtime::RuntimeCall,
                        >,
                    },
                }
                #[derive(
                    ::subxt::ext::codec::Decode,
                    ::subxt::ext::codec::Encode,
                    ::subxt::ext::scale_decode::DecodeAsType,
                    ::subxt::ext::scale_encode::EncodeAsType,
                    Clone,
                    Debug,
                    Eq,
                    PartialEq
                )]
                #[codec(crate = ::subxt::ext::codec)]
                #[decode_as_type(crate_path = ":: subxt :: ext :: scale_decode")]
                #[encode_as_type(crate_path = ":: subxt :: ext :: scale_encode")]
                /**
			Custom [dispatch errors](https://docs.substrate.io/main-docs/build/events-errors/)
			of this pallet.
			*/
                pub enum Error {
                    #[codec(index = 0)]
                    ///Failed to schedule a call
                    FailedToSchedule,
                    #[codec(index = 1)]
                    ///Cannot find the scheduled call.
                    NotFound,
                    #[codec(index = 2)]
                    ///Given target block number is in the past.
                    TargetBlockNumberInPast,
                    #[codec(index = 3)]
                    ///Reschedule failed because it does not change scheduled time.
                    RescheduleNoChange,
                    #[codec(index = 4)]
                    ///Attempt to use a non-named function on a named task.
                    Named,
                }
                #[derive(
                    ::subxt::ext::codec::Decode,
                    ::subxt::ext::codec::Encode,
                    ::subxt::ext::scale_decode::DecodeAsType,
                    ::subxt::ext::scale_encode::EncodeAsType,
                    Clone,
                    Debug,
                    Eq,
                    PartialEq
                )]
                #[codec(crate = ::subxt::ext::codec)]
                #[decode_as_type(crate_path = ":: subxt :: ext :: scale_decode")]
                #[encode_as_type(crate_path = ":: subxt :: ext :: scale_encode")]
                ///Events type.
                pub enum Event {
                    #[codec(index = 0)]
                    ///Scheduled some task.
                    Scheduled {
                        when: ::core::primitive::u32,
                        index: ::core::primitive::u32,
                    },
                    #[codec(index = 1)]
                    ///Canceled some task.
                    Canceled {
                        when: ::core::primitive::u32,
                        index: ::core::primitive::u32,
                    },
                    #[codec(index = 2)]
                    ///Dispatched some task.
                    Dispatched {
                        task: (::core::primitive::u32, ::core::primitive::u32),
                        id: ::core::option::Option<[::core::primitive::u8; 32usize]>,
                        result: ::core::result::Result<
                            (),
                            runtime_types::sp_runtime::DispatchError,
                        >,
                    },
                    #[codec(index = 3)]
                    ///The call for the provided hash was not found so the task has been aborted.
                    CallUnavailable {
                        task: (::core::primitive::u32, ::core::primitive::u32),
                        id: ::core::option::Option<[::core::primitive::u8; 32usize]>,
                    },
                    #[codec(index = 4)]
                    ///The given task was unable to be renewed since the agenda is full at that block.
                    PeriodicFailed {
                        task: (::core::primitive::u32, ::core::primitive::u32),
                        id: ::core::option::Option<[::core::primitive::u8; 32usize]>,
                    },
                    #[codec(index = 5)]
                    ///The given task can never be executed since it is overweight.
                    PermanentlyOverweight {
                        task: (::core::primitive::u32, ::core::primitive::u32),
                        id: ::core::option::Option<[::core::primitive::u8; 32usize]>,
                    },
                }
            }
            #[derive(
                ::subxt::ext::codec::Decode,
                ::subxt::ext::codec::Encode,
                ::subxt::ext::scale_decode::DecodeAsType,
                ::subxt::ext::scale_encode::EncodeAsType,
                Clone,
                Debug,
                Eq,
                PartialEq
            )]
            #[codec(crate = ::subxt::ext::codec)]
            #[decode_as_type(crate_path = ":: subxt :: ext :: scale_decode")]
            #[encode_as_type(crate_path = ":: subxt :: ext :: scale_encode")]
            pub struct Scheduled<_0, _1, _2, _3, _4> {
                pub maybe_id: ::core::option::Option<_0>,
                pub priority: ::core::primitive::u8,
                pub call: _1,
                pub maybe_periodic: ::core::option::Option<(_2, _2)>,
                pub origin: _3,
                #[codec(skip)]
                pub __subxt_unused_type_params: ::core::marker::PhantomData<_4>,
            }
        }
        pub mod pallet_session {
            use super::runtime_types;
            pub mod pallet {
                use super::runtime_types;
                #[derive(
                    ::subxt::ext::codec::Decode,
                    ::subxt::ext::codec::Encode,
                    ::subxt::ext::scale_decode::DecodeAsType,
                    ::subxt::ext::scale_encode::EncodeAsType,
                    Clone,
                    Debug,
                    Eq,
                    PartialEq
                )]
                #[codec(crate = ::subxt::ext::codec)]
                #[decode_as_type(crate_path = ":: subxt :: ext :: scale_decode")]
                #[encode_as_type(crate_path = ":: subxt :: ext :: scale_encode")]
                ///Contains one variant per dispatchable that can be called by an extrinsic.
                pub enum Call {
                    #[codec(index = 0)]
                    ///Sets the session key(s) of the function caller to `keys`.
                    ///Allows an account to set its session key prior to becoming a validator.
                    ///This doesn't take effect until the next session.
                    ///
                    ///The dispatch origin of this function must be signed.
                    ///
                    ///## Complexity
                    ///- `O(1)`. Actual cost depends on the number of length of `T::Keys::key_ids()` which is
                    ///  fixed.
                    set_keys {
                        keys: runtime_types::tangle_standalone_runtime::opaque::SessionKeys,
                        proof: ::std::vec::Vec<::core::primitive::u8>,
                    },
                    #[codec(index = 1)]
                    ///Removes any session key(s) of the function caller.
                    ///
                    ///This doesn't take effect until the next session.
                    ///
                    ///The dispatch origin of this function must be Signed and the account must be either be
                    ///convertible to a validator ID using the chain's typical addressing system (this usually
                    ///means being a controller account) or directly convertible into a validator ID (which
                    ///usually means being a stash account).
                    ///
                    ///## Complexity
                    ///- `O(1)` in number of key types. Actual cost depends on the number of length of
                    ///  `T::Keys::key_ids()` which is fixed.
                    purge_keys,
                }
                #[derive(
                    ::subxt::ext::codec::Decode,
                    ::subxt::ext::codec::Encode,
                    ::subxt::ext::scale_decode::DecodeAsType,
                    ::subxt::ext::scale_encode::EncodeAsType,
                    Clone,
                    Debug,
                    Eq,
                    PartialEq
                )]
                #[codec(crate = ::subxt::ext::codec)]
                #[decode_as_type(crate_path = ":: subxt :: ext :: scale_decode")]
                #[encode_as_type(crate_path = ":: subxt :: ext :: scale_encode")]
                ///Error for the session pallet.
                pub enum Error {
                    #[codec(index = 0)]
                    ///Invalid ownership proof.
                    InvalidProof,
                    #[codec(index = 1)]
                    ///No associated validator ID for account.
                    NoAssociatedValidatorId,
                    #[codec(index = 2)]
                    ///Registered duplicate key.
                    DuplicatedKey,
                    #[codec(index = 3)]
                    ///No keys are associated with this account.
                    NoKeys,
                    #[codec(index = 4)]
                    ///Key setting account is not live, so it's impossible to associate keys.
                    NoAccount,
                }
                #[derive(
                    ::subxt::ext::codec::Decode,
                    ::subxt::ext::codec::Encode,
                    ::subxt::ext::scale_decode::DecodeAsType,
                    ::subxt::ext::scale_encode::EncodeAsType,
                    Clone,
                    Debug,
                    Eq,
                    PartialEq
                )]
                #[codec(crate = ::subxt::ext::codec)]
                #[decode_as_type(crate_path = ":: subxt :: ext :: scale_decode")]
                #[encode_as_type(crate_path = ":: subxt :: ext :: scale_encode")]
                /**
			The [event](https://docs.substrate.io/main-docs/build/events-errors/) emitted
			by this pallet.
			*/
                pub enum Event {
                    #[codec(index = 0)]
                    ///New session has happened. Note that the argument is the session index, not the
                    ///block number as the type might suggest.
                    NewSession { session_index: ::core::primitive::u32 },
                }
            }
        }
        pub mod pallet_staking {
            use super::runtime_types;
            pub mod pallet {
                use super::runtime_types;
                pub mod pallet {
                    use super::runtime_types;
                    #[derive(
                        ::subxt::ext::codec::Decode,
                        ::subxt::ext::codec::Encode,
                        ::subxt::ext::scale_decode::DecodeAsType,
                        ::subxt::ext::scale_encode::EncodeAsType,
                        Clone,
                        Debug,
                        Eq,
                        PartialEq
                    )]
                    #[codec(crate = ::subxt::ext::codec)]
                    #[decode_as_type(crate_path = ":: subxt :: ext :: scale_decode")]
                    #[encode_as_type(crate_path = ":: subxt :: ext :: scale_encode")]
                    ///Contains one variant per dispatchable that can be called by an extrinsic.
                    pub enum Call {
                        #[codec(index = 0)]
                        ///Take the origin account as a stash and lock up `value` of its balance. `controller` will
                        ///be the account that controls it.
                        ///
                        ///`value` must be more than the `minimum_balance` specified by `T::Currency`.
                        ///
                        ///The dispatch origin for this call must be _Signed_ by the stash account.
                        ///
                        ///Emits `Bonded`.
                        ///## Complexity
                        ///- Independent of the arguments. Moderate complexity.
                        ///- O(1).
                        ///- Three extra DB entries.
                        ///
                        ///NOTE: Two of the storage writes (`Self::bonded`, `Self::payee`) are _never_ cleaned
                        ///unless the `origin` falls below _existential deposit_ and gets removed as dust.
                        bond {
                            #[codec(compact)]
                            value: ::core::primitive::u128,
                            payee: runtime_types::pallet_staking::RewardDestination<
                                ::subxt::utils::AccountId32,
                            >,
                        },
                        #[codec(index = 1)]
                        ///Add some extra amount that have appeared in the stash `free_balance` into the balance up
                        ///for staking.
                        ///
                        ///The dispatch origin for this call must be _Signed_ by the stash, not the controller.
                        ///
                        ///Use this if there are additional funds in your stash account that you wish to bond.
                        ///Unlike [`bond`](Self::bond) or [`unbond`](Self::unbond) this function does not impose
                        ///any limitation on the amount that can be added.
                        ///
                        ///Emits `Bonded`.
                        ///
                        ///## Complexity
                        ///- Independent of the arguments. Insignificant complexity.
                        ///- O(1).
                        bond_extra {
                            #[codec(compact)]
                            max_additional: ::core::primitive::u128,
                        },
                        #[codec(index = 2)]
                        ///Schedule a portion of the stash to be unlocked ready for transfer out after the bond
                        ///period ends. If this leaves an amount actively bonded less than
                        ///T::Currency::minimum_balance(), then it is increased to the full amount.
                        ///
                        ///The dispatch origin for this call must be _Signed_ by the controller, not the stash.
                        ///
                        ///Once the unlock period is done, you can call `withdraw_unbonded` to actually move
                        ///the funds out of management ready for transfer.
                        ///
                        ///No more than a limited number of unlocking chunks (see `MaxUnlockingChunks`)
                        ///can co-exists at the same time. If there are no unlocking chunks slots available
                        ///[`Call::withdraw_unbonded`] is called to remove some of the chunks (if possible).
                        ///
                        ///If a user encounters the `InsufficientBond` error when calling this extrinsic,
                        ///they should call `chill` first in order to free up their bonded funds.
                        ///
                        ///Emits `Unbonded`.
                        ///
                        ///See also [`Call::withdraw_unbonded`].
                        unbond { #[codec(compact)] value: ::core::primitive::u128 },
                        #[codec(index = 3)]
                        ///Remove any unlocked chunks from the `unlocking` queue from our management.
                        ///
                        ///This essentially frees up that balance to be used by the stash account to do
                        ///whatever it wants.
                        ///
                        ///The dispatch origin for this call must be _Signed_ by the controller.
                        ///
                        ///Emits `Withdrawn`.
                        ///
                        ///See also [`Call::unbond`].
                        ///
                        ///## Complexity
                        ///O(S) where S is the number of slashing spans to remove
                        ///NOTE: Weight annotation is the kill scenario, we refund otherwise.
                        withdraw_unbonded { num_slashing_spans: ::core::primitive::u32 },
                        #[codec(index = 4)]
                        ///Declare the desire to validate for the origin controller.
                        ///
                        ///Effects will be felt at the beginning of the next era.
                        ///
                        ///The dispatch origin for this call must be _Signed_ by the controller, not the stash.
                        validate {
                            prefs: runtime_types::pallet_staking::ValidatorPrefs,
                        },
                        #[codec(index = 5)]
                        ///Declare the desire to nominate `targets` for the origin controller.
                        ///
                        ///Effects will be felt at the beginning of the next era.
                        ///
                        ///The dispatch origin for this call must be _Signed_ by the controller, not the stash.
                        ///
                        ///## Complexity
                        ///- The transaction's complexity is proportional to the size of `targets` (N)
                        ///which is capped at CompactAssignments::LIMIT (T::MaxNominations).
                        ///- Both the reads and writes follow a similar pattern.
                        nominate {
                            targets: ::std::vec::Vec<
                                ::subxt::utils::MultiAddress<
                                    ::subxt::utils::AccountId32,
                                    ::core::primitive::u32,
                                >,
                            >,
                        },
                        #[codec(index = 6)]
                        ///Declare no desire to either validate or nominate.
                        ///
                        ///Effects will be felt at the beginning of the next era.
                        ///
                        ///The dispatch origin for this call must be _Signed_ by the controller, not the stash.
                        ///
                        ///## Complexity
                        ///- Independent of the arguments. Insignificant complexity.
                        ///- Contains one read.
                        ///- Writes are limited to the `origin` account key.
                        chill,
                        #[codec(index = 7)]
                        ///(Re-)set the payment target for a controller.
                        ///
                        ///Effects will be felt instantly (as soon as this function is completed successfully).
                        ///
                        ///The dispatch origin for this call must be _Signed_ by the controller, not the stash.
                        ///
                        ///## Complexity
                        ///- O(1)
                        ///- Independent of the arguments. Insignificant complexity.
                        ///- Contains a limited number of reads.
                        ///- Writes are limited to the `origin` account key.
                        ///---------
                        set_payee {
                            payee: runtime_types::pallet_staking::RewardDestination<
                                ::subxt::utils::AccountId32,
                            >,
                        },
                        #[codec(index = 8)]
                        ///(Re-)sets the controller of a stash to the stash itself. This function previously
                        ///accepted a `controller` argument to set the controller to an account other than the
                        ///stash itself. This functionality has now been removed, now only setting the controller
                        ///to the stash, if it is not already.
                        ///
                        ///Effects will be felt instantly (as soon as this function is completed successfully).
                        ///
                        ///The dispatch origin for this call must be _Signed_ by the stash, not the controller.
                        ///
                        ///## Complexity
                        ///O(1)
                        ///- Independent of the arguments. Insignificant complexity.
                        ///- Contains a limited number of reads.
                        ///- Writes are limited to the `origin` account key.
                        set_controller,
                        #[codec(index = 9)]
                        ///Sets the ideal number of validators.
                        ///
                        ///The dispatch origin must be Root.
                        ///
                        ///## Complexity
                        ///O(1)
                        set_validator_count {
                            #[codec(compact)]
                            new: ::core::primitive::u32,
                        },
                        #[codec(index = 10)]
                        ///Increments the ideal number of validators upto maximum of
                        ///`ElectionProviderBase::MaxWinners`.
                        ///
                        ///The dispatch origin must be Root.
                        ///
                        ///## Complexity
                        ///Same as [`Self::set_validator_count`].
                        increase_validator_count {
                            #[codec(compact)]
                            additional: ::core::primitive::u32,
                        },
                        #[codec(index = 11)]
                        ///Scale up the ideal number of validators by a factor upto maximum of
                        ///`ElectionProviderBase::MaxWinners`.
                        ///
                        ///The dispatch origin must be Root.
                        ///
                        ///## Complexity
                        ///Same as [`Self::set_validator_count`].
                        scale_validator_count {
                            factor: runtime_types::sp_arithmetic::per_things::Percent,
                        },
                        #[codec(index = 12)]
                        ///Force there to be no new eras indefinitely.
                        ///
                        ///The dispatch origin must be Root.
                        ///
                        ///# Warning
                        ///
                        ///The election process starts multiple blocks before the end of the era.
                        ///Thus the election process may be ongoing when this is called. In this case the
                        ///election will continue until the next era is triggered.
                        ///
                        ///## Complexity
                        ///- No arguments.
                        ///- Weight: O(1)
                        force_no_eras,
                        #[codec(index = 13)]
                        ///Force there to be a new era at the end of the next session. After this, it will be
                        ///reset to normal (non-forced) behaviour.
                        ///
                        ///The dispatch origin must be Root.
                        ///
                        ///# Warning
                        ///
                        ///The election process starts multiple blocks before the end of the era.
                        ///If this is called just before a new era is triggered, the election process may not
                        ///have enough blocks to get a result.
                        ///
                        ///## Complexity
                        ///- No arguments.
                        ///- Weight: O(1)
                        force_new_era,
                        #[codec(index = 14)]
                        ///Set the validators who cannot be slashed (if any).
                        ///
                        ///The dispatch origin must be Root.
                        set_invulnerables {
                            invulnerables: ::std::vec::Vec<::subxt::utils::AccountId32>,
                        },
                        #[codec(index = 15)]
                        ///Force a current staker to become completely unstaked, immediately.
                        ///
                        ///The dispatch origin must be Root.
                        force_unstake {
                            stash: ::subxt::utils::AccountId32,
                            num_slashing_spans: ::core::primitive::u32,
                        },
                        #[codec(index = 16)]
                        ///Force there to be a new era at the end of sessions indefinitely.
                        ///
                        ///The dispatch origin must be Root.
                        ///
                        ///# Warning
                        ///
                        ///The election process starts multiple blocks before the end of the era.
                        ///If this is called just before a new era is triggered, the election process may not
                        ///have enough blocks to get a result.
                        force_new_era_always,
                        #[codec(index = 17)]
                        ///Cancel enactment of a deferred slash.
                        ///
                        ///Can be called by the `T::AdminOrigin`.
                        ///
                        ///Parameters: era and indices of the slashes for that era to kill.
                        cancel_deferred_slash {
                            era: ::core::primitive::u32,
                            slash_indices: ::std::vec::Vec<::core::primitive::u32>,
                        },
                        #[codec(index = 18)]
                        ///Pay out all the stakers behind a single validator for a single era.
                        ///
                        ///- `validator_stash` is the stash account of the validator. Their nominators, up to
                        ///  `T::MaxNominatorRewardedPerValidator`, will also receive their rewards.
                        ///- `era` may be any era between `[current_era - history_depth; current_era]`.
                        ///
                        ///The origin of this call must be _Signed_. Any account can call this function, even if
                        ///it is not one of the stakers.
                        ///
                        ///## Complexity
                        ///- At most O(MaxNominatorRewardedPerValidator).
                        payout_stakers {
                            validator_stash: ::subxt::utils::AccountId32,
                            era: ::core::primitive::u32,
                        },
                        #[codec(index = 19)]
                        ///Rebond a portion of the stash scheduled to be unlocked.
                        ///
                        ///The dispatch origin must be signed by the controller.
                        ///
                        ///## Complexity
                        ///- Time complexity: O(L), where L is unlocking chunks
                        ///- Bounded by `MaxUnlockingChunks`.
                        rebond { #[codec(compact)] value: ::core::primitive::u128 },
                        #[codec(index = 20)]
                        ///Remove all data structures concerning a staker/stash once it is at a state where it can
                        ///be considered `dust` in the staking system. The requirements are:
                        ///
                        ///1. the `total_balance` of the stash is below existential deposit.
                        ///2. or, the `ledger.total` of the stash is below existential deposit.
                        ///
                        ///The former can happen in cases like a slash; the latter when a fully unbonded account
                        ///is still receiving staking rewards in `RewardDestination::Staked`.
                        ///
                        ///It can be called by anyone, as long as `stash` meets the above requirements.
                        ///
                        ///Refunds the transaction fees upon successful execution.
                        reap_stash {
                            stash: ::subxt::utils::AccountId32,
                            num_slashing_spans: ::core::primitive::u32,
                        },
                        #[codec(index = 21)]
                        ///Remove the given nominations from the calling validator.
                        ///
                        ///Effects will be felt at the beginning of the next era.
                        ///
                        ///The dispatch origin for this call must be _Signed_ by the controller, not the stash.
                        ///
                        ///- `who`: A list of nominator stash accounts who are nominating this validator which
                        ///  should no longer be nominating this validator.
                        ///
                        ///Note: Making this call only makes sense if you first set the validator preferences to
                        ///block any further nominations.
                        kick {
                            who: ::std::vec::Vec<
                                ::subxt::utils::MultiAddress<
                                    ::subxt::utils::AccountId32,
                                    ::core::primitive::u32,
                                >,
                            >,
                        },
                        #[codec(index = 22)]
                        ///Update the various staking configurations .
                        ///
                        ///* `min_nominator_bond`: The minimum active bond needed to be a nominator.
                        ///* `min_validator_bond`: The minimum active bond needed to be a validator.
                        ///* `max_nominator_count`: The max number of users who can be a nominator at once. When
                        ///  set to `None`, no limit is enforced.
                        ///* `max_validator_count`: The max number of users who can be a validator at once. When
                        ///  set to `None`, no limit is enforced.
                        ///* `chill_threshold`: The ratio of `max_nominator_count` or `max_validator_count` which
                        ///  should be filled in order for the `chill_other` transaction to work.
                        ///* `min_commission`: The minimum amount of commission that each validators must maintain.
                        ///  This is checked only upon calling `validate`. Existing validators are not affected.
                        ///
                        ///RuntimeOrigin must be Root to call this function.
                        ///
                        ///NOTE: Existing nominators and validators will not be affected by this update.
                        ///to kick people under the new limits, `chill_other` should be called.
                        set_staking_configs {
                            min_nominator_bond: runtime_types::pallet_staking::pallet::pallet::ConfigOp<
                                ::core::primitive::u128,
                            >,
                            min_validator_bond: runtime_types::pallet_staking::pallet::pallet::ConfigOp<
                                ::core::primitive::u128,
                            >,
                            max_nominator_count: runtime_types::pallet_staking::pallet::pallet::ConfigOp<
                                ::core::primitive::u32,
                            >,
                            max_validator_count: runtime_types::pallet_staking::pallet::pallet::ConfigOp<
                                ::core::primitive::u32,
                            >,
                            chill_threshold: runtime_types::pallet_staking::pallet::pallet::ConfigOp<
                                runtime_types::sp_arithmetic::per_things::Percent,
                            >,
                            min_commission: runtime_types::pallet_staking::pallet::pallet::ConfigOp<
                                runtime_types::sp_arithmetic::per_things::Perbill,
                            >,
                        },
                        #[codec(index = 23)]
                        ///Declare a `controller` to stop participating as either a validator or nominator.
                        ///
                        ///Effects will be felt at the beginning of the next era.
                        ///
                        ///The dispatch origin for this call must be _Signed_, but can be called by anyone.
                        ///
                        ///If the caller is the same as the controller being targeted, then no further checks are
                        ///enforced, and this function behaves just like `chill`.
                        ///
                        ///If the caller is different than the controller being targeted, the following conditions
                        ///must be met:
                        ///
                        ///* `controller` must belong to a nominator who has become non-decodable,
                        ///
                        ///Or:
                        ///
                        ///* A `ChillThreshold` must be set and checked which defines how close to the max
                        ///  nominators or validators we must reach before users can start chilling one-another.
                        ///* A `MaxNominatorCount` and `MaxValidatorCount` must be set which is used to determine
                        ///  how close we are to the threshold.
                        ///* A `MinNominatorBond` and `MinValidatorBond` must be set and checked, which determines
                        ///  if this is a person that should be chilled because they have not met the threshold
                        ///  bond required.
                        ///
                        ///This can be helpful if bond requirements are updated, and we need to remove old users
                        ///who do not satisfy these requirements.
                        chill_other { controller: ::subxt::utils::AccountId32 },
                        #[codec(index = 24)]
                        ///Force a validator to have at least the minimum commission. This will not affect a
                        ///validator who already has a commission greater than or equal to the minimum. Any account
                        ///can call this.
                        force_apply_min_commission {
                            validator_stash: ::subxt::utils::AccountId32,
                        },
                        #[codec(index = 25)]
                        ///Sets the minimum amount of commission that each validators must maintain.
                        ///
                        ///This call has lower privilege requirements than `set_staking_config` and can be called
                        ///by the `T::AdminOrigin`. Root can always call this.
                        set_min_commission {
                            new: runtime_types::sp_arithmetic::per_things::Perbill,
                        },
                    }
                    #[derive(
                        ::subxt::ext::codec::Decode,
                        ::subxt::ext::codec::Encode,
                        ::subxt::ext::scale_decode::DecodeAsType,
                        ::subxt::ext::scale_encode::EncodeAsType,
                        Clone,
                        Debug,
                        Eq,
                        PartialEq
                    )]
                    #[codec(crate = ::subxt::ext::codec)]
                    #[decode_as_type(crate_path = ":: subxt :: ext :: scale_decode")]
                    #[encode_as_type(crate_path = ":: subxt :: ext :: scale_encode")]
                    pub enum ConfigOp<_0> {
                        #[codec(index = 0)]
                        Noop,
                        #[codec(index = 1)]
                        Set(_0),
                        #[codec(index = 2)]
                        Remove,
                    }
                    #[derive(
                        ::subxt::ext::codec::Decode,
                        ::subxt::ext::codec::Encode,
                        ::subxt::ext::scale_decode::DecodeAsType,
                        ::subxt::ext::scale_encode::EncodeAsType,
                        Clone,
                        Debug,
                        Eq,
                        PartialEq
                    )]
                    #[codec(crate = ::subxt::ext::codec)]
                    #[decode_as_type(crate_path = ":: subxt :: ext :: scale_decode")]
                    #[encode_as_type(crate_path = ":: subxt :: ext :: scale_encode")]
                    /**
			Custom [dispatch errors](https://docs.substrate.io/main-docs/build/events-errors/)
			of this pallet.
			*/
                    pub enum Error {
                        #[codec(index = 0)]
                        ///Not a controller account.
                        NotController,
                        #[codec(index = 1)]
                        ///Not a stash account.
                        NotStash,
                        #[codec(index = 2)]
                        ///Stash is already bonded.
                        AlreadyBonded,
                        #[codec(index = 3)]
                        ///Controller is already paired.
                        AlreadyPaired,
                        #[codec(index = 4)]
                        ///Targets cannot be empty.
                        EmptyTargets,
                        #[codec(index = 5)]
                        ///Duplicate index.
                        DuplicateIndex,
                        #[codec(index = 6)]
                        ///Slash record index out of bounds.
                        InvalidSlashIndex,
                        #[codec(index = 7)]
                        ///Cannot have a validator or nominator role, with value less than the minimum defined by
                        ///governance (see `MinValidatorBond` and `MinNominatorBond`). If unbonding is the
                        ///intention, `chill` first to remove one's role as validator/nominator.
                        InsufficientBond,
                        #[codec(index = 8)]
                        ///Can not schedule more unlock chunks.
                        NoMoreChunks,
                        #[codec(index = 9)]
                        ///Can not rebond without unlocking chunks.
                        NoUnlockChunk,
                        #[codec(index = 10)]
                        ///Attempting to target a stash that still has funds.
                        FundedTarget,
                        #[codec(index = 11)]
                        ///Invalid era to reward.
                        InvalidEraToReward,
                        #[codec(index = 12)]
                        ///Invalid number of nominations.
                        InvalidNumberOfNominations,
                        #[codec(index = 13)]
                        ///Items are not sorted and unique.
                        NotSortedAndUnique,
                        #[codec(index = 14)]
                        ///Rewards for this era have already been claimed for this validator.
                        AlreadyClaimed,
                        #[codec(index = 15)]
                        ///Incorrect previous history depth input provided.
                        IncorrectHistoryDepth,
                        #[codec(index = 16)]
                        ///Incorrect number of slashing spans provided.
                        IncorrectSlashingSpans,
                        #[codec(index = 17)]
                        ///Internal state has become somehow corrupted and the operation cannot continue.
                        BadState,
                        #[codec(index = 18)]
                        ///Too many nomination targets supplied.
                        TooManyTargets,
                        #[codec(index = 19)]
                        ///A nomination target was supplied that was blocked or otherwise not a validator.
                        BadTarget,
                        #[codec(index = 20)]
                        ///The user has enough bond and thus cannot be chilled forcefully by an external person.
                        CannotChillOther,
                        #[codec(index = 21)]
                        ///There are too many nominators in the system. Governance needs to adjust the staking
                        ///settings to keep things safe for the runtime.
                        TooManyNominators,
                        #[codec(index = 22)]
                        ///There are too many validator candidates in the system. Governance needs to adjust the
                        ///staking settings to keep things safe for the runtime.
                        TooManyValidators,
                        #[codec(index = 23)]
                        ///Commission is too low. Must be at least `MinCommission`.
                        CommissionTooLow,
                        #[codec(index = 24)]
                        ///Some bound is not met.
                        BoundNotMet,
                    }
                    #[derive(
                        ::subxt::ext::codec::Decode,
                        ::subxt::ext::codec::Encode,
                        ::subxt::ext::scale_decode::DecodeAsType,
                        ::subxt::ext::scale_encode::EncodeAsType,
                        Clone,
                        Debug,
                        Eq,
                        PartialEq
                    )]
                    #[codec(crate = ::subxt::ext::codec)]
                    #[decode_as_type(crate_path = ":: subxt :: ext :: scale_decode")]
                    #[encode_as_type(crate_path = ":: subxt :: ext :: scale_encode")]
                    /**
			The [event](https://docs.substrate.io/main-docs/build/events-errors/) emitted
			by this pallet.
			*/
                    pub enum Event {
                        #[codec(index = 0)]
                        ///The era payout has been set; the first balance is the validator-payout; the second is
                        ///the remainder from the maximum amount of reward.
                        EraPaid {
                            era_index: ::core::primitive::u32,
                            validator_payout: ::core::primitive::u128,
                            remainder: ::core::primitive::u128,
                        },
                        #[codec(index = 1)]
                        ///The nominator has been rewarded by this amount.
                        Rewarded {
                            stash: ::subxt::utils::AccountId32,
                            amount: ::core::primitive::u128,
                        },
                        #[codec(index = 2)]
                        ///A staker (validator or nominator) has been slashed by the given amount.
                        Slashed {
                            staker: ::subxt::utils::AccountId32,
                            amount: ::core::primitive::u128,
                        },
                        #[codec(index = 3)]
                        ///A slash for the given validator, for the given percentage of their stake, at the given
                        ///era as been reported.
                        SlashReported {
                            validator: ::subxt::utils::AccountId32,
                            fraction: runtime_types::sp_arithmetic::per_things::Perbill,
                            slash_era: ::core::primitive::u32,
                        },
                        #[codec(index = 4)]
                        ///An old slashing report from a prior era was discarded because it could
                        ///not be processed.
                        OldSlashingReportDiscarded {
                            session_index: ::core::primitive::u32,
                        },
                        #[codec(index = 5)]
                        ///A new set of stakers was elected.
                        StakersElected,
                        #[codec(index = 6)]
                        ///An account has bonded this amount. \[stash, amount\]
                        ///
                        ///NOTE: This event is only emitted when funds are bonded via a dispatchable. Notably,
                        ///it will not be emitted for staking rewards when they are added to stake.
                        Bonded {
                            stash: ::subxt::utils::AccountId32,
                            amount: ::core::primitive::u128,
                        },
                        #[codec(index = 7)]
                        ///An account has unbonded this amount.
                        Unbonded {
                            stash: ::subxt::utils::AccountId32,
                            amount: ::core::primitive::u128,
                        },
                        #[codec(index = 8)]
                        ///An account has called `withdraw_unbonded` and removed unbonding chunks worth `Balance`
                        ///from the unlocking queue.
                        Withdrawn {
                            stash: ::subxt::utils::AccountId32,
                            amount: ::core::primitive::u128,
                        },
                        #[codec(index = 9)]
                        ///A nominator has been kicked from a validator.
                        Kicked {
                            nominator: ::subxt::utils::AccountId32,
                            stash: ::subxt::utils::AccountId32,
                        },
                        #[codec(index = 10)]
                        ///The election failed. No new era is planned.
                        StakingElectionFailed,
                        #[codec(index = 11)]
                        ///An account has stopped participating as either a validator or nominator.
                        Chilled { stash: ::subxt::utils::AccountId32 },
                        #[codec(index = 12)]
                        ///The stakers' rewards are getting paid.
                        PayoutStarted {
                            era_index: ::core::primitive::u32,
                            validator_stash: ::subxt::utils::AccountId32,
                        },
                        #[codec(index = 13)]
                        ///A validator has set their preferences.
                        ValidatorPrefsSet {
                            stash: ::subxt::utils::AccountId32,
                            prefs: runtime_types::pallet_staking::ValidatorPrefs,
                        },
                        #[codec(index = 14)]
                        ///A new force era mode was set.
                        ForceEra { mode: runtime_types::pallet_staking::Forcing },
                    }
                }
            }
            pub mod slashing {
                use super::runtime_types;
                #[derive(
                    ::subxt::ext::codec::Decode,
                    ::subxt::ext::codec::Encode,
                    ::subxt::ext::scale_decode::DecodeAsType,
                    ::subxt::ext::scale_encode::EncodeAsType,
                    Clone,
                    Debug,
                    Eq,
                    PartialEq
                )]
                #[codec(crate = ::subxt::ext::codec)]
                #[decode_as_type(crate_path = ":: subxt :: ext :: scale_decode")]
                #[encode_as_type(crate_path = ":: subxt :: ext :: scale_encode")]
                pub struct SlashingSpans {
                    pub span_index: ::core::primitive::u32,
                    pub last_start: ::core::primitive::u32,
                    pub last_nonzero_slash: ::core::primitive::u32,
                    pub prior: ::std::vec::Vec<::core::primitive::u32>,
                }
                #[derive(
                    ::subxt::ext::codec::Decode,
                    ::subxt::ext::codec::Encode,
                    ::subxt::ext::scale_decode::DecodeAsType,
                    ::subxt::ext::scale_encode::EncodeAsType,
                    Clone,
                    Debug,
                    Eq,
                    PartialEq
                )]
                #[codec(crate = ::subxt::ext::codec)]
                #[decode_as_type(crate_path = ":: subxt :: ext :: scale_decode")]
                #[encode_as_type(crate_path = ":: subxt :: ext :: scale_encode")]
                pub struct SpanRecord<_0> {
                    pub slashed: _0,
                    pub paid_out: _0,
                }
            }
            #[derive(
                ::subxt::ext::codec::Decode,
                ::subxt::ext::codec::Encode,
                ::subxt::ext::scale_decode::DecodeAsType,
                ::subxt::ext::scale_encode::EncodeAsType,
                Clone,
                Debug,
                Eq,
                PartialEq
            )]
            #[codec(crate = ::subxt::ext::codec)]
            #[decode_as_type(crate_path = ":: subxt :: ext :: scale_decode")]
            #[encode_as_type(crate_path = ":: subxt :: ext :: scale_encode")]
            pub struct ActiveEraInfo {
                pub index: ::core::primitive::u32,
                pub start: ::core::option::Option<::core::primitive::u64>,
            }
            #[derive(
                ::subxt::ext::codec::Decode,
                ::subxt::ext::codec::Encode,
                ::subxt::ext::scale_decode::DecodeAsType,
                ::subxt::ext::scale_encode::EncodeAsType,
                Clone,
                Debug,
                Eq,
                PartialEq
            )]
            #[codec(crate = ::subxt::ext::codec)]
            #[decode_as_type(crate_path = ":: subxt :: ext :: scale_decode")]
            #[encode_as_type(crate_path = ":: subxt :: ext :: scale_encode")]
            pub struct EraRewardPoints<_0> {
                pub total: ::core::primitive::u32,
                pub individual: ::subxt::utils::KeyedVec<_0, ::core::primitive::u32>,
            }
            #[derive(
                ::subxt::ext::codec::Decode,
                ::subxt::ext::codec::Encode,
                ::subxt::ext::scale_decode::DecodeAsType,
                ::subxt::ext::scale_encode::EncodeAsType,
                Clone,
                Debug,
                Eq,
                PartialEq
            )]
            #[codec(crate = ::subxt::ext::codec)]
            #[decode_as_type(crate_path = ":: subxt :: ext :: scale_decode")]
            #[encode_as_type(crate_path = ":: subxt :: ext :: scale_encode")]
            pub struct Exposure<_0, _1> {
                #[codec(compact)]
                pub total: _1,
                #[codec(compact)]
                pub own: _1,
                pub others: ::std::vec::Vec<
                    runtime_types::pallet_staking::IndividualExposure<_0, _1>,
                >,
            }
            #[derive(
                ::subxt::ext::codec::Decode,
                ::subxt::ext::codec::Encode,
                ::subxt::ext::scale_decode::DecodeAsType,
                ::subxt::ext::scale_encode::EncodeAsType,
                Clone,
                Debug,
                Eq,
                PartialEq
            )]
            #[codec(crate = ::subxt::ext::codec)]
            #[decode_as_type(crate_path = ":: subxt :: ext :: scale_decode")]
            #[encode_as_type(crate_path = ":: subxt :: ext :: scale_encode")]
            pub enum Forcing {
                #[codec(index = 0)]
                NotForcing,
                #[codec(index = 1)]
                ForceNew,
                #[codec(index = 2)]
                ForceNone,
                #[codec(index = 3)]
                ForceAlways,
            }
            #[derive(
                ::subxt::ext::codec::Decode,
                ::subxt::ext::codec::Encode,
                ::subxt::ext::scale_decode::DecodeAsType,
                ::subxt::ext::scale_encode::EncodeAsType,
                Clone,
                Debug,
                Eq,
                PartialEq
            )]
            #[codec(crate = ::subxt::ext::codec)]
            #[decode_as_type(crate_path = ":: subxt :: ext :: scale_decode")]
            #[encode_as_type(crate_path = ":: subxt :: ext :: scale_encode")]
            pub struct IndividualExposure<_0, _1> {
                pub who: _0,
                #[codec(compact)]
                pub value: _1,
            }
            #[derive(
                ::subxt::ext::codec::Decode,
                ::subxt::ext::codec::Encode,
                ::subxt::ext::scale_decode::DecodeAsType,
                ::subxt::ext::scale_encode::EncodeAsType,
                Clone,
                Debug,
                Eq,
                PartialEq
            )]
            #[codec(crate = ::subxt::ext::codec)]
            #[decode_as_type(crate_path = ":: subxt :: ext :: scale_decode")]
            #[encode_as_type(crate_path = ":: subxt :: ext :: scale_encode")]
            pub struct Nominations {
                pub targets: runtime_types::bounded_collections::bounded_vec::BoundedVec<
                    ::subxt::utils::AccountId32,
                >,
                pub submitted_in: ::core::primitive::u32,
                pub suppressed: ::core::primitive::bool,
            }
            #[derive(
                ::subxt::ext::codec::Decode,
                ::subxt::ext::codec::Encode,
                ::subxt::ext::scale_decode::DecodeAsType,
                ::subxt::ext::scale_encode::EncodeAsType,
                Clone,
                Debug,
                Eq,
                PartialEq
            )]
            #[codec(crate = ::subxt::ext::codec)]
            #[decode_as_type(crate_path = ":: subxt :: ext :: scale_decode")]
            #[encode_as_type(crate_path = ":: subxt :: ext :: scale_encode")]
            pub enum RewardDestination<_0> {
                #[codec(index = 0)]
                Staked,
                #[codec(index = 1)]
                Stash,
                #[codec(index = 2)]
                Controller,
                #[codec(index = 3)]
                Account(_0),
                #[codec(index = 4)]
                None,
            }
            #[derive(
                ::subxt::ext::codec::Decode,
                ::subxt::ext::codec::Encode,
                ::subxt::ext::scale_decode::DecodeAsType,
                ::subxt::ext::scale_encode::EncodeAsType,
                Clone,
                Debug,
                Eq,
                PartialEq
            )]
            #[codec(crate = ::subxt::ext::codec)]
            #[decode_as_type(crate_path = ":: subxt :: ext :: scale_decode")]
            #[encode_as_type(crate_path = ":: subxt :: ext :: scale_encode")]
            pub struct StakingLedger {
                pub stash: ::subxt::utils::AccountId32,
                #[codec(compact)]
                pub total: ::core::primitive::u128,
                #[codec(compact)]
                pub active: ::core::primitive::u128,
                pub unlocking: runtime_types::bounded_collections::bounded_vec::BoundedVec<
                    runtime_types::pallet_staking::UnlockChunk<::core::primitive::u128>,
                >,
                pub claimed_rewards: runtime_types::bounded_collections::bounded_vec::BoundedVec<
                    ::core::primitive::u32,
                >,
            }
            #[derive(
                ::subxt::ext::codec::Decode,
                ::subxt::ext::codec::Encode,
                ::subxt::ext::scale_decode::DecodeAsType,
                ::subxt::ext::scale_encode::EncodeAsType,
                Clone,
                Debug,
                Eq,
                PartialEq
            )]
            #[codec(crate = ::subxt::ext::codec)]
            #[decode_as_type(crate_path = ":: subxt :: ext :: scale_decode")]
            #[encode_as_type(crate_path = ":: subxt :: ext :: scale_encode")]
            pub struct UnappliedSlash<_0, _1> {
                pub validator: _0,
                pub own: _1,
                pub others: ::std::vec::Vec<(_0, _1)>,
                pub reporters: ::std::vec::Vec<_0>,
                pub payout: _1,
            }
            #[derive(
                ::subxt::ext::codec::Decode,
                ::subxt::ext::codec::Encode,
                ::subxt::ext::scale_decode::DecodeAsType,
                ::subxt::ext::scale_encode::EncodeAsType,
                Clone,
                Debug,
                Eq,
                PartialEq
            )]
            #[codec(crate = ::subxt::ext::codec)]
            #[decode_as_type(crate_path = ":: subxt :: ext :: scale_decode")]
            #[encode_as_type(crate_path = ":: subxt :: ext :: scale_encode")]
            pub struct UnlockChunk<_0> {
                #[codec(compact)]
                pub value: _0,
                #[codec(compact)]
                pub era: ::core::primitive::u32,
            }
            #[derive(
                ::subxt::ext::codec::Decode,
                ::subxt::ext::codec::Encode,
                ::subxt::ext::scale_decode::DecodeAsType,
                ::subxt::ext::scale_encode::EncodeAsType,
                Clone,
                Debug,
                Eq,
                PartialEq
            )]
            #[codec(crate = ::subxt::ext::codec)]
            #[decode_as_type(crate_path = ":: subxt :: ext :: scale_decode")]
            #[encode_as_type(crate_path = ":: subxt :: ext :: scale_encode")]
            pub struct ValidatorPrefs {
                #[codec(compact)]
                pub commission: runtime_types::sp_arithmetic::per_things::Perbill,
                pub blocked: ::core::primitive::bool,
            }
        }
        pub mod pallet_sudo {
            use super::runtime_types;
            pub mod pallet {
                use super::runtime_types;
                #[derive(
                    ::subxt::ext::codec::Decode,
                    ::subxt::ext::codec::Encode,
                    ::subxt::ext::scale_decode::DecodeAsType,
                    ::subxt::ext::scale_encode::EncodeAsType,
                    Clone,
                    Debug,
                    Eq,
                    PartialEq
                )]
                #[codec(crate = ::subxt::ext::codec)]
                #[decode_as_type(crate_path = ":: subxt :: ext :: scale_decode")]
                #[encode_as_type(crate_path = ":: subxt :: ext :: scale_encode")]
                ///Contains one variant per dispatchable that can be called by an extrinsic.
                pub enum Call {
                    #[codec(index = 0)]
                    ///Authenticates the sudo key and dispatches a function call with `Root` origin.
                    ///
                    ///The dispatch origin for this call must be _Signed_.
                    ///
                    ///## Complexity
                    ///- O(1).
                    sudo {
                        call: ::std::boxed::Box<
                            runtime_types::tangle_standalone_runtime::RuntimeCall,
                        >,
                    },
                    #[codec(index = 1)]
                    ///Authenticates the sudo key and dispatches a function call with `Root` origin.
                    ///This function does not check the weight of the call, and instead allows the
                    ///Sudo user to specify the weight of the call.
                    ///
                    ///The dispatch origin for this call must be _Signed_.
                    ///
                    ///## Complexity
                    ///- O(1).
                    sudo_unchecked_weight {
                        call: ::std::boxed::Box<
                            runtime_types::tangle_standalone_runtime::RuntimeCall,
                        >,
                        weight: runtime_types::sp_weights::weight_v2::Weight,
                    },
                    #[codec(index = 2)]
                    ///Authenticates the current sudo key and sets the given AccountId (`new`) as the new sudo
                    ///key.
                    ///
                    ///The dispatch origin for this call must be _Signed_.
                    ///
                    ///## Complexity
                    ///- O(1).
                    set_key {
                        new: ::subxt::utils::MultiAddress<
                            ::subxt::utils::AccountId32,
                            ::core::primitive::u32,
                        >,
                    },
                    #[codec(index = 3)]
                    ///Authenticates the sudo key and dispatches a function call with `Signed` origin from
                    ///a given account.
                    ///
                    ///The dispatch origin for this call must be _Signed_.
                    ///
                    ///## Complexity
                    ///- O(1).
                    sudo_as {
                        who: ::subxt::utils::MultiAddress<
                            ::subxt::utils::AccountId32,
                            ::core::primitive::u32,
                        >,
                        call: ::std::boxed::Box<
                            runtime_types::tangle_standalone_runtime::RuntimeCall,
                        >,
                    },
                }
                #[derive(
                    ::subxt::ext::codec::Decode,
                    ::subxt::ext::codec::Encode,
                    ::subxt::ext::scale_decode::DecodeAsType,
                    ::subxt::ext::scale_encode::EncodeAsType,
                    Clone,
                    Debug,
                    Eq,
                    PartialEq
                )]
                #[codec(crate = ::subxt::ext::codec)]
                #[decode_as_type(crate_path = ":: subxt :: ext :: scale_decode")]
                #[encode_as_type(crate_path = ":: subxt :: ext :: scale_encode")]
                ///Error for the Sudo pallet
                pub enum Error {
                    #[codec(index = 0)]
                    ///Sender must be the Sudo account
                    RequireSudo,
                }
                #[derive(
                    ::subxt::ext::codec::Decode,
                    ::subxt::ext::codec::Encode,
                    ::subxt::ext::scale_decode::DecodeAsType,
                    ::subxt::ext::scale_encode::EncodeAsType,
                    Clone,
                    Debug,
                    Eq,
                    PartialEq
                )]
                #[codec(crate = ::subxt::ext::codec)]
                #[decode_as_type(crate_path = ":: subxt :: ext :: scale_decode")]
                #[encode_as_type(crate_path = ":: subxt :: ext :: scale_encode")]
                /**
			The [event](https://docs.substrate.io/main-docs/build/events-errors/) emitted
			by this pallet.
			*/
                pub enum Event {
                    #[codec(index = 0)]
                    ///A sudo just took place. \[result\]
                    Sudid {
                        sudo_result: ::core::result::Result<
                            (),
                            runtime_types::sp_runtime::DispatchError,
                        >,
                    },
                    #[codec(index = 1)]
                    ///The \[sudoer\] just switched identity; the old key is supplied if one existed.
                    KeyChanged {
                        old_sudoer: ::core::option::Option<::subxt::utils::AccountId32>,
                    },
                    #[codec(index = 2)]
                    ///A sudo just took place. \[result\]
                    SudoAsDone {
                        sudo_result: ::core::result::Result<
                            (),
                            runtime_types::sp_runtime::DispatchError,
                        >,
                    },
                }
            }
        }
        pub mod pallet_timestamp {
            use super::runtime_types;
            pub mod pallet {
                use super::runtime_types;
                #[derive(
                    ::subxt::ext::codec::Decode,
                    ::subxt::ext::codec::Encode,
                    ::subxt::ext::scale_decode::DecodeAsType,
                    ::subxt::ext::scale_encode::EncodeAsType,
                    Clone,
                    Debug,
                    Eq,
                    PartialEq
                )]
                #[codec(crate = ::subxt::ext::codec)]
                #[decode_as_type(crate_path = ":: subxt :: ext :: scale_decode")]
                #[encode_as_type(crate_path = ":: subxt :: ext :: scale_encode")]
                ///Contains one variant per dispatchable that can be called by an extrinsic.
                pub enum Call {
                    #[codec(index = 0)]
                    ///Set the current time.
                    ///
                    ///This call should be invoked exactly once per block. It will panic at the finalization
                    ///phase, if this call hasn't been invoked by that time.
                    ///
                    ///The timestamp should be greater than the previous one by the amount specified by
                    ///`MinimumPeriod`.
                    ///
                    ///The dispatch origin for this call must be `Inherent`.
                    ///
                    ///## Complexity
                    ///- `O(1)` (Note that implementations of `OnTimestampSet` must also be `O(1)`)
                    ///- 1 storage read and 1 storage mutation (codec `O(1)`). (because of `DidUpdate::take` in
                    ///  `on_finalize`)
                    ///- 1 event handler `on_timestamp_set`. Must be `O(1)`.
                    set { #[codec(compact)] now: ::core::primitive::u64 },
                }
            }
        }
        pub mod pallet_transaction_pause {
            use super::runtime_types;
            pub mod module {
                use super::runtime_types;
                #[derive(
                    ::subxt::ext::codec::Decode,
                    ::subxt::ext::codec::Encode,
                    ::subxt::ext::scale_decode::DecodeAsType,
                    ::subxt::ext::scale_encode::EncodeAsType,
                    Clone,
                    Debug,
                    Eq,
                    PartialEq
                )]
                #[codec(crate = ::subxt::ext::codec)]
                #[decode_as_type(crate_path = ":: subxt :: ext :: scale_decode")]
                #[encode_as_type(crate_path = ":: subxt :: ext :: scale_encode")]
                ///Contains one variant per dispatchable that can be called by an extrinsic.
                pub enum Call {
                    #[codec(index = 0)]
                    pause_transaction {
                        pallet_name: ::std::vec::Vec<::core::primitive::u8>,
                        function_name: ::std::vec::Vec<::core::primitive::u8>,
                    },
                    #[codec(index = 1)]
                    unpause_transaction {
                        pallet_name: ::std::vec::Vec<::core::primitive::u8>,
                        function_name: ::std::vec::Vec<::core::primitive::u8>,
                    },
                }
                #[derive(
                    ::subxt::ext::codec::Decode,
                    ::subxt::ext::codec::Encode,
                    ::subxt::ext::scale_decode::DecodeAsType,
                    ::subxt::ext::scale_encode::EncodeAsType,
                    Clone,
                    Debug,
                    Eq,
                    PartialEq
                )]
                #[codec(crate = ::subxt::ext::codec)]
                #[decode_as_type(crate_path = ":: subxt :: ext :: scale_decode")]
                #[encode_as_type(crate_path = ":: subxt :: ext :: scale_encode")]
                /**
			Custom [dispatch errors](https://docs.substrate.io/main-docs/build/events-errors/)
			of this pallet.
			*/
                pub enum Error {
                    #[codec(index = 0)]
                    ///can not pause
                    CannotPause,
                    #[codec(index = 1)]
                    ///invalid character encoding
                    InvalidCharacter,
                }
                #[derive(
                    ::subxt::ext::codec::Decode,
                    ::subxt::ext::codec::Encode,
                    ::subxt::ext::scale_decode::DecodeAsType,
                    ::subxt::ext::scale_encode::EncodeAsType,
                    Clone,
                    Debug,
                    Eq,
                    PartialEq
                )]
                #[codec(crate = ::subxt::ext::codec)]
                #[decode_as_type(crate_path = ":: subxt :: ext :: scale_decode")]
                #[encode_as_type(crate_path = ":: subxt :: ext :: scale_encode")]
                /**
			The [event](https://docs.substrate.io/main-docs/build/events-errors/) emitted
			by this pallet.
			*/
                pub enum Event {
                    #[codec(index = 0)]
                    ///Paused transaction
                    TransactionPaused {
                        pallet_name_bytes: ::std::vec::Vec<::core::primitive::u8>,
                        function_name_bytes: ::std::vec::Vec<::core::primitive::u8>,
                    },
                    #[codec(index = 1)]
                    ///Unpaused transaction
                    TransactionUnpaused {
                        pallet_name_bytes: ::std::vec::Vec<::core::primitive::u8>,
                        function_name_bytes: ::std::vec::Vec<::core::primitive::u8>,
                    },
                }
            }
        }
        pub mod pallet_transaction_payment {
            use super::runtime_types;
            pub mod pallet {
                use super::runtime_types;
                #[derive(
                    ::subxt::ext::codec::Decode,
                    ::subxt::ext::codec::Encode,
                    ::subxt::ext::scale_decode::DecodeAsType,
                    ::subxt::ext::scale_encode::EncodeAsType,
                    Clone,
                    Debug,
                    Eq,
                    PartialEq
                )]
                #[codec(crate = ::subxt::ext::codec)]
                #[decode_as_type(crate_path = ":: subxt :: ext :: scale_decode")]
                #[encode_as_type(crate_path = ":: subxt :: ext :: scale_encode")]
                /**
			The [event](https://docs.substrate.io/main-docs/build/events-errors/) emitted
			by this pallet.
			*/
                pub enum Event {
                    #[codec(index = 0)]
                    ///A transaction fee `actual_fee`, of which `tip` was added to the minimum inclusion fee,
                    ///has been paid by `who`.
                    TransactionFeePaid {
                        who: ::subxt::utils::AccountId32,
                        actual_fee: ::core::primitive::u128,
                        tip: ::core::primitive::u128,
                    },
                }
            }
            #[derive(
                ::subxt::ext::codec::Decode,
                ::subxt::ext::codec::Encode,
                ::subxt::ext::scale_decode::DecodeAsType,
                ::subxt::ext::scale_encode::EncodeAsType,
                Clone,
                Debug,
                Eq,
                PartialEq
            )]
            #[codec(crate = ::subxt::ext::codec)]
            #[decode_as_type(crate_path = ":: subxt :: ext :: scale_decode")]
            #[encode_as_type(crate_path = ":: subxt :: ext :: scale_encode")]
            pub struct ChargeTransactionPayment(
                #[codec(compact)]
                pub ::core::primitive::u128,
            );
            #[derive(
                ::subxt::ext::codec::Decode,
                ::subxt::ext::codec::Encode,
                ::subxt::ext::scale_decode::DecodeAsType,
                ::subxt::ext::scale_encode::EncodeAsType,
                Clone,
                Debug,
                Eq,
                PartialEq
            )]
            #[codec(crate = ::subxt::ext::codec)]
            #[decode_as_type(crate_path = ":: subxt :: ext :: scale_decode")]
            #[encode_as_type(crate_path = ":: subxt :: ext :: scale_encode")]
            pub enum Releases {
                #[codec(index = 0)]
                V1Ancient,
                #[codec(index = 1)]
                V2,
            }
        }
        pub mod pallet_treasury {
            use super::runtime_types;
            pub mod pallet {
                use super::runtime_types;
                #[derive(
                    ::subxt::ext::codec::Decode,
                    ::subxt::ext::codec::Encode,
                    ::subxt::ext::scale_decode::DecodeAsType,
                    ::subxt::ext::scale_encode::EncodeAsType,
                    Clone,
                    Debug,
                    Eq,
                    PartialEq
                )]
                #[codec(crate = ::subxt::ext::codec)]
                #[decode_as_type(crate_path = ":: subxt :: ext :: scale_decode")]
                #[encode_as_type(crate_path = ":: subxt :: ext :: scale_encode")]
                ///Contains one variant per dispatchable that can be called by an extrinsic.
                pub enum Call {
                    #[codec(index = 0)]
                    ///Put forward a suggestion for spending. A deposit proportional to the value
                    ///is reserved and slashed if the proposal is rejected. It is returned once the
                    ///proposal is awarded.
                    ///
                    ///## Complexity
                    ///- O(1)
                    propose_spend {
                        #[codec(compact)]
                        value: ::core::primitive::u128,
                        beneficiary: ::subxt::utils::MultiAddress<
                            ::subxt::utils::AccountId32,
                            ::core::primitive::u32,
                        >,
                    },
                    #[codec(index = 1)]
                    ///Reject a proposed spend. The original deposit will be slashed.
                    ///
                    ///May only be called from `T::RejectOrigin`.
                    ///
                    ///## Complexity
                    ///- O(1)
                    reject_proposal {
                        #[codec(compact)]
                        proposal_id: ::core::primitive::u32,
                    },
                    #[codec(index = 2)]
                    ///Approve a proposal. At a later time, the proposal will be allocated to the beneficiary
                    ///and the original deposit will be returned.
                    ///
                    ///May only be called from `T::ApproveOrigin`.
                    ///
                    ///## Complexity
                    /// - O(1).
                    approve_proposal {
                        #[codec(compact)]
                        proposal_id: ::core::primitive::u32,
                    },
                    #[codec(index = 3)]
                    ///Propose and approve a spend of treasury funds.
                    ///
                    ///- `origin`: Must be `SpendOrigin` with the `Success` value being at least `amount`.
                    ///- `amount`: The amount to be transferred from the treasury to the `beneficiary`.
                    ///- `beneficiary`: The destination account for the transfer.
                    ///
                    ///NOTE: For record-keeping purposes, the proposer is deemed to be equivalent to the
                    ///beneficiary.
                    spend {
                        #[codec(compact)]
                        amount: ::core::primitive::u128,
                        beneficiary: ::subxt::utils::MultiAddress<
                            ::subxt::utils::AccountId32,
                            ::core::primitive::u32,
                        >,
                    },
                    #[codec(index = 4)]
                    ///Force a previously approved proposal to be removed from the approval queue.
                    ///The original deposit will no longer be returned.
                    ///
                    ///May only be called from `T::RejectOrigin`.
                    ///- `proposal_id`: The index of a proposal
                    ///
                    ///## Complexity
                    ///- O(A) where `A` is the number of approvals
                    ///
                    ///Errors:
                    ///- `ProposalNotApproved`: The `proposal_id` supplied was not found in the approval queue,
                    ///i.e., the proposal has not been approved. This could also mean the proposal does not
                    ///exist altogether, thus there is no way it would have been approved in the first place.
                    remove_approval {
                        #[codec(compact)]
                        proposal_id: ::core::primitive::u32,
                    },
                }
                #[derive(
                    ::subxt::ext::codec::Decode,
                    ::subxt::ext::codec::Encode,
                    ::subxt::ext::scale_decode::DecodeAsType,
                    ::subxt::ext::scale_encode::EncodeAsType,
                    Clone,
                    Debug,
                    Eq,
                    PartialEq
                )]
                #[codec(crate = ::subxt::ext::codec)]
                #[decode_as_type(crate_path = ":: subxt :: ext :: scale_decode")]
                #[encode_as_type(crate_path = ":: subxt :: ext :: scale_encode")]
                ///Error for the treasury pallet.
                pub enum Error {
                    #[codec(index = 0)]
                    ///Proposer's balance is too low.
                    InsufficientProposersBalance,
                    #[codec(index = 1)]
                    ///No proposal or bounty at that index.
                    InvalidIndex,
                    #[codec(index = 2)]
                    ///Too many approvals in the queue.
                    TooManyApprovals,
                    #[codec(index = 3)]
                    ///The spend origin is valid but the amount it is allowed to spend is lower than the
                    ///amount to be spent.
                    InsufficientPermission,
                    #[codec(index = 4)]
                    ///Proposal has not been approved.
                    ProposalNotApproved,
                }
                #[derive(
                    ::subxt::ext::codec::Decode,
                    ::subxt::ext::codec::Encode,
                    ::subxt::ext::scale_decode::DecodeAsType,
                    ::subxt::ext::scale_encode::EncodeAsType,
                    Clone,
                    Debug,
                    Eq,
                    PartialEq
                )]
                #[codec(crate = ::subxt::ext::codec)]
                #[decode_as_type(crate_path = ":: subxt :: ext :: scale_decode")]
                #[encode_as_type(crate_path = ":: subxt :: ext :: scale_encode")]
                /**
			The [event](https://docs.substrate.io/main-docs/build/events-errors/) emitted
			by this pallet.
			*/
                pub enum Event {
                    #[codec(index = 0)]
                    ///New proposal.
                    Proposed { proposal_index: ::core::primitive::u32 },
                    #[codec(index = 1)]
                    ///We have ended a spend period and will now allocate funds.
                    Spending { budget_remaining: ::core::primitive::u128 },
                    #[codec(index = 2)]
                    ///Some funds have been allocated.
                    Awarded {
                        proposal_index: ::core::primitive::u32,
                        award: ::core::primitive::u128,
                        account: ::subxt::utils::AccountId32,
                    },
                    #[codec(index = 3)]
                    ///A proposal was rejected; funds were slashed.
                    Rejected {
                        proposal_index: ::core::primitive::u32,
                        slashed: ::core::primitive::u128,
                    },
                    #[codec(index = 4)]
                    ///Some of our funds have been burnt.
                    Burnt { burnt_funds: ::core::primitive::u128 },
                    #[codec(index = 5)]
                    ///Spending has finished; this is the amount that rolls over until next spend.
                    Rollover { rollover_balance: ::core::primitive::u128 },
                    #[codec(index = 6)]
                    ///Some funds have been deposited.
                    Deposit { value: ::core::primitive::u128 },
                    #[codec(index = 7)]
                    ///A new spend proposal has been approved.
                    SpendApproved {
                        proposal_index: ::core::primitive::u32,
                        amount: ::core::primitive::u128,
                        beneficiary: ::subxt::utils::AccountId32,
                    },
                    #[codec(index = 8)]
                    ///The inactive funds of the pallet have been updated.
                    UpdatedInactive {
                        reactivated: ::core::primitive::u128,
                        deactivated: ::core::primitive::u128,
                    },
                }
            }
            #[derive(
                ::subxt::ext::codec::Decode,
                ::subxt::ext::codec::Encode,
                ::subxt::ext::scale_decode::DecodeAsType,
                ::subxt::ext::scale_encode::EncodeAsType,
                Clone,
                Debug,
                Eq,
                PartialEq
            )]
            #[codec(crate = ::subxt::ext::codec)]
            #[decode_as_type(crate_path = ":: subxt :: ext :: scale_decode")]
            #[encode_as_type(crate_path = ":: subxt :: ext :: scale_encode")]
            pub struct Proposal<_0, _1> {
                pub proposer: _0,
                pub value: _1,
                pub beneficiary: _0,
                pub bond: _1,
            }
        }
        pub mod pallet_utility {
            use super::runtime_types;
            pub mod pallet {
                use super::runtime_types;
                #[derive(
                    ::subxt::ext::codec::Decode,
                    ::subxt::ext::codec::Encode,
                    ::subxt::ext::scale_decode::DecodeAsType,
                    ::subxt::ext::scale_encode::EncodeAsType,
                    Clone,
                    Debug,
                    Eq,
                    PartialEq
                )]
                #[codec(crate = ::subxt::ext::codec)]
                #[decode_as_type(crate_path = ":: subxt :: ext :: scale_decode")]
                #[encode_as_type(crate_path = ":: subxt :: ext :: scale_encode")]
                ///Contains one variant per dispatchable that can be called by an extrinsic.
                pub enum Call {
                    #[codec(index = 0)]
                    ///Send a batch of dispatch calls.
                    ///
                    ///May be called from any origin except `None`.
                    ///
                    ///- `calls`: The calls to be dispatched from the same origin. The number of call must not
                    ///  exceed the constant: `batched_calls_limit` (available in constant metadata).
                    ///
                    ///If origin is root then the calls are dispatched without checking origin filter. (This
                    ///includes bypassing `frame_system::Config::BaseCallFilter`).
                    ///
                    ///## Complexity
                    ///- O(C) where C is the number of calls to be batched.
                    ///
                    ///This will return `Ok` in all circumstances. To determine the success of the batch, an
                    ///event is deposited. If a call failed and the batch was interrupted, then the
                    ///`BatchInterrupted` event is deposited, along with the number of successful calls made
                    ///and the error of the failed call. If all were successful, then the `BatchCompleted`
                    ///event is deposited.
                    batch {
                        calls: ::std::vec::Vec<
                            runtime_types::tangle_standalone_runtime::RuntimeCall,
                        >,
                    },
                    #[codec(index = 1)]
                    ///Send a call through an indexed pseudonym of the sender.
                    ///
                    ///Filter from origin are passed along. The call will be dispatched with an origin which
                    ///use the same filter as the origin of this call.
                    ///
                    ///NOTE: If you need to ensure that any account-based filtering is not honored (i.e.
                    ///because you expect `proxy` to have been used prior in the call stack and you do not want
                    ///the call restrictions to apply to any sub-accounts), then use `as_multi_threshold_1`
                    ///in the Multisig pallet instead.
                    ///
                    ///NOTE: Prior to version *12, this was called `as_limited_sub`.
                    ///
                    ///The dispatch origin for this call must be _Signed_.
                    as_derivative {
                        index: ::core::primitive::u16,
                        call: ::std::boxed::Box<
                            runtime_types::tangle_standalone_runtime::RuntimeCall,
                        >,
                    },
                    #[codec(index = 2)]
                    ///Send a batch of dispatch calls and atomically execute them.
                    ///The whole transaction will rollback and fail if any of the calls failed.
                    ///
                    ///May be called from any origin except `None`.
                    ///
                    ///- `calls`: The calls to be dispatched from the same origin. The number of call must not
                    ///  exceed the constant: `batched_calls_limit` (available in constant metadata).
                    ///
                    ///If origin is root then the calls are dispatched without checking origin filter. (This
                    ///includes bypassing `frame_system::Config::BaseCallFilter`).
                    ///
                    ///## Complexity
                    ///- O(C) where C is the number of calls to be batched.
                    batch_all {
                        calls: ::std::vec::Vec<
                            runtime_types::tangle_standalone_runtime::RuntimeCall,
                        >,
                    },
                    #[codec(index = 3)]
                    ///Dispatches a function call with a provided origin.
                    ///
                    ///The dispatch origin for this call must be _Root_.
                    ///
                    ///## Complexity
                    ///- O(1).
                    dispatch_as {
                        as_origin: ::std::boxed::Box<
                            runtime_types::tangle_standalone_runtime::OriginCaller,
                        >,
                        call: ::std::boxed::Box<
                            runtime_types::tangle_standalone_runtime::RuntimeCall,
                        >,
                    },
                    #[codec(index = 4)]
                    ///Send a batch of dispatch calls.
                    ///Unlike `batch`, it allows errors and won't interrupt.
                    ///
                    ///May be called from any origin except `None`.
                    ///
                    ///- `calls`: The calls to be dispatched from the same origin. The number of call must not
                    ///  exceed the constant: `batched_calls_limit` (available in constant metadata).
                    ///
                    ///If origin is root then the calls are dispatch without checking origin filter. (This
                    ///includes bypassing `frame_system::Config::BaseCallFilter`).
                    ///
                    ///## Complexity
                    ///- O(C) where C is the number of calls to be batched.
                    force_batch {
                        calls: ::std::vec::Vec<
                            runtime_types::tangle_standalone_runtime::RuntimeCall,
                        >,
                    },
                    #[codec(index = 5)]
                    ///Dispatch a function call with a specified weight.
                    ///
                    ///This function does not check the weight of the call, and instead allows the
                    ///Root origin to specify the weight of the call.
                    ///
                    ///The dispatch origin for this call must be _Root_.
                    with_weight {
                        call: ::std::boxed::Box<
                            runtime_types::tangle_standalone_runtime::RuntimeCall,
                        >,
                        weight: runtime_types::sp_weights::weight_v2::Weight,
                    },
                }
                #[derive(
                    ::subxt::ext::codec::Decode,
                    ::subxt::ext::codec::Encode,
                    ::subxt::ext::scale_decode::DecodeAsType,
                    ::subxt::ext::scale_encode::EncodeAsType,
                    Clone,
                    Debug,
                    Eq,
                    PartialEq
                )]
                #[codec(crate = ::subxt::ext::codec)]
                #[decode_as_type(crate_path = ":: subxt :: ext :: scale_decode")]
                #[encode_as_type(crate_path = ":: subxt :: ext :: scale_encode")]
                /**
			Custom [dispatch errors](https://docs.substrate.io/main-docs/build/events-errors/)
			of this pallet.
			*/
                pub enum Error {
                    #[codec(index = 0)]
                    ///Too many calls batched.
                    TooManyCalls,
                }
                #[derive(
                    ::subxt::ext::codec::Decode,
                    ::subxt::ext::codec::Encode,
                    ::subxt::ext::scale_decode::DecodeAsType,
                    ::subxt::ext::scale_encode::EncodeAsType,
                    Clone,
                    Debug,
                    Eq,
                    PartialEq
                )]
                #[codec(crate = ::subxt::ext::codec)]
                #[decode_as_type(crate_path = ":: subxt :: ext :: scale_decode")]
                #[encode_as_type(crate_path = ":: subxt :: ext :: scale_encode")]
                /**
			The [event](https://docs.substrate.io/main-docs/build/events-errors/) emitted
			by this pallet.
			*/
                pub enum Event {
                    #[codec(index = 0)]
                    ///Batch of dispatches did not complete fully. Index of first failing dispatch given, as
                    ///well as the error.
                    BatchInterrupted {
                        index: ::core::primitive::u32,
                        error: runtime_types::sp_runtime::DispatchError,
                    },
                    #[codec(index = 1)]
                    ///Batch of dispatches completed fully with no error.
                    BatchCompleted,
                    #[codec(index = 2)]
                    ///Batch of dispatches completed but has errors.
                    BatchCompletedWithErrors,
                    #[codec(index = 3)]
                    ///A single item within a Batch of dispatches has completed with no error.
                    ItemCompleted,
                    #[codec(index = 4)]
                    ///A single item within a Batch of dispatches has completed with error.
                    ItemFailed { error: runtime_types::sp_runtime::DispatchError },
                    #[codec(index = 5)]
                    ///A call was dispatched.
                    DispatchedAs {
                        result: ::core::result::Result<
                            (),
                            runtime_types::sp_runtime::DispatchError,
                        >,
                    },
                }
            }
        }
        pub mod pallet_vesting {
            use super::runtime_types;
            pub mod pallet {
                use super::runtime_types;
                #[derive(
                    ::subxt::ext::codec::Decode,
                    ::subxt::ext::codec::Encode,
                    ::subxt::ext::scale_decode::DecodeAsType,
                    ::subxt::ext::scale_encode::EncodeAsType,
                    Clone,
                    Debug,
                    Eq,
                    PartialEq
                )]
                #[codec(crate = ::subxt::ext::codec)]
                #[decode_as_type(crate_path = ":: subxt :: ext :: scale_decode")]
                #[encode_as_type(crate_path = ":: subxt :: ext :: scale_encode")]
                ///Contains one variant per dispatchable that can be called by an extrinsic.
                pub enum Call {
                    #[codec(index = 0)]
                    ///Unlock any vested funds of the sender account.
                    ///
                    ///The dispatch origin for this call must be _Signed_ and the sender must have funds still
                    ///locked under this pallet.
                    ///
                    ///Emits either `VestingCompleted` or `VestingUpdated`.
                    ///
                    ///## Complexity
                    ///- `O(1)`.
                    vest,
                    #[codec(index = 1)]
                    ///Unlock any vested funds of a `target` account.
                    ///
                    ///The dispatch origin for this call must be _Signed_.
                    ///
                    ///- `target`: The account whose vested funds should be unlocked. Must have funds still
                    ///locked under this pallet.
                    ///
                    ///Emits either `VestingCompleted` or `VestingUpdated`.
                    ///
                    ///## Complexity
                    ///- `O(1)`.
                    vest_other {
                        target: ::subxt::utils::MultiAddress<
                            ::subxt::utils::AccountId32,
                            ::core::primitive::u32,
                        >,
                    },
                    #[codec(index = 2)]
                    ///Create a vested transfer.
                    ///
                    ///The dispatch origin for this call must be _Signed_.
                    ///
                    ///- `target`: The account receiving the vested funds.
                    ///- `schedule`: The vesting schedule attached to the transfer.
                    ///
                    ///Emits `VestingCreated`.
                    ///
                    ///NOTE: This will unlock all schedules through the current block.
                    ///
                    ///## Complexity
                    ///- `O(1)`.
                    vested_transfer {
                        target: ::subxt::utils::MultiAddress<
                            ::subxt::utils::AccountId32,
                            ::core::primitive::u32,
                        >,
                        schedule: runtime_types::pallet_vesting::vesting_info::VestingInfo<
                            ::core::primitive::u128,
                            ::core::primitive::u32,
                        >,
                    },
                    #[codec(index = 3)]
                    ///Force a vested transfer.
                    ///
                    ///The dispatch origin for this call must be _Root_.
                    ///
                    ///- `source`: The account whose funds should be transferred.
                    ///- `target`: The account that should be transferred the vested funds.
                    ///- `schedule`: The vesting schedule attached to the transfer.
                    ///
                    ///Emits `VestingCreated`.
                    ///
                    ///NOTE: This will unlock all schedules through the current block.
                    ///
                    ///## Complexity
                    ///- `O(1)`.
                    force_vested_transfer {
                        source: ::subxt::utils::MultiAddress<
                            ::subxt::utils::AccountId32,
                            ::core::primitive::u32,
                        >,
                        target: ::subxt::utils::MultiAddress<
                            ::subxt::utils::AccountId32,
                            ::core::primitive::u32,
                        >,
                        schedule: runtime_types::pallet_vesting::vesting_info::VestingInfo<
                            ::core::primitive::u128,
                            ::core::primitive::u32,
                        >,
                    },
                    #[codec(index = 4)]
                    ///Merge two vesting schedules together, creating a new vesting schedule that unlocks over
                    ///the highest possible start and end blocks. If both schedules have already started the
                    ///current block will be used as the schedule start; with the caveat that if one schedule
                    ///is finished by the current block, the other will be treated as the new merged schedule,
                    ///unmodified.
                    ///
                    ///NOTE: If `schedule1_index == schedule2_index` this is a no-op.
                    ///NOTE: This will unlock all schedules through the current block prior to merging.
                    ///NOTE: If both schedules have ended by the current block, no new schedule will be created
                    ///and both will be removed.
                    ///
                    ///Merged schedule attributes:
                    ///- `starting_block`: `MAX(schedule1.starting_block, scheduled2.starting_block,
                    ///  current_block)`.
                    ///- `ending_block`: `MAX(schedule1.ending_block, schedule2.ending_block)`.
                    ///- `locked`: `schedule1.locked_at(current_block) + schedule2.locked_at(current_block)`.
                    ///
                    ///The dispatch origin for this call must be _Signed_.
                    ///
                    ///- `schedule1_index`: index of the first schedule to merge.
                    ///- `schedule2_index`: index of the second schedule to merge.
                    merge_schedules {
                        schedule1_index: ::core::primitive::u32,
                        schedule2_index: ::core::primitive::u32,
                    },
                }
                #[derive(
                    ::subxt::ext::codec::Decode,
                    ::subxt::ext::codec::Encode,
                    ::subxt::ext::scale_decode::DecodeAsType,
                    ::subxt::ext::scale_encode::EncodeAsType,
                    Clone,
                    Debug,
                    Eq,
                    PartialEq
                )]
                #[codec(crate = ::subxt::ext::codec)]
                #[decode_as_type(crate_path = ":: subxt :: ext :: scale_decode")]
                #[encode_as_type(crate_path = ":: subxt :: ext :: scale_encode")]
                ///Error for the vesting pallet.
                pub enum Error {
                    #[codec(index = 0)]
                    ///The account given is not vesting.
                    NotVesting,
                    #[codec(index = 1)]
                    ///The account already has `MaxVestingSchedules` count of schedules and thus
                    ///cannot add another one. Consider merging existing schedules in order to add another.
                    AtMaxVestingSchedules,
                    #[codec(index = 2)]
                    ///Amount being transferred is too low to create a vesting schedule.
                    AmountLow,
                    #[codec(index = 3)]
                    ///An index was out of bounds of the vesting schedules.
                    ScheduleIndexOutOfBounds,
                    #[codec(index = 4)]
                    ///Failed to create a new schedule because some parameter was invalid.
                    InvalidScheduleParams,
                }
                #[derive(
                    ::subxt::ext::codec::Decode,
                    ::subxt::ext::codec::Encode,
                    ::subxt::ext::scale_decode::DecodeAsType,
                    ::subxt::ext::scale_encode::EncodeAsType,
                    Clone,
                    Debug,
                    Eq,
                    PartialEq
                )]
                #[codec(crate = ::subxt::ext::codec)]
                #[decode_as_type(crate_path = ":: subxt :: ext :: scale_decode")]
                #[encode_as_type(crate_path = ":: subxt :: ext :: scale_encode")]
                /**
			The [event](https://docs.substrate.io/main-docs/build/events-errors/) emitted
			by this pallet.
			*/
                pub enum Event {
                    #[codec(index = 0)]
                    ///The amount vested has been updated. This could indicate a change in funds available.
                    ///The balance given is the amount which is left unvested (and thus locked).
                    VestingUpdated {
                        account: ::subxt::utils::AccountId32,
                        unvested: ::core::primitive::u128,
                    },
                    #[codec(index = 1)]
                    ///An \[account\] has become fully vested.
                    VestingCompleted { account: ::subxt::utils::AccountId32 },
                }
            }
            pub mod vesting_info {
                use super::runtime_types;
                #[derive(
                    ::subxt::ext::codec::Decode,
                    ::subxt::ext::codec::Encode,
                    ::subxt::ext::scale_decode::DecodeAsType,
                    ::subxt::ext::scale_encode::EncodeAsType,
                    Clone,
                    Debug,
                    Eq,
                    PartialEq
                )]
                #[codec(crate = ::subxt::ext::codec)]
                #[decode_as_type(crate_path = ":: subxt :: ext :: scale_decode")]
                #[encode_as_type(crate_path = ":: subxt :: ext :: scale_encode")]
                pub struct VestingInfo<_0, _1> {
                    pub locked: _0,
                    pub per_block: _0,
                    pub starting_block: _1,
                }
            }
            #[derive(
                ::subxt::ext::codec::Decode,
                ::subxt::ext::codec::Encode,
                ::subxt::ext::scale_decode::DecodeAsType,
                ::subxt::ext::scale_encode::EncodeAsType,
                Clone,
                Debug,
                Eq,
                PartialEq
            )]
            #[codec(crate = ::subxt::ext::codec)]
            #[decode_as_type(crate_path = ":: subxt :: ext :: scale_decode")]
            #[encode_as_type(crate_path = ":: subxt :: ext :: scale_encode")]
            pub enum Releases {
                #[codec(index = 0)]
                V0,
                #[codec(index = 1)]
                V1,
            }
        }
        pub mod primitive_types {
            use super::runtime_types;
            #[derive(
                ::subxt::ext::codec::Decode,
                ::subxt::ext::codec::Encode,
                ::subxt::ext::scale_decode::DecodeAsType,
                ::subxt::ext::scale_encode::EncodeAsType,
                Clone,
                Debug,
                Eq,
                PartialEq
            )]
            #[codec(crate = ::subxt::ext::codec)]
            #[decode_as_type(crate_path = ":: subxt :: ext :: scale_decode")]
            #[encode_as_type(crate_path = ":: subxt :: ext :: scale_encode")]
            pub struct U256(pub [::core::primitive::u64; 4usize]);
        }
        pub mod sp_arithmetic {
            use super::runtime_types;
            pub mod fixed_point {
                use super::runtime_types;
                #[derive(
                    ::subxt::ext::codec::CompactAs,
                    ::subxt::ext::codec::Decode,
                    ::subxt::ext::codec::Encode,
                    ::subxt::ext::scale_decode::DecodeAsType,
                    ::subxt::ext::scale_encode::EncodeAsType,
                    Clone,
                    Debug,
                    Eq,
                    PartialEq
                )]
                #[codec(crate = ::subxt::ext::codec)]
                #[decode_as_type(crate_path = ":: subxt :: ext :: scale_decode")]
                #[encode_as_type(crate_path = ":: subxt :: ext :: scale_encode")]
                pub struct FixedU128(pub ::core::primitive::u128);
            }
            pub mod per_things {
                use super::runtime_types;
                #[derive(
                    ::subxt::ext::codec::CompactAs,
                    ::subxt::ext::codec::Decode,
                    ::subxt::ext::codec::Encode,
                    ::subxt::ext::scale_decode::DecodeAsType,
                    ::subxt::ext::scale_encode::EncodeAsType,
                    Clone,
                    Debug,
                    Eq,
                    PartialEq
                )]
                #[codec(crate = ::subxt::ext::codec)]
                #[decode_as_type(crate_path = ":: subxt :: ext :: scale_decode")]
                #[encode_as_type(crate_path = ":: subxt :: ext :: scale_encode")]
                pub struct PerU16(pub ::core::primitive::u16);
                #[derive(
                    ::subxt::ext::codec::CompactAs,
                    ::subxt::ext::codec::Decode,
                    ::subxt::ext::codec::Encode,
                    ::subxt::ext::scale_decode::DecodeAsType,
                    ::subxt::ext::scale_encode::EncodeAsType,
                    Clone,
                    Debug,
                    Eq,
                    PartialEq
                )]
                #[codec(crate = ::subxt::ext::codec)]
                #[decode_as_type(crate_path = ":: subxt :: ext :: scale_decode")]
                #[encode_as_type(crate_path = ":: subxt :: ext :: scale_encode")]
                pub struct Perbill(pub ::core::primitive::u32);
                #[derive(
                    ::subxt::ext::codec::CompactAs,
                    ::subxt::ext::codec::Decode,
                    ::subxt::ext::codec::Encode,
                    ::subxt::ext::scale_decode::DecodeAsType,
                    ::subxt::ext::scale_encode::EncodeAsType,
                    Clone,
                    Debug,
                    Eq,
                    PartialEq
                )]
                #[codec(crate = ::subxt::ext::codec)]
                #[decode_as_type(crate_path = ":: subxt :: ext :: scale_decode")]
                #[encode_as_type(crate_path = ":: subxt :: ext :: scale_encode")]
                pub struct Percent(pub ::core::primitive::u8);
                #[derive(
                    ::subxt::ext::codec::CompactAs,
                    ::subxt::ext::codec::Decode,
                    ::subxt::ext::codec::Encode,
                    ::subxt::ext::scale_decode::DecodeAsType,
                    ::subxt::ext::scale_encode::EncodeAsType,
                    Clone,
                    Debug,
                    Eq,
                    PartialEq
                )]
                #[codec(crate = ::subxt::ext::codec)]
                #[decode_as_type(crate_path = ":: subxt :: ext :: scale_decode")]
                #[encode_as_type(crate_path = ":: subxt :: ext :: scale_encode")]
                pub struct Permill(pub ::core::primitive::u32);
            }
            #[derive(
                ::subxt::ext::codec::Decode,
                ::subxt::ext::codec::Encode,
                ::subxt::ext::scale_decode::DecodeAsType,
                ::subxt::ext::scale_encode::EncodeAsType,
                Clone,
                Debug,
                Eq,
                PartialEq
            )]
            #[codec(crate = ::subxt::ext::codec)]
            #[decode_as_type(crate_path = ":: subxt :: ext :: scale_decode")]
            #[encode_as_type(crate_path = ":: subxt :: ext :: scale_encode")]
            pub enum ArithmeticError {
                #[codec(index = 0)]
                Underflow,
                #[codec(index = 1)]
                Overflow,
                #[codec(index = 2)]
                DivisionByZero,
            }
        }
        pub mod sp_consensus_aura {
            use super::runtime_types;
            pub mod sr25519 {
                use super::runtime_types;
                pub mod app_sr25519 {
                    use super::runtime_types;
                    #[derive(
                        ::subxt::ext::codec::Decode,
                        ::subxt::ext::codec::Encode,
                        ::subxt::ext::scale_decode::DecodeAsType,
                        ::subxt::ext::scale_encode::EncodeAsType,
                        Clone,
                        Debug,
                        Eq,
                        PartialEq
                    )]
                    #[codec(crate = ::subxt::ext::codec)]
                    #[decode_as_type(crate_path = ":: subxt :: ext :: scale_decode")]
                    #[encode_as_type(crate_path = ":: subxt :: ext :: scale_encode")]
                    pub struct Public(pub runtime_types::sp_core::sr25519::Public);
                }
            }
        }
        pub mod sp_consensus_grandpa {
            use super::runtime_types;
            pub mod app {
                use super::runtime_types;
                #[derive(
                    ::subxt::ext::codec::Decode,
                    ::subxt::ext::codec::Encode,
                    ::subxt::ext::scale_decode::DecodeAsType,
                    ::subxt::ext::scale_encode::EncodeAsType,
                    Clone,
                    Debug,
                    Eq,
                    PartialEq
                )]
                #[codec(crate = ::subxt::ext::codec)]
                #[decode_as_type(crate_path = ":: subxt :: ext :: scale_decode")]
                #[encode_as_type(crate_path = ":: subxt :: ext :: scale_encode")]
                pub struct Public(pub runtime_types::sp_core::ed25519::Public);
                #[derive(
                    ::subxt::ext::codec::Decode,
                    ::subxt::ext::codec::Encode,
                    ::subxt::ext::scale_decode::DecodeAsType,
                    ::subxt::ext::scale_encode::EncodeAsType,
                    Clone,
                    Debug,
                    Eq,
                    PartialEq
                )]
                #[codec(crate = ::subxt::ext::codec)]
                #[decode_as_type(crate_path = ":: subxt :: ext :: scale_decode")]
                #[encode_as_type(crate_path = ":: subxt :: ext :: scale_encode")]
                pub struct Signature(pub runtime_types::sp_core::ed25519::Signature);
            }
            #[derive(
                ::subxt::ext::codec::Decode,
                ::subxt::ext::codec::Encode,
                ::subxt::ext::scale_decode::DecodeAsType,
                ::subxt::ext::scale_encode::EncodeAsType,
                Clone,
                Debug,
                Eq,
                PartialEq
            )]
            #[codec(crate = ::subxt::ext::codec)]
            #[decode_as_type(crate_path = ":: subxt :: ext :: scale_decode")]
            #[encode_as_type(crate_path = ":: subxt :: ext :: scale_encode")]
            pub enum Equivocation<_0, _1> {
                #[codec(index = 0)]
                Prevote(
                    runtime_types::finality_grandpa::Equivocation<
                        runtime_types::sp_consensus_grandpa::app::Public,
                        runtime_types::finality_grandpa::Prevote<_0, _1>,
                        runtime_types::sp_consensus_grandpa::app::Signature,
                    >,
                ),
                #[codec(index = 1)]
                Precommit(
                    runtime_types::finality_grandpa::Equivocation<
                        runtime_types::sp_consensus_grandpa::app::Public,
                        runtime_types::finality_grandpa::Precommit<_0, _1>,
                        runtime_types::sp_consensus_grandpa::app::Signature,
                    >,
                ),
            }
            #[derive(
                ::subxt::ext::codec::Decode,
                ::subxt::ext::codec::Encode,
                ::subxt::ext::scale_decode::DecodeAsType,
                ::subxt::ext::scale_encode::EncodeAsType,
                Clone,
                Debug,
                Eq,
                PartialEq
            )]
            #[codec(crate = ::subxt::ext::codec)]
            #[decode_as_type(crate_path = ":: subxt :: ext :: scale_decode")]
            #[encode_as_type(crate_path = ":: subxt :: ext :: scale_encode")]
            pub struct EquivocationProof<_0, _1> {
                pub set_id: ::core::primitive::u64,
                pub equivocation: runtime_types::sp_consensus_grandpa::Equivocation<
                    _0,
                    _1,
                >,
            }
        }
        pub mod sp_consensus_slots {
            use super::runtime_types;
            #[derive(
                ::subxt::ext::codec::CompactAs,
                ::subxt::ext::codec::Decode,
                ::subxt::ext::codec::Encode,
                ::subxt::ext::scale_decode::DecodeAsType,
                ::subxt::ext::scale_encode::EncodeAsType,
                Clone,
                Debug,
                Eq,
                PartialEq
            )]
            #[codec(crate = ::subxt::ext::codec)]
            #[decode_as_type(crate_path = ":: subxt :: ext :: scale_decode")]
            #[encode_as_type(crate_path = ":: subxt :: ext :: scale_encode")]
            pub struct Slot(pub ::core::primitive::u64);
        }
        pub mod sp_core {
            use super::runtime_types;
            pub mod crypto {
                use super::runtime_types;
                #[derive(
                    ::subxt::ext::codec::Decode,
                    ::subxt::ext::codec::Encode,
                    ::subxt::ext::scale_decode::DecodeAsType,
                    ::subxt::ext::scale_encode::EncodeAsType,
                    Clone,
                    Debug,
                    Eq,
                    PartialEq
                )]
                #[codec(crate = ::subxt::ext::codec)]
                #[decode_as_type(crate_path = ":: subxt :: ext :: scale_decode")]
                #[encode_as_type(crate_path = ":: subxt :: ext :: scale_encode")]
                pub struct KeyTypeId(pub [::core::primitive::u8; 4usize]);
            }
            pub mod ecdsa {
                use super::runtime_types;
                #[derive(
                    ::subxt::ext::codec::Decode,
                    ::subxt::ext::codec::Encode,
                    ::subxt::ext::scale_decode::DecodeAsType,
                    ::subxt::ext::scale_encode::EncodeAsType,
                    Clone,
                    Debug,
                    Eq,
                    PartialEq
                )]
                #[codec(crate = ::subxt::ext::codec)]
                #[decode_as_type(crate_path = ":: subxt :: ext :: scale_decode")]
                #[encode_as_type(crate_path = ":: subxt :: ext :: scale_encode")]
                pub struct Public(pub [::core::primitive::u8; 33usize]);
                #[derive(
                    ::subxt::ext::codec::Decode,
                    ::subxt::ext::codec::Encode,
                    ::subxt::ext::scale_decode::DecodeAsType,
                    ::subxt::ext::scale_encode::EncodeAsType,
                    Clone,
                    Debug,
                    Eq,
                    PartialEq
                )]
                #[codec(crate = ::subxt::ext::codec)]
                #[decode_as_type(crate_path = ":: subxt :: ext :: scale_decode")]
                #[encode_as_type(crate_path = ":: subxt :: ext :: scale_encode")]
                pub struct Signature(pub [::core::primitive::u8; 65usize]);
            }
            pub mod ed25519 {
                use super::runtime_types;
                #[derive(
                    ::subxt::ext::codec::Decode,
                    ::subxt::ext::codec::Encode,
                    ::subxt::ext::scale_decode::DecodeAsType,
                    ::subxt::ext::scale_encode::EncodeAsType,
                    Clone,
                    Debug,
                    Eq,
                    PartialEq
                )]
                #[codec(crate = ::subxt::ext::codec)]
                #[decode_as_type(crate_path = ":: subxt :: ext :: scale_decode")]
                #[encode_as_type(crate_path = ":: subxt :: ext :: scale_encode")]
                pub struct Public(pub [::core::primitive::u8; 32usize]);
                #[derive(
                    ::subxt::ext::codec::Decode,
                    ::subxt::ext::codec::Encode,
                    ::subxt::ext::scale_decode::DecodeAsType,
                    ::subxt::ext::scale_encode::EncodeAsType,
                    Clone,
                    Debug,
                    Eq,
                    PartialEq
                )]
                #[codec(crate = ::subxt::ext::codec)]
                #[decode_as_type(crate_path = ":: subxt :: ext :: scale_decode")]
                #[encode_as_type(crate_path = ":: subxt :: ext :: scale_encode")]
                pub struct Signature(pub [::core::primitive::u8; 64usize]);
            }
            pub mod offchain {
                use super::runtime_types;
                #[derive(
                    ::subxt::ext::codec::Decode,
                    ::subxt::ext::codec::Encode,
                    ::subxt::ext::scale_decode::DecodeAsType,
                    ::subxt::ext::scale_encode::EncodeAsType,
                    Clone,
                    Debug,
                    Eq,
                    PartialEq
                )]
                #[codec(crate = ::subxt::ext::codec)]
                #[decode_as_type(crate_path = ":: subxt :: ext :: scale_decode")]
                #[encode_as_type(crate_path = ":: subxt :: ext :: scale_encode")]
                pub struct OpaqueMultiaddr(pub ::std::vec::Vec<::core::primitive::u8>);
                #[derive(
                    ::subxt::ext::codec::Decode,
                    ::subxt::ext::codec::Encode,
                    ::subxt::ext::scale_decode::DecodeAsType,
                    ::subxt::ext::scale_encode::EncodeAsType,
                    Clone,
                    Debug,
                    Eq,
                    PartialEq
                )]
                #[codec(crate = ::subxt::ext::codec)]
                #[decode_as_type(crate_path = ":: subxt :: ext :: scale_decode")]
                #[encode_as_type(crate_path = ":: subxt :: ext :: scale_encode")]
                pub struct OpaqueNetworkState {
                    pub peer_id: runtime_types::sp_core::OpaquePeerId,
                    pub external_addresses: ::std::vec::Vec<
                        runtime_types::sp_core::offchain::OpaqueMultiaddr,
                    >,
                }
            }
            pub mod sr25519 {
                use super::runtime_types;
                #[derive(
                    ::subxt::ext::codec::Decode,
                    ::subxt::ext::codec::Encode,
                    ::subxt::ext::scale_decode::DecodeAsType,
                    ::subxt::ext::scale_encode::EncodeAsType,
                    Clone,
                    Debug,
                    Eq,
                    PartialEq
                )]
                #[codec(crate = ::subxt::ext::codec)]
                #[decode_as_type(crate_path = ":: subxt :: ext :: scale_decode")]
                #[encode_as_type(crate_path = ":: subxt :: ext :: scale_encode")]
                pub struct Public(pub [::core::primitive::u8; 32usize]);
                #[derive(
                    ::subxt::ext::codec::Decode,
                    ::subxt::ext::codec::Encode,
                    ::subxt::ext::scale_decode::DecodeAsType,
                    ::subxt::ext::scale_encode::EncodeAsType,
                    Clone,
                    Debug,
                    Eq,
                    PartialEq
                )]
                #[codec(crate = ::subxt::ext::codec)]
                #[decode_as_type(crate_path = ":: subxt :: ext :: scale_decode")]
                #[encode_as_type(crate_path = ":: subxt :: ext :: scale_encode")]
                pub struct Signature(pub [::core::primitive::u8; 64usize]);
            }
            #[derive(
                ::subxt::ext::codec::Decode,
                ::subxt::ext::codec::Encode,
                ::subxt::ext::scale_decode::DecodeAsType,
                ::subxt::ext::scale_encode::EncodeAsType,
                Clone,
                Debug,
                Eq,
                PartialEq
            )]
            #[codec(crate = ::subxt::ext::codec)]
            #[decode_as_type(crate_path = ":: subxt :: ext :: scale_decode")]
            #[encode_as_type(crate_path = ":: subxt :: ext :: scale_encode")]
            pub struct OpaquePeerId(pub ::std::vec::Vec<::core::primitive::u8>);
            #[derive(
                ::subxt::ext::codec::Decode,
                ::subxt::ext::codec::Encode,
                ::subxt::ext::scale_decode::DecodeAsType,
                ::subxt::ext::scale_encode::EncodeAsType,
                Clone,
                Debug,
                Eq,
                PartialEq
            )]
            #[codec(crate = ::subxt::ext::codec)]
            #[decode_as_type(crate_path = ":: subxt :: ext :: scale_decode")]
            #[encode_as_type(crate_path = ":: subxt :: ext :: scale_encode")]
            pub enum Void {}
        }
        pub mod sp_npos_elections {
            use super::runtime_types;
            #[derive(
                ::subxt::ext::codec::Decode,
                ::subxt::ext::codec::Encode,
                ::subxt::ext::scale_decode::DecodeAsType,
                ::subxt::ext::scale_encode::EncodeAsType,
                Clone,
                Debug,
                Eq,
                PartialEq
            )]
            #[codec(crate = ::subxt::ext::codec)]
            #[decode_as_type(crate_path = ":: subxt :: ext :: scale_decode")]
            #[encode_as_type(crate_path = ":: subxt :: ext :: scale_encode")]
            pub struct ElectionScore {
                pub minimal_stake: ::core::primitive::u128,
                pub sum_stake: ::core::primitive::u128,
                pub sum_stake_squared: ::core::primitive::u128,
            }
            #[derive(
                ::subxt::ext::codec::Decode,
                ::subxt::ext::codec::Encode,
                ::subxt::ext::scale_decode::DecodeAsType,
                ::subxt::ext::scale_encode::EncodeAsType,
                Clone,
                Debug,
                Eq,
                PartialEq
            )]
            #[codec(crate = ::subxt::ext::codec)]
            #[decode_as_type(crate_path = ":: subxt :: ext :: scale_decode")]
            #[encode_as_type(crate_path = ":: subxt :: ext :: scale_encode")]
            pub struct Support<_0> {
                pub total: ::core::primitive::u128,
                pub voters: ::std::vec::Vec<(_0, ::core::primitive::u128)>,
            }
        }
        pub mod sp_runtime {
            use super::runtime_types;
            pub mod generic {
                use super::runtime_types;
                pub mod digest {
                    use super::runtime_types;
                    #[derive(
                        ::subxt::ext::codec::Decode,
                        ::subxt::ext::codec::Encode,
                        ::subxt::ext::scale_decode::DecodeAsType,
                        ::subxt::ext::scale_encode::EncodeAsType,
                        Clone,
                        Debug,
                        Eq,
                        PartialEq
                    )]
                    #[codec(crate = ::subxt::ext::codec)]
                    #[decode_as_type(crate_path = ":: subxt :: ext :: scale_decode")]
                    #[encode_as_type(crate_path = ":: subxt :: ext :: scale_encode")]
                    pub struct Digest {
                        pub logs: ::std::vec::Vec<
                            runtime_types::sp_runtime::generic::digest::DigestItem,
                        >,
                    }
                    #[derive(
                        ::subxt::ext::codec::Decode,
                        ::subxt::ext::codec::Encode,
                        ::subxt::ext::scale_decode::DecodeAsType,
                        ::subxt::ext::scale_encode::EncodeAsType,
                        Clone,
                        Debug,
                        Eq,
                        PartialEq
                    )]
                    #[codec(crate = ::subxt::ext::codec)]
                    #[decode_as_type(crate_path = ":: subxt :: ext :: scale_decode")]
                    #[encode_as_type(crate_path = ":: subxt :: ext :: scale_encode")]
                    pub enum DigestItem {
                        #[codec(index = 6)]
                        PreRuntime(
                            [::core::primitive::u8; 4usize],
                            ::std::vec::Vec<::core::primitive::u8>,
                        ),
                        #[codec(index = 4)]
                        Consensus(
                            [::core::primitive::u8; 4usize],
                            ::std::vec::Vec<::core::primitive::u8>,
                        ),
                        #[codec(index = 5)]
                        Seal(
                            [::core::primitive::u8; 4usize],
                            ::std::vec::Vec<::core::primitive::u8>,
                        ),
                        #[codec(index = 0)]
                        Other(::std::vec::Vec<::core::primitive::u8>),
                        #[codec(index = 8)]
                        RuntimeEnvironmentUpdated,
                    }
                }
                pub mod era {
                    use super::runtime_types;
                    #[derive(
                        ::subxt::ext::codec::Decode,
                        ::subxt::ext::codec::Encode,
                        ::subxt::ext::scale_decode::DecodeAsType,
                        ::subxt::ext::scale_encode::EncodeAsType,
                        Clone,
                        Debug,
                        Eq,
                        PartialEq
                    )]
                    #[codec(crate = ::subxt::ext::codec)]
                    #[decode_as_type(crate_path = ":: subxt :: ext :: scale_decode")]
                    #[encode_as_type(crate_path = ":: subxt :: ext :: scale_encode")]
                    pub enum Era {
                        #[codec(index = 0)]
                        Immortal,
                        #[codec(index = 1)]
                        Mortal1(::core::primitive::u8),
                        #[codec(index = 2)]
                        Mortal2(::core::primitive::u8),
                        #[codec(index = 3)]
                        Mortal3(::core::primitive::u8),
                        #[codec(index = 4)]
                        Mortal4(::core::primitive::u8),
                        #[codec(index = 5)]
                        Mortal5(::core::primitive::u8),
                        #[codec(index = 6)]
                        Mortal6(::core::primitive::u8),
                        #[codec(index = 7)]
                        Mortal7(::core::primitive::u8),
                        #[codec(index = 8)]
                        Mortal8(::core::primitive::u8),
                        #[codec(index = 9)]
                        Mortal9(::core::primitive::u8),
                        #[codec(index = 10)]
                        Mortal10(::core::primitive::u8),
                        #[codec(index = 11)]
                        Mortal11(::core::primitive::u8),
                        #[codec(index = 12)]
                        Mortal12(::core::primitive::u8),
                        #[codec(index = 13)]
                        Mortal13(::core::primitive::u8),
                        #[codec(index = 14)]
                        Mortal14(::core::primitive::u8),
                        #[codec(index = 15)]
                        Mortal15(::core::primitive::u8),
                        #[codec(index = 16)]
                        Mortal16(::core::primitive::u8),
                        #[codec(index = 17)]
                        Mortal17(::core::primitive::u8),
                        #[codec(index = 18)]
                        Mortal18(::core::primitive::u8),
                        #[codec(index = 19)]
                        Mortal19(::core::primitive::u8),
                        #[codec(index = 20)]
                        Mortal20(::core::primitive::u8),
                        #[codec(index = 21)]
                        Mortal21(::core::primitive::u8),
                        #[codec(index = 22)]
                        Mortal22(::core::primitive::u8),
                        #[codec(index = 23)]
                        Mortal23(::core::primitive::u8),
                        #[codec(index = 24)]
                        Mortal24(::core::primitive::u8),
                        #[codec(index = 25)]
                        Mortal25(::core::primitive::u8),
                        #[codec(index = 26)]
                        Mortal26(::core::primitive::u8),
                        #[codec(index = 27)]
                        Mortal27(::core::primitive::u8),
                        #[codec(index = 28)]
                        Mortal28(::core::primitive::u8),
                        #[codec(index = 29)]
                        Mortal29(::core::primitive::u8),
                        #[codec(index = 30)]
                        Mortal30(::core::primitive::u8),
                        #[codec(index = 31)]
                        Mortal31(::core::primitive::u8),
                        #[codec(index = 32)]
                        Mortal32(::core::primitive::u8),
                        #[codec(index = 33)]
                        Mortal33(::core::primitive::u8),
                        #[codec(index = 34)]
                        Mortal34(::core::primitive::u8),
                        #[codec(index = 35)]
                        Mortal35(::core::primitive::u8),
                        #[codec(index = 36)]
                        Mortal36(::core::primitive::u8),
                        #[codec(index = 37)]
                        Mortal37(::core::primitive::u8),
                        #[codec(index = 38)]
                        Mortal38(::core::primitive::u8),
                        #[codec(index = 39)]
                        Mortal39(::core::primitive::u8),
                        #[codec(index = 40)]
                        Mortal40(::core::primitive::u8),
                        #[codec(index = 41)]
                        Mortal41(::core::primitive::u8),
                        #[codec(index = 42)]
                        Mortal42(::core::primitive::u8),
                        #[codec(index = 43)]
                        Mortal43(::core::primitive::u8),
                        #[codec(index = 44)]
                        Mortal44(::core::primitive::u8),
                        #[codec(index = 45)]
                        Mortal45(::core::primitive::u8),
                        #[codec(index = 46)]
                        Mortal46(::core::primitive::u8),
                        #[codec(index = 47)]
                        Mortal47(::core::primitive::u8),
                        #[codec(index = 48)]
                        Mortal48(::core::primitive::u8),
                        #[codec(index = 49)]
                        Mortal49(::core::primitive::u8),
                        #[codec(index = 50)]
                        Mortal50(::core::primitive::u8),
                        #[codec(index = 51)]
                        Mortal51(::core::primitive::u8),
                        #[codec(index = 52)]
                        Mortal52(::core::primitive::u8),
                        #[codec(index = 53)]
                        Mortal53(::core::primitive::u8),
                        #[codec(index = 54)]
                        Mortal54(::core::primitive::u8),
                        #[codec(index = 55)]
                        Mortal55(::core::primitive::u8),
                        #[codec(index = 56)]
                        Mortal56(::core::primitive::u8),
                        #[codec(index = 57)]
                        Mortal57(::core::primitive::u8),
                        #[codec(index = 58)]
                        Mortal58(::core::primitive::u8),
                        #[codec(index = 59)]
                        Mortal59(::core::primitive::u8),
                        #[codec(index = 60)]
                        Mortal60(::core::primitive::u8),
                        #[codec(index = 61)]
                        Mortal61(::core::primitive::u8),
                        #[codec(index = 62)]
                        Mortal62(::core::primitive::u8),
                        #[codec(index = 63)]
                        Mortal63(::core::primitive::u8),
                        #[codec(index = 64)]
                        Mortal64(::core::primitive::u8),
                        #[codec(index = 65)]
                        Mortal65(::core::primitive::u8),
                        #[codec(index = 66)]
                        Mortal66(::core::primitive::u8),
                        #[codec(index = 67)]
                        Mortal67(::core::primitive::u8),
                        #[codec(index = 68)]
                        Mortal68(::core::primitive::u8),
                        #[codec(index = 69)]
                        Mortal69(::core::primitive::u8),
                        #[codec(index = 70)]
                        Mortal70(::core::primitive::u8),
                        #[codec(index = 71)]
                        Mortal71(::core::primitive::u8),
                        #[codec(index = 72)]
                        Mortal72(::core::primitive::u8),
                        #[codec(index = 73)]
                        Mortal73(::core::primitive::u8),
                        #[codec(index = 74)]
                        Mortal74(::core::primitive::u8),
                        #[codec(index = 75)]
                        Mortal75(::core::primitive::u8),
                        #[codec(index = 76)]
                        Mortal76(::core::primitive::u8),
                        #[codec(index = 77)]
                        Mortal77(::core::primitive::u8),
                        #[codec(index = 78)]
                        Mortal78(::core::primitive::u8),
                        #[codec(index = 79)]
                        Mortal79(::core::primitive::u8),
                        #[codec(index = 80)]
                        Mortal80(::core::primitive::u8),
                        #[codec(index = 81)]
                        Mortal81(::core::primitive::u8),
                        #[codec(index = 82)]
                        Mortal82(::core::primitive::u8),
                        #[codec(index = 83)]
                        Mortal83(::core::primitive::u8),
                        #[codec(index = 84)]
                        Mortal84(::core::primitive::u8),
                        #[codec(index = 85)]
                        Mortal85(::core::primitive::u8),
                        #[codec(index = 86)]
                        Mortal86(::core::primitive::u8),
                        #[codec(index = 87)]
                        Mortal87(::core::primitive::u8),
                        #[codec(index = 88)]
                        Mortal88(::core::primitive::u8),
                        #[codec(index = 89)]
                        Mortal89(::core::primitive::u8),
                        #[codec(index = 90)]
                        Mortal90(::core::primitive::u8),
                        #[codec(index = 91)]
                        Mortal91(::core::primitive::u8),
                        #[codec(index = 92)]
                        Mortal92(::core::primitive::u8),
                        #[codec(index = 93)]
                        Mortal93(::core::primitive::u8),
                        #[codec(index = 94)]
                        Mortal94(::core::primitive::u8),
                        #[codec(index = 95)]
                        Mortal95(::core::primitive::u8),
                        #[codec(index = 96)]
                        Mortal96(::core::primitive::u8),
                        #[codec(index = 97)]
                        Mortal97(::core::primitive::u8),
                        #[codec(index = 98)]
                        Mortal98(::core::primitive::u8),
                        #[codec(index = 99)]
                        Mortal99(::core::primitive::u8),
                        #[codec(index = 100)]
                        Mortal100(::core::primitive::u8),
                        #[codec(index = 101)]
                        Mortal101(::core::primitive::u8),
                        #[codec(index = 102)]
                        Mortal102(::core::primitive::u8),
                        #[codec(index = 103)]
                        Mortal103(::core::primitive::u8),
                        #[codec(index = 104)]
                        Mortal104(::core::primitive::u8),
                        #[codec(index = 105)]
                        Mortal105(::core::primitive::u8),
                        #[codec(index = 106)]
                        Mortal106(::core::primitive::u8),
                        #[codec(index = 107)]
                        Mortal107(::core::primitive::u8),
                        #[codec(index = 108)]
                        Mortal108(::core::primitive::u8),
                        #[codec(index = 109)]
                        Mortal109(::core::primitive::u8),
                        #[codec(index = 110)]
                        Mortal110(::core::primitive::u8),
                        #[codec(index = 111)]
                        Mortal111(::core::primitive::u8),
                        #[codec(index = 112)]
                        Mortal112(::core::primitive::u8),
                        #[codec(index = 113)]
                        Mortal113(::core::primitive::u8),
                        #[codec(index = 114)]
                        Mortal114(::core::primitive::u8),
                        #[codec(index = 115)]
                        Mortal115(::core::primitive::u8),
                        #[codec(index = 116)]
                        Mortal116(::core::primitive::u8),
                        #[codec(index = 117)]
                        Mortal117(::core::primitive::u8),
                        #[codec(index = 118)]
                        Mortal118(::core::primitive::u8),
                        #[codec(index = 119)]
                        Mortal119(::core::primitive::u8),
                        #[codec(index = 120)]
                        Mortal120(::core::primitive::u8),
                        #[codec(index = 121)]
                        Mortal121(::core::primitive::u8),
                        #[codec(index = 122)]
                        Mortal122(::core::primitive::u8),
                        #[codec(index = 123)]
                        Mortal123(::core::primitive::u8),
                        #[codec(index = 124)]
                        Mortal124(::core::primitive::u8),
                        #[codec(index = 125)]
                        Mortal125(::core::primitive::u8),
                        #[codec(index = 126)]
                        Mortal126(::core::primitive::u8),
                        #[codec(index = 127)]
                        Mortal127(::core::primitive::u8),
                        #[codec(index = 128)]
                        Mortal128(::core::primitive::u8),
                        #[codec(index = 129)]
                        Mortal129(::core::primitive::u8),
                        #[codec(index = 130)]
                        Mortal130(::core::primitive::u8),
                        #[codec(index = 131)]
                        Mortal131(::core::primitive::u8),
                        #[codec(index = 132)]
                        Mortal132(::core::primitive::u8),
                        #[codec(index = 133)]
                        Mortal133(::core::primitive::u8),
                        #[codec(index = 134)]
                        Mortal134(::core::primitive::u8),
                        #[codec(index = 135)]
                        Mortal135(::core::primitive::u8),
                        #[codec(index = 136)]
                        Mortal136(::core::primitive::u8),
                        #[codec(index = 137)]
                        Mortal137(::core::primitive::u8),
                        #[codec(index = 138)]
                        Mortal138(::core::primitive::u8),
                        #[codec(index = 139)]
                        Mortal139(::core::primitive::u8),
                        #[codec(index = 140)]
                        Mortal140(::core::primitive::u8),
                        #[codec(index = 141)]
                        Mortal141(::core::primitive::u8),
                        #[codec(index = 142)]
                        Mortal142(::core::primitive::u8),
                        #[codec(index = 143)]
                        Mortal143(::core::primitive::u8),
                        #[codec(index = 144)]
                        Mortal144(::core::primitive::u8),
                        #[codec(index = 145)]
                        Mortal145(::core::primitive::u8),
                        #[codec(index = 146)]
                        Mortal146(::core::primitive::u8),
                        #[codec(index = 147)]
                        Mortal147(::core::primitive::u8),
                        #[codec(index = 148)]
                        Mortal148(::core::primitive::u8),
                        #[codec(index = 149)]
                        Mortal149(::core::primitive::u8),
                        #[codec(index = 150)]
                        Mortal150(::core::primitive::u8),
                        #[codec(index = 151)]
                        Mortal151(::core::primitive::u8),
                        #[codec(index = 152)]
                        Mortal152(::core::primitive::u8),
                        #[codec(index = 153)]
                        Mortal153(::core::primitive::u8),
                        #[codec(index = 154)]
                        Mortal154(::core::primitive::u8),
                        #[codec(index = 155)]
                        Mortal155(::core::primitive::u8),
                        #[codec(index = 156)]
                        Mortal156(::core::primitive::u8),
                        #[codec(index = 157)]
                        Mortal157(::core::primitive::u8),
                        #[codec(index = 158)]
                        Mortal158(::core::primitive::u8),
                        #[codec(index = 159)]
                        Mortal159(::core::primitive::u8),
                        #[codec(index = 160)]
                        Mortal160(::core::primitive::u8),
                        #[codec(index = 161)]
                        Mortal161(::core::primitive::u8),
                        #[codec(index = 162)]
                        Mortal162(::core::primitive::u8),
                        #[codec(index = 163)]
                        Mortal163(::core::primitive::u8),
                        #[codec(index = 164)]
                        Mortal164(::core::primitive::u8),
                        #[codec(index = 165)]
                        Mortal165(::core::primitive::u8),
                        #[codec(index = 166)]
                        Mortal166(::core::primitive::u8),
                        #[codec(index = 167)]
                        Mortal167(::core::primitive::u8),
                        #[codec(index = 168)]
                        Mortal168(::core::primitive::u8),
                        #[codec(index = 169)]
                        Mortal169(::core::primitive::u8),
                        #[codec(index = 170)]
                        Mortal170(::core::primitive::u8),
                        #[codec(index = 171)]
                        Mortal171(::core::primitive::u8),
                        #[codec(index = 172)]
                        Mortal172(::core::primitive::u8),
                        #[codec(index = 173)]
                        Mortal173(::core::primitive::u8),
                        #[codec(index = 174)]
                        Mortal174(::core::primitive::u8),
                        #[codec(index = 175)]
                        Mortal175(::core::primitive::u8),
                        #[codec(index = 176)]
                        Mortal176(::core::primitive::u8),
                        #[codec(index = 177)]
                        Mortal177(::core::primitive::u8),
                        #[codec(index = 178)]
                        Mortal178(::core::primitive::u8),
                        #[codec(index = 179)]
                        Mortal179(::core::primitive::u8),
                        #[codec(index = 180)]
                        Mortal180(::core::primitive::u8),
                        #[codec(index = 181)]
                        Mortal181(::core::primitive::u8),
                        #[codec(index = 182)]
                        Mortal182(::core::primitive::u8),
                        #[codec(index = 183)]
                        Mortal183(::core::primitive::u8),
                        #[codec(index = 184)]
                        Mortal184(::core::primitive::u8),
                        #[codec(index = 185)]
                        Mortal185(::core::primitive::u8),
                        #[codec(index = 186)]
                        Mortal186(::core::primitive::u8),
                        #[codec(index = 187)]
                        Mortal187(::core::primitive::u8),
                        #[codec(index = 188)]
                        Mortal188(::core::primitive::u8),
                        #[codec(index = 189)]
                        Mortal189(::core::primitive::u8),
                        #[codec(index = 190)]
                        Mortal190(::core::primitive::u8),
                        #[codec(index = 191)]
                        Mortal191(::core::primitive::u8),
                        #[codec(index = 192)]
                        Mortal192(::core::primitive::u8),
                        #[codec(index = 193)]
                        Mortal193(::core::primitive::u8),
                        #[codec(index = 194)]
                        Mortal194(::core::primitive::u8),
                        #[codec(index = 195)]
                        Mortal195(::core::primitive::u8),
                        #[codec(index = 196)]
                        Mortal196(::core::primitive::u8),
                        #[codec(index = 197)]
                        Mortal197(::core::primitive::u8),
                        #[codec(index = 198)]
                        Mortal198(::core::primitive::u8),
                        #[codec(index = 199)]
                        Mortal199(::core::primitive::u8),
                        #[codec(index = 200)]
                        Mortal200(::core::primitive::u8),
                        #[codec(index = 201)]
                        Mortal201(::core::primitive::u8),
                        #[codec(index = 202)]
                        Mortal202(::core::primitive::u8),
                        #[codec(index = 203)]
                        Mortal203(::core::primitive::u8),
                        #[codec(index = 204)]
                        Mortal204(::core::primitive::u8),
                        #[codec(index = 205)]
                        Mortal205(::core::primitive::u8),
                        #[codec(index = 206)]
                        Mortal206(::core::primitive::u8),
                        #[codec(index = 207)]
                        Mortal207(::core::primitive::u8),
                        #[codec(index = 208)]
                        Mortal208(::core::primitive::u8),
                        #[codec(index = 209)]
                        Mortal209(::core::primitive::u8),
                        #[codec(index = 210)]
                        Mortal210(::core::primitive::u8),
                        #[codec(index = 211)]
                        Mortal211(::core::primitive::u8),
                        #[codec(index = 212)]
                        Mortal212(::core::primitive::u8),
                        #[codec(index = 213)]
                        Mortal213(::core::primitive::u8),
                        #[codec(index = 214)]
                        Mortal214(::core::primitive::u8),
                        #[codec(index = 215)]
                        Mortal215(::core::primitive::u8),
                        #[codec(index = 216)]
                        Mortal216(::core::primitive::u8),
                        #[codec(index = 217)]
                        Mortal217(::core::primitive::u8),
                        #[codec(index = 218)]
                        Mortal218(::core::primitive::u8),
                        #[codec(index = 219)]
                        Mortal219(::core::primitive::u8),
                        #[codec(index = 220)]
                        Mortal220(::core::primitive::u8),
                        #[codec(index = 221)]
                        Mortal221(::core::primitive::u8),
                        #[codec(index = 222)]
                        Mortal222(::core::primitive::u8),
                        #[codec(index = 223)]
                        Mortal223(::core::primitive::u8),
                        #[codec(index = 224)]
                        Mortal224(::core::primitive::u8),
                        #[codec(index = 225)]
                        Mortal225(::core::primitive::u8),
                        #[codec(index = 226)]
                        Mortal226(::core::primitive::u8),
                        #[codec(index = 227)]
                        Mortal227(::core::primitive::u8),
                        #[codec(index = 228)]
                        Mortal228(::core::primitive::u8),
                        #[codec(index = 229)]
                        Mortal229(::core::primitive::u8),
                        #[codec(index = 230)]
                        Mortal230(::core::primitive::u8),
                        #[codec(index = 231)]
                        Mortal231(::core::primitive::u8),
                        #[codec(index = 232)]
                        Mortal232(::core::primitive::u8),
                        #[codec(index = 233)]
                        Mortal233(::core::primitive::u8),
                        #[codec(index = 234)]
                        Mortal234(::core::primitive::u8),
                        #[codec(index = 235)]
                        Mortal235(::core::primitive::u8),
                        #[codec(index = 236)]
                        Mortal236(::core::primitive::u8),
                        #[codec(index = 237)]
                        Mortal237(::core::primitive::u8),
                        #[codec(index = 238)]
                        Mortal238(::core::primitive::u8),
                        #[codec(index = 239)]
                        Mortal239(::core::primitive::u8),
                        #[codec(index = 240)]
                        Mortal240(::core::primitive::u8),
                        #[codec(index = 241)]
                        Mortal241(::core::primitive::u8),
                        #[codec(index = 242)]
                        Mortal242(::core::primitive::u8),
                        #[codec(index = 243)]
                        Mortal243(::core::primitive::u8),
                        #[codec(index = 244)]
                        Mortal244(::core::primitive::u8),
                        #[codec(index = 245)]
                        Mortal245(::core::primitive::u8),
                        #[codec(index = 246)]
                        Mortal246(::core::primitive::u8),
                        #[codec(index = 247)]
                        Mortal247(::core::primitive::u8),
                        #[codec(index = 248)]
                        Mortal248(::core::primitive::u8),
                        #[codec(index = 249)]
                        Mortal249(::core::primitive::u8),
                        #[codec(index = 250)]
                        Mortal250(::core::primitive::u8),
                        #[codec(index = 251)]
                        Mortal251(::core::primitive::u8),
                        #[codec(index = 252)]
                        Mortal252(::core::primitive::u8),
                        #[codec(index = 253)]
                        Mortal253(::core::primitive::u8),
                        #[codec(index = 254)]
                        Mortal254(::core::primitive::u8),
                        #[codec(index = 255)]
                        Mortal255(::core::primitive::u8),
                    }
                }
                pub mod unchecked_extrinsic {
                    use super::runtime_types;
                    #[derive(
                        ::subxt::ext::codec::Decode,
                        ::subxt::ext::codec::Encode,
                        ::subxt::ext::scale_decode::DecodeAsType,
                        ::subxt::ext::scale_encode::EncodeAsType,
                        Clone,
                        Debug,
                        Eq,
                        PartialEq
                    )]
                    #[codec(crate = ::subxt::ext::codec)]
                    #[decode_as_type(crate_path = ":: subxt :: ext :: scale_decode")]
                    #[encode_as_type(crate_path = ":: subxt :: ext :: scale_encode")]
                    pub struct UncheckedExtrinsic<_0, _1, _2, _3>(
                        pub ::std::vec::Vec<::core::primitive::u8>,
                        #[codec(skip)]
                        pub ::core::marker::PhantomData<(_1, _0, _2, _3)>,
                    );
                }
            }
            #[derive(
                ::subxt::ext::codec::Decode,
                ::subxt::ext::codec::Encode,
                ::subxt::ext::scale_decode::DecodeAsType,
                ::subxt::ext::scale_encode::EncodeAsType,
                Clone,
                Debug,
                Eq,
                PartialEq
            )]
            #[codec(crate = ::subxt::ext::codec)]
            #[decode_as_type(crate_path = ":: subxt :: ext :: scale_decode")]
            #[encode_as_type(crate_path = ":: subxt :: ext :: scale_encode")]
            pub enum DispatchError {
                #[codec(index = 0)]
                Other,
                #[codec(index = 1)]
                CannotLookup,
                #[codec(index = 2)]
                BadOrigin,
                #[codec(index = 3)]
                Module(runtime_types::sp_runtime::ModuleError),
                #[codec(index = 4)]
                ConsumerRemaining,
                #[codec(index = 5)]
                NoProviders,
                #[codec(index = 6)]
                TooManyConsumers,
                #[codec(index = 7)]
                Token(runtime_types::sp_runtime::TokenError),
                #[codec(index = 8)]
                Arithmetic(runtime_types::sp_arithmetic::ArithmeticError),
                #[codec(index = 9)]
                Transactional(runtime_types::sp_runtime::TransactionalError),
                #[codec(index = 10)]
                Exhausted,
                #[codec(index = 11)]
                Corruption,
                #[codec(index = 12)]
                Unavailable,
                #[codec(index = 13)]
                RootNotAllowed,
            }
            #[derive(
                ::subxt::ext::codec::Decode,
                ::subxt::ext::codec::Encode,
                ::subxt::ext::scale_decode::DecodeAsType,
                ::subxt::ext::scale_encode::EncodeAsType,
                Clone,
                Debug,
                Eq,
                PartialEq
            )]
            #[codec(crate = ::subxt::ext::codec)]
            #[decode_as_type(crate_path = ":: subxt :: ext :: scale_decode")]
            #[encode_as_type(crate_path = ":: subxt :: ext :: scale_encode")]
            pub struct ModuleError {
                pub index: ::core::primitive::u8,
                pub error: [::core::primitive::u8; 4usize],
            }
            #[derive(
                ::subxt::ext::codec::Decode,
                ::subxt::ext::codec::Encode,
                ::subxt::ext::scale_decode::DecodeAsType,
                ::subxt::ext::scale_encode::EncodeAsType,
                Clone,
                Debug,
                Eq,
                PartialEq
            )]
            #[codec(crate = ::subxt::ext::codec)]
            #[decode_as_type(crate_path = ":: subxt :: ext :: scale_decode")]
            #[encode_as_type(crate_path = ":: subxt :: ext :: scale_encode")]
            pub enum MultiSignature {
                #[codec(index = 0)]
                Ed25519(runtime_types::sp_core::ed25519::Signature),
                #[codec(index = 1)]
                Sr25519(runtime_types::sp_core::sr25519::Signature),
                #[codec(index = 2)]
                Ecdsa(runtime_types::sp_core::ecdsa::Signature),
            }
            #[derive(
                ::subxt::ext::codec::Decode,
                ::subxt::ext::codec::Encode,
                ::subxt::ext::scale_decode::DecodeAsType,
                ::subxt::ext::scale_encode::EncodeAsType,
                Clone,
                Debug,
                Eq,
                PartialEq
            )]
            #[codec(crate = ::subxt::ext::codec)]
            #[decode_as_type(crate_path = ":: subxt :: ext :: scale_decode")]
            #[encode_as_type(crate_path = ":: subxt :: ext :: scale_encode")]
            pub enum TokenError {
                #[codec(index = 0)]
                FundsUnavailable,
                #[codec(index = 1)]
                OnlyProvider,
                #[codec(index = 2)]
                BelowMinimum,
                #[codec(index = 3)]
                CannotCreate,
                #[codec(index = 4)]
                UnknownAsset,
                #[codec(index = 5)]
                Frozen,
                #[codec(index = 6)]
                Unsupported,
                #[codec(index = 7)]
                CannotCreateHold,
                #[codec(index = 8)]
                NotExpendable,
                #[codec(index = 9)]
                Blocked,
            }
            #[derive(
                ::subxt::ext::codec::Decode,
                ::subxt::ext::codec::Encode,
                ::subxt::ext::scale_decode::DecodeAsType,
                ::subxt::ext::scale_encode::EncodeAsType,
                Clone,
                Debug,
                Eq,
                PartialEq
            )]
            #[codec(crate = ::subxt::ext::codec)]
            #[decode_as_type(crate_path = ":: subxt :: ext :: scale_decode")]
            #[encode_as_type(crate_path = ":: subxt :: ext :: scale_encode")]
            pub enum TransactionalError {
                #[codec(index = 0)]
                LimitReached,
                #[codec(index = 1)]
                NoLayer,
            }
        }
        pub mod sp_staking {
            use super::runtime_types;
            pub mod offence {
                use super::runtime_types;
                #[derive(
                    ::subxt::ext::codec::Decode,
                    ::subxt::ext::codec::Encode,
                    ::subxt::ext::scale_decode::DecodeAsType,
                    ::subxt::ext::scale_encode::EncodeAsType,
                    Clone,
                    Debug,
                    Eq,
                    PartialEq
                )]
                #[codec(crate = ::subxt::ext::codec)]
                #[decode_as_type(crate_path = ":: subxt :: ext :: scale_decode")]
                #[encode_as_type(crate_path = ":: subxt :: ext :: scale_encode")]
                pub struct OffenceDetails<_0, _1> {
                    pub offender: _1,
                    pub reporters: ::std::vec::Vec<_0>,
                }
            }
        }
        pub mod sp_version {
            use super::runtime_types;
            #[derive(
                ::subxt::ext::codec::Decode,
                ::subxt::ext::codec::Encode,
                ::subxt::ext::scale_decode::DecodeAsType,
                ::subxt::ext::scale_encode::EncodeAsType,
                Clone,
                Debug,
                Eq,
                PartialEq
            )]
            #[codec(crate = ::subxt::ext::codec)]
            #[decode_as_type(crate_path = ":: subxt :: ext :: scale_decode")]
            #[encode_as_type(crate_path = ":: subxt :: ext :: scale_encode")]
            pub struct RuntimeVersion {
                pub spec_name: ::std::string::String,
                pub impl_name: ::std::string::String,
                pub authoring_version: ::core::primitive::u32,
                pub spec_version: ::core::primitive::u32,
                pub impl_version: ::core::primitive::u32,
                pub apis: ::std::vec::Vec<
                    ([::core::primitive::u8; 8usize], ::core::primitive::u32),
                >,
                pub transaction_version: ::core::primitive::u32,
                pub state_version: ::core::primitive::u8,
            }
        }
        pub mod sp_weights {
            use super::runtime_types;
            pub mod weight_v2 {
                use super::runtime_types;
                #[derive(
                    ::subxt::ext::codec::Decode,
                    ::subxt::ext::codec::Encode,
                    ::subxt::ext::scale_decode::DecodeAsType,
                    ::subxt::ext::scale_encode::EncodeAsType,
                    Clone,
                    Debug,
                    Eq,
                    PartialEq
                )]
                #[codec(crate = ::subxt::ext::codec)]
                #[decode_as_type(crate_path = ":: subxt :: ext :: scale_decode")]
                #[encode_as_type(crate_path = ":: subxt :: ext :: scale_encode")]
                pub struct Weight {
                    #[codec(compact)]
                    pub ref_time: ::core::primitive::u64,
                    #[codec(compact)]
                    pub proof_size: ::core::primitive::u64,
                }
            }
            #[derive(
                ::subxt::ext::codec::Decode,
                ::subxt::ext::codec::Encode,
                ::subxt::ext::scale_decode::DecodeAsType,
                ::subxt::ext::scale_encode::EncodeAsType,
                Clone,
                Debug,
                Eq,
                PartialEq
            )]
            #[codec(crate = ::subxt::ext::codec)]
            #[decode_as_type(crate_path = ":: subxt :: ext :: scale_decode")]
            #[encode_as_type(crate_path = ":: subxt :: ext :: scale_encode")]
            pub struct RuntimeDbWeight {
                pub read: ::core::primitive::u64,
                pub write: ::core::primitive::u64,
            }
        }
        pub mod tangle_standalone_runtime {
            use super::runtime_types;
            pub mod opaque {
                use super::runtime_types;
                #[derive(
                    ::subxt::ext::codec::Decode,
                    ::subxt::ext::codec::Encode,
                    ::subxt::ext::scale_decode::DecodeAsType,
                    ::subxt::ext::scale_encode::EncodeAsType,
                    Clone,
                    Debug,
                    Eq,
                    PartialEq
                )]
                #[codec(crate = ::subxt::ext::codec)]
                #[decode_as_type(crate_path = ":: subxt :: ext :: scale_decode")]
                #[encode_as_type(crate_path = ":: subxt :: ext :: scale_encode")]
                pub struct SessionKeys {
                    pub aura: runtime_types::sp_consensus_aura::sr25519::app_sr25519::Public,
                    pub grandpa: runtime_types::sp_consensus_grandpa::app::Public,
                    pub im_online: runtime_types::pallet_im_online::sr25519::app_sr25519::Public,
                    pub dkg: runtime_types::dkg_runtime_primitives::crypto::Public,
                }
            }
            #[derive(
                ::subxt::ext::codec::Decode,
                ::subxt::ext::codec::Encode,
                ::subxt::ext::scale_decode::DecodeAsType,
                ::subxt::ext::scale_encode::EncodeAsType,
                Clone,
                Debug,
                Eq,
                PartialEq
            )]
            #[codec(crate = ::subxt::ext::codec)]
            #[decode_as_type(crate_path = ":: subxt :: ext :: scale_decode")]
            #[encode_as_type(crate_path = ":: subxt :: ext :: scale_encode")]
            pub struct MaxVotes;
            #[derive(
                ::subxt::ext::codec::Decode,
                ::subxt::ext::codec::Encode,
                ::subxt::ext::scale_decode::DecodeAsType,
                ::subxt::ext::scale_encode::EncodeAsType,
                Clone,
                Debug,
                Eq,
                PartialEq
            )]
            #[codec(crate = ::subxt::ext::codec)]
            #[decode_as_type(crate_path = ":: subxt :: ext :: scale_decode")]
            #[encode_as_type(crate_path = ":: subxt :: ext :: scale_encode")]
            pub struct NposSolution16 {
                pub votes1: ::std::vec::Vec<
                    (
                        ::subxt::ext::codec::Compact<::core::primitive::u32>,
                        ::subxt::ext::codec::Compact<::core::primitive::u16>,
                    ),
                >,
                pub votes2: ::std::vec::Vec<
                    (
                        ::subxt::ext::codec::Compact<::core::primitive::u32>,
                        (
                            ::subxt::ext::codec::Compact<::core::primitive::u16>,
                            ::subxt::ext::codec::Compact<
                                runtime_types::sp_arithmetic::per_things::PerU16,
                            >,
                        ),
                        ::subxt::ext::codec::Compact<::core::primitive::u16>,
                    ),
                >,
                pub votes3: ::std::vec::Vec<
                    (
                        ::subxt::ext::codec::Compact<::core::primitive::u32>,
                        [(
                            ::subxt::ext::codec::Compact<::core::primitive::u16>,
                            ::subxt::ext::codec::Compact<
                                runtime_types::sp_arithmetic::per_things::PerU16,
                            >,
                        ); 2usize],
                        ::subxt::ext::codec::Compact<::core::primitive::u16>,
                    ),
                >,
                pub votes4: ::std::vec::Vec<
                    (
                        ::subxt::ext::codec::Compact<::core::primitive::u32>,
                        [(
                            ::subxt::ext::codec::Compact<::core::primitive::u16>,
                            ::subxt::ext::codec::Compact<
                                runtime_types::sp_arithmetic::per_things::PerU16,
                            >,
                        ); 3usize],
                        ::subxt::ext::codec::Compact<::core::primitive::u16>,
                    ),
                >,
                pub votes5: ::std::vec::Vec<
                    (
                        ::subxt::ext::codec::Compact<::core::primitive::u32>,
                        [(
                            ::subxt::ext::codec::Compact<::core::primitive::u16>,
                            ::subxt::ext::codec::Compact<
                                runtime_types::sp_arithmetic::per_things::PerU16,
                            >,
                        ); 4usize],
                        ::subxt::ext::codec::Compact<::core::primitive::u16>,
                    ),
                >,
                pub votes6: ::std::vec::Vec<
                    (
                        ::subxt::ext::codec::Compact<::core::primitive::u32>,
                        [(
                            ::subxt::ext::codec::Compact<::core::primitive::u16>,
                            ::subxt::ext::codec::Compact<
                                runtime_types::sp_arithmetic::per_things::PerU16,
                            >,
                        ); 5usize],
                        ::subxt::ext::codec::Compact<::core::primitive::u16>,
                    ),
                >,
                pub votes7: ::std::vec::Vec<
                    (
                        ::subxt::ext::codec::Compact<::core::primitive::u32>,
                        [(
                            ::subxt::ext::codec::Compact<::core::primitive::u16>,
                            ::subxt::ext::codec::Compact<
                                runtime_types::sp_arithmetic::per_things::PerU16,
                            >,
                        ); 6usize],
                        ::subxt::ext::codec::Compact<::core::primitive::u16>,
                    ),
                >,
                pub votes8: ::std::vec::Vec<
                    (
                        ::subxt::ext::codec::Compact<::core::primitive::u32>,
                        [(
                            ::subxt::ext::codec::Compact<::core::primitive::u16>,
                            ::subxt::ext::codec::Compact<
                                runtime_types::sp_arithmetic::per_things::PerU16,
                            >,
                        ); 7usize],
                        ::subxt::ext::codec::Compact<::core::primitive::u16>,
                    ),
                >,
                pub votes9: ::std::vec::Vec<
                    (
                        ::subxt::ext::codec::Compact<::core::primitive::u32>,
                        [(
                            ::subxt::ext::codec::Compact<::core::primitive::u16>,
                            ::subxt::ext::codec::Compact<
                                runtime_types::sp_arithmetic::per_things::PerU16,
                            >,
                        ); 8usize],
                        ::subxt::ext::codec::Compact<::core::primitive::u16>,
                    ),
                >,
                pub votes10: ::std::vec::Vec<
                    (
                        ::subxt::ext::codec::Compact<::core::primitive::u32>,
                        [(
                            ::subxt::ext::codec::Compact<::core::primitive::u16>,
                            ::subxt::ext::codec::Compact<
                                runtime_types::sp_arithmetic::per_things::PerU16,
                            >,
                        ); 9usize],
                        ::subxt::ext::codec::Compact<::core::primitive::u16>,
                    ),
                >,
                pub votes11: ::std::vec::Vec<
                    (
                        ::subxt::ext::codec::Compact<::core::primitive::u32>,
                        [(
                            ::subxt::ext::codec::Compact<::core::primitive::u16>,
                            ::subxt::ext::codec::Compact<
                                runtime_types::sp_arithmetic::per_things::PerU16,
                            >,
                        ); 10usize],
                        ::subxt::ext::codec::Compact<::core::primitive::u16>,
                    ),
                >,
                pub votes12: ::std::vec::Vec<
                    (
                        ::subxt::ext::codec::Compact<::core::primitive::u32>,
                        [(
                            ::subxt::ext::codec::Compact<::core::primitive::u16>,
                            ::subxt::ext::codec::Compact<
                                runtime_types::sp_arithmetic::per_things::PerU16,
                            >,
                        ); 11usize],
                        ::subxt::ext::codec::Compact<::core::primitive::u16>,
                    ),
                >,
                pub votes13: ::std::vec::Vec<
                    (
                        ::subxt::ext::codec::Compact<::core::primitive::u32>,
                        [(
                            ::subxt::ext::codec::Compact<::core::primitive::u16>,
                            ::subxt::ext::codec::Compact<
                                runtime_types::sp_arithmetic::per_things::PerU16,
                            >,
                        ); 12usize],
                        ::subxt::ext::codec::Compact<::core::primitive::u16>,
                    ),
                >,
                pub votes14: ::std::vec::Vec<
                    (
                        ::subxt::ext::codec::Compact<::core::primitive::u32>,
                        [(
                            ::subxt::ext::codec::Compact<::core::primitive::u16>,
                            ::subxt::ext::codec::Compact<
                                runtime_types::sp_arithmetic::per_things::PerU16,
                            >,
                        ); 13usize],
                        ::subxt::ext::codec::Compact<::core::primitive::u16>,
                    ),
                >,
                pub votes15: ::std::vec::Vec<
                    (
                        ::subxt::ext::codec::Compact<::core::primitive::u32>,
                        [(
                            ::subxt::ext::codec::Compact<::core::primitive::u16>,
                            ::subxt::ext::codec::Compact<
                                runtime_types::sp_arithmetic::per_things::PerU16,
                            >,
                        ); 14usize],
                        ::subxt::ext::codec::Compact<::core::primitive::u16>,
                    ),
                >,
                pub votes16: ::std::vec::Vec<
                    (
                        ::subxt::ext::codec::Compact<::core::primitive::u32>,
                        [(
                            ::subxt::ext::codec::Compact<::core::primitive::u16>,
                            ::subxt::ext::codec::Compact<
                                runtime_types::sp_arithmetic::per_things::PerU16,
                            >,
                        ); 15usize],
                        ::subxt::ext::codec::Compact<::core::primitive::u16>,
                    ),
                >,
            }
            #[derive(
                ::subxt::ext::codec::Decode,
                ::subxt::ext::codec::Encode,
                ::subxt::ext::scale_decode::DecodeAsType,
                ::subxt::ext::scale_encode::EncodeAsType,
                Clone,
                Debug,
                Eq,
                PartialEq
            )]
            #[codec(crate = ::subxt::ext::codec)]
            #[decode_as_type(crate_path = ":: subxt :: ext :: scale_decode")]
            #[encode_as_type(crate_path = ":: subxt :: ext :: scale_encode")]
            pub enum OriginCaller {
                #[codec(index = 0)]
                system(
                    runtime_types::frame_support::dispatch::RawOrigin<
                        ::subxt::utils::AccountId32,
                    >,
                ),
                #[codec(index = 15)]
                Council(
                    runtime_types::pallet_collective::RawOrigin<
                        ::subxt::utils::AccountId32,
                    >,
                ),
                #[codec(index = 35)]
                Ethereum(runtime_types::pallet_ethereum::RawOrigin),
                #[codec(index = 3)]
                Void(runtime_types::sp_core::Void),
            }
            #[derive(
                ::subxt::ext::codec::Decode,
                ::subxt::ext::codec::Encode,
                ::subxt::ext::scale_decode::DecodeAsType,
                ::subxt::ext::scale_encode::EncodeAsType,
                Clone,
                Debug,
                Eq,
                PartialEq
            )]
            #[codec(crate = ::subxt::ext::codec)]
            #[decode_as_type(crate_path = ":: subxt :: ext :: scale_decode")]
            #[encode_as_type(crate_path = ":: subxt :: ext :: scale_encode")]
            pub struct Runtime;
            #[derive(
                ::subxt::ext::codec::Decode,
                ::subxt::ext::codec::Encode,
                ::subxt::ext::scale_decode::DecodeAsType,
                ::subxt::ext::scale_encode::EncodeAsType,
                Clone,
                Debug,
                Eq,
                PartialEq
            )]
            #[codec(crate = ::subxt::ext::codec)]
            #[decode_as_type(crate_path = ":: subxt :: ext :: scale_decode")]
            #[encode_as_type(crate_path = ":: subxt :: ext :: scale_encode")]
            pub enum RuntimeCall {
                #[codec(index = 0)]
                System(runtime_types::frame_system::pallet::Call),
                #[codec(index = 1)]
                Timestamp(runtime_types::pallet_timestamp::pallet::Call),
                #[codec(index = 2)]
                Sudo(runtime_types::pallet_sudo::pallet::Call),
                #[codec(index = 4)]
                Balances(runtime_types::pallet_balances::pallet::Call),
                #[codec(index = 8)]
                Grandpa(runtime_types::pallet_grandpa::pallet::Call),
                #[codec(index = 9)]
                DKG(runtime_types::pallet_dkg_metadata::pallet::Call),
                #[codec(index = 10)]
                DKGProposals(runtime_types::pallet_dkg_proposals::pallet::Call),
                #[codec(index = 11)]
                DKGProposalHandler(
                    runtime_types::pallet_dkg_proposal_handler::pallet::Call,
                ),
                #[codec(index = 12)]
                BridgeRegistry(runtime_types::pallet_bridge_registry::pallet::Call),
                #[codec(index = 13)]
                Indices(runtime_types::pallet_indices::pallet::Call),
                #[codec(index = 14)]
                Democracy(runtime_types::pallet_democracy::pallet::Call),
                #[codec(index = 15)]
                Council(runtime_types::pallet_collective::pallet::Call),
                #[codec(index = 16)]
                Vesting(runtime_types::pallet_vesting::pallet::Call),
                #[codec(index = 17)]
                Claims(runtime_types::pallet_ecdsa_claims::pallet::Call),
                #[codec(index = 18)]
                Elections(runtime_types::pallet_elections_phragmen::pallet::Call),
                #[codec(index = 19)]
                ElectionProviderMultiPhase(
                    runtime_types::pallet_election_provider_multi_phase::pallet::Call,
                ),
                #[codec(index = 20)]
                Staking(runtime_types::pallet_staking::pallet::pallet::Call),
                #[codec(index = 21)]
                Session(runtime_types::pallet_session::pallet::Call),
                #[codec(index = 23)]
                Treasury(runtime_types::pallet_treasury::pallet::Call),
                #[codec(index = 24)]
                Bounties(runtime_types::pallet_bounties::pallet::Call),
                #[codec(index = 25)]
                ChildBounties(runtime_types::pallet_child_bounties::pallet::Call),
                #[codec(index = 26)]
                BagsList(runtime_types::pallet_bags_list::pallet::Call),
                #[codec(index = 27)]
                NominationPools(runtime_types::pallet_nomination_pools::pallet::Call),
                #[codec(index = 28)]
                Scheduler(runtime_types::pallet_scheduler::pallet::Call),
                #[codec(index = 29)]
                Preimage(runtime_types::pallet_preimage::pallet::Call),
                #[codec(index = 31)]
                TransactionPause(runtime_types::pallet_transaction_pause::module::Call),
                #[codec(index = 32)]
                ImOnline(runtime_types::pallet_im_online::pallet::Call),
                #[codec(index = 33)]
                Identity(runtime_types::pallet_identity::pallet::Call),
                #[codec(index = 34)]
                Utility(runtime_types::pallet_utility::pallet::Call),
                #[codec(index = 35)]
                Ethereum(runtime_types::pallet_ethereum::pallet::Call),
                #[codec(index = 36)]
                EVM(runtime_types::pallet_evm::pallet::Call),
                #[codec(index = 38)]
                DynamicFee(runtime_types::pallet_dynamic_fee::pallet::Call),
                #[codec(index = 39)]
                BaseFee(runtime_types::pallet_base_fee::pallet::Call),
                #[codec(index = 40)]
                HotfixSufficients(
                    runtime_types::pallet_hotfix_sufficients::pallet::Call,
                ),
                #[codec(index = 41)]
                Eth2Client(runtime_types::pallet_eth2_light_client::pallet::Call),
            }
            #[derive(
                ::subxt::ext::codec::Decode,
                ::subxt::ext::codec::Encode,
                ::subxt::ext::scale_decode::DecodeAsType,
                ::subxt::ext::scale_encode::EncodeAsType,
                Clone,
                Debug,
                Eq,
                PartialEq
            )]
            #[codec(crate = ::subxt::ext::codec)]
            #[decode_as_type(crate_path = ":: subxt :: ext :: scale_decode")]
            #[encode_as_type(crate_path = ":: subxt :: ext :: scale_encode")]
            pub enum RuntimeEvent {
                #[codec(index = 0)]
                System(runtime_types::frame_system::pallet::Event),
                #[codec(index = 2)]
                Sudo(runtime_types::pallet_sudo::pallet::Event),
                #[codec(index = 4)]
                Balances(runtime_types::pallet_balances::pallet::Event),
                #[codec(index = 5)]
                TransactionPayment(
                    runtime_types::pallet_transaction_payment::pallet::Event,
                ),
                #[codec(index = 8)]
                Grandpa(runtime_types::pallet_grandpa::pallet::Event),
                #[codec(index = 9)]
                DKG(runtime_types::pallet_dkg_metadata::pallet::Event),
                #[codec(index = 10)]
                DKGProposals(runtime_types::pallet_dkg_proposals::pallet::Event),
                #[codec(index = 11)]
                DKGProposalHandler(
                    runtime_types::pallet_dkg_proposal_handler::pallet::Event,
                ),
                #[codec(index = 12)]
                BridgeRegistry(runtime_types::pallet_bridge_registry::pallet::Event),
                #[codec(index = 13)]
                Indices(runtime_types::pallet_indices::pallet::Event),
                #[codec(index = 14)]
                Democracy(runtime_types::pallet_democracy::pallet::Event),
                #[codec(index = 15)]
                Council(runtime_types::pallet_collective::pallet::Event),
                #[codec(index = 16)]
                Vesting(runtime_types::pallet_vesting::pallet::Event),
                #[codec(index = 17)]
                Claims(runtime_types::pallet_ecdsa_claims::pallet::Event),
                #[codec(index = 18)]
                Elections(runtime_types::pallet_elections_phragmen::pallet::Event),
                #[codec(index = 19)]
                ElectionProviderMultiPhase(
                    runtime_types::pallet_election_provider_multi_phase::pallet::Event,
                ),
                #[codec(index = 20)]
                Staking(runtime_types::pallet_staking::pallet::pallet::Event),
                #[codec(index = 21)]
                Session(runtime_types::pallet_session::pallet::Event),
                #[codec(index = 23)]
                Treasury(runtime_types::pallet_treasury::pallet::Event),
                #[codec(index = 24)]
                Bounties(runtime_types::pallet_bounties::pallet::Event),
                #[codec(index = 25)]
                ChildBounties(runtime_types::pallet_child_bounties::pallet::Event),
                #[codec(index = 26)]
                BagsList(runtime_types::pallet_bags_list::pallet::Event),
                #[codec(index = 27)]
                NominationPools(runtime_types::pallet_nomination_pools::pallet::Event),
                #[codec(index = 28)]
                Scheduler(runtime_types::pallet_scheduler::pallet::Event),
                #[codec(index = 29)]
                Preimage(runtime_types::pallet_preimage::pallet::Event),
                #[codec(index = 30)]
                Offences(runtime_types::pallet_offences::pallet::Event),
                #[codec(index = 31)]
                TransactionPause(runtime_types::pallet_transaction_pause::module::Event),
                #[codec(index = 32)]
                ImOnline(runtime_types::pallet_im_online::pallet::Event),
                #[codec(index = 33)]
                Identity(runtime_types::pallet_identity::pallet::Event),
                #[codec(index = 34)]
                Utility(runtime_types::pallet_utility::pallet::Event),
                #[codec(index = 35)]
                Ethereum(runtime_types::pallet_ethereum::pallet::Event),
                #[codec(index = 36)]
                EVM(runtime_types::pallet_evm::pallet::Event),
                #[codec(index = 39)]
                BaseFee(runtime_types::pallet_base_fee::pallet::Event),
                #[codec(index = 41)]
                Eth2Client(runtime_types::pallet_eth2_light_client::pallet::Event),
            }
        }
        pub mod webb_proposals {
            use super::runtime_types;
            pub mod header {
                use super::runtime_types;
                #[derive(
                    ::subxt::ext::codec::Decode,
                    ::subxt::ext::codec::Encode,
                    ::subxt::ext::scale_decode::DecodeAsType,
                    ::subxt::ext::scale_encode::EncodeAsType,
                    Clone,
                    Debug,
                    Eq,
                    PartialEq
                )]
                #[codec(crate = ::subxt::ext::codec)]
                #[decode_as_type(crate_path = ":: subxt :: ext :: scale_decode")]
                #[encode_as_type(crate_path = ":: subxt :: ext :: scale_encode")]
                pub struct ResourceId(pub [::core::primitive::u8; 32usize]);
                #[derive(
                    ::subxt::ext::codec::Decode,
                    ::subxt::ext::codec::Encode,
                    ::subxt::ext::scale_decode::DecodeAsType,
                    ::subxt::ext::scale_encode::EncodeAsType,
                    Clone,
                    Debug,
                    Eq,
                    PartialEq
                )]
                #[codec(crate = ::subxt::ext::codec)]
                #[decode_as_type(crate_path = ":: subxt :: ext :: scale_decode")]
                #[encode_as_type(crate_path = ":: subxt :: ext :: scale_encode")]
                pub enum TypedChainId {
                    #[codec(index = 0)]
                    None,
                    #[codec(index = 1)]
                    Evm(::core::primitive::u32),
                    #[codec(index = 2)]
                    Substrate(::core::primitive::u32),
                    #[codec(index = 3)]
                    PolkadotParachain(::core::primitive::u32),
                    #[codec(index = 4)]
                    KusamaParachain(::core::primitive::u32),
                    #[codec(index = 5)]
                    RococoParachain(::core::primitive::u32),
                    #[codec(index = 6)]
                    Cosmos(::core::primitive::u32),
                    #[codec(index = 7)]
                    Solana(::core::primitive::u32),
                    #[codec(index = 8)]
                    Ink(::core::primitive::u32),
                }
            }
            pub mod nonce {
                use super::runtime_types;
                #[derive(
                    ::subxt::ext::codec::CompactAs,
                    ::subxt::ext::codec::Decode,
                    ::subxt::ext::codec::Encode,
                    ::subxt::ext::scale_decode::DecodeAsType,
                    ::subxt::ext::scale_encode::EncodeAsType,
                    Clone,
                    Debug,
                    Eq,
                    PartialEq
                )]
                #[codec(crate = ::subxt::ext::codec)]
                #[decode_as_type(crate_path = ":: subxt :: ext :: scale_decode")]
                #[encode_as_type(crate_path = ":: subxt :: ext :: scale_encode")]
                pub struct Nonce(pub ::core::primitive::u32);
            }
            pub mod proposal {
                use super::runtime_types;
                #[derive(
                    ::subxt::ext::codec::Decode,
                    ::subxt::ext::codec::Encode,
                    ::subxt::ext::scale_decode::DecodeAsType,
                    ::subxt::ext::scale_encode::EncodeAsType,
                    Clone,
                    Debug,
                    Eq,
                    PartialEq
                )]
                #[codec(crate = ::subxt::ext::codec)]
                #[decode_as_type(crate_path = ":: subxt :: ext :: scale_decode")]
                #[encode_as_type(crate_path = ":: subxt :: ext :: scale_encode")]
                pub enum Proposal<_0> {
                    #[codec(index = 0)]
                    Signed {
                        kind: runtime_types::webb_proposals::proposal::ProposalKind,
                        data: runtime_types::bounded_collections::bounded_vec::BoundedVec<
                            ::core::primitive::u8,
                        >,
                        signature: runtime_types::bounded_collections::bounded_vec::BoundedVec<
                            ::core::primitive::u8,
                        >,
                    },
                    #[codec(index = 1)]
                    Unsigned {
                        kind: runtime_types::webb_proposals::proposal::ProposalKind,
                        data: runtime_types::bounded_collections::bounded_vec::BoundedVec<
                            ::core::primitive::u8,
                        >,
                    },
                    __Ignore(::core::marker::PhantomData<_0>),
                }
                #[derive(
                    ::subxt::ext::codec::Decode,
                    ::subxt::ext::codec::Encode,
                    ::subxt::ext::scale_decode::DecodeAsType,
                    ::subxt::ext::scale_encode::EncodeAsType,
                    Clone,
                    Debug,
                    Eq,
                    PartialEq
                )]
                #[codec(crate = ::subxt::ext::codec)]
                #[decode_as_type(crate_path = ":: subxt :: ext :: scale_decode")]
                #[encode_as_type(crate_path = ":: subxt :: ext :: scale_encode")]
                pub enum ProposalKind {
                    #[codec(index = 0)]
                    Refresh,
                    #[codec(index = 1)]
                    ProposerSetUpdate,
                    #[codec(index = 2)]
                    EVM,
                    #[codec(index = 3)]
                    AnchorCreate,
                    #[codec(index = 4)]
                    AnchorUpdate,
                    #[codec(index = 5)]
                    TokenAdd,
                    #[codec(index = 6)]
                    TokenRemove,
                    #[codec(index = 7)]
                    WrappingFeeUpdate,
                    #[codec(index = 8)]
                    ResourceIdUpdate,
                    #[codec(index = 9)]
                    RescueTokens,
                    #[codec(index = 10)]
                    MaxDepositLimitUpdate,
                    #[codec(index = 11)]
                    MinWithdrawalLimitUpdate,
                    #[codec(index = 12)]
                    SetVerifier,
                    #[codec(index = 13)]
                    SetTreasuryHandler,
                    #[codec(index = 14)]
                    FeeRecipientUpdate,
                }
            }
        }
    }
}
