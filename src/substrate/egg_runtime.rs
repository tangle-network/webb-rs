# [allow (dead_code , unused_imports , non_camel_case_types)] pub mod api { use super :: api as root_mod ; pub static PALLETS : [& str ; 43usize] = ["System" , "Timestamp" , "Sudo" , "RandomnessCollectiveFlip" , "Balances" , "TransactionPayment" , "Authorship" , "Aura" , "Grandpa" , "Indices" , "Democracy" , "Council" , "Elections" , "ElectionProviderMultiPhase" , "Staking" , "Session" , "Historical" , "Treasury" , "Bounties" , "ChildBounties" , "BagsList" , "NominationPools" , "Scheduler" , "Preimage" , "Offences" , "DKG" , "DKGProposals" , "DKGProposalHandler" , "HasherBn254" , "AssetRegistry" , "Currencies" , "Tokens" , "TokenWrapper" , "MixerVerifierBn254" , "AnchorVerifierBn254" , "MerkleTreeBn254" , "LinkableTreeBn254" , "MixerBn254" , "SignatureBridge" , "VAnchorVerifier2x2Bn254" , "Bridge" , "VAnchorBn254" , "VAnchorHandlerBn254" ,] ; # [derive (:: subxt :: codec :: Decode , :: subxt :: codec :: Encode , Clone , Debug , Eq , PartialEq)] pub enum Event { # [codec (index = 0)] System (system :: Event) , # [codec (index = 2)] Sudo (sudo :: Event) , # [codec (index = 4)] Balances (balances :: Event) , # [codec (index = 5)] TransactionPayment (transaction_payment :: Event) , # [codec (index = 8)] Grandpa (grandpa :: Event) , # [codec (index = 9)] Indices (indices :: Event) , # [codec (index = 10)] Democracy (democracy :: Event) , # [codec (index = 11)] Council (council :: Event) , # [codec (index = 12)] Elections (elections :: Event) , # [codec (index = 13)] ElectionProviderMultiPhase (election_provider_multi_phase :: Event) , # [codec (index = 14)] Staking (staking :: Event) , # [codec (index = 15)] Session (session :: Event) , # [codec (index = 17)] Treasury (treasury :: Event) , # [codec (index = 18)] Bounties (bounties :: Event) , # [codec (index = 19)] ChildBounties (child_bounties :: Event) , # [codec (index = 20)] BagsList (bags_list :: Event) , # [codec (index = 21)] NominationPools (nomination_pools :: Event) , # [codec (index = 22)] Scheduler (scheduler :: Event) , # [codec (index = 23)] Preimage (preimage :: Event) , # [codec (index = 24)] Offences (offences :: Event) , # [codec (index = 25)] DKG (dkg :: Event) , # [codec (index = 26)] DKGProposals (dkg_proposals :: Event) , # [codec (index = 27)] DKGProposalHandler (dkg_proposal_handler :: Event) , # [codec (index = 28)] HasherBn254 (hasher_bn254 :: Event) , # [codec (index = 29)] AssetRegistry (asset_registry :: Event) , # [codec (index = 31)] Tokens (tokens :: Event) , # [codec (index = 32)] TokenWrapper (token_wrapper :: Event) , # [codec (index = 33)] MixerVerifierBn254 (mixer_verifier_bn254 :: Event) , # [codec (index = 34)] AnchorVerifierBn254 (anchor_verifier_bn254 :: Event) , # [codec (index = 35)] MerkleTreeBn254 (merkle_tree_bn254 :: Event) , # [codec (index = 36)] LinkableTreeBn254 (linkable_tree_bn254 :: Event) , # [codec (index = 37)] MixerBn254 (mixer_bn254 :: Event) , # [codec (index = 38)] SignatureBridge (signature_bridge :: Event) , # [codec (index = 39)] VAnchorVerifier2x2Bn254 (v_anchor_verifier2x2_bn254 :: Event) , # [codec (index = 40)] Bridge (bridge :: Event) , # [codec (index = 41)] VAnchorBn254 (v_anchor_bn254 :: Event) , # [codec (index = 42)] VAnchorHandlerBn254 (v_anchor_handler_bn254 :: Event) , } pub mod system { use super :: root_mod ; use super :: runtime_types ; pub mod calls { use super :: root_mod ; use super :: runtime_types ; type DispatchError = runtime_types :: sp_runtime :: DispatchError ; # [derive (:: subxt :: codec :: Decode , :: subxt :: codec :: Encode , Clone , Debug , Eq , PartialEq)] pub struct FillBlock { pub ratio : runtime_types :: sp_arithmetic :: per_things :: Perbill , } impl :: subxt :: Call for FillBlock { const PALLET : & 'static str = "System" ; const FUNCTION : & 'static str = "fill_block" ; } # [derive (:: subxt :: codec :: Decode , :: subxt :: codec :: Encode , Clone , Debug , Eq , PartialEq)] pub struct Remark { pub remark : :: std :: vec :: Vec < :: core :: primitive :: u8 > , } impl :: subxt :: Call for Remark { const PALLET : & 'static str = "System" ; const FUNCTION : & 'static str = "remark" ; } # [derive (:: subxt :: codec :: CompactAs , :: subxt :: codec :: Decode , :: subxt :: codec :: Encode , Clone , Debug , Eq , PartialEq)] pub struct SetHeapPages { pub pages : :: core :: primitive :: u64 , } impl :: subxt :: Call for SetHeapPages { const PALLET : & 'static str = "System" ; const FUNCTION : & 'static str = "set_heap_pages" ; } # [derive (:: subxt :: codec :: Decode , :: subxt :: codec :: Encode , Clone , Debug , Eq , PartialEq)] pub struct SetCode { pub code : :: std :: vec :: Vec < :: core :: primitive :: u8 > , } impl :: subxt :: Call for SetCode { const PALLET : & 'static str = "System" ; const FUNCTION : & 'static str = "set_code" ; } # [derive (:: subxt :: codec :: Decode , :: subxt :: codec :: Encode , Clone , Debug , Eq , PartialEq)] pub struct SetCodeWithoutChecks { pub code : :: std :: vec :: Vec < :: core :: primitive :: u8 > , } impl :: subxt :: Call for SetCodeWithoutChecks { const PALLET : & 'static str = "System" ; const FUNCTION : & 'static str = "set_code_without_checks" ; } # [derive (:: subxt :: codec :: Decode , :: subxt :: codec :: Encode , Clone , Debug , Eq , PartialEq)] pub struct SetStorage { pub items : :: std :: vec :: Vec < (:: std :: vec :: Vec < :: core :: primitive :: u8 > , :: std :: vec :: Vec < :: core :: primitive :: u8 > ,) > , } impl :: subxt :: Call for SetStorage { const PALLET : & 'static str = "System" ; const FUNCTION : & 'static str = "set_storage" ; } # [derive (:: subxt :: codec :: Decode , :: subxt :: codec :: Encode , Clone , Debug , Eq , PartialEq)] pub struct KillStorage { pub keys : :: std :: vec :: Vec < :: std :: vec :: Vec < :: core :: primitive :: u8 > > , } impl :: subxt :: Call for KillStorage { const PALLET : & 'static str = "System" ; const FUNCTION : & 'static str = "kill_storage" ; } # [derive (:: subxt :: codec :: Decode , :: subxt :: codec :: Encode , Clone , Debug , Eq , PartialEq)] pub struct KillPrefix { pub prefix : :: std :: vec :: Vec < :: core :: primitive :: u8 > , pub subkeys : :: core :: primitive :: u32 , } impl :: subxt :: Call for KillPrefix { const PALLET : & 'static str = "System" ; const FUNCTION : & 'static str = "kill_prefix" ; } # [derive (:: subxt :: codec :: Decode , :: subxt :: codec :: Encode , Clone , Debug , Eq , PartialEq)] pub struct RemarkWithEvent { pub remark : :: std :: vec :: Vec < :: core :: primitive :: u8 > , } impl :: subxt :: Call for RemarkWithEvent { const PALLET : & 'static str = "System" ; const FUNCTION : & 'static str = "remark_with_event" ; } pub struct TransactionApi < 'a , T : :: subxt :: Config , X > { client : & 'a :: subxt :: Client < T > , marker : :: core :: marker :: PhantomData < X > , } impl < 'a , T , X > TransactionApi < 'a , T , X > where T : :: subxt :: Config , X : :: subxt :: extrinsic :: ExtrinsicParams < T > , { pub fn new (client : & 'a :: subxt :: Client < T >) -> Self { Self { client , marker : :: core :: marker :: PhantomData } } # [doc = "A dispatch that will fill the block weight up to the given ratio."] pub fn fill_block (& self , ratio : runtime_types :: sp_arithmetic :: per_things :: Perbill ,) -> Result < :: subxt :: SubmittableExtrinsic < 'a , T , X , FillBlock , DispatchError , root_mod :: Event > , :: subxt :: BasicError > { if self . client . metadata () . call_hash :: < FillBlock > () ? == [228u8 , 117u8 , 251u8 , 95u8 , 47u8 , 56u8 , 32u8 , 177u8 , 191u8 , 72u8 , 75u8 , 23u8 , 193u8 , 175u8 , 227u8 , 218u8 , 127u8 , 94u8 , 114u8 , 110u8 , 215u8 , 61u8 , 162u8 , 102u8 , 73u8 , 89u8 , 218u8 , 148u8 , 59u8 , 73u8 , 59u8 , 149u8 ,] { let call = FillBlock { ratio , } ; Ok (:: subxt :: SubmittableExtrinsic :: new (self . client , call)) } else { Err (:: subxt :: MetadataError :: IncompatibleMetadata . into ()) } } # [doc = "Make some on-chain remark."] # [doc = ""] # [doc = "# <weight>"] # [doc = "- `O(1)`"] # [doc = "# </weight>"] pub fn remark (& self , remark : :: std :: vec :: Vec < :: core :: primitive :: u8 > ,) -> Result < :: subxt :: SubmittableExtrinsic < 'a , T , X , Remark , DispatchError , root_mod :: Event > , :: subxt :: BasicError > { if self . client . metadata () . call_hash :: < Remark > () ? == [186u8 , 79u8 , 33u8 , 199u8 , 216u8 , 115u8 , 19u8 , 146u8 , 220u8 , 174u8 , 98u8 , 61u8 , 179u8 , 230u8 , 40u8 , 70u8 , 22u8 , 251u8 , 77u8 , 62u8 , 133u8 , 80u8 , 186u8 , 70u8 , 135u8 , 172u8 , 178u8 , 241u8 , 69u8 , 106u8 , 235u8 , 140u8 ,] { let call = Remark { remark , } ; Ok (:: subxt :: SubmittableExtrinsic :: new (self . client , call)) } else { Err (:: subxt :: MetadataError :: IncompatibleMetadata . into ()) } } # [doc = "Set the number of pages in the WebAssembly environment's heap."] pub fn set_heap_pages (& self , pages : :: core :: primitive :: u64 ,) -> Result < :: subxt :: SubmittableExtrinsic < 'a , T , X , SetHeapPages , DispatchError , root_mod :: Event > , :: subxt :: BasicError > { if self . client . metadata () . call_hash :: < SetHeapPages > () ? == [77u8 , 138u8 , 122u8 , 55u8 , 179u8 , 101u8 , 60u8 , 137u8 , 173u8 , 39u8 , 28u8 , 36u8 , 237u8 , 243u8 , 232u8 , 162u8 , 76u8 , 176u8 , 135u8 , 58u8 , 60u8 , 177u8 , 105u8 , 136u8 , 94u8 , 53u8 , 26u8 , 31u8 , 41u8 , 156u8 , 228u8 , 241u8 ,] { let call = SetHeapPages { pages , } ; Ok (:: subxt :: SubmittableExtrinsic :: new (self . client , call)) } else { Err (:: subxt :: MetadataError :: IncompatibleMetadata . into ()) } } # [doc = "Set the new runtime code."] # [doc = ""] # [doc = "# <weight>"] # [doc = "- `O(C + S)` where `C` length of `code` and `S` complexity of `can_set_code`"] # [doc = "- 1 call to `can_set_code`: `O(S)` (calls `sp_io::misc::runtime_version` which is"] # [doc = "  expensive)."] # [doc = "- 1 storage write (codec `O(C)`)."] # [doc = "- 1 digest item."] # [doc = "- 1 event."] # [doc = "The weight of this function is dependent on the runtime, but generally this is very"] # [doc = "expensive. We will treat this as a full block."] # [doc = "# </weight>"] pub fn set_code (& self , code : :: std :: vec :: Vec < :: core :: primitive :: u8 > ,) -> Result < :: subxt :: SubmittableExtrinsic < 'a , T , X , SetCode , DispatchError , root_mod :: Event > , :: subxt :: BasicError > { if self . client . metadata () . call_hash :: < SetCode > () ? == [35u8 , 75u8 , 103u8 , 203u8 , 91u8 , 141u8 , 77u8 , 95u8 , 37u8 , 157u8 , 107u8 , 240u8 , 54u8 , 242u8 , 245u8 , 205u8 , 104u8 , 165u8 , 177u8 , 37u8 , 86u8 , 197u8 , 28u8 , 202u8 , 121u8 , 159u8 , 18u8 , 204u8 , 237u8 , 117u8 , 141u8 , 131u8 ,] { let call = SetCode { code , } ; Ok (:: subxt :: SubmittableExtrinsic :: new (self . client , call)) } else { Err (:: subxt :: MetadataError :: IncompatibleMetadata . into ()) } } # [doc = "Set the new runtime code without doing any checks of the given `code`."] # [doc = ""] # [doc = "# <weight>"] # [doc = "- `O(C)` where `C` length of `code`"] # [doc = "- 1 storage write (codec `O(C)`)."] # [doc = "- 1 digest item."] # [doc = "- 1 event."] # [doc = "The weight of this function is dependent on the runtime. We will treat this as a full"] # [doc = "block. # </weight>"] pub fn set_code_without_checks (& self , code : :: std :: vec :: Vec < :: core :: primitive :: u8 > ,) -> Result < :: subxt :: SubmittableExtrinsic < 'a , T , X , SetCodeWithoutChecks , DispatchError , root_mod :: Event > , :: subxt :: BasicError > { if self . client . metadata () . call_hash :: < SetCodeWithoutChecks > () ? == [150u8 , 148u8 , 119u8 , 129u8 , 77u8 , 216u8 , 135u8 , 187u8 , 127u8 , 24u8 , 238u8 , 15u8 , 227u8 , 229u8 , 191u8 , 217u8 , 106u8 , 129u8 , 149u8 , 79u8 , 154u8 , 78u8 , 53u8 , 159u8 , 89u8 , 69u8 , 103u8 , 197u8 , 93u8 , 161u8 , 134u8 , 17u8 ,] { let call = SetCodeWithoutChecks { code , } ; Ok (:: subxt :: SubmittableExtrinsic :: new (self . client , call)) } else { Err (:: subxt :: MetadataError :: IncompatibleMetadata . into ()) } } # [doc = "Set some items of storage."] pub fn set_storage (& self , items : :: std :: vec :: Vec < (:: std :: vec :: Vec < :: core :: primitive :: u8 > , :: std :: vec :: Vec < :: core :: primitive :: u8 > ,) > ,) -> Result < :: subxt :: SubmittableExtrinsic < 'a , T , X , SetStorage , DispatchError , root_mod :: Event > , :: subxt :: BasicError > { if self . client . metadata () . call_hash :: < SetStorage > () ? == [197u8 , 12u8 , 119u8 , 205u8 , 152u8 , 103u8 , 211u8 , 170u8 , 146u8 , 253u8 , 25u8 , 56u8 , 180u8 , 146u8 , 74u8 , 75u8 , 38u8 , 108u8 , 212u8 , 154u8 , 23u8 , 22u8 , 148u8 , 175u8 , 107u8 , 186u8 , 222u8 , 13u8 , 149u8 , 132u8 , 204u8 , 217u8 ,] { let call = SetStorage { items , } ; Ok (:: subxt :: SubmittableExtrinsic :: new (self . client , call)) } else { Err (:: subxt :: MetadataError :: IncompatibleMetadata . into ()) } } # [doc = "Kill some items from storage."] pub fn kill_storage (& self , keys : :: std :: vec :: Vec < :: std :: vec :: Vec < :: core :: primitive :: u8 > > ,) -> Result < :: subxt :: SubmittableExtrinsic < 'a , T , X , KillStorage , DispatchError , root_mod :: Event > , :: subxt :: BasicError > { if self . client . metadata () . call_hash :: < KillStorage > () ? == [154u8 , 115u8 , 185u8 , 20u8 , 126u8 , 90u8 , 222u8 , 131u8 , 199u8 , 57u8 , 184u8 , 226u8 , 43u8 , 245u8 , 161u8 , 176u8 , 194u8 , 123u8 , 139u8 , 97u8 , 97u8 , 94u8 , 47u8 , 64u8 , 204u8 , 96u8 , 190u8 , 94u8 , 216u8 , 237u8 , 69u8 , 51u8 ,] { let call = KillStorage { keys , } ; Ok (:: subxt :: SubmittableExtrinsic :: new (self . client , call)) } else { Err (:: subxt :: MetadataError :: IncompatibleMetadata . into ()) } } # [doc = "Kill all storage items with a key that starts with the given prefix."] # [doc = ""] # [doc = "**NOTE:** We rely on the Root origin to provide us the number of subkeys under"] # [doc = "the prefix we are removing to accurately calculate the weight of this function."] pub fn kill_prefix (& self , prefix : :: std :: vec :: Vec < :: core :: primitive :: u8 > , subkeys : :: core :: primitive :: u32 ,) -> Result < :: subxt :: SubmittableExtrinsic < 'a , T , X , KillPrefix , DispatchError , root_mod :: Event > , :: subxt :: BasicError > { if self . client . metadata () . call_hash :: < KillPrefix > () ? == [214u8 , 101u8 , 191u8 , 241u8 , 1u8 , 241u8 , 144u8 , 116u8 , 246u8 , 199u8 , 159u8 , 249u8 , 155u8 , 164u8 , 220u8 , 221u8 , 75u8 , 33u8 , 204u8 , 3u8 , 255u8 , 201u8 , 187u8 , 238u8 , 181u8 , 213u8 , 41u8 , 105u8 , 234u8 , 120u8 , 202u8 , 115u8 ,] { let call = KillPrefix { prefix , subkeys , } ; Ok (:: subxt :: SubmittableExtrinsic :: new (self . client , call)) } else { Err (:: subxt :: MetadataError :: IncompatibleMetadata . into ()) } } # [doc = "Make some on-chain remark and emit event."] pub fn remark_with_event (& self , remark : :: std :: vec :: Vec < :: core :: primitive :: u8 > ,) -> Result < :: subxt :: SubmittableExtrinsic < 'a , T , X , RemarkWithEvent , DispatchError , root_mod :: Event > , :: subxt :: BasicError > { if self . client . metadata () . call_hash :: < RemarkWithEvent > () ? == [171u8 , 82u8 , 75u8 , 237u8 , 69u8 , 197u8 , 223u8 , 125u8 , 123u8 , 51u8 , 241u8 , 35u8 , 202u8 , 210u8 , 227u8 , 109u8 , 1u8 , 241u8 , 255u8 , 63u8 , 33u8 , 115u8 , 156u8 , 239u8 , 97u8 , 76u8 , 193u8 , 35u8 , 74u8 , 199u8 , 43u8 , 255u8 ,] { let call = RemarkWithEvent { remark , } ; Ok (:: subxt :: SubmittableExtrinsic :: new (self . client , call)) } else { Err (:: subxt :: MetadataError :: IncompatibleMetadata . into ()) } } } } pub type Event = runtime_types :: frame_system :: pallet :: Event ; pub mod events { use super :: runtime_types ; # [derive (:: subxt :: codec :: Decode , :: subxt :: codec :: Encode , Clone , Debug , Eq , PartialEq)] # [doc = "An extrinsic completed successfully."] pub struct ExtrinsicSuccess { pub dispatch_info : runtime_types :: frame_support :: weights :: DispatchInfo , } impl :: subxt :: Event for ExtrinsicSuccess { const PALLET : & 'static str = "System" ; const EVENT : & 'static str = "ExtrinsicSuccess" ; } # [derive (:: subxt :: codec :: Decode , :: subxt :: codec :: Encode , Clone , Debug , Eq , PartialEq)] # [doc = "An extrinsic failed."] pub struct ExtrinsicFailed { pub dispatch_error : runtime_types :: sp_runtime :: DispatchError , pub dispatch_info : runtime_types :: frame_support :: weights :: DispatchInfo , } impl :: subxt :: Event for ExtrinsicFailed { const PALLET : & 'static str = "System" ; const EVENT : & 'static str = "ExtrinsicFailed" ; } # [derive (:: subxt :: codec :: Decode , :: subxt :: codec :: Encode , Clone , Debug , Eq , PartialEq)] # [doc = "`:code` was updated."] pub struct CodeUpdated ; impl :: subxt :: Event for CodeUpdated { const PALLET : & 'static str = "System" ; const EVENT : & 'static str = "CodeUpdated" ; } # [derive (:: subxt :: codec :: Decode , :: subxt :: codec :: Encode , Clone , Debug , Eq , PartialEq)] # [doc = "A new account was created."] pub struct NewAccount { pub account : :: subxt :: sp_core :: crypto :: AccountId32 , } impl :: subxt :: Event for NewAccount { const PALLET : & 'static str = "System" ; const EVENT : & 'static str = "NewAccount" ; } # [derive (:: subxt :: codec :: Decode , :: subxt :: codec :: Encode , Clone , Debug , Eq , PartialEq)] # [doc = "An account was reaped."] pub struct KilledAccount { pub account : :: subxt :: sp_core :: crypto :: AccountId32 , } impl :: subxt :: Event for KilledAccount { const PALLET : & 'static str = "System" ; const EVENT : & 'static str = "KilledAccount" ; } # [derive (:: subxt :: codec :: Decode , :: subxt :: codec :: Encode , Clone , Debug , Eq , PartialEq)] # [doc = "On on-chain remark happened."] pub struct Remarked { pub sender : :: subxt :: sp_core :: crypto :: AccountId32 , pub hash : :: subxt :: sp_core :: H256 , } impl :: subxt :: Event for Remarked { const PALLET : & 'static str = "System" ; const EVENT : & 'static str = "Remarked" ; } } pub mod storage { use super :: runtime_types ; pub struct Account < 'a > (pub & 'a :: subxt :: sp_core :: crypto :: AccountId32) ; impl :: subxt :: StorageEntry for Account < '_ > { const PALLET : & 'static str = "System" ; const STORAGE : & 'static str = "Account" ; type Value = runtime_types :: frame_system :: AccountInfo < :: core :: primitive :: u32 , runtime_types :: pallet_balances :: AccountData < :: core :: primitive :: u128 > > ; fn key (& self) -> :: subxt :: StorageEntryKey { :: subxt :: StorageEntryKey :: Map (vec ! [:: subxt :: StorageMapKey :: new (& self . 0 , :: subxt :: StorageHasher :: Blake2_128Concat)]) } } pub struct ExtrinsicCount ; impl :: subxt :: StorageEntry for ExtrinsicCount { const PALLET : & 'static str = "System" ; const STORAGE : & 'static str = "ExtrinsicCount" ; type Value = :: core :: primitive :: u32 ; fn key (& self) -> :: subxt :: StorageEntryKey { :: subxt :: StorageEntryKey :: Plain } } pub struct BlockWeight ; impl :: subxt :: StorageEntry for BlockWeight { const PALLET : & 'static str = "System" ; const STORAGE : & 'static str = "BlockWeight" ; type Value = runtime_types :: frame_support :: weights :: PerDispatchClass < :: core :: primitive :: u64 > ; fn key (& self) -> :: subxt :: StorageEntryKey { :: subxt :: StorageEntryKey :: Plain } } pub struct AllExtrinsicsLen ; impl :: subxt :: StorageEntry for AllExtrinsicsLen { const PALLET : & 'static str = "System" ; const STORAGE : & 'static str = "AllExtrinsicsLen" ; type Value = :: core :: primitive :: u32 ; fn key (& self) -> :: subxt :: StorageEntryKey { :: subxt :: StorageEntryKey :: Plain } } pub struct BlockHash < 'a > (pub & 'a :: core :: primitive :: u32) ; impl :: subxt :: StorageEntry for BlockHash < '_ > { const PALLET : & 'static str = "System" ; const STORAGE : & 'static str = "BlockHash" ; type Value = :: subxt :: sp_core :: H256 ; fn key (& self) -> :: subxt :: StorageEntryKey { :: subxt :: StorageEntryKey :: Map (vec ! [:: subxt :: StorageMapKey :: new (& self . 0 , :: subxt :: StorageHasher :: Twox64Concat)]) } } pub struct ExtrinsicData < 'a > (pub & 'a :: core :: primitive :: u32) ; impl :: subxt :: StorageEntry for ExtrinsicData < '_ > { const PALLET : & 'static str = "System" ; const STORAGE : & 'static str = "ExtrinsicData" ; type Value = :: std :: vec :: Vec < :: core :: primitive :: u8 > ; fn key (& self) -> :: subxt :: StorageEntryKey { :: subxt :: StorageEntryKey :: Map (vec ! [:: subxt :: StorageMapKey :: new (& self . 0 , :: subxt :: StorageHasher :: Twox64Concat)]) } } pub struct Number ; impl :: subxt :: StorageEntry for Number { const PALLET : & 'static str = "System" ; const STORAGE : & 'static str = "Number" ; type Value = :: core :: primitive :: u32 ; fn key (& self) -> :: subxt :: StorageEntryKey { :: subxt :: StorageEntryKey :: Plain } } pub struct ParentHash ; impl :: subxt :: StorageEntry for ParentHash { const PALLET : & 'static str = "System" ; const STORAGE : & 'static str = "ParentHash" ; type Value = :: subxt :: sp_core :: H256 ; fn key (& self) -> :: subxt :: StorageEntryKey { :: subxt :: StorageEntryKey :: Plain } } pub struct Digest ; impl :: subxt :: StorageEntry for Digest { const PALLET : & 'static str = "System" ; const STORAGE : & 'static str = "Digest" ; type Value = runtime_types :: sp_runtime :: generic :: digest :: Digest ; fn key (& self) -> :: subxt :: StorageEntryKey { :: subxt :: StorageEntryKey :: Plain } } pub struct Events ; impl :: subxt :: StorageEntry for Events { const PALLET : & 'static str = "System" ; const STORAGE : & 'static str = "Events" ; type Value = :: std :: vec :: Vec < runtime_types :: frame_system :: EventRecord < runtime_types :: egg_standalone_runtime :: Event , :: subxt :: sp_core :: H256 > > ; fn key (& self) -> :: subxt :: StorageEntryKey { :: subxt :: StorageEntryKey :: Plain } } pub struct EventCount ; impl :: subxt :: StorageEntry for EventCount { const PALLET : & 'static str = "System" ; const STORAGE : & 'static str = "EventCount" ; type Value = :: core :: primitive :: u32 ; fn key (& self) -> :: subxt :: StorageEntryKey { :: subxt :: StorageEntryKey :: Plain } } pub struct EventTopics < 'a > (pub & 'a :: subxt :: sp_core :: H256) ; impl :: subxt :: StorageEntry for EventTopics < '_ > { const PALLET : & 'static str = "System" ; const STORAGE : & 'static str = "EventTopics" ; type Value = :: std :: vec :: Vec < (:: core :: primitive :: u32 , :: core :: primitive :: u32 ,) > ; fn key (& self) -> :: subxt :: StorageEntryKey { :: subxt :: StorageEntryKey :: Map (vec ! [:: subxt :: StorageMapKey :: new (& self . 0 , :: subxt :: StorageHasher :: Blake2_128Concat)]) } } pub struct LastRuntimeUpgrade ; impl :: subxt :: StorageEntry for LastRuntimeUpgrade { const PALLET : & 'static str = "System" ; const STORAGE : & 'static str = "LastRuntimeUpgrade" ; type Value = runtime_types :: frame_system :: LastRuntimeUpgradeInfo ; fn key (& self) -> :: subxt :: StorageEntryKey { :: subxt :: StorageEntryKey :: Plain } } pub struct UpgradedToU32RefCount ; impl :: subxt :: StorageEntry for UpgradedToU32RefCount { const PALLET : & 'static str = "System" ; const STORAGE : & 'static str = "UpgradedToU32RefCount" ; type Value = :: core :: primitive :: bool ; fn key (& self) -> :: subxt :: StorageEntryKey { :: subxt :: StorageEntryKey :: Plain } } pub struct UpgradedToTripleRefCount ; impl :: subxt :: StorageEntry for UpgradedToTripleRefCount { const PALLET : & 'static str = "System" ; const STORAGE : & 'static str = "UpgradedToTripleRefCount" ; type Value = :: core :: primitive :: bool ; fn key (& self) -> :: subxt :: StorageEntryKey { :: subxt :: StorageEntryKey :: Plain } } pub struct ExecutionPhase ; impl :: subxt :: StorageEntry for ExecutionPhase { const PALLET : & 'static str = "System" ; const STORAGE : & 'static str = "ExecutionPhase" ; type Value = runtime_types :: frame_system :: Phase ; fn key (& self) -> :: subxt :: StorageEntryKey { :: subxt :: StorageEntryKey :: Plain } } pub struct StorageApi < 'a , T : :: subxt :: Config > { client : & 'a :: subxt :: Client < T > , } impl < 'a , T : :: subxt :: Config > StorageApi < 'a , T > { pub fn new (client : & 'a :: subxt :: Client < T >) -> Self { Self { client } } # [doc = " The full account information for a particular account ID."] pub async fn account (& self , _0 : & :: subxt :: sp_core :: crypto :: AccountId32 , block_hash : :: core :: option :: Option < T :: Hash > ,) -> :: core :: result :: Result < runtime_types :: frame_system :: AccountInfo < :: core :: primitive :: u32 , runtime_types :: pallet_balances :: AccountData < :: core :: primitive :: u128 > > , :: subxt :: BasicError > { if self . client . metadata () . storage_hash :: < Account > () ? == [224u8 , 184u8 , 2u8 , 14u8 , 38u8 , 177u8 , 223u8 , 98u8 , 223u8 , 15u8 , 130u8 , 23u8 , 212u8 , 69u8 , 61u8 , 165u8 , 171u8 , 61u8 , 171u8 , 57u8 , 88u8 , 71u8 , 168u8 , 172u8 , 54u8 , 91u8 , 109u8 , 231u8 , 169u8 , 167u8 , 195u8 , 46u8 ,] { let entry = Account (_0) ; self . client . storage () . fetch_or_default (& entry , block_hash) . await } else { Err (:: subxt :: MetadataError :: IncompatibleMetadata . into ()) } } # [doc = " The full account information for a particular account ID."] pub async fn account_iter (& self , block_hash : :: core :: option :: Option < T :: Hash > ,) -> :: core :: result :: Result < :: subxt :: KeyIter < 'a , T , Account < 'a > > , :: subxt :: BasicError > { if self . client . metadata () . storage_hash :: < Account > () ? == [224u8 , 184u8 , 2u8 , 14u8 , 38u8 , 177u8 , 223u8 , 98u8 , 223u8 , 15u8 , 130u8 , 23u8 , 212u8 , 69u8 , 61u8 , 165u8 , 171u8 , 61u8 , 171u8 , 57u8 , 88u8 , 71u8 , 168u8 , 172u8 , 54u8 , 91u8 , 109u8 , 231u8 , 169u8 , 167u8 , 195u8 , 46u8 ,] { self . client . storage () . iter (block_hash) . await } else { Err (:: subxt :: MetadataError :: IncompatibleMetadata . into ()) } } # [doc = " Total extrinsics count for the current block."] pub async fn extrinsic_count (& self , block_hash : :: core :: option :: Option < T :: Hash > ,) -> :: core :: result :: Result < :: core :: option :: Option < :: core :: primitive :: u32 > , :: subxt :: BasicError > { if self . client . metadata () . storage_hash :: < ExtrinsicCount > () ? == [223u8 , 60u8 , 201u8 , 120u8 , 36u8 , 44u8 , 180u8 , 210u8 , 242u8 , 53u8 , 222u8 , 154u8 , 123u8 , 176u8 , 249u8 , 8u8 , 225u8 , 28u8 , 232u8 , 4u8 , 136u8 , 41u8 , 151u8 , 82u8 , 189u8 , 149u8 , 49u8 , 166u8 , 139u8 , 9u8 , 163u8 , 231u8 ,] { let entry = ExtrinsicCount ; self . client . storage () . fetch (& entry , block_hash) . await } else { Err (:: subxt :: MetadataError :: IncompatibleMetadata . into ()) } } # [doc = " The current weight for the block."] pub async fn block_weight (& self , block_hash : :: core :: option :: Option < T :: Hash > ,) -> :: core :: result :: Result < runtime_types :: frame_support :: weights :: PerDispatchClass < :: core :: primitive :: u64 > , :: subxt :: BasicError > { if self . client . metadata () . storage_hash :: < BlockWeight > () ? == [2u8 , 236u8 , 190u8 , 174u8 , 244u8 , 98u8 , 194u8 , 168u8 , 89u8 , 208u8 , 7u8 , 45u8 , 175u8 , 171u8 , 177u8 , 121u8 , 215u8 , 190u8 , 184u8 , 195u8 , 49u8 , 133u8 , 44u8 , 1u8 , 181u8 , 215u8 , 89u8 , 84u8 , 255u8 , 16u8 , 57u8 , 152u8 ,] { let entry = BlockWeight ; self . client . storage () . fetch_or_default (& entry , block_hash) . await } else { Err (:: subxt :: MetadataError :: IncompatibleMetadata . into ()) } } # [doc = " Total length (in bytes) for all extrinsics put together, for the current block."] pub async fn all_extrinsics_len (& self , block_hash : :: core :: option :: Option < T :: Hash > ,) -> :: core :: result :: Result < :: core :: option :: Option < :: core :: primitive :: u32 > , :: subxt :: BasicError > { if self . client . metadata () . storage_hash :: < AllExtrinsicsLen > () ? == [202u8 , 145u8 , 209u8 , 225u8 , 40u8 , 220u8 , 174u8 , 74u8 , 93u8 , 164u8 , 254u8 , 248u8 , 254u8 , 192u8 , 32u8 , 117u8 , 96u8 , 149u8 , 53u8 , 145u8 , 219u8 , 64u8 , 234u8 , 18u8 , 217u8 , 200u8 , 203u8 , 141u8 , 145u8 , 28u8 , 134u8 , 60u8 ,] { let entry = AllExtrinsicsLen ; self . client . storage () . fetch (& entry , block_hash) . await } else { Err (:: subxt :: MetadataError :: IncompatibleMetadata . into ()) } } # [doc = " Map of block numbers to block hashes."] pub async fn block_hash (& self , _0 : & :: core :: primitive :: u32 , block_hash : :: core :: option :: Option < T :: Hash > ,) -> :: core :: result :: Result < :: subxt :: sp_core :: H256 , :: subxt :: BasicError > { if self . client . metadata () . storage_hash :: < BlockHash > () ? == [24u8 , 99u8 , 146u8 , 142u8 , 205u8 , 166u8 , 4u8 , 32u8 , 218u8 , 213u8 , 24u8 , 236u8 , 45u8 , 116u8 , 145u8 , 204u8 , 27u8 , 141u8 , 169u8 , 249u8 , 111u8 , 141u8 , 37u8 , 136u8 , 45u8 , 73u8 , 167u8 , 217u8 , 118u8 , 206u8 , 246u8 , 120u8 ,] { let entry = BlockHash (_0) ; self . client . storage () . fetch_or_default (& entry , block_hash) . await } else { Err (:: subxt :: MetadataError :: IncompatibleMetadata . into ()) } } # [doc = " Map of block numbers to block hashes."] pub async fn block_hash_iter (& self , block_hash : :: core :: option :: Option < T :: Hash > ,) -> :: core :: result :: Result < :: subxt :: KeyIter < 'a , T , BlockHash < 'a > > , :: subxt :: BasicError > { if self . client . metadata () . storage_hash :: < BlockHash > () ? == [24u8 , 99u8 , 146u8 , 142u8 , 205u8 , 166u8 , 4u8 , 32u8 , 218u8 , 213u8 , 24u8 , 236u8 , 45u8 , 116u8 , 145u8 , 204u8 , 27u8 , 141u8 , 169u8 , 249u8 , 111u8 , 141u8 , 37u8 , 136u8 , 45u8 , 73u8 , 167u8 , 217u8 , 118u8 , 206u8 , 246u8 , 120u8 ,] { self . client . storage () . iter (block_hash) . await } else { Err (:: subxt :: MetadataError :: IncompatibleMetadata . into ()) } } # [doc = " Extrinsics data for the current block (maps an extrinsic's index to its data)."] pub async fn extrinsic_data (& self , _0 : & :: core :: primitive :: u32 , block_hash : :: core :: option :: Option < T :: Hash > ,) -> :: core :: result :: Result < :: std :: vec :: Vec < :: core :: primitive :: u8 > , :: subxt :: BasicError > { if self . client . metadata () . storage_hash :: < ExtrinsicData > () ? == [210u8 , 224u8 , 211u8 , 186u8 , 118u8 , 210u8 , 185u8 , 194u8 , 238u8 , 211u8 , 254u8 , 73u8 , 67u8 , 184u8 , 31u8 , 229u8 , 168u8 , 125u8 , 98u8 , 23u8 , 241u8 , 59u8 , 49u8 , 86u8 , 126u8 , 9u8 , 114u8 , 163u8 , 160u8 , 62u8 , 50u8 , 67u8 ,] { let entry = ExtrinsicData (_0) ; self . client . storage () . fetch_or_default (& entry , block_hash) . await } else { Err (:: subxt :: MetadataError :: IncompatibleMetadata . into ()) } } # [doc = " Extrinsics data for the current block (maps an extrinsic's index to its data)."] pub async fn extrinsic_data_iter (& self , block_hash : :: core :: option :: Option < T :: Hash > ,) -> :: core :: result :: Result < :: subxt :: KeyIter < 'a , T , ExtrinsicData < 'a > > , :: subxt :: BasicError > { if self . client . metadata () . storage_hash :: < ExtrinsicData > () ? == [210u8 , 224u8 , 211u8 , 186u8 , 118u8 , 210u8 , 185u8 , 194u8 , 238u8 , 211u8 , 254u8 , 73u8 , 67u8 , 184u8 , 31u8 , 229u8 , 168u8 , 125u8 , 98u8 , 23u8 , 241u8 , 59u8 , 49u8 , 86u8 , 126u8 , 9u8 , 114u8 , 163u8 , 160u8 , 62u8 , 50u8 , 67u8 ,] { self . client . storage () . iter (block_hash) . await } else { Err (:: subxt :: MetadataError :: IncompatibleMetadata . into ()) } } # [doc = " The current block number being processed. Set by `execute_block`."] pub async fn number (& self , block_hash : :: core :: option :: Option < T :: Hash > ,) -> :: core :: result :: Result < :: core :: primitive :: u32 , :: subxt :: BasicError > { if self . client . metadata () . storage_hash :: < Number > () ? == [228u8 , 96u8 , 102u8 , 190u8 , 252u8 , 130u8 , 239u8 , 172u8 , 126u8 , 235u8 , 246u8 , 139u8 , 208u8 , 15u8 , 88u8 , 245u8 , 141u8 , 232u8 , 43u8 , 204u8 , 36u8 , 87u8 , 211u8 , 141u8 , 187u8 , 68u8 , 236u8 , 70u8 , 193u8 , 235u8 , 164u8 , 191u8 ,] { let entry = Number ; self . client . storage () . fetch_or_default (& entry , block_hash) . await } else { Err (:: subxt :: MetadataError :: IncompatibleMetadata . into ()) } } # [doc = " Hash of the previous block."] pub async fn parent_hash (& self , block_hash : :: core :: option :: Option < T :: Hash > ,) -> :: core :: result :: Result < :: subxt :: sp_core :: H256 , :: subxt :: BasicError > { if self . client . metadata () . storage_hash :: < ParentHash > () ? == [194u8 , 221u8 , 147u8 , 22u8 , 68u8 , 141u8 , 32u8 , 6u8 , 202u8 , 39u8 , 164u8 , 184u8 , 69u8 , 126u8 , 190u8 , 101u8 , 215u8 , 27u8 , 127u8 , 157u8 , 200u8 , 69u8 , 170u8 , 139u8 , 232u8 , 27u8 , 254u8 , 181u8 , 183u8 , 105u8 , 111u8 , 177u8 ,] { let entry = ParentHash ; self . client . storage () . fetch_or_default (& entry , block_hash) . await } else { Err (:: subxt :: MetadataError :: IncompatibleMetadata . into ()) } } # [doc = " Digest of the current block, also part of the block header."] pub async fn digest (& self , block_hash : :: core :: option :: Option < T :: Hash > ,) -> :: core :: result :: Result < runtime_types :: sp_runtime :: generic :: digest :: Digest , :: subxt :: BasicError > { if self . client . metadata () . storage_hash :: < Digest > () ? == [10u8 , 176u8 , 13u8 , 228u8 , 226u8 , 42u8 , 210u8 , 151u8 , 107u8 , 212u8 , 136u8 , 15u8 , 38u8 , 182u8 , 225u8 , 12u8 , 250u8 , 56u8 , 193u8 , 243u8 , 219u8 , 113u8 , 95u8 , 233u8 , 21u8 , 229u8 , 125u8 , 146u8 , 92u8 , 250u8 , 32u8 , 168u8 ,] { let entry = Digest ; self . client . storage () . fetch_or_default (& entry , block_hash) . await } else { Err (:: subxt :: MetadataError :: IncompatibleMetadata . into ()) } } # [doc = " Events deposited for the current block."] # [doc = ""] # [doc = " NOTE: The item is unbound and should therefore never be read on chain."] # [doc = " It could otherwise inflate the PoV size of a block."] # [doc = ""] # [doc = " Events have a large in-memory size. Box the events to not go out-of-memory"] # [doc = " just in case someone still reads them from within the runtime."] pub async fn events (& self , block_hash : :: core :: option :: Option < T :: Hash > ,) -> :: core :: result :: Result < :: std :: vec :: Vec < runtime_types :: frame_system :: EventRecord < runtime_types :: egg_standalone_runtime :: Event , :: subxt :: sp_core :: H256 > > , :: subxt :: BasicError > { if self . client . metadata () . storage_hash :: < Events > () ? == [133u8 , 139u8 , 38u8 , 244u8 , 74u8 , 136u8 , 2u8 , 6u8 , 224u8 , 246u8 , 8u8 , 235u8 , 189u8 , 23u8 , 159u8 , 253u8 , 197u8 , 39u8 , 161u8 , 140u8 , 215u8 , 221u8 , 86u8 , 251u8 , 51u8 , 201u8 , 161u8 , 125u8 , 121u8 , 146u8 , 227u8 , 164u8 ,] { let entry = Events ; self . client . storage () . fetch_or_default (& entry , block_hash) . await } else { Err (:: subxt :: MetadataError :: IncompatibleMetadata . into ()) } } # [doc = " The number of events in the `Events<T>` list."] pub async fn event_count (& self , block_hash : :: core :: option :: Option < T :: Hash > ,) -> :: core :: result :: Result < :: core :: primitive :: u32 , :: subxt :: BasicError > { if self . client . metadata () . storage_hash :: < EventCount > () ? == [236u8 , 93u8 , 90u8 , 177u8 , 250u8 , 211u8 , 138u8 , 187u8 , 26u8 , 208u8 , 203u8 , 113u8 , 221u8 , 233u8 , 227u8 , 9u8 , 249u8 , 25u8 , 202u8 , 185u8 , 161u8 , 144u8 , 167u8 , 104u8 , 127u8 , 187u8 , 38u8 , 18u8 , 52u8 , 61u8 , 66u8 , 112u8 ,] { let entry = EventCount ; self . client . storage () . fetch_or_default (& entry , block_hash) . await } else { Err (:: subxt :: MetadataError :: IncompatibleMetadata . into ()) } } # [doc = " Mapping between a topic (represented by T::Hash) and a vector of indexes"] # [doc = " of events in the `<Events<T>>` list."] # [doc = ""] # [doc = " All topic vectors have deterministic storage locations depending on the topic. This"] # [doc = " allows light-clients to leverage the changes trie storage tracking mechanism and"] # [doc = " in case of changes fetch the list of events of interest."] # [doc = ""] # [doc = " The value has the type `(T::BlockNumber, EventIndex)` because if we used only just"] # [doc = " the `EventIndex` then in case if the topic has the same contents on the next block"] # [doc = " no notification will be triggered thus the event might be lost."] pub async fn event_topics (& self , _0 : & :: subxt :: sp_core :: H256 , block_hash : :: core :: option :: Option < T :: Hash > ,) -> :: core :: result :: Result < :: std :: vec :: Vec < (:: core :: primitive :: u32 , :: core :: primitive :: u32 ,) > , :: subxt :: BasicError > { if self . client . metadata () . storage_hash :: < EventTopics > () ? == [231u8 , 73u8 , 172u8 , 223u8 , 210u8 , 145u8 , 151u8 , 102u8 , 73u8 , 23u8 , 140u8 , 55u8 , 97u8 , 40u8 , 219u8 , 239u8 , 229u8 , 177u8 , 72u8 , 41u8 , 93u8 , 178u8 , 7u8 , 209u8 , 57u8 , 86u8 , 153u8 , 252u8 , 86u8 , 152u8 , 245u8 , 179u8 ,] { let entry = EventTopics (_0) ; self . client . storage () . fetch_or_default (& entry , block_hash) . await } else { Err (:: subxt :: MetadataError :: IncompatibleMetadata . into ()) } } # [doc = " Mapping between a topic (represented by T::Hash) and a vector of indexes"] # [doc = " of events in the `<Events<T>>` list."] # [doc = ""] # [doc = " All topic vectors have deterministic storage locations depending on the topic. This"] # [doc = " allows light-clients to leverage the changes trie storage tracking mechanism and"] # [doc = " in case of changes fetch the list of events of interest."] # [doc = ""] # [doc = " The value has the type `(T::BlockNumber, EventIndex)` because if we used only just"] # [doc = " the `EventIndex` then in case if the topic has the same contents on the next block"] # [doc = " no notification will be triggered thus the event might be lost."] pub async fn event_topics_iter (& self , block_hash : :: core :: option :: Option < T :: Hash > ,) -> :: core :: result :: Result < :: subxt :: KeyIter < 'a , T , EventTopics < 'a > > , :: subxt :: BasicError > { if self . client . metadata () . storage_hash :: < EventTopics > () ? == [231u8 , 73u8 , 172u8 , 223u8 , 210u8 , 145u8 , 151u8 , 102u8 , 73u8 , 23u8 , 140u8 , 55u8 , 97u8 , 40u8 , 219u8 , 239u8 , 229u8 , 177u8 , 72u8 , 41u8 , 93u8 , 178u8 , 7u8 , 209u8 , 57u8 , 86u8 , 153u8 , 252u8 , 86u8 , 152u8 , 245u8 , 179u8 ,] { self . client . storage () . iter (block_hash) . await } else { Err (:: subxt :: MetadataError :: IncompatibleMetadata . into ()) } } # [doc = " Stores the `spec_version` and `spec_name` of when the last runtime upgrade happened."] pub async fn last_runtime_upgrade (& self , block_hash : :: core :: option :: Option < T :: Hash > ,) -> :: core :: result :: Result < :: core :: option :: Option < runtime_types :: frame_system :: LastRuntimeUpgradeInfo > , :: subxt :: BasicError > { if self . client . metadata () . storage_hash :: < LastRuntimeUpgrade > () ? == [219u8 , 153u8 , 158u8 , 38u8 , 45u8 , 65u8 , 151u8 , 137u8 , 53u8 , 76u8 , 11u8 , 181u8 , 218u8 , 248u8 , 125u8 , 190u8 , 100u8 , 240u8 , 173u8 , 75u8 , 179u8 , 137u8 , 198u8 , 197u8 , 248u8 , 185u8 , 118u8 , 58u8 , 42u8 , 165u8 , 125u8 , 119u8 ,] { let entry = LastRuntimeUpgrade ; self . client . storage () . fetch (& entry , block_hash) . await } else { Err (:: subxt :: MetadataError :: IncompatibleMetadata . into ()) } } # [doc = " True if we have upgraded so that `type RefCount` is `u32`. False (default) if not."] pub async fn upgraded_to_u32_ref_count (& self , block_hash : :: core :: option :: Option < T :: Hash > ,) -> :: core :: result :: Result < :: core :: primitive :: bool , :: subxt :: BasicError > { if self . client . metadata () . storage_hash :: < UpgradedToU32RefCount > () ? == [171u8 , 88u8 , 244u8 , 92u8 , 122u8 , 67u8 , 27u8 , 18u8 , 59u8 , 175u8 , 175u8 , 178u8 , 20u8 , 150u8 , 213u8 , 59u8 , 222u8 , 141u8 , 32u8 , 107u8 , 3u8 , 114u8 , 83u8 , 250u8 , 180u8 , 233u8 , 152u8 , 54u8 , 187u8 , 99u8 , 131u8 , 204u8 ,] { let entry = UpgradedToU32RefCount ; self . client . storage () . fetch_or_default (& entry , block_hash) . await } else { Err (:: subxt :: MetadataError :: IncompatibleMetadata . into ()) } } # [doc = " True if we have upgraded so that AccountInfo contains three types of `RefCount`. False"] # [doc = " (default) if not."] pub async fn upgraded_to_triple_ref_count (& self , block_hash : :: core :: option :: Option < T :: Hash > ,) -> :: core :: result :: Result < :: core :: primitive :: bool , :: subxt :: BasicError > { if self . client . metadata () . storage_hash :: < UpgradedToTripleRefCount > () ? == [90u8 , 33u8 , 56u8 , 86u8 , 90u8 , 101u8 , 89u8 , 133u8 , 203u8 , 56u8 , 201u8 , 210u8 , 244u8 , 232u8 , 150u8 , 18u8 , 51u8 , 105u8 , 14u8 , 230u8 , 103u8 , 155u8 , 246u8 , 99u8 , 53u8 , 207u8 , 225u8 , 128u8 , 186u8 , 76u8 , 40u8 , 185u8 ,] { let entry = UpgradedToTripleRefCount ; self . client . storage () . fetch_or_default (& entry , block_hash) . await } else { Err (:: subxt :: MetadataError :: IncompatibleMetadata . into ()) } } # [doc = " The execution phase of the block."] pub async fn execution_phase (& self , block_hash : :: core :: option :: Option < T :: Hash > ,) -> :: core :: result :: Result < :: core :: option :: Option < runtime_types :: frame_system :: Phase > , :: subxt :: BasicError > { if self . client . metadata () . storage_hash :: < ExecutionPhase > () ? == [174u8 , 13u8 , 230u8 , 220u8 , 239u8 , 161u8 , 172u8 , 122u8 , 188u8 , 95u8 , 141u8 , 118u8 , 91u8 , 158u8 , 111u8 , 145u8 , 243u8 , 173u8 , 226u8 , 212u8 , 187u8 , 118u8 , 94u8 , 132u8 , 221u8 , 244u8 , 61u8 , 148u8 , 217u8 , 30u8 , 238u8 , 225u8 ,] { let entry = ExecutionPhase ; self . client . storage () . fetch (& entry , block_hash) . await } else { Err (:: subxt :: MetadataError :: IncompatibleMetadata . into ()) } } } } pub mod constants { use super :: runtime_types ; pub struct ConstantsApi < 'a , T : :: subxt :: Config > { client : & 'a :: subxt :: Client < T > , } impl < 'a , T : :: subxt :: Config > ConstantsApi < 'a , T > { pub fn new (client : & 'a :: subxt :: Client < T >) -> Self { Self { client } } # [doc = " Block & extrinsics weights: base values and limits."] pub fn block_weights (& self) -> :: core :: result :: Result < runtime_types :: frame_system :: limits :: BlockWeights , :: subxt :: BasicError > { if self . client . metadata () . constant_hash ("System" , "BlockWeights") ? == [224u8 , 62u8 , 209u8 , 193u8 , 114u8 , 176u8 , 64u8 , 61u8 , 25u8 , 95u8 , 104u8 , 110u8 , 106u8 , 190u8 , 192u8 , 66u8 , 16u8 , 90u8 , 133u8 , 221u8 , 109u8 , 73u8 , 235u8 , 160u8 , 166u8 , 241u8 , 88u8 , 8u8 , 78u8 , 47u8 , 40u8 , 210u8 ,] { let pallet = self . client . metadata () . pallet ("System") ? ; let constant = pallet . constant ("BlockWeights") ? ; let value = :: subxt :: codec :: Decode :: decode (& mut & constant . value [..]) ? ; Ok (value) } else { Err (:: subxt :: MetadataError :: IncompatibleMetadata . into ()) } } # [doc = " The maximum length of a block (in bytes)."] pub fn block_length (& self) -> :: core :: result :: Result < runtime_types :: frame_system :: limits :: BlockLength , :: subxt :: BasicError > { if self . client . metadata () . constant_hash ("System" , "BlockLength") ? == [120u8 , 249u8 , 182u8 , 103u8 , 246u8 , 214u8 , 149u8 , 44u8 , 42u8 , 64u8 , 2u8 , 56u8 , 157u8 , 184u8 , 43u8 , 195u8 , 214u8 , 251u8 , 207u8 , 207u8 , 249u8 , 105u8 , 203u8 , 108u8 , 179u8 , 93u8 , 93u8 , 246u8 , 40u8 , 175u8 , 160u8 , 114u8 ,] { let pallet = self . client . metadata () . pallet ("System") ? ; let constant = pallet . constant ("BlockLength") ? ; let value = :: subxt :: codec :: Decode :: decode (& mut & constant . value [..]) ? ; Ok (value) } else { Err (:: subxt :: MetadataError :: IncompatibleMetadata . into ()) } } # [doc = " Maximum number of block number to block hash mappings to keep (oldest pruned first)."] pub fn block_hash_count (& self) -> :: core :: result :: Result < :: core :: primitive :: u32 , :: subxt :: BasicError > { if self . client . metadata () . constant_hash ("System" , "BlockHashCount") ? == [26u8 , 201u8 , 14u8 , 127u8 , 151u8 , 212u8 , 14u8 , 28u8 , 184u8 , 180u8 , 96u8 , 223u8 , 210u8 , 69u8 , 176u8 , 187u8 , 183u8 , 124u8 , 4u8 , 13u8 , 0u8 , 241u8 , 151u8 , 202u8 , 41u8 , 152u8 , 230u8 , 247u8 , 138u8 , 23u8 , 132u8 , 49u8 ,] { let pallet = self . client . metadata () . pallet ("System") ? ; let constant = pallet . constant ("BlockHashCount") ? ; let value = :: subxt :: codec :: Decode :: decode (& mut & constant . value [..]) ? ; Ok (value) } else { Err (:: subxt :: MetadataError :: IncompatibleMetadata . into ()) } } # [doc = " The weight of runtime database operations the runtime can invoke."] pub fn db_weight (& self) -> :: core :: result :: Result < runtime_types :: frame_support :: weights :: RuntimeDbWeight , :: subxt :: BasicError > { if self . client . metadata () . constant_hash ("System" , "DbWeight") ? == [203u8 , 8u8 , 106u8 , 152u8 , 74u8 , 132u8 , 2u8 , 132u8 , 244u8 , 106u8 , 147u8 , 12u8 , 93u8 , 80u8 , 61u8 , 158u8 , 172u8 , 178u8 , 228u8 , 125u8 , 213u8 , 102u8 , 75u8 , 210u8 , 64u8 , 185u8 , 204u8 , 84u8 , 10u8 , 164u8 , 204u8 , 62u8 ,] { let pallet = self . client . metadata () . pallet ("System") ? ; let constant = pallet . constant ("DbWeight") ? ; let value = :: subxt :: codec :: Decode :: decode (& mut & constant . value [..]) ? ; Ok (value) } else { Err (:: subxt :: MetadataError :: IncompatibleMetadata . into ()) } } # [doc = " Get the chain's current version."] pub fn version (& self) -> :: core :: result :: Result < runtime_types :: sp_version :: RuntimeVersion , :: subxt :: BasicError > { if self . client . metadata () . constant_hash ("System" , "Version") ? == [94u8 , 38u8 , 84u8 , 42u8 , 79u8 , 171u8 , 95u8 , 229u8 , 82u8 , 12u8 , 86u8 , 145u8 , 94u8 , 53u8 , 9u8 , 195u8 , 122u8 , 250u8 , 104u8 , 145u8 , 64u8 , 146u8 , 154u8 , 148u8 , 43u8 , 129u8 , 108u8 , 233u8 , 142u8 , 45u8 , 73u8 , 238u8 ,] { let pallet = self . client . metadata () . pallet ("System") ? ; let constant = pallet . constant ("Version") ? ; let value = :: subxt :: codec :: Decode :: decode (& mut & constant . value [..]) ? ; Ok (value) } else { Err (:: subxt :: MetadataError :: IncompatibleMetadata . into ()) } } # [doc = " The designated SS85 prefix of this chain."] # [doc = ""] # [doc = " This replaces the \"ss58Format\" property declared in the chain spec. Reason is"] # [doc = " that the runtime should know about the prefix in order to make use of it as"] # [doc = " an identifier of the chain."] pub fn ss58_prefix (& self) -> :: core :: result :: Result < :: core :: primitive :: u16 , :: subxt :: BasicError > { if self . client . metadata () . constant_hash ("System" , "SS58Prefix") ? == [197u8 , 217u8 , 49u8 , 68u8 , 82u8 , 238u8 , 120u8 , 50u8 , 91u8 , 58u8 , 6u8 , 156u8 , 40u8 , 1u8 , 241u8 , 213u8 , 141u8 , 74u8 , 83u8 , 115u8 , 117u8 , 41u8 , 119u8 , 50u8 , 140u8 , 136u8 , 163u8 , 185u8 , 34u8 , 190u8 , 60u8 , 97u8 ,] { let pallet = self . client . metadata () . pallet ("System") ? ; let constant = pallet . constant ("SS58Prefix") ? ; let value = :: subxt :: codec :: Decode :: decode (& mut & constant . value [..]) ? ; Ok (value) } else { Err (:: subxt :: MetadataError :: IncompatibleMetadata . into ()) } } } } } pub mod timestamp { use super :: root_mod ; use super :: runtime_types ; pub mod calls { use super :: root_mod ; use super :: runtime_types ; type DispatchError = runtime_types :: sp_runtime :: DispatchError ; # [derive (:: subxt :: codec :: Decode , :: subxt :: codec :: Encode , Clone , Debug , Eq , PartialEq)] pub struct Set { # [codec (compact)] pub now : :: core :: primitive :: u64 , } impl :: subxt :: Call for Set { const PALLET : & 'static str = "Timestamp" ; const FUNCTION : & 'static str = "set" ; } pub struct TransactionApi < 'a , T : :: subxt :: Config , X > { client : & 'a :: subxt :: Client < T > , marker : :: core :: marker :: PhantomData < X > , } impl < 'a , T , X > TransactionApi < 'a , T , X > where T : :: subxt :: Config , X : :: subxt :: extrinsic :: ExtrinsicParams < T > , { pub fn new (client : & 'a :: subxt :: Client < T >) -> Self { Self { client , marker : :: core :: marker :: PhantomData } } # [doc = "Set the current time."] # [doc = ""] # [doc = "This call should be invoked exactly once per block. It will panic at the finalization"] # [doc = "phase, if this call hasn't been invoked by that time."] # [doc = ""] # [doc = "The timestamp should be greater than the previous one by the amount specified by"] # [doc = "`MinimumPeriod`."] # [doc = ""] # [doc = "The dispatch origin for this call must be `Inherent`."] # [doc = ""] # [doc = "# <weight>"] # [doc = "- `O(1)` (Note that implementations of `OnTimestampSet` must also be `O(1)`)"] # [doc = "- 1 storage read and 1 storage mutation (codec `O(1)`). (because of `DidUpdate::take` in"] # [doc = "  `on_finalize`)"] # [doc = "- 1 event handler `on_timestamp_set`. Must be `O(1)`."] # [doc = "# </weight>"] pub fn set (& self , now : :: core :: primitive :: u64 ,) -> Result < :: subxt :: SubmittableExtrinsic < 'a , T , X , Set , DispatchError , root_mod :: Event > , :: subxt :: BasicError > { if self . client . metadata () . call_hash :: < Set > () ? == [191u8 , 73u8 , 102u8 , 150u8 , 65u8 , 157u8 , 172u8 , 194u8 , 7u8 , 72u8 , 1u8 , 35u8 , 54u8 , 99u8 , 245u8 , 139u8 , 40u8 , 136u8 , 245u8 , 53u8 , 167u8 , 100u8 , 143u8 , 244u8 , 160u8 , 5u8 , 18u8 , 130u8 , 77u8 , 160u8 , 227u8 , 51u8 ,] { let call = Set { now , } ; Ok (:: subxt :: SubmittableExtrinsic :: new (self . client , call)) } else { Err (:: subxt :: MetadataError :: IncompatibleMetadata . into ()) } } } } pub mod storage { use super :: runtime_types ; pub struct Now ; impl :: subxt :: StorageEntry for Now { const PALLET : & 'static str = "Timestamp" ; const STORAGE : & 'static str = "Now" ; type Value = :: core :: primitive :: u64 ; fn key (& self) -> :: subxt :: StorageEntryKey { :: subxt :: StorageEntryKey :: Plain } } pub struct DidUpdate ; impl :: subxt :: StorageEntry for DidUpdate { const PALLET : & 'static str = "Timestamp" ; const STORAGE : & 'static str = "DidUpdate" ; type Value = :: core :: primitive :: bool ; fn key (& self) -> :: subxt :: StorageEntryKey { :: subxt :: StorageEntryKey :: Plain } } pub struct StorageApi < 'a , T : :: subxt :: Config > { client : & 'a :: subxt :: Client < T > , } impl < 'a , T : :: subxt :: Config > StorageApi < 'a , T > { pub fn new (client : & 'a :: subxt :: Client < T >) -> Self { Self { client } } # [doc = " Current time for the current block."] pub async fn now (& self , block_hash : :: core :: option :: Option < T :: Hash > ,) -> :: core :: result :: Result < :: core :: primitive :: u64 , :: subxt :: BasicError > { if self . client . metadata () . storage_hash :: < Now > () ? == [148u8 , 53u8 , 50u8 , 54u8 , 13u8 , 161u8 , 57u8 , 150u8 , 16u8 , 83u8 , 144u8 , 221u8 , 59u8 , 75u8 , 158u8 , 130u8 , 39u8 , 123u8 , 106u8 , 134u8 , 202u8 , 185u8 , 83u8 , 85u8 , 60u8 , 41u8 , 120u8 , 96u8 , 210u8 , 34u8 , 2u8 , 250u8 ,] { let entry = Now ; self . client . storage () . fetch_or_default (& entry , block_hash) . await } else { Err (:: subxt :: MetadataError :: IncompatibleMetadata . into ()) } } # [doc = " Did the timestamp get updated in this block?"] pub async fn did_update (& self , block_hash : :: core :: option :: Option < T :: Hash > ,) -> :: core :: result :: Result < :: core :: primitive :: bool , :: subxt :: BasicError > { if self . client . metadata () . storage_hash :: < DidUpdate > () ? == [70u8 , 13u8 , 92u8 , 186u8 , 80u8 , 151u8 , 167u8 , 90u8 , 158u8 , 232u8 , 175u8 , 13u8 , 103u8 , 135u8 , 2u8 , 78u8 , 16u8 , 6u8 , 39u8 , 158u8 , 167u8 , 85u8 , 27u8 , 47u8 , 122u8 , 73u8 , 127u8 , 26u8 , 35u8 , 168u8 , 72u8 , 204u8 ,] { let entry = DidUpdate ; self . client . storage () . fetch_or_default (& entry , block_hash) . await } else { Err (:: subxt :: MetadataError :: IncompatibleMetadata . into ()) } } } } pub mod constants { use super :: runtime_types ; pub struct ConstantsApi < 'a , T : :: subxt :: Config > { client : & 'a :: subxt :: Client < T > , } impl < 'a , T : :: subxt :: Config > ConstantsApi < 'a , T > { pub fn new (client : & 'a :: subxt :: Client < T >) -> Self { Self { client } } # [doc = " The minimum period between blocks. Beware that this is different to the *expected*"] # [doc = " period that the block production apparatus provides. Your chosen consensus system will"] # [doc = " generally work with this to determine a sensible block time. e.g. For Aura, it will be"] # [doc = " double this period on default settings."] pub fn minimum_period (& self) -> :: core :: result :: Result < :: core :: primitive :: u64 , :: subxt :: BasicError > { if self . client . metadata () . constant_hash ("Timestamp" , "MinimumPeriod") ? == [224u8 , 163u8 , 2u8 , 57u8 , 22u8 , 120u8 , 36u8 , 145u8 , 190u8 , 20u8 , 13u8 , 182u8 , 94u8 , 250u8 , 138u8 , 166u8 , 43u8 , 184u8 , 117u8 , 174u8 , 236u8 , 84u8 , 149u8 , 87u8 , 176u8 , 229u8 , 213u8 , 83u8 , 187u8 , 168u8 , 16u8 , 210u8 ,] { let pallet = self . client . metadata () . pallet ("Timestamp") ? ; let constant = pallet . constant ("MinimumPeriod") ? ; let value = :: subxt :: codec :: Decode :: decode (& mut & constant . value [..]) ? ; Ok (value) } else { Err (:: subxt :: MetadataError :: IncompatibleMetadata . into ()) } } } } } pub mod sudo { use super :: root_mod ; use super :: runtime_types ; pub mod calls { use super :: root_mod ; use super :: runtime_types ; type DispatchError = runtime_types :: sp_runtime :: DispatchError ; # [derive (:: subxt :: codec :: Decode , :: subxt :: codec :: Encode , Clone , Debug , Eq , PartialEq)] pub struct Sudo { pub call : :: std :: boxed :: Box < runtime_types :: egg_standalone_runtime :: Call > , } impl :: subxt :: Call for Sudo { const PALLET : & 'static str = "Sudo" ; const FUNCTION : & 'static str = "sudo" ; } # [derive (:: subxt :: codec :: Decode , :: subxt :: codec :: Encode , Clone , Debug , Eq , PartialEq)] pub struct SudoUncheckedWeight { pub call : :: std :: boxed :: Box < runtime_types :: egg_standalone_runtime :: Call > , pub weight : :: core :: primitive :: u64 , } impl :: subxt :: Call for SudoUncheckedWeight { const PALLET : & 'static str = "Sudo" ; const FUNCTION : & 'static str = "sudo_unchecked_weight" ; } # [derive (:: subxt :: codec :: Decode , :: subxt :: codec :: Encode , Clone , Debug , Eq , PartialEq)] pub struct SetKey { pub new : :: subxt :: sp_runtime :: MultiAddress < :: subxt :: sp_core :: crypto :: AccountId32 , :: core :: primitive :: u32 > , } impl :: subxt :: Call for SetKey { const PALLET : & 'static str = "Sudo" ; const FUNCTION : & 'static str = "set_key" ; } # [derive (:: subxt :: codec :: Decode , :: subxt :: codec :: Encode , Clone , Debug , Eq , PartialEq)] pub struct SudoAs { pub who : :: subxt :: sp_runtime :: MultiAddress < :: subxt :: sp_core :: crypto :: AccountId32 , :: core :: primitive :: u32 > , pub call : :: std :: boxed :: Box < runtime_types :: egg_standalone_runtime :: Call > , } impl :: subxt :: Call for SudoAs { const PALLET : & 'static str = "Sudo" ; const FUNCTION : & 'static str = "sudo_as" ; } pub struct TransactionApi < 'a , T : :: subxt :: Config , X > { client : & 'a :: subxt :: Client < T > , marker : :: core :: marker :: PhantomData < X > , } impl < 'a , T , X > TransactionApi < 'a , T , X > where T : :: subxt :: Config , X : :: subxt :: extrinsic :: ExtrinsicParams < T > , { pub fn new (client : & 'a :: subxt :: Client < T >) -> Self { Self { client , marker : :: core :: marker :: PhantomData } } # [doc = "Authenticates the sudo key and dispatches a function call with `Root` origin."] # [doc = ""] # [doc = "The dispatch origin for this call must be _Signed_."] # [doc = ""] # [doc = "# <weight>"] # [doc = "- O(1)."] # [doc = "- Limited storage reads."] # [doc = "- One DB write (event)."] # [doc = "- Weight of derivative `call` execution + 10,000."] # [doc = "# </weight>"] pub fn sudo (& self , call : runtime_types :: egg_standalone_runtime :: Call ,) -> Result < :: subxt :: SubmittableExtrinsic < 'a , T , X , Sudo , DispatchError , root_mod :: Event > , :: subxt :: BasicError > { if self . client . metadata () . call_hash :: < Sudo > () ? == [210u8 , 192u8 , 186u8 , 187u8 , 55u8 , 197u8 , 87u8 , 108u8 , 90u8 , 167u8 , 166u8 , 192u8 , 13u8 , 44u8 , 144u8 , 167u8 , 132u8 , 39u8 , 79u8 , 181u8 , 1u8 , 209u8 , 207u8 , 4u8 , 107u8 , 239u8 , 213u8 , 217u8 , 11u8 , 247u8 , 167u8 , 203u8 ,] { let call = Sudo { call : :: std :: boxed :: Box :: new (call) , } ; Ok (:: subxt :: SubmittableExtrinsic :: new (self . client , call)) } else { Err (:: subxt :: MetadataError :: IncompatibleMetadata . into ()) } } # [doc = "Authenticates the sudo key and dispatches a function call with `Root` origin."] # [doc = "This function does not check the weight of the call, and instead allows the"] # [doc = "Sudo user to specify the weight of the call."] # [doc = ""] # [doc = "The dispatch origin for this call must be _Signed_."] # [doc = ""] # [doc = "# <weight>"] # [doc = "- O(1)."] # [doc = "- The weight of this call is defined by the caller."] # [doc = "# </weight>"] pub fn sudo_unchecked_weight (& self , call : runtime_types :: egg_standalone_runtime :: Call , weight : :: core :: primitive :: u64 ,) -> Result < :: subxt :: SubmittableExtrinsic < 'a , T , X , SudoUncheckedWeight , DispatchError , root_mod :: Event > , :: subxt :: BasicError > { if self . client . metadata () . call_hash :: < SudoUncheckedWeight > () ? == [58u8 , 72u8 , 138u8 , 143u8 , 139u8 , 10u8 , 123u8 , 171u8 , 227u8 , 22u8 , 122u8 , 27u8 , 236u8 , 59u8 , 124u8 , 86u8 , 42u8 , 250u8 , 165u8 , 46u8 , 21u8 , 64u8 , 92u8 , 141u8 , 48u8 , 227u8 , 62u8 , 151u8 , 107u8 , 144u8 , 169u8 , 31u8 ,] { let call = SudoUncheckedWeight { call : :: std :: boxed :: Box :: new (call) , weight , } ; Ok (:: subxt :: SubmittableExtrinsic :: new (self . client , call)) } else { Err (:: subxt :: MetadataError :: IncompatibleMetadata . into ()) } } # [doc = "Authenticates the current sudo key and sets the given AccountId (`new`) as the new sudo"] # [doc = "key."] # [doc = ""] # [doc = "The dispatch origin for this call must be _Signed_."] # [doc = ""] # [doc = "# <weight>"] # [doc = "- O(1)."] # [doc = "- Limited storage reads."] # [doc = "- One DB change."] # [doc = "# </weight>"] pub fn set_key (& self , new : :: subxt :: sp_runtime :: MultiAddress < :: subxt :: sp_core :: crypto :: AccountId32 , :: core :: primitive :: u32 > ,) -> Result < :: subxt :: SubmittableExtrinsic < 'a , T , X , SetKey , DispatchError , root_mod :: Event > , :: subxt :: BasicError > { if self . client . metadata () . call_hash :: < SetKey > () ? == [142u8 , 228u8 , 169u8 , 153u8 , 89u8 , 247u8 , 116u8 , 76u8 , 245u8 , 199u8 , 2u8 , 131u8 , 195u8 , 249u8 , 201u8 , 178u8 , 212u8 , 253u8 , 144u8 , 48u8 , 172u8 , 25u8 , 184u8 , 72u8 , 32u8 , 150u8 , 161u8 , 116u8 , 72u8 , 162u8 , 236u8 , 131u8 ,] { let call = SetKey { new , } ; Ok (:: subxt :: SubmittableExtrinsic :: new (self . client , call)) } else { Err (:: subxt :: MetadataError :: IncompatibleMetadata . into ()) } } # [doc = "Authenticates the sudo key and dispatches a function call with `Signed` origin from"] # [doc = "a given account."] # [doc = ""] # [doc = "The dispatch origin for this call must be _Signed_."] # [doc = ""] # [doc = "# <weight>"] # [doc = "- O(1)."] # [doc = "- Limited storage reads."] # [doc = "- One DB write (event)."] # [doc = "- Weight of derivative `call` execution + 10,000."] # [doc = "# </weight>"] pub fn sudo_as (& self , who : :: subxt :: sp_runtime :: MultiAddress < :: subxt :: sp_core :: crypto :: AccountId32 , :: core :: primitive :: u32 > , call : runtime_types :: egg_standalone_runtime :: Call ,) -> Result < :: subxt :: SubmittableExtrinsic < 'a , T , X , SudoAs , DispatchError , root_mod :: Event > , :: subxt :: BasicError > { if self . client . metadata () . call_hash :: < SudoAs > () ? == [195u8 , 82u8 , 111u8 , 103u8 , 155u8 , 236u8 , 81u8 , 208u8 , 127u8 , 139u8 , 50u8 , 105u8 , 150u8 , 84u8 , 47u8 , 8u8 , 36u8 , 97u8 , 81u8 , 158u8 , 6u8 , 149u8 , 86u8 , 53u8 , 4u8 , 176u8 , 76u8 , 226u8 , 72u8 , 77u8 , 172u8 , 133u8 ,] { let call = SudoAs { who , call : :: std :: boxed :: Box :: new (call) , } ; Ok (:: subxt :: SubmittableExtrinsic :: new (self . client , call)) } else { Err (:: subxt :: MetadataError :: IncompatibleMetadata . into ()) } } } } pub type Event = runtime_types :: pallet_sudo :: pallet :: Event ; pub mod events { use super :: runtime_types ; # [derive (:: subxt :: codec :: Decode , :: subxt :: codec :: Encode , Clone , Debug , Eq , PartialEq)] # [doc = "A sudo just took place. \\[result\\]"] pub struct Sudid { pub sudo_result : :: core :: result :: Result < () , runtime_types :: sp_runtime :: DispatchError > , } impl :: subxt :: Event for Sudid { const PALLET : & 'static str = "Sudo" ; const EVENT : & 'static str = "Sudid" ; } # [derive (:: subxt :: codec :: Decode , :: subxt :: codec :: Encode , Clone , Debug , Eq , PartialEq)] # [doc = "The \\[sudoer\\] just switched identity; the old key is supplied if one existed."] pub struct KeyChanged { pub old_sudoer : :: core :: option :: Option < :: subxt :: sp_core :: crypto :: AccountId32 > , } impl :: subxt :: Event for KeyChanged { const PALLET : & 'static str = "Sudo" ; const EVENT : & 'static str = "KeyChanged" ; } # [derive (:: subxt :: codec :: Decode , :: subxt :: codec :: Encode , Clone , Debug , Eq , PartialEq)] # [doc = "A sudo just took place. \\[result\\]"] pub struct SudoAsDone { pub sudo_result : :: core :: result :: Result < () , runtime_types :: sp_runtime :: DispatchError > , } impl :: subxt :: Event for SudoAsDone { const PALLET : & 'static str = "Sudo" ; const EVENT : & 'static str = "SudoAsDone" ; } } pub mod storage { use super :: runtime_types ; pub struct Key ; impl :: subxt :: StorageEntry for Key { const PALLET : & 'static str = "Sudo" ; const STORAGE : & 'static str = "Key" ; type Value = :: subxt :: sp_core :: crypto :: AccountId32 ; fn key (& self) -> :: subxt :: StorageEntryKey { :: subxt :: StorageEntryKey :: Plain } } pub struct StorageApi < 'a , T : :: subxt :: Config > { client : & 'a :: subxt :: Client < T > , } impl < 'a , T : :: subxt :: Config > StorageApi < 'a , T > { pub fn new (client : & 'a :: subxt :: Client < T >) -> Self { Self { client } } # [doc = " The `AccountId` of the sudo key."] pub async fn key (& self , block_hash : :: core :: option :: Option < T :: Hash > ,) -> :: core :: result :: Result < :: core :: option :: Option < :: subxt :: sp_core :: crypto :: AccountId32 > , :: subxt :: BasicError > { if self . client . metadata () . storage_hash :: < Key > () ? == [222u8 , 90u8 , 158u8 , 233u8 , 184u8 , 23u8 , 141u8 , 135u8 , 81u8 , 187u8 , 47u8 , 100u8 , 30u8 , 81u8 , 239u8 , 197u8 , 249u8 , 253u8 , 73u8 , 207u8 , 161u8 , 141u8 , 174u8 , 59u8 , 74u8 , 181u8 , 10u8 , 90u8 , 22u8 , 109u8 , 62u8 , 27u8 ,] { let entry = Key ; self . client . storage () . fetch (& entry , block_hash) . await } else { Err (:: subxt :: MetadataError :: IncompatibleMetadata . into ()) } } } } } pub mod randomness_collective_flip { use super :: root_mod ; use super :: runtime_types ; pub mod storage { use super :: runtime_types ; pub struct RandomMaterial ; impl :: subxt :: StorageEntry for RandomMaterial { const PALLET : & 'static str = "RandomnessCollectiveFlip" ; const STORAGE : & 'static str = "RandomMaterial" ; type Value = runtime_types :: sp_runtime :: bounded :: bounded_vec :: BoundedVec < :: subxt :: sp_core :: H256 > ; fn key (& self) -> :: subxt :: StorageEntryKey { :: subxt :: StorageEntryKey :: Plain } } pub struct StorageApi < 'a , T : :: subxt :: Config > { client : & 'a :: subxt :: Client < T > , } impl < 'a , T : :: subxt :: Config > StorageApi < 'a , T > { pub fn new (client : & 'a :: subxt :: Client < T >) -> Self { Self { client } } # [doc = " Series of block headers from the last 81 blocks that acts as random seed material. This"] # [doc = " is arranged as a ring buffer with `block_number % 81` being the index into the `Vec` of"] # [doc = " the oldest hash."] pub async fn random_material (& self , block_hash : :: core :: option :: Option < T :: Hash > ,) -> :: core :: result :: Result < runtime_types :: sp_runtime :: bounded :: bounded_vec :: BoundedVec < :: subxt :: sp_core :: H256 > , :: subxt :: BasicError > { if self . client . metadata () . storage_hash :: < RandomMaterial > () ? == [60u8 , 176u8 , 119u8 , 155u8 , 161u8 , 136u8 , 144u8 , 88u8 , 26u8 , 57u8 , 142u8 , 34u8 , 5u8 , 37u8 , 115u8 , 11u8 , 90u8 , 222u8 , 147u8 , 194u8 , 82u8 , 194u8 , 70u8 , 227u8 , 175u8 , 198u8 , 235u8 , 24u8 , 7u8 , 87u8 , 203u8 , 182u8 ,] { let entry = RandomMaterial ; self . client . storage () . fetch_or_default (& entry , block_hash) . await } else { Err (:: subxt :: MetadataError :: IncompatibleMetadata . into ()) } } } } } pub mod balances { use super :: root_mod ; use super :: runtime_types ; pub mod calls { use super :: root_mod ; use super :: runtime_types ; type DispatchError = runtime_types :: sp_runtime :: DispatchError ; # [derive (:: subxt :: codec :: Decode , :: subxt :: codec :: Encode , Clone , Debug , Eq , PartialEq)] pub struct Transfer { pub dest : :: subxt :: sp_runtime :: MultiAddress < :: subxt :: sp_core :: crypto :: AccountId32 , :: core :: primitive :: u32 > , # [codec (compact)] pub value : :: core :: primitive :: u128 , } impl :: subxt :: Call for Transfer { const PALLET : & 'static str = "Balances" ; const FUNCTION : & 'static str = "transfer" ; } # [derive (:: subxt :: codec :: Decode , :: subxt :: codec :: Encode , Clone , Debug , Eq , PartialEq)] pub struct SetBalance { pub who : :: subxt :: sp_runtime :: MultiAddress < :: subxt :: sp_core :: crypto :: AccountId32 , :: core :: primitive :: u32 > , # [codec (compact)] pub new_free : :: core :: primitive :: u128 , # [codec (compact)] pub new_reserved : :: core :: primitive :: u128 , } impl :: subxt :: Call for SetBalance { const PALLET : & 'static str = "Balances" ; const FUNCTION : & 'static str = "set_balance" ; } # [derive (:: subxt :: codec :: Decode , :: subxt :: codec :: Encode , Clone , Debug , Eq , PartialEq)] pub struct ForceTransfer { pub source : :: subxt :: sp_runtime :: MultiAddress < :: subxt :: sp_core :: crypto :: AccountId32 , :: core :: primitive :: u32 > , pub dest : :: subxt :: sp_runtime :: MultiAddress < :: subxt :: sp_core :: crypto :: AccountId32 , :: core :: primitive :: u32 > , # [codec (compact)] pub value : :: core :: primitive :: u128 , } impl :: subxt :: Call for ForceTransfer { const PALLET : & 'static str = "Balances" ; const FUNCTION : & 'static str = "force_transfer" ; } # [derive (:: subxt :: codec :: Decode , :: subxt :: codec :: Encode , Clone , Debug , Eq , PartialEq)] pub struct TransferKeepAlive { pub dest : :: subxt :: sp_runtime :: MultiAddress < :: subxt :: sp_core :: crypto :: AccountId32 , :: core :: primitive :: u32 > , # [codec (compact)] pub value : :: core :: primitive :: u128 , } impl :: subxt :: Call for TransferKeepAlive { const PALLET : & 'static str = "Balances" ; const FUNCTION : & 'static str = "transfer_keep_alive" ; } # [derive (:: subxt :: codec :: Decode , :: subxt :: codec :: Encode , Clone , Debug , Eq , PartialEq)] pub struct TransferAll { pub dest : :: subxt :: sp_runtime :: MultiAddress < :: subxt :: sp_core :: crypto :: AccountId32 , :: core :: primitive :: u32 > , pub keep_alive : :: core :: primitive :: bool , } impl :: subxt :: Call for TransferAll { const PALLET : & 'static str = "Balances" ; const FUNCTION : & 'static str = "transfer_all" ; } # [derive (:: subxt :: codec :: Decode , :: subxt :: codec :: Encode , Clone , Debug , Eq , PartialEq)] pub struct ForceUnreserve { pub who : :: subxt :: sp_runtime :: MultiAddress < :: subxt :: sp_core :: crypto :: AccountId32 , :: core :: primitive :: u32 > , pub amount : :: core :: primitive :: u128 , } impl :: subxt :: Call for ForceUnreserve { const PALLET : & 'static str = "Balances" ; const FUNCTION : & 'static str = "force_unreserve" ; } pub struct TransactionApi < 'a , T : :: subxt :: Config , X > { client : & 'a :: subxt :: Client < T > , marker : :: core :: marker :: PhantomData < X > , } impl < 'a , T , X > TransactionApi < 'a , T , X > where T : :: subxt :: Config , X : :: subxt :: extrinsic :: ExtrinsicParams < T > , { pub fn new (client : & 'a :: subxt :: Client < T >) -> Self { Self { client , marker : :: core :: marker :: PhantomData } } # [doc = "Transfer some liquid free balance to another account."] # [doc = ""] # [doc = "`transfer` will set the `FreeBalance` of the sender and receiver."] # [doc = "If the sender's account is below the existential deposit as a result"] # [doc = "of the transfer, the account will be reaped."] # [doc = ""] # [doc = "The dispatch origin for this call must be `Signed` by the transactor."] # [doc = ""] # [doc = "# <weight>"] # [doc = "- Dependent on arguments but not critical, given proper implementations for input config"] # [doc = "  types. See related functions below."] # [doc = "- It contains a limited number of reads and writes internally and no complex"] # [doc = "  computation."] # [doc = ""] # [doc = "Related functions:"] # [doc = ""] # [doc = "  - `ensure_can_withdraw` is always called internally but has a bounded complexity."] # [doc = "  - Transferring balances to accounts that did not exist before will cause"] # [doc = "    `T::OnNewAccount::on_new_account` to be called."] # [doc = "  - Removing enough funds from an account will trigger `T::DustRemoval::on_unbalanced`."] # [doc = "  - `transfer_keep_alive` works the same way as `transfer`, but has an additional check"] # [doc = "    that the transfer will not kill the origin account."] # [doc = "---------------------------------"] # [doc = "- Origin account is already in memory, so no DB operations for them."] # [doc = "# </weight>"] pub fn transfer (& self , dest : :: subxt :: sp_runtime :: MultiAddress < :: subxt :: sp_core :: crypto :: AccountId32 , :: core :: primitive :: u32 > , value : :: core :: primitive :: u128 ,) -> Result < :: subxt :: SubmittableExtrinsic < 'a , T , X , Transfer , DispatchError , root_mod :: Event > , :: subxt :: BasicError > { if self . client . metadata () . call_hash :: < Transfer > () ? == [51u8 , 127u8 , 65u8 , 149u8 , 186u8 , 25u8 , 125u8 , 225u8 , 172u8 , 243u8 , 144u8 , 156u8 , 86u8 , 150u8 , 89u8 , 114u8 , 9u8 , 142u8 , 44u8 , 98u8 , 24u8 , 252u8 , 83u8 , 64u8 , 78u8 , 247u8 , 136u8 , 130u8 , 203u8 , 10u8 , 206u8 , 48u8 ,] { let call = Transfer { dest , value , } ; Ok (:: subxt :: SubmittableExtrinsic :: new (self . client , call)) } else { Err (:: subxt :: MetadataError :: IncompatibleMetadata . into ()) } } # [doc = "Set the balances of a given account."] # [doc = ""] # [doc = "This will alter `FreeBalance` and `ReservedBalance` in storage. it will"] # [doc = "also alter the total issuance of the system (`TotalIssuance`) appropriately."] # [doc = "If the new free or reserved balance is below the existential deposit,"] # [doc = "it will reset the account nonce (`frame_system::AccountNonce`)."] # [doc = ""] # [doc = "The dispatch origin for this call is `root`."] pub fn set_balance (& self , who : :: subxt :: sp_runtime :: MultiAddress < :: subxt :: sp_core :: crypto :: AccountId32 , :: core :: primitive :: u32 > , new_free : :: core :: primitive :: u128 , new_reserved : :: core :: primitive :: u128 ,) -> Result < :: subxt :: SubmittableExtrinsic < 'a , T , X , SetBalance , DispatchError , root_mod :: Event > , :: subxt :: BasicError > { if self . client . metadata () . call_hash :: < SetBalance > () ? == [126u8 , 224u8 , 173u8 , 235u8 , 17u8 , 214u8 , 51u8 , 73u8 , 132u8 , 184u8 , 52u8 , 124u8 , 147u8 , 120u8 , 186u8 , 82u8 , 247u8 , 199u8 , 89u8 , 31u8 , 111u8 , 94u8 , 224u8 , 130u8 , 198u8 , 2u8 , 60u8 , 0u8 , 16u8 , 248u8 , 243u8 , 216u8 ,] { let call = SetBalance { who , new_free , new_reserved , } ; Ok (:: subxt :: SubmittableExtrinsic :: new (self . client , call)) } else { Err (:: subxt :: MetadataError :: IncompatibleMetadata . into ()) } } # [doc = "Exactly as `transfer`, except the origin must be root and the source account may be"] # [doc = "specified."] # [doc = "# <weight>"] # [doc = "- Same as transfer, but additional read and write because the source account is not"] # [doc = "  assumed to be in the overlay."] # [doc = "# </weight>"] pub fn force_transfer (& self , source : :: subxt :: sp_runtime :: MultiAddress < :: subxt :: sp_core :: crypto :: AccountId32 , :: core :: primitive :: u32 > , dest : :: subxt :: sp_runtime :: MultiAddress < :: subxt :: sp_core :: crypto :: AccountId32 , :: core :: primitive :: u32 > , value : :: core :: primitive :: u128 ,) -> Result < :: subxt :: SubmittableExtrinsic < 'a , T , X , ForceTransfer , DispatchError , root_mod :: Event > , :: subxt :: BasicError > { if self . client . metadata () . call_hash :: < ForceTransfer > () ? == [39u8 , 171u8 , 216u8 , 52u8 , 120u8 , 195u8 , 8u8 , 202u8 , 157u8 , 154u8 , 191u8 , 235u8 , 163u8 , 121u8 , 132u8 , 119u8 , 166u8 , 162u8 , 163u8 , 68u8 , 144u8 , 193u8 , 97u8 , 194u8 , 130u8 , 136u8 , 234u8 , 84u8 , 177u8 , 134u8 , 0u8 , 232u8 ,] { let call = ForceTransfer { source , dest , value , } ; Ok (:: subxt :: SubmittableExtrinsic :: new (self . client , call)) } else { Err (:: subxt :: MetadataError :: IncompatibleMetadata . into ()) } } # [doc = "Same as the [`transfer`] call, but with a check that the transfer will not kill the"] # [doc = "origin account."] # [doc = ""] # [doc = "99% of the time you want [`transfer`] instead."] # [doc = ""] # [doc = "[`transfer`]: struct.Pallet.html#method.transfer"] pub fn transfer_keep_alive (& self , dest : :: subxt :: sp_runtime :: MultiAddress < :: subxt :: sp_core :: crypto :: AccountId32 , :: core :: primitive :: u32 > , value : :: core :: primitive :: u128 ,) -> Result < :: subxt :: SubmittableExtrinsic < 'a , T , X , TransferKeepAlive , DispatchError , root_mod :: Event > , :: subxt :: BasicError > { if self . client . metadata () . call_hash :: < TransferKeepAlive > () ? == [81u8 , 224u8 , 225u8 , 42u8 , 20u8 , 198u8 , 176u8 , 165u8 , 166u8 , 150u8 , 143u8 , 162u8 , 202u8 , 240u8 , 59u8 , 171u8 , 17u8 , 168u8 , 211u8 , 217u8 , 137u8 , 108u8 , 207u8 , 95u8 , 221u8 , 51u8 , 152u8 , 4u8 , 208u8 , 79u8 , 251u8 , 29u8 ,] { let call = TransferKeepAlive { dest , value , } ; Ok (:: subxt :: SubmittableExtrinsic :: new (self . client , call)) } else { Err (:: subxt :: MetadataError :: IncompatibleMetadata . into ()) } } # [doc = "Transfer the entire transferable balance from the caller account."] # [doc = ""] # [doc = "NOTE: This function only attempts to transfer _transferable_ balances. This means that"] # [doc = "any locked, reserved, or existential deposits (when `keep_alive` is `true`), will not be"] # [doc = "transferred by this function. To ensure that this function results in a killed account,"] # [doc = "you might need to prepare the account by removing any reference counters, storage"] # [doc = "deposits, etc..."] # [doc = ""] # [doc = "The dispatch origin of this call must be Signed."] # [doc = ""] # [doc = "- `dest`: The recipient of the transfer."] # [doc = "- `keep_alive`: A boolean to determine if the `transfer_all` operation should send all"] # [doc = "  of the funds the account has, causing the sender account to be killed (false), or"] # [doc = "  transfer everything except at least the existential deposit, which will guarantee to"] # [doc = "  keep the sender account alive (true). # <weight>"] # [doc = "- O(1). Just like transfer, but reading the user's transferable balance first."] # [doc = "  #</weight>"] pub fn transfer_all (& self , dest : :: subxt :: sp_runtime :: MultiAddress < :: subxt :: sp_core :: crypto :: AccountId32 , :: core :: primitive :: u32 > , keep_alive : :: core :: primitive :: bool ,) -> Result < :: subxt :: SubmittableExtrinsic < 'a , T , X , TransferAll , DispatchError , root_mod :: Event > , :: subxt :: BasicError > { if self . client . metadata () . call_hash :: < TransferAll > () ? == [48u8 , 241u8 , 202u8 , 6u8 , 29u8 , 207u8 , 104u8 , 141u8 , 218u8 , 18u8 , 127u8 , 214u8 , 99u8 , 196u8 , 39u8 , 229u8 , 120u8 , 123u8 , 130u8 , 56u8 , 129u8 , 169u8 , 149u8 , 62u8 , 221u8 , 108u8 , 55u8 , 201u8 , 106u8 , 36u8 , 255u8 , 85u8 ,] { let call = TransferAll { dest , keep_alive , } ; Ok (:: subxt :: SubmittableExtrinsic :: new (self . client , call)) } else { Err (:: subxt :: MetadataError :: IncompatibleMetadata . into ()) } } # [doc = "Unreserve some balance from a user by force."] # [doc = ""] # [doc = "Can only be called by ROOT."] pub fn force_unreserve (& self , who : :: subxt :: sp_runtime :: MultiAddress < :: subxt :: sp_core :: crypto :: AccountId32 , :: core :: primitive :: u32 > , amount : :: core :: primitive :: u128 ,) -> Result < :: subxt :: SubmittableExtrinsic < 'a , T , X , ForceUnreserve , DispatchError , root_mod :: Event > , :: subxt :: BasicError > { if self . client . metadata () . call_hash :: < ForceUnreserve > () ? == [4u8 , 231u8 , 55u8 , 137u8 , 114u8 , 76u8 , 44u8 , 166u8 , 28u8 , 224u8 , 22u8 , 92u8 , 76u8 , 124u8 , 219u8 , 29u8 , 204u8 , 207u8 , 179u8 , 134u8 , 93u8 , 137u8 , 33u8 , 178u8 , 174u8 , 106u8 , 132u8 , 204u8 , 180u8 , 122u8 , 162u8 , 110u8 ,] { let call = ForceUnreserve { who , amount , } ; Ok (:: subxt :: SubmittableExtrinsic :: new (self . client , call)) } else { Err (:: subxt :: MetadataError :: IncompatibleMetadata . into ()) } } } } pub type Event = runtime_types :: pallet_balances :: pallet :: Event ; pub mod events { use super :: runtime_types ; # [derive (:: subxt :: codec :: Decode , :: subxt :: codec :: Encode , Clone , Debug , Eq , PartialEq)] # [doc = "An account was created with some free balance."] pub struct Endowed { pub account : :: subxt :: sp_core :: crypto :: AccountId32 , pub free_balance : :: core :: primitive :: u128 , } impl :: subxt :: Event for Endowed { const PALLET : & 'static str = "Balances" ; const EVENT : & 'static str = "Endowed" ; } # [derive (:: subxt :: codec :: Decode , :: subxt :: codec :: Encode , Clone , Debug , Eq , PartialEq)] # [doc = "An account was removed whose balance was non-zero but below ExistentialDeposit,"] # [doc = "resulting in an outright loss."] pub struct DustLost { pub account : :: subxt :: sp_core :: crypto :: AccountId32 , pub amount : :: core :: primitive :: u128 , } impl :: subxt :: Event for DustLost { const PALLET : & 'static str = "Balances" ; const EVENT : & 'static str = "DustLost" ; } # [derive (:: subxt :: codec :: Decode , :: subxt :: codec :: Encode , Clone , Debug , Eq , PartialEq)] # [doc = "Transfer succeeded."] pub struct Transfer { pub from : :: subxt :: sp_core :: crypto :: AccountId32 , pub to : :: subxt :: sp_core :: crypto :: AccountId32 , pub amount : :: core :: primitive :: u128 , } impl :: subxt :: Event for Transfer { const PALLET : & 'static str = "Balances" ; const EVENT : & 'static str = "Transfer" ; } # [derive (:: subxt :: codec :: Decode , :: subxt :: codec :: Encode , Clone , Debug , Eq , PartialEq)] # [doc = "A balance was set by root."] pub struct BalanceSet { pub who : :: subxt :: sp_core :: crypto :: AccountId32 , pub free : :: core :: primitive :: u128 , pub reserved : :: core :: primitive :: u128 , } impl :: subxt :: Event for BalanceSet { const PALLET : & 'static str = "Balances" ; const EVENT : & 'static str = "BalanceSet" ; } # [derive (:: subxt :: codec :: Decode , :: subxt :: codec :: Encode , Clone , Debug , Eq , PartialEq)] # [doc = "Some balance was reserved (moved from free to reserved)."] pub struct Reserved { pub who : :: subxt :: sp_core :: crypto :: AccountId32 , pub amount : :: core :: primitive :: u128 , } impl :: subxt :: Event for Reserved { const PALLET : & 'static str = "Balances" ; const EVENT : & 'static str = "Reserved" ; } # [derive (:: subxt :: codec :: Decode , :: subxt :: codec :: Encode , Clone , Debug , Eq , PartialEq)] # [doc = "Some balance was unreserved (moved from reserved to free)."] pub struct Unreserved { pub who : :: subxt :: sp_core :: crypto :: AccountId32 , pub amount : :: core :: primitive :: u128 , } impl :: subxt :: Event for Unreserved { const PALLET : & 'static str = "Balances" ; const EVENT : & 'static str = "Unreserved" ; } # [derive (:: subxt :: codec :: Decode , :: subxt :: codec :: Encode , Clone , Debug , Eq , PartialEq)] # [doc = "Some balance was moved from the reserve of the first account to the second account."] # [doc = "Final argument indicates the destination balance type."] pub struct ReserveRepatriated { pub from : :: subxt :: sp_core :: crypto :: AccountId32 , pub to : :: subxt :: sp_core :: crypto :: AccountId32 , pub amount : :: core :: primitive :: u128 , pub destination_status : runtime_types :: frame_support :: traits :: tokens :: misc :: BalanceStatus , } impl :: subxt :: Event for ReserveRepatriated { const PALLET : & 'static str = "Balances" ; const EVENT : & 'static str = "ReserveRepatriated" ; } # [derive (:: subxt :: codec :: Decode , :: subxt :: codec :: Encode , Clone , Debug , Eq , PartialEq)] # [doc = "Some amount was deposited (e.g. for transaction fees)."] pub struct Deposit { pub who : :: subxt :: sp_core :: crypto :: AccountId32 , pub amount : :: core :: primitive :: u128 , } impl :: subxt :: Event for Deposit { const PALLET : & 'static str = "Balances" ; const EVENT : & 'static str = "Deposit" ; } # [derive (:: subxt :: codec :: Decode , :: subxt :: codec :: Encode , Clone , Debug , Eq , PartialEq)] # [doc = "Some amount was withdrawn from the account (e.g. for transaction fees)."] pub struct Withdraw { pub who : :: subxt :: sp_core :: crypto :: AccountId32 , pub amount : :: core :: primitive :: u128 , } impl :: subxt :: Event for Withdraw { const PALLET : & 'static str = "Balances" ; const EVENT : & 'static str = "Withdraw" ; } # [derive (:: subxt :: codec :: Decode , :: subxt :: codec :: Encode , Clone , Debug , Eq , PartialEq)] # [doc = "Some amount was removed from the account (e.g. for misbehavior)."] pub struct Slashed { pub who : :: subxt :: sp_core :: crypto :: AccountId32 , pub amount : :: core :: primitive :: u128 , } impl :: subxt :: Event for Slashed { const PALLET : & 'static str = "Balances" ; const EVENT : & 'static str = "Slashed" ; } } pub mod storage { use super :: runtime_types ; pub struct TotalIssuance ; impl :: subxt :: StorageEntry for TotalIssuance { const PALLET : & 'static str = "Balances" ; const STORAGE : & 'static str = "TotalIssuance" ; type Value = :: core :: primitive :: u128 ; fn key (& self) -> :: subxt :: StorageEntryKey { :: subxt :: StorageEntryKey :: Plain } } pub struct Account < 'a > (pub & 'a :: subxt :: sp_core :: crypto :: AccountId32) ; impl :: subxt :: StorageEntry for Account < '_ > { const PALLET : & 'static str = "Balances" ; const STORAGE : & 'static str = "Account" ; type Value = runtime_types :: pallet_balances :: AccountData < :: core :: primitive :: u128 > ; fn key (& self) -> :: subxt :: StorageEntryKey { :: subxt :: StorageEntryKey :: Map (vec ! [:: subxt :: StorageMapKey :: new (& self . 0 , :: subxt :: StorageHasher :: Blake2_128Concat)]) } } pub struct Locks < 'a > (pub & 'a :: subxt :: sp_core :: crypto :: AccountId32) ; impl :: subxt :: StorageEntry for Locks < '_ > { const PALLET : & 'static str = "Balances" ; const STORAGE : & 'static str = "Locks" ; type Value = runtime_types :: sp_runtime :: bounded :: weak_bounded_vec :: WeakBoundedVec < runtime_types :: pallet_balances :: BalanceLock < :: core :: primitive :: u128 > > ; fn key (& self) -> :: subxt :: StorageEntryKey { :: subxt :: StorageEntryKey :: Map (vec ! [:: subxt :: StorageMapKey :: new (& self . 0 , :: subxt :: StorageHasher :: Blake2_128Concat)]) } } pub struct Reserves < 'a > (pub & 'a :: subxt :: sp_core :: crypto :: AccountId32) ; impl :: subxt :: StorageEntry for Reserves < '_ > { const PALLET : & 'static str = "Balances" ; const STORAGE : & 'static str = "Reserves" ; type Value = runtime_types :: sp_runtime :: bounded :: bounded_vec :: BoundedVec < runtime_types :: pallet_balances :: ReserveData < [:: core :: primitive :: u8 ; 8usize] , :: core :: primitive :: u128 > > ; fn key (& self) -> :: subxt :: StorageEntryKey { :: subxt :: StorageEntryKey :: Map (vec ! [:: subxt :: StorageMapKey :: new (& self . 0 , :: subxt :: StorageHasher :: Blake2_128Concat)]) } } pub struct StorageVersion ; impl :: subxt :: StorageEntry for StorageVersion { const PALLET : & 'static str = "Balances" ; const STORAGE : & 'static str = "StorageVersion" ; type Value = runtime_types :: pallet_balances :: Releases ; fn key (& self) -> :: subxt :: StorageEntryKey { :: subxt :: StorageEntryKey :: Plain } } pub struct StorageApi < 'a , T : :: subxt :: Config > { client : & 'a :: subxt :: Client < T > , } impl < 'a , T : :: subxt :: Config > StorageApi < 'a , T > { pub fn new (client : & 'a :: subxt :: Client < T >) -> Self { Self { client } } # [doc = " The total units issued in the system."] pub async fn total_issuance (& self , block_hash : :: core :: option :: Option < T :: Hash > ,) -> :: core :: result :: Result < :: core :: primitive :: u128 , :: subxt :: BasicError > { if self . client . metadata () . storage_hash :: < TotalIssuance > () ? == [1u8 , 206u8 , 252u8 , 237u8 , 6u8 , 30u8 , 20u8 , 232u8 , 164u8 , 115u8 , 51u8 , 156u8 , 156u8 , 206u8 , 241u8 , 187u8 , 44u8 , 84u8 , 25u8 , 164u8 , 235u8 , 20u8 , 86u8 , 242u8 , 124u8 , 23u8 , 28u8 , 140u8 , 26u8 , 73u8 , 231u8 , 51u8 ,] { let entry = TotalIssuance ; self . client . storage () . fetch_or_default (& entry , block_hash) . await } else { Err (:: subxt :: MetadataError :: IncompatibleMetadata . into ()) } } # [doc = " The Balances pallet example of storing the balance of an account."] # [doc = ""] # [doc = " # Example"] # [doc = ""] # [doc = " ```nocompile"] # [doc = "  impl pallet_balances::Config for Runtime {"] # [doc = "    type AccountStore = StorageMapShim<Self::Account<Runtime>, frame_system::Provider<Runtime>, AccountId, Self::AccountData<Balance>>"] # [doc = "  }"] # [doc = " ```"] # [doc = ""] # [doc = " You can also store the balance of an account in the `System` pallet."] # [doc = ""] # [doc = " # Example"] # [doc = ""] # [doc = " ```nocompile"] # [doc = "  impl pallet_balances::Config for Runtime {"] # [doc = "   type AccountStore = System"] # [doc = "  }"] # [doc = " ```"] # [doc = ""] # [doc = " But this comes with tradeoffs, storing account balances in the system pallet stores"] # [doc = " `frame_system` data alongside the account data contrary to storing account balances in the"] # [doc = " `Balances` pallet, which uses a `StorageMap` to store balances data only."] # [doc = " NOTE: This is only used in the case that this pallet is used to store balances."] pub async fn account (& self , _0 : & :: subxt :: sp_core :: crypto :: AccountId32 , block_hash : :: core :: option :: Option < T :: Hash > ,) -> :: core :: result :: Result < runtime_types :: pallet_balances :: AccountData < :: core :: primitive :: u128 > , :: subxt :: BasicError > { if self . client . metadata () . storage_hash :: < Account > () ? == [129u8 , 169u8 , 171u8 , 206u8 , 229u8 , 178u8 , 69u8 , 118u8 , 199u8 , 64u8 , 254u8 , 67u8 , 16u8 , 154u8 , 160u8 , 197u8 , 177u8 , 161u8 , 148u8 , 199u8 , 78u8 , 219u8 , 187u8 , 83u8 , 99u8 , 110u8 , 207u8 , 252u8 , 243u8 , 39u8 , 46u8 , 106u8 ,] { let entry = Account (_0) ; self . client . storage () . fetch_or_default (& entry , block_hash) . await } else { Err (:: subxt :: MetadataError :: IncompatibleMetadata . into ()) } } # [doc = " The Balances pallet example of storing the balance of an account."] # [doc = ""] # [doc = " # Example"] # [doc = ""] # [doc = " ```nocompile"] # [doc = "  impl pallet_balances::Config for Runtime {"] # [doc = "    type AccountStore = StorageMapShim<Self::Account<Runtime>, frame_system::Provider<Runtime>, AccountId, Self::AccountData<Balance>>"] # [doc = "  }"] # [doc = " ```"] # [doc = ""] # [doc = " You can also store the balance of an account in the `System` pallet."] # [doc = ""] # [doc = " # Example"] # [doc = ""] # [doc = " ```nocompile"] # [doc = "  impl pallet_balances::Config for Runtime {"] # [doc = "   type AccountStore = System"] # [doc = "  }"] # [doc = " ```"] # [doc = ""] # [doc = " But this comes with tradeoffs, storing account balances in the system pallet stores"] # [doc = " `frame_system` data alongside the account data contrary to storing account balances in the"] # [doc = " `Balances` pallet, which uses a `StorageMap` to store balances data only."] # [doc = " NOTE: This is only used in the case that this pallet is used to store balances."] pub async fn account_iter (& self , block_hash : :: core :: option :: Option < T :: Hash > ,) -> :: core :: result :: Result < :: subxt :: KeyIter < 'a , T , Account < 'a > > , :: subxt :: BasicError > { if self . client . metadata () . storage_hash :: < Account > () ? == [129u8 , 169u8 , 171u8 , 206u8 , 229u8 , 178u8 , 69u8 , 118u8 , 199u8 , 64u8 , 254u8 , 67u8 , 16u8 , 154u8 , 160u8 , 197u8 , 177u8 , 161u8 , 148u8 , 199u8 , 78u8 , 219u8 , 187u8 , 83u8 , 99u8 , 110u8 , 207u8 , 252u8 , 243u8 , 39u8 , 46u8 , 106u8 ,] { self . client . storage () . iter (block_hash) . await } else { Err (:: subxt :: MetadataError :: IncompatibleMetadata . into ()) } } # [doc = " Any liquidity locks on some account balances."] # [doc = " NOTE: Should only be accessed when setting, changing and freeing a lock."] pub async fn locks (& self , _0 : & :: subxt :: sp_core :: crypto :: AccountId32 , block_hash : :: core :: option :: Option < T :: Hash > ,) -> :: core :: result :: Result < runtime_types :: sp_runtime :: bounded :: weak_bounded_vec :: WeakBoundedVec < runtime_types :: pallet_balances :: BalanceLock < :: core :: primitive :: u128 > > , :: subxt :: BasicError > { if self . client . metadata () . storage_hash :: < Locks > () ? == [31u8 , 76u8 , 213u8 , 60u8 , 86u8 , 11u8 , 155u8 , 151u8 , 33u8 , 212u8 , 74u8 , 89u8 , 174u8 , 74u8 , 195u8 , 107u8 , 29u8 , 163u8 , 178u8 , 34u8 , 209u8 , 8u8 , 201u8 , 237u8 , 77u8 , 99u8 , 205u8 , 212u8 , 236u8 , 132u8 , 2u8 , 252u8 ,] { let entry = Locks (_0) ; self . client . storage () . fetch_or_default (& entry , block_hash) . await } else { Err (:: subxt :: MetadataError :: IncompatibleMetadata . into ()) } } # [doc = " Any liquidity locks on some account balances."] # [doc = " NOTE: Should only be accessed when setting, changing and freeing a lock."] pub async fn locks_iter (& self , block_hash : :: core :: option :: Option < T :: Hash > ,) -> :: core :: result :: Result < :: subxt :: KeyIter < 'a , T , Locks < 'a > > , :: subxt :: BasicError > { if self . client . metadata () . storage_hash :: < Locks > () ? == [31u8 , 76u8 , 213u8 , 60u8 , 86u8 , 11u8 , 155u8 , 151u8 , 33u8 , 212u8 , 74u8 , 89u8 , 174u8 , 74u8 , 195u8 , 107u8 , 29u8 , 163u8 , 178u8 , 34u8 , 209u8 , 8u8 , 201u8 , 237u8 , 77u8 , 99u8 , 205u8 , 212u8 , 236u8 , 132u8 , 2u8 , 252u8 ,] { self . client . storage () . iter (block_hash) . await } else { Err (:: subxt :: MetadataError :: IncompatibleMetadata . into ()) } } # [doc = " Named reserves on some account balances."] pub async fn reserves (& self , _0 : & :: subxt :: sp_core :: crypto :: AccountId32 , block_hash : :: core :: option :: Option < T :: Hash > ,) -> :: core :: result :: Result < runtime_types :: sp_runtime :: bounded :: bounded_vec :: BoundedVec < runtime_types :: pallet_balances :: ReserveData < [:: core :: primitive :: u8 ; 8usize] , :: core :: primitive :: u128 > > , :: subxt :: BasicError > { if self . client . metadata () . storage_hash :: < Reserves > () ? == [103u8 , 6u8 , 69u8 , 151u8 , 81u8 , 40u8 , 146u8 , 113u8 , 56u8 , 239u8 , 104u8 , 31u8 , 168u8 , 242u8 , 141u8 , 121u8 , 213u8 , 213u8 , 114u8 , 63u8 , 62u8 , 47u8 , 91u8 , 119u8 , 57u8 , 91u8 , 95u8 , 81u8 , 19u8 , 208u8 , 59u8 , 146u8 ,] { let entry = Reserves (_0) ; self . client . storage () . fetch_or_default (& entry , block_hash) . await } else { Err (:: subxt :: MetadataError :: IncompatibleMetadata . into ()) } } # [doc = " Named reserves on some account balances."] pub async fn reserves_iter (& self , block_hash : :: core :: option :: Option < T :: Hash > ,) -> :: core :: result :: Result < :: subxt :: KeyIter < 'a , T , Reserves < 'a > > , :: subxt :: BasicError > { if self . client . metadata () . storage_hash :: < Reserves > () ? == [103u8 , 6u8 , 69u8 , 151u8 , 81u8 , 40u8 , 146u8 , 113u8 , 56u8 , 239u8 , 104u8 , 31u8 , 168u8 , 242u8 , 141u8 , 121u8 , 213u8 , 213u8 , 114u8 , 63u8 , 62u8 , 47u8 , 91u8 , 119u8 , 57u8 , 91u8 , 95u8 , 81u8 , 19u8 , 208u8 , 59u8 , 146u8 ,] { self . client . storage () . iter (block_hash) . await } else { Err (:: subxt :: MetadataError :: IncompatibleMetadata . into ()) } } # [doc = " Storage version of the pallet."] # [doc = ""] # [doc = " This is set to v2.0.0 for new networks."] pub async fn storage_version (& self , block_hash : :: core :: option :: Option < T :: Hash > ,) -> :: core :: result :: Result < runtime_types :: pallet_balances :: Releases , :: subxt :: BasicError > { if self . client . metadata () . storage_hash :: < StorageVersion > () ? == [135u8 , 96u8 , 28u8 , 234u8 , 124u8 , 212u8 , 56u8 , 140u8 , 40u8 , 101u8 , 235u8 , 128u8 , 136u8 , 221u8 , 182u8 , 81u8 , 17u8 , 9u8 , 184u8 , 228u8 , 174u8 , 165u8 , 200u8 , 162u8 , 214u8 , 178u8 , 227u8 , 72u8 , 34u8 , 5u8 , 173u8 , 96u8 ,] { let entry = StorageVersion ; self . client . storage () . fetch_or_default (& entry , block_hash) . await } else { Err (:: subxt :: MetadataError :: IncompatibleMetadata . into ()) } } } } pub mod constants { use super :: runtime_types ; pub struct ConstantsApi < 'a , T : :: subxt :: Config > { client : & 'a :: subxt :: Client < T > , } impl < 'a , T : :: subxt :: Config > ConstantsApi < 'a , T > { pub fn new (client : & 'a :: subxt :: Client < T >) -> Self { Self { client } } # [doc = " The minimum amount required to keep an account open."] pub fn existential_deposit (& self) -> :: core :: result :: Result < :: core :: primitive :: u128 , :: subxt :: BasicError > { if self . client . metadata () . constant_hash ("Balances" , "ExistentialDeposit") ? == [202u8 , 63u8 , 75u8 , 48u8 , 180u8 , 188u8 , 14u8 , 23u8 , 114u8 , 16u8 , 55u8 , 252u8 , 69u8 , 225u8 , 179u8 , 117u8 , 183u8 , 114u8 , 75u8 , 194u8 , 240u8 , 65u8 , 20u8 , 175u8 , 215u8 , 35u8 , 172u8 , 159u8 , 31u8 , 92u8 , 31u8 , 61u8 ,] { let pallet = self . client . metadata () . pallet ("Balances") ? ; let constant = pallet . constant ("ExistentialDeposit") ? ; let value = :: subxt :: codec :: Decode :: decode (& mut & constant . value [..]) ? ; Ok (value) } else { Err (:: subxt :: MetadataError :: IncompatibleMetadata . into ()) } } # [doc = " The maximum number of locks that should exist on an account."] # [doc = " Not strictly enforced, but used for weight estimation."] pub fn max_locks (& self) -> :: core :: result :: Result < :: core :: primitive :: u32 , :: subxt :: BasicError > { if self . client . metadata () . constant_hash ("Balances" , "MaxLocks") ? == [250u8 , 58u8 , 19u8 , 15u8 , 35u8 , 113u8 , 227u8 , 89u8 , 39u8 , 75u8 , 21u8 , 108u8 , 202u8 , 32u8 , 163u8 , 167u8 , 207u8 , 233u8 , 69u8 , 151u8 , 53u8 , 164u8 , 230u8 , 16u8 , 14u8 , 22u8 , 172u8 , 46u8 , 36u8 , 216u8 , 29u8 , 1u8 ,] { let pallet = self . client . metadata () . pallet ("Balances") ? ; let constant = pallet . constant ("MaxLocks") ? ; let value = :: subxt :: codec :: Decode :: decode (& mut & constant . value [..]) ? ; Ok (value) } else { Err (:: subxt :: MetadataError :: IncompatibleMetadata . into ()) } } # [doc = " The maximum number of named reserves that can exist on an account."] pub fn max_reserves (& self) -> :: core :: result :: Result < :: core :: primitive :: u32 , :: subxt :: BasicError > { if self . client . metadata () . constant_hash ("Balances" , "MaxReserves") ? == [24u8 , 30u8 , 77u8 , 89u8 , 216u8 , 114u8 , 140u8 , 11u8 , 127u8 , 252u8 , 130u8 , 203u8 , 4u8 , 55u8 , 62u8 , 240u8 , 65u8 , 182u8 , 187u8 , 189u8 , 140u8 , 6u8 , 177u8 , 216u8 , 159u8 , 108u8 , 18u8 , 73u8 , 95u8 , 67u8 , 62u8 , 50u8 ,] { let pallet = self . client . metadata () . pallet ("Balances") ? ; let constant = pallet . constant ("MaxReserves") ? ; let value = :: subxt :: codec :: Decode :: decode (& mut & constant . value [..]) ? ; Ok (value) } else { Err (:: subxt :: MetadataError :: IncompatibleMetadata . into ()) } } } } } pub mod transaction_payment { use super :: root_mod ; use super :: runtime_types ; pub type Event = runtime_types :: pallet_transaction_payment :: pallet :: Event ; pub mod events { use super :: runtime_types ; # [derive (:: subxt :: codec :: Decode , :: subxt :: codec :: Encode , Clone , Debug , Eq , PartialEq)] # [doc = "A transaction fee `actual_fee`, of which `tip` was added to the minimum inclusion fee,"] # [doc = "has been paid by `who`."] pub struct TransactionFeePaid { pub who : :: subxt :: sp_core :: crypto :: AccountId32 , pub actual_fee : :: core :: primitive :: u128 , pub tip : :: core :: primitive :: u128 , } impl :: subxt :: Event for TransactionFeePaid { const PALLET : & 'static str = "TransactionPayment" ; const EVENT : & 'static str = "TransactionFeePaid" ; } } pub mod storage { use super :: runtime_types ; pub struct NextFeeMultiplier ; impl :: subxt :: StorageEntry for NextFeeMultiplier { const PALLET : & 'static str = "TransactionPayment" ; const STORAGE : & 'static str = "NextFeeMultiplier" ; type Value = runtime_types :: sp_arithmetic :: fixed_point :: FixedU128 ; fn key (& self) -> :: subxt :: StorageEntryKey { :: subxt :: StorageEntryKey :: Plain } } pub struct StorageVersion ; impl :: subxt :: StorageEntry for StorageVersion { const PALLET : & 'static str = "TransactionPayment" ; const STORAGE : & 'static str = "StorageVersion" ; type Value = runtime_types :: pallet_transaction_payment :: Releases ; fn key (& self) -> :: subxt :: StorageEntryKey { :: subxt :: StorageEntryKey :: Plain } } pub struct StorageApi < 'a , T : :: subxt :: Config > { client : & 'a :: subxt :: Client < T > , } impl < 'a , T : :: subxt :: Config > StorageApi < 'a , T > { pub fn new (client : & 'a :: subxt :: Client < T >) -> Self { Self { client } } pub async fn next_fee_multiplier (& self , block_hash : :: core :: option :: Option < T :: Hash > ,) -> :: core :: result :: Result < runtime_types :: sp_arithmetic :: fixed_point :: FixedU128 , :: subxt :: BasicError > { if self . client . metadata () . storage_hash :: < NextFeeMultiplier > () ? == [232u8 , 48u8 , 68u8 , 202u8 , 209u8 , 29u8 , 249u8 , 71u8 , 0u8 , 84u8 , 229u8 , 250u8 , 176u8 , 203u8 , 27u8 , 26u8 , 34u8 , 55u8 , 83u8 , 183u8 , 224u8 , 40u8 , 62u8 , 127u8 , 131u8 , 88u8 , 128u8 , 9u8 , 56u8 , 178u8 , 31u8 , 183u8 ,] { let entry = NextFeeMultiplier ; self . client . storage () . fetch_or_default (& entry , block_hash) . await } else { Err (:: subxt :: MetadataError :: IncompatibleMetadata . into ()) } } pub async fn storage_version (& self , block_hash : :: core :: option :: Option < T :: Hash > ,) -> :: core :: result :: Result < runtime_types :: pallet_transaction_payment :: Releases , :: subxt :: BasicError > { if self . client . metadata () . storage_hash :: < StorageVersion > () ? == [219u8 , 243u8 , 82u8 , 176u8 , 65u8 , 5u8 , 132u8 , 114u8 , 8u8 , 82u8 , 176u8 , 200u8 , 97u8 , 150u8 , 177u8 , 164u8 , 166u8 , 11u8 , 34u8 , 12u8 , 12u8 , 198u8 , 58u8 , 191u8 , 186u8 , 221u8 , 221u8 , 119u8 , 181u8 , 253u8 , 154u8 , 228u8 ,] { let entry = StorageVersion ; self . client . storage () . fetch_or_default (& entry , block_hash) . await } else { Err (:: subxt :: MetadataError :: IncompatibleMetadata . into ()) } } } } pub mod constants { use super :: runtime_types ; pub struct ConstantsApi < 'a , T : :: subxt :: Config > { client : & 'a :: subxt :: Client < T > , } impl < 'a , T : :: subxt :: Config > ConstantsApi < 'a , T > { pub fn new (client : & 'a :: subxt :: Client < T >) -> Self { Self { client } } # [doc = " A fee mulitplier for `Operational` extrinsics to compute \"virtual tip\" to boost their"] # [doc = " `priority`"] # [doc = ""] # [doc = " This value is multipled by the `final_fee` to obtain a \"virtual tip\" that is later"] # [doc = " added to a tip component in regular `priority` calculations."] # [doc = " It means that a `Normal` transaction can front-run a similarly-sized `Operational`"] # [doc = " extrinsic (with no tip), by including a tip value greater than the virtual tip."] # [doc = ""] # [doc = " ```rust,ignore"] # [doc = " // For `Normal`"] # [doc = " let priority = priority_calc(tip);"] # [doc = ""] # [doc = " // For `Operational`"] # [doc = " let virtual_tip = (inclusion_fee + tip) * OperationalFeeMultiplier;"] # [doc = " let priority = priority_calc(tip + virtual_tip);"] # [doc = " ```"] # [doc = ""] # [doc = " Note that since we use `final_fee` the multiplier applies also to the regular `tip`"] # [doc = " sent with the transaction. So, not only does the transaction get a priority bump based"] # [doc = " on the `inclusion_fee`, but we also amplify the impact of tips applied to `Operational`"] # [doc = " transactions."] pub fn operational_fee_multiplier (& self) -> :: core :: result :: Result < :: core :: primitive :: u8 , :: subxt :: BasicError > { if self . client . metadata () . constant_hash ("TransactionPayment" , "OperationalFeeMultiplier") ? == [161u8 , 232u8 , 150u8 , 43u8 , 106u8 , 83u8 , 56u8 , 248u8 , 54u8 , 123u8 , 244u8 , 73u8 , 5u8 , 49u8 , 245u8 , 150u8 , 70u8 , 92u8 , 158u8 , 207u8 , 127u8 , 115u8 , 211u8 , 21u8 , 24u8 , 136u8 , 89u8 , 44u8 , 151u8 , 211u8 , 235u8 , 196u8 ,] { let pallet = self . client . metadata () . pallet ("TransactionPayment") ? ; let constant = pallet . constant ("OperationalFeeMultiplier") ? ; let value = :: subxt :: codec :: Decode :: decode (& mut & constant . value [..]) ? ; Ok (value) } else { Err (:: subxt :: MetadataError :: IncompatibleMetadata . into ()) } } } } } pub mod authorship { use super :: root_mod ; use super :: runtime_types ; pub mod calls { use super :: root_mod ; use super :: runtime_types ; type DispatchError = runtime_types :: sp_runtime :: DispatchError ; # [derive (:: subxt :: codec :: Decode , :: subxt :: codec :: Encode , Clone , Debug , Eq , PartialEq)] pub struct SetUncles { pub new_uncles : :: std :: vec :: Vec < runtime_types :: sp_runtime :: generic :: header :: Header < :: core :: primitive :: u32 , runtime_types :: sp_runtime :: traits :: BlakeTwo256 > > , } impl :: subxt :: Call for SetUncles { const PALLET : & 'static str = "Authorship" ; const FUNCTION : & 'static str = "set_uncles" ; } pub struct TransactionApi < 'a , T : :: subxt :: Config , X > { client : & 'a :: subxt :: Client < T > , marker : :: core :: marker :: PhantomData < X > , } impl < 'a , T , X > TransactionApi < 'a , T , X > where T : :: subxt :: Config , X : :: subxt :: extrinsic :: ExtrinsicParams < T > , { pub fn new (client : & 'a :: subxt :: Client < T >) -> Self { Self { client , marker : :: core :: marker :: PhantomData } } # [doc = "Provide a set of uncles."] pub fn set_uncles (& self , new_uncles : :: std :: vec :: Vec < runtime_types :: sp_runtime :: generic :: header :: Header < :: core :: primitive :: u32 , runtime_types :: sp_runtime :: traits :: BlakeTwo256 > > ,) -> Result < :: subxt :: SubmittableExtrinsic < 'a , T , X , SetUncles , DispatchError , root_mod :: Event > , :: subxt :: BasicError > { if self . client . metadata () . call_hash :: < SetUncles > () ? == [5u8 , 56u8 , 71u8 , 152u8 , 103u8 , 232u8 , 101u8 , 171u8 , 200u8 , 2u8 , 177u8 , 102u8 , 0u8 , 93u8 , 210u8 , 90u8 , 56u8 , 151u8 , 5u8 , 235u8 , 227u8 , 197u8 , 189u8 , 248u8 , 2u8 , 71u8 , 49u8 , 220u8 , 212u8 , 253u8 , 235u8 , 67u8 ,] { let call = SetUncles { new_uncles , } ; Ok (:: subxt :: SubmittableExtrinsic :: new (self . client , call)) } else { Err (:: subxt :: MetadataError :: IncompatibleMetadata . into ()) } } } } pub mod storage { use super :: runtime_types ; pub struct Uncles ; impl :: subxt :: StorageEntry for Uncles { const PALLET : & 'static str = "Authorship" ; const STORAGE : & 'static str = "Uncles" ; type Value = runtime_types :: sp_runtime :: bounded :: bounded_vec :: BoundedVec < runtime_types :: pallet_authorship :: UncleEntryItem < :: core :: primitive :: u32 , :: subxt :: sp_core :: H256 , :: subxt :: sp_core :: crypto :: AccountId32 > > ; fn key (& self) -> :: subxt :: StorageEntryKey { :: subxt :: StorageEntryKey :: Plain } } pub struct Author ; impl :: subxt :: StorageEntry for Author { const PALLET : & 'static str = "Authorship" ; const STORAGE : & 'static str = "Author" ; type Value = :: subxt :: sp_core :: crypto :: AccountId32 ; fn key (& self) -> :: subxt :: StorageEntryKey { :: subxt :: StorageEntryKey :: Plain } } pub struct DidSetUncles ; impl :: subxt :: StorageEntry for DidSetUncles { const PALLET : & 'static str = "Authorship" ; const STORAGE : & 'static str = "DidSetUncles" ; type Value = :: core :: primitive :: bool ; fn key (& self) -> :: subxt :: StorageEntryKey { :: subxt :: StorageEntryKey :: Plain } } pub struct StorageApi < 'a , T : :: subxt :: Config > { client : & 'a :: subxt :: Client < T > , } impl < 'a , T : :: subxt :: Config > StorageApi < 'a , T > { pub fn new (client : & 'a :: subxt :: Client < T >) -> Self { Self { client } } # [doc = " Uncles"] pub async fn uncles (& self , block_hash : :: core :: option :: Option < T :: Hash > ,) -> :: core :: result :: Result < runtime_types :: sp_runtime :: bounded :: bounded_vec :: BoundedVec < runtime_types :: pallet_authorship :: UncleEntryItem < :: core :: primitive :: u32 , :: subxt :: sp_core :: H256 , :: subxt :: sp_core :: crypto :: AccountId32 > > , :: subxt :: BasicError > { if self . client . metadata () . storage_hash :: < Uncles > () ? == [104u8 , 166u8 , 142u8 , 139u8 , 46u8 , 63u8 , 163u8 , 183u8 , 45u8 , 77u8 , 156u8 , 44u8 , 228u8 , 57u8 , 253u8 , 230u8 , 103u8 , 119u8 , 145u8 , 135u8 , 251u8 , 182u8 , 144u8 , 165u8 , 127u8 , 150u8 , 127u8 , 185u8 , 146u8 , 228u8 , 91u8 , 163u8 ,] { let entry = Uncles ; self . client . storage () . fetch_or_default (& entry , block_hash) . await } else { Err (:: subxt :: MetadataError :: IncompatibleMetadata . into ()) } } # [doc = " Author of current block."] pub async fn author (& self , block_hash : :: core :: option :: Option < T :: Hash > ,) -> :: core :: result :: Result < :: core :: option :: Option < :: subxt :: sp_core :: crypto :: AccountId32 > , :: subxt :: BasicError > { if self . client . metadata () . storage_hash :: < Author > () ? == [191u8 , 57u8 , 3u8 , 242u8 , 220u8 , 123u8 , 103u8 , 215u8 , 149u8 , 120u8 , 20u8 , 139u8 , 146u8 , 234u8 , 180u8 , 105u8 , 129u8 , 128u8 , 114u8 , 147u8 , 114u8 , 236u8 , 23u8 , 21u8 , 15u8 , 250u8 , 180u8 , 19u8 , 177u8 , 145u8 , 77u8 , 228u8 ,] { let entry = Author ; self . client . storage () . fetch (& entry , block_hash) . await } else { Err (:: subxt :: MetadataError :: IncompatibleMetadata . into ()) } } # [doc = " Whether uncles were already set in this block."] pub async fn did_set_uncles (& self , block_hash : :: core :: option :: Option < T :: Hash > ,) -> :: core :: result :: Result < :: core :: primitive :: bool , :: subxt :: BasicError > { if self . client . metadata () . storage_hash :: < DidSetUncles > () ? == [64u8 , 3u8 , 208u8 , 187u8 , 50u8 , 45u8 , 37u8 , 88u8 , 163u8 , 226u8 , 37u8 , 126u8 , 232u8 , 107u8 , 156u8 , 187u8 , 29u8 , 15u8 , 53u8 , 46u8 , 28u8 , 73u8 , 83u8 , 123u8 , 14u8 , 244u8 , 243u8 , 43u8 , 245u8 , 143u8 , 15u8 , 115u8 ,] { let entry = DidSetUncles ; self . client . storage () . fetch_or_default (& entry , block_hash) . await } else { Err (:: subxt :: MetadataError :: IncompatibleMetadata . into ()) } } } } pub mod constants { use super :: runtime_types ; pub struct ConstantsApi < 'a , T : :: subxt :: Config > { client : & 'a :: subxt :: Client < T > , } impl < 'a , T : :: subxt :: Config > ConstantsApi < 'a , T > { pub fn new (client : & 'a :: subxt :: Client < T >) -> Self { Self { client } } # [doc = " The number of blocks back we should accept uncles."] # [doc = " This means that we will deal with uncle-parents that are"] # [doc = " `UncleGenerations + 1` before `now`."] pub fn uncle_generations (& self) -> :: core :: result :: Result < :: core :: primitive :: u32 , :: subxt :: BasicError > { if self . client . metadata () . constant_hash ("Authorship" , "UncleGenerations") ? == [0u8 , 72u8 , 57u8 , 175u8 , 222u8 , 143u8 , 191u8 , 33u8 , 163u8 , 157u8 , 202u8 , 83u8 , 186u8 , 103u8 , 162u8 , 103u8 , 227u8 , 158u8 , 239u8 , 212u8 , 205u8 , 193u8 , 226u8 , 138u8 , 5u8 , 220u8 , 221u8 , 42u8 , 7u8 , 146u8 , 173u8 , 205u8 ,] { let pallet = self . client . metadata () . pallet ("Authorship") ? ; let constant = pallet . constant ("UncleGenerations") ? ; let value = :: subxt :: codec :: Decode :: decode (& mut & constant . value [..]) ? ; Ok (value) } else { Err (:: subxt :: MetadataError :: IncompatibleMetadata . into ()) } } } } } pub mod aura { use super :: root_mod ; use super :: runtime_types ; pub mod storage { use super :: runtime_types ; pub struct Authorities ; impl :: subxt :: StorageEntry for Authorities { const PALLET : & 'static str = "Aura" ; const STORAGE : & 'static str = "Authorities" ; type Value = runtime_types :: sp_runtime :: bounded :: bounded_vec :: BoundedVec < runtime_types :: sp_consensus_aura :: sr25519 :: app_sr25519 :: Public > ; fn key (& self) -> :: subxt :: StorageEntryKey { :: subxt :: StorageEntryKey :: Plain } } pub struct CurrentSlot ; impl :: subxt :: StorageEntry for CurrentSlot { const PALLET : & 'static str = "Aura" ; const STORAGE : & 'static str = "CurrentSlot" ; type Value = runtime_types :: sp_consensus_slots :: Slot ; fn key (& self) -> :: subxt :: StorageEntryKey { :: subxt :: StorageEntryKey :: Plain } } pub struct StorageApi < 'a , T : :: subxt :: Config > { client : & 'a :: subxt :: Client < T > , } impl < 'a , T : :: subxt :: Config > StorageApi < 'a , T > { pub fn new (client : & 'a :: subxt :: Client < T >) -> Self { Self { client } } # [doc = " The current authority set."] pub async fn authorities (& self , block_hash : :: core :: option :: Option < T :: Hash > ,) -> :: core :: result :: Result < runtime_types :: sp_runtime :: bounded :: bounded_vec :: BoundedVec < runtime_types :: sp_consensus_aura :: sr25519 :: app_sr25519 :: Public > , :: subxt :: BasicError > { if self . client . metadata () . storage_hash :: < Authorities > () ? == [168u8 , 101u8 , 224u8 , 96u8 , 254u8 , 152u8 , 213u8 , 141u8 , 46u8 , 181u8 , 131u8 , 23u8 , 218u8 , 24u8 , 145u8 , 111u8 , 161u8 , 192u8 , 253u8 , 29u8 , 128u8 , 92u8 , 125u8 , 159u8 , 242u8 , 144u8 , 253u8 , 174u8 , 50u8 , 190u8 , 148u8 , 193u8 ,] { let entry = Authorities ; self . client . storage () . fetch_or_default (& entry , block_hash) . await } else { Err (:: subxt :: MetadataError :: IncompatibleMetadata . into ()) } } # [doc = " The current slot of this block."] # [doc = ""] # [doc = " This will be set in `on_initialize`."] pub async fn current_slot (& self , block_hash : :: core :: option :: Option < T :: Hash > ,) -> :: core :: result :: Result < runtime_types :: sp_consensus_slots :: Slot , :: subxt :: BasicError > { if self . client . metadata () . storage_hash :: < CurrentSlot > () ? == [233u8 , 102u8 , 77u8 , 99u8 , 103u8 , 50u8 , 151u8 , 229u8 , 46u8 , 226u8 , 181u8 , 37u8 , 117u8 , 204u8 , 234u8 , 120u8 , 116u8 , 166u8 , 80u8 , 188u8 , 92u8 , 154u8 , 137u8 , 150u8 , 79u8 , 164u8 , 29u8 , 203u8 , 2u8 , 51u8 , 123u8 , 104u8 ,] { let entry = CurrentSlot ; self . client . storage () . fetch_or_default (& entry , block_hash) . await } else { Err (:: subxt :: MetadataError :: IncompatibleMetadata . into ()) } } } } } pub mod grandpa { use super :: root_mod ; use super :: runtime_types ; pub mod calls { use super :: root_mod ; use super :: runtime_types ; type DispatchError = runtime_types :: sp_runtime :: DispatchError ; # [derive (:: subxt :: codec :: Decode , :: subxt :: codec :: Encode , Clone , Debug , Eq , PartialEq)] pub struct ReportEquivocation { pub equivocation_proof : :: std :: boxed :: Box < runtime_types :: sp_finality_grandpa :: EquivocationProof < :: subxt :: sp_core :: H256 , :: core :: primitive :: u32 > > , pub key_owner_proof : runtime_types :: sp_session :: MembershipProof , } impl :: subxt :: Call for ReportEquivocation { const PALLET : & 'static str = "Grandpa" ; const FUNCTION : & 'static str = "report_equivocation" ; } # [derive (:: subxt :: codec :: Decode , :: subxt :: codec :: Encode , Clone , Debug , Eq , PartialEq)] pub struct ReportEquivocationUnsigned { pub equivocation_proof : :: std :: boxed :: Box < runtime_types :: sp_finality_grandpa :: EquivocationProof < :: subxt :: sp_core :: H256 , :: core :: primitive :: u32 > > , pub key_owner_proof : runtime_types :: sp_session :: MembershipProof , } impl :: subxt :: Call for ReportEquivocationUnsigned { const PALLET : & 'static str = "Grandpa" ; const FUNCTION : & 'static str = "report_equivocation_unsigned" ; } # [derive (:: subxt :: codec :: Decode , :: subxt :: codec :: Encode , Clone , Debug , Eq , PartialEq)] pub struct NoteStalled { pub delay : :: core :: primitive :: u32 , pub best_finalized_block_number : :: core :: primitive :: u32 , } impl :: subxt :: Call for NoteStalled { const PALLET : & 'static str = "Grandpa" ; const FUNCTION : & 'static str = "note_stalled" ; } pub struct TransactionApi < 'a , T : :: subxt :: Config , X > { client : & 'a :: subxt :: Client < T > , marker : :: core :: marker :: PhantomData < X > , } impl < 'a , T , X > TransactionApi < 'a , T , X > where T : :: subxt :: Config , X : :: subxt :: extrinsic :: ExtrinsicParams < T > , { pub fn new (client : & 'a :: subxt :: Client < T >) -> Self { Self { client , marker : :: core :: marker :: PhantomData } } # [doc = "Report voter equivocation/misbehavior. This method will verify the"] # [doc = "equivocation proof and validate the given key ownership proof"] # [doc = "against the extracted offender. If both are valid, the offence"] # [doc = "will be reported."] pub fn report_equivocation (& self , equivocation_proof : runtime_types :: sp_finality_grandpa :: EquivocationProof < :: subxt :: sp_core :: H256 , :: core :: primitive :: u32 > , key_owner_proof : runtime_types :: sp_session :: MembershipProof ,) -> Result < :: subxt :: SubmittableExtrinsic < 'a , T , X , ReportEquivocation , DispatchError , root_mod :: Event > , :: subxt :: BasicError > { if self . client . metadata () . call_hash :: < ReportEquivocation > () ? == [230u8 , 252u8 , 24u8 , 207u8 , 164u8 , 127u8 , 177u8 , 30u8 , 113u8 , 175u8 , 207u8 , 252u8 , 230u8 , 225u8 , 181u8 , 190u8 , 236u8 , 110u8 , 145u8 , 168u8 , 200u8 , 134u8 , 88u8 , 234u8 , 231u8 , 45u8 , 149u8 , 169u8 , 155u8 , 114u8 , 62u8 , 65u8 ,] { let call = ReportEquivocation { equivocation_proof : :: std :: boxed :: Box :: new (equivocation_proof) , key_owner_proof , } ; Ok (:: subxt :: SubmittableExtrinsic :: new (self . client , call)) } else { Err (:: subxt :: MetadataError :: IncompatibleMetadata . into ()) } } # [doc = "Report voter equivocation/misbehavior. This method will verify the"] # [doc = "equivocation proof and validate the given key ownership proof"] # [doc = "against the extracted offender. If both are valid, the offence"] # [doc = "will be reported."] # [doc = ""] # [doc = "This extrinsic must be called unsigned and it is expected that only"] # [doc = "block authors will call it (validated in `ValidateUnsigned`), as such"] # [doc = "if the block author is defined it will be defined as the equivocation"] # [doc = "reporter."] pub fn report_equivocation_unsigned (& self , equivocation_proof : runtime_types :: sp_finality_grandpa :: EquivocationProof < :: subxt :: sp_core :: H256 , :: core :: primitive :: u32 > , key_owner_proof : runtime_types :: sp_session :: MembershipProof ,) -> Result < :: subxt :: SubmittableExtrinsic < 'a , T , X , ReportEquivocationUnsigned , DispatchError , root_mod :: Event > , :: subxt :: BasicError > { if self . client . metadata () . call_hash :: < ReportEquivocationUnsigned > () ? == [141u8 , 235u8 , 27u8 , 135u8 , 124u8 , 124u8 , 234u8 , 51u8 , 100u8 , 105u8 , 188u8 , 248u8 , 133u8 , 10u8 , 84u8 , 14u8 , 40u8 , 235u8 , 14u8 , 107u8 , 63u8 , 148u8 , 107u8 , 172u8 , 136u8 , 159u8 , 86u8 , 23u8 , 145u8 , 221u8 , 93u8 , 206u8 ,] { let call = ReportEquivocationUnsigned { equivocation_proof : :: std :: boxed :: Box :: new (equivocation_proof) , key_owner_proof , } ; Ok (:: subxt :: SubmittableExtrinsic :: new (self . client , call)) } else { Err (:: subxt :: MetadataError :: IncompatibleMetadata . into ()) } } # [doc = "Note that the current authority set of the GRANDPA finality gadget has stalled."] # [doc = ""] # [doc = "This will trigger a forced authority set change at the beginning of the next session, to"] # [doc = "be enacted `delay` blocks after that. The `delay` should be high enough to safely assume"] # [doc = "that the block signalling the forced change will not be re-orged e.g. 1000 blocks."] # [doc = "The block production rate (which may be slowed down because of finality lagging) should"] # [doc = "be taken into account when choosing the `delay`. The GRANDPA voters based on the new"] # [doc = "authority will start voting on top of `best_finalized_block_number` for new finalized"] # [doc = "blocks. `best_finalized_block_number` should be the highest of the latest finalized"] # [doc = "block of all validators of the new authority set."] # [doc = ""] # [doc = "Only callable by root."] pub fn note_stalled (& self , delay : :: core :: primitive :: u32 , best_finalized_block_number : :: core :: primitive :: u32 ,) -> Result < :: subxt :: SubmittableExtrinsic < 'a , T , X , NoteStalled , DispatchError , root_mod :: Event > , :: subxt :: BasicError > { if self . client . metadata () . call_hash :: < NoteStalled > () ? == [227u8 , 98u8 , 249u8 , 158u8 , 96u8 , 124u8 , 72u8 , 188u8 , 27u8 , 215u8 , 73u8 , 62u8 , 103u8 , 79u8 , 38u8 , 48u8 , 212u8 , 88u8 , 233u8 , 187u8 , 11u8 , 95u8 , 39u8 , 247u8 , 55u8 , 184u8 , 228u8 , 102u8 , 13u8 , 251u8 , 52u8 , 206u8 ,] { let call = NoteStalled { delay , best_finalized_block_number , } ; Ok (:: subxt :: SubmittableExtrinsic :: new (self . client , call)) } else { Err (:: subxt :: MetadataError :: IncompatibleMetadata . into ()) } } } } pub type Event = runtime_types :: pallet_grandpa :: pallet :: Event ; pub mod events { use super :: runtime_types ; # [derive (:: subxt :: codec :: Decode , :: subxt :: codec :: Encode , Clone , Debug , Eq , PartialEq)] # [doc = "New authority set has been applied."] pub struct NewAuthorities { pub authority_set : :: std :: vec :: Vec < (runtime_types :: sp_finality_grandpa :: app :: Public , :: core :: primitive :: u64 ,) > , } impl :: subxt :: Event for NewAuthorities { const PALLET : & 'static str = "Grandpa" ; const EVENT : & 'static str = "NewAuthorities" ; } # [derive (:: subxt :: codec :: Decode , :: subxt :: codec :: Encode , Clone , Debug , Eq , PartialEq)] # [doc = "Current authority set has been paused."] pub struct Paused ; impl :: subxt :: Event for Paused { const PALLET : & 'static str = "Grandpa" ; const EVENT : & 'static str = "Paused" ; } # [derive (:: subxt :: codec :: Decode , :: subxt :: codec :: Encode , Clone , Debug , Eq , PartialEq)] # [doc = "Current authority set has been resumed."] pub struct Resumed ; impl :: subxt :: Event for Resumed { const PALLET : & 'static str = "Grandpa" ; const EVENT : & 'static str = "Resumed" ; } } pub mod storage { use super :: runtime_types ; pub struct State ; impl :: subxt :: StorageEntry for State { const PALLET : & 'static str = "Grandpa" ; const STORAGE : & 'static str = "State" ; type Value = runtime_types :: pallet_grandpa :: StoredState < :: core :: primitive :: u32 > ; fn key (& self) -> :: subxt :: StorageEntryKey { :: subxt :: StorageEntryKey :: Plain } } pub struct PendingChange ; impl :: subxt :: StorageEntry for PendingChange { const PALLET : & 'static str = "Grandpa" ; const STORAGE : & 'static str = "PendingChange" ; type Value = runtime_types :: pallet_grandpa :: StoredPendingChange < :: core :: primitive :: u32 > ; fn key (& self) -> :: subxt :: StorageEntryKey { :: subxt :: StorageEntryKey :: Plain } } pub struct NextForced ; impl :: subxt :: StorageEntry for NextForced { const PALLET : & 'static str = "Grandpa" ; const STORAGE : & 'static str = "NextForced" ; type Value = :: core :: primitive :: u32 ; fn key (& self) -> :: subxt :: StorageEntryKey { :: subxt :: StorageEntryKey :: Plain } } pub struct Stalled ; impl :: subxt :: StorageEntry for Stalled { const PALLET : & 'static str = "Grandpa" ; const STORAGE : & 'static str = "Stalled" ; type Value = (:: core :: primitive :: u32 , :: core :: primitive :: u32 ,) ; fn key (& self) -> :: subxt :: StorageEntryKey { :: subxt :: StorageEntryKey :: Plain } } pub struct CurrentSetId ; impl :: subxt :: StorageEntry for CurrentSetId { const PALLET : & 'static str = "Grandpa" ; const STORAGE : & 'static str = "CurrentSetId" ; type Value = :: core :: primitive :: u64 ; fn key (& self) -> :: subxt :: StorageEntryKey { :: subxt :: StorageEntryKey :: Plain } } pub struct SetIdSession < 'a > (pub & 'a :: core :: primitive :: u64) ; impl :: subxt :: StorageEntry for SetIdSession < '_ > { const PALLET : & 'static str = "Grandpa" ; const STORAGE : & 'static str = "SetIdSession" ; type Value = :: core :: primitive :: u32 ; fn key (& self) -> :: subxt :: StorageEntryKey { :: subxt :: StorageEntryKey :: Map (vec ! [:: subxt :: StorageMapKey :: new (& self . 0 , :: subxt :: StorageHasher :: Twox64Concat)]) } } pub struct StorageApi < 'a , T : :: subxt :: Config > { client : & 'a :: subxt :: Client < T > , } impl < 'a , T : :: subxt :: Config > StorageApi < 'a , T > { pub fn new (client : & 'a :: subxt :: Client < T >) -> Self { Self { client } } # [doc = " State of the current authority set."] pub async fn state (& self , block_hash : :: core :: option :: Option < T :: Hash > ,) -> :: core :: result :: Result < runtime_types :: pallet_grandpa :: StoredState < :: core :: primitive :: u32 > , :: subxt :: BasicError > { if self . client . metadata () . storage_hash :: < State > () ? == [159u8 , 75u8 , 78u8 , 23u8 , 98u8 , 89u8 , 239u8 , 230u8 , 192u8 , 67u8 , 139u8 , 222u8 , 151u8 , 237u8 , 216u8 , 20u8 , 235u8 , 247u8 , 180u8 , 24u8 , 64u8 , 160u8 , 58u8 , 15u8 , 205u8 , 191u8 , 120u8 , 68u8 , 32u8 , 5u8 , 161u8 , 106u8 ,] { let entry = State ; self . client . storage () . fetch_or_default (& entry , block_hash) . await } else { Err (:: subxt :: MetadataError :: IncompatibleMetadata . into ()) } } # [doc = " Pending change: (signaled at, scheduled change)."] pub async fn pending_change (& self , block_hash : :: core :: option :: Option < T :: Hash > ,) -> :: core :: result :: Result < :: core :: option :: Option < runtime_types :: pallet_grandpa :: StoredPendingChange < :: core :: primitive :: u32 > > , :: subxt :: BasicError > { if self . client . metadata () . storage_hash :: < PendingChange > () ? == [128u8 , 176u8 , 209u8 , 41u8 , 231u8 , 111u8 , 205u8 , 198u8 , 154u8 , 44u8 , 228u8 , 231u8 , 44u8 , 110u8 , 74u8 , 9u8 , 31u8 , 86u8 , 128u8 , 244u8 , 112u8 , 21u8 , 120u8 , 176u8 , 50u8 , 213u8 , 122u8 , 46u8 , 85u8 , 255u8 , 40u8 , 173u8 ,] { let entry = PendingChange ; self . client . storage () . fetch (& entry , block_hash) . await } else { Err (:: subxt :: MetadataError :: IncompatibleMetadata . into ()) } } # [doc = " next block number where we can force a change."] pub async fn next_forced (& self , block_hash : :: core :: option :: Option < T :: Hash > ,) -> :: core :: result :: Result < :: core :: option :: Option < :: core :: primitive :: u32 > , :: subxt :: BasicError > { if self . client . metadata () . storage_hash :: < NextForced > () ? == [99u8 , 43u8 , 245u8 , 201u8 , 60u8 , 9u8 , 122u8 , 99u8 , 188u8 , 29u8 , 67u8 , 6u8 , 193u8 , 133u8 , 179u8 , 67u8 , 202u8 , 208u8 , 62u8 , 179u8 , 19u8 , 169u8 , 196u8 , 119u8 , 107u8 , 75u8 , 100u8 , 3u8 , 121u8 , 18u8 , 80u8 , 156u8 ,] { let entry = NextForced ; self . client . storage () . fetch (& entry , block_hash) . await } else { Err (:: subxt :: MetadataError :: IncompatibleMetadata . into ()) } } # [doc = " `true` if we are currently stalled."] pub async fn stalled (& self , block_hash : :: core :: option :: Option < T :: Hash > ,) -> :: core :: result :: Result < :: core :: option :: Option < (:: core :: primitive :: u32 , :: core :: primitive :: u32 ,) > , :: subxt :: BasicError > { if self . client . metadata () . storage_hash :: < Stalled > () ? == [219u8 , 8u8 , 37u8 , 78u8 , 150u8 , 55u8 , 0u8 , 57u8 , 201u8 , 170u8 , 186u8 , 189u8 , 56u8 , 161u8 , 44u8 , 15u8 , 53u8 , 178u8 , 224u8 , 208u8 , 231u8 , 109u8 , 14u8 , 209u8 , 57u8 , 205u8 , 237u8 , 153u8 , 231u8 , 156u8 , 24u8 , 185u8 ,] { let entry = Stalled ; self . client . storage () . fetch (& entry , block_hash) . await } else { Err (:: subxt :: MetadataError :: IncompatibleMetadata . into ()) } } # [doc = " The number of changes (both in terms of keys and underlying economic responsibilities)"] # [doc = " in the \"set\" of Grandpa validators from genesis."] pub async fn current_set_id (& self , block_hash : :: core :: option :: Option < T :: Hash > ,) -> :: core :: result :: Result < :: core :: primitive :: u64 , :: subxt :: BasicError > { if self . client . metadata () . storage_hash :: < CurrentSetId > () ? == [129u8 , 7u8 , 62u8 , 101u8 , 199u8 , 60u8 , 56u8 , 33u8 , 54u8 , 158u8 , 20u8 , 178u8 , 244u8 , 145u8 , 189u8 , 197u8 , 157u8 , 163u8 , 116u8 , 36u8 , 105u8 , 52u8 , 149u8 , 244u8 , 108u8 , 94u8 , 109u8 , 111u8 , 244u8 , 137u8 , 7u8 , 108u8 ,] { let entry = CurrentSetId ; self . client . storage () . fetch_or_default (& entry , block_hash) . await } else { Err (:: subxt :: MetadataError :: IncompatibleMetadata . into ()) } } # [doc = " A mapping from grandpa set ID to the index of the *most recent* session for which its"] # [doc = " members were responsible."] # [doc = ""] # [doc = " TWOX-NOTE: `SetId` is not under user control."] pub async fn set_id_session (& self , _0 : & :: core :: primitive :: u64 , block_hash : :: core :: option :: Option < T :: Hash > ,) -> :: core :: result :: Result < :: core :: option :: Option < :: core :: primitive :: u32 > , :: subxt :: BasicError > { if self . client . metadata () . storage_hash :: < SetIdSession > () ? == [91u8 , 175u8 , 145u8 , 127u8 , 242u8 , 81u8 , 13u8 , 231u8 , 110u8 , 11u8 , 166u8 , 169u8 , 103u8 , 146u8 , 123u8 , 133u8 , 157u8 , 15u8 , 33u8 , 234u8 , 108u8 , 13u8 , 88u8 , 115u8 , 254u8 , 9u8 , 145u8 , 199u8 , 102u8 , 47u8 , 53u8 , 134u8 ,] { let entry = SetIdSession (_0) ; self . client . storage () . fetch (& entry , block_hash) . await } else { Err (:: subxt :: MetadataError :: IncompatibleMetadata . into ()) } } # [doc = " A mapping from grandpa set ID to the index of the *most recent* session for which its"] # [doc = " members were responsible."] # [doc = ""] # [doc = " TWOX-NOTE: `SetId` is not under user control."] pub async fn set_id_session_iter (& self , block_hash : :: core :: option :: Option < T :: Hash > ,) -> :: core :: result :: Result < :: subxt :: KeyIter < 'a , T , SetIdSession < 'a > > , :: subxt :: BasicError > { if self . client . metadata () . storage_hash :: < SetIdSession > () ? == [91u8 , 175u8 , 145u8 , 127u8 , 242u8 , 81u8 , 13u8 , 231u8 , 110u8 , 11u8 , 166u8 , 169u8 , 103u8 , 146u8 , 123u8 , 133u8 , 157u8 , 15u8 , 33u8 , 234u8 , 108u8 , 13u8 , 88u8 , 115u8 , 254u8 , 9u8 , 145u8 , 199u8 , 102u8 , 47u8 , 53u8 , 134u8 ,] { self . client . storage () . iter (block_hash) . await } else { Err (:: subxt :: MetadataError :: IncompatibleMetadata . into ()) } } } } pub mod constants { use super :: runtime_types ; pub struct ConstantsApi < 'a , T : :: subxt :: Config > { client : & 'a :: subxt :: Client < T > , } impl < 'a , T : :: subxt :: Config > ConstantsApi < 'a , T > { pub fn new (client : & 'a :: subxt :: Client < T >) -> Self { Self { client } } # [doc = " Max Authorities in use"] pub fn max_authorities (& self) -> :: core :: result :: Result < :: core :: primitive :: u32 , :: subxt :: BasicError > { if self . client . metadata () . constant_hash ("Grandpa" , "MaxAuthorities") ? == [205u8 , 23u8 , 62u8 , 93u8 , 110u8 , 248u8 , 109u8 , 245u8 , 1u8 , 57u8 , 144u8 , 146u8 , 103u8 , 0u8 , 178u8 , 246u8 , 63u8 , 80u8 , 77u8 , 155u8 , 202u8 , 208u8 , 73u8 , 194u8 , 210u8 , 49u8 , 121u8 , 99u8 , 101u8 , 222u8 , 127u8 , 206u8 ,] { let pallet = self . client . metadata () . pallet ("Grandpa") ? ; let constant = pallet . constant ("MaxAuthorities") ? ; let value = :: subxt :: codec :: Decode :: decode (& mut & constant . value [..]) ? ; Ok (value) } else { Err (:: subxt :: MetadataError :: IncompatibleMetadata . into ()) } } } } } pub mod indices { use super :: root_mod ; use super :: runtime_types ; pub mod calls { use super :: root_mod ; use super :: runtime_types ; type DispatchError = runtime_types :: sp_runtime :: DispatchError ; # [derive (:: subxt :: codec :: CompactAs , :: subxt :: codec :: Decode , :: subxt :: codec :: Encode , Clone , Debug , Eq , PartialEq)] pub struct Claim { pub index : :: core :: primitive :: u32 , } impl :: subxt :: Call for Claim { const PALLET : & 'static str = "Indices" ; const FUNCTION : & 'static str = "claim" ; } # [derive (:: subxt :: codec :: Decode , :: subxt :: codec :: Encode , Clone , Debug , Eq , PartialEq)] pub struct Transfer { pub new : :: subxt :: sp_core :: crypto :: AccountId32 , pub index : :: core :: primitive :: u32 , } impl :: subxt :: Call for Transfer { const PALLET : & 'static str = "Indices" ; const FUNCTION : & 'static str = "transfer" ; } # [derive (:: subxt :: codec :: CompactAs , :: subxt :: codec :: Decode , :: subxt :: codec :: Encode , Clone , Debug , Eq , PartialEq)] pub struct Free { pub index : :: core :: primitive :: u32 , } impl :: subxt :: Call for Free { const PALLET : & 'static str = "Indices" ; const FUNCTION : & 'static str = "free" ; } # [derive (:: subxt :: codec :: Decode , :: subxt :: codec :: Encode , Clone , Debug , Eq , PartialEq)] pub struct ForceTransfer { pub new : :: subxt :: sp_core :: crypto :: AccountId32 , pub index : :: core :: primitive :: u32 , pub freeze : :: core :: primitive :: bool , } impl :: subxt :: Call for ForceTransfer { const PALLET : & 'static str = "Indices" ; const FUNCTION : & 'static str = "force_transfer" ; } # [derive (:: subxt :: codec :: CompactAs , :: subxt :: codec :: Decode , :: subxt :: codec :: Encode , Clone , Debug , Eq , PartialEq)] pub struct Freeze { pub index : :: core :: primitive :: u32 , } impl :: subxt :: Call for Freeze { const PALLET : & 'static str = "Indices" ; const FUNCTION : & 'static str = "freeze" ; } pub struct TransactionApi < 'a , T : :: subxt :: Config , X > { client : & 'a :: subxt :: Client < T > , marker : :: core :: marker :: PhantomData < X > , } impl < 'a , T , X > TransactionApi < 'a , T , X > where T : :: subxt :: Config , X : :: subxt :: extrinsic :: ExtrinsicParams < T > , { pub fn new (client : & 'a :: subxt :: Client < T >) -> Self { Self { client , marker : :: core :: marker :: PhantomData } } # [doc = "Assign an previously unassigned index."] # [doc = ""] # [doc = "Payment: `Deposit` is reserved from the sender account."] # [doc = ""] # [doc = "The dispatch origin for this call must be _Signed_."] # [doc = ""] # [doc = "- `index`: the index to be claimed. This must not be in use."] # [doc = ""] # [doc = "Emits `IndexAssigned` if successful."] # [doc = ""] # [doc = "# <weight>"] # [doc = "- `O(1)`."] # [doc = "- One storage mutation (codec `O(1)`)."] # [doc = "- One reserve operation."] # [doc = "- One event."] # [doc = "-------------------"] # [doc = "- DB Weight: 1 Read/Write (Accounts)"] # [doc = "# </weight>"] pub fn claim (& self , index : :: core :: primitive :: u32 ,) -> Result < :: subxt :: SubmittableExtrinsic < 'a , T , X , Claim , DispatchError , root_mod :: Event > , :: subxt :: BasicError > { if self . client . metadata () . call_hash :: < Claim > () ? == [27u8 , 4u8 , 108u8 , 55u8 , 23u8 , 109u8 , 175u8 , 25u8 , 201u8 , 230u8 , 228u8 , 51u8 , 164u8 , 15u8 , 79u8 , 10u8 , 219u8 , 182u8 , 242u8 , 102u8 , 164u8 , 148u8 , 39u8 , 91u8 , 106u8 , 197u8 , 29u8 , 190u8 , 178u8 , 221u8 , 16u8 , 87u8 ,] { let call = Claim { index , } ; Ok (:: subxt :: SubmittableExtrinsic :: new (self . client , call)) } else { Err (:: subxt :: MetadataError :: IncompatibleMetadata . into ()) } } # [doc = "Assign an index already owned by the sender to another account. The balance reservation"] # [doc = "is effectively transferred to the new account."] # [doc = ""] # [doc = "The dispatch origin for this call must be _Signed_."] # [doc = ""] # [doc = "- `index`: the index to be re-assigned. This must be owned by the sender."] # [doc = "- `new`: the new owner of the index. This function is a no-op if it is equal to sender."] # [doc = ""] # [doc = "Emits `IndexAssigned` if successful."] # [doc = ""] # [doc = "# <weight>"] # [doc = "- `O(1)`."] # [doc = "- One storage mutation (codec `O(1)`)."] # [doc = "- One transfer operation."] # [doc = "- One event."] # [doc = "-------------------"] # [doc = "- DB Weight:"] # [doc = "   - Reads: Indices Accounts, System Account (recipient)"] # [doc = "   - Writes: Indices Accounts, System Account (recipient)"] # [doc = "# </weight>"] pub fn transfer (& self , new : :: subxt :: sp_core :: crypto :: AccountId32 , index : :: core :: primitive :: u32 ,) -> Result < :: subxt :: SubmittableExtrinsic < 'a , T , X , Transfer , DispatchError , root_mod :: Event > , :: subxt :: BasicError > { if self . client . metadata () . call_hash :: < Transfer > () ? == [124u8 , 83u8 , 33u8 , 230u8 , 23u8 , 70u8 , 83u8 , 59u8 , 76u8 , 100u8 , 219u8 , 100u8 , 165u8 , 163u8 , 102u8 , 193u8 , 11u8 , 22u8 , 30u8 , 125u8 , 114u8 , 28u8 , 61u8 , 156u8 , 38u8 , 170u8 , 129u8 , 74u8 , 187u8 , 28u8 , 33u8 , 65u8 ,] { let call = Transfer { new , index , } ; Ok (:: subxt :: SubmittableExtrinsic :: new (self . client , call)) } else { Err (:: subxt :: MetadataError :: IncompatibleMetadata . into ()) } } # [doc = "Free up an index owned by the sender."] # [doc = ""] # [doc = "Payment: Any previous deposit placed for the index is unreserved in the sender account."] # [doc = ""] # [doc = "The dispatch origin for this call must be _Signed_ and the sender must own the index."] # [doc = ""] # [doc = "- `index`: the index to be freed. This must be owned by the sender."] # [doc = ""] # [doc = "Emits `IndexFreed` if successful."] # [doc = ""] # [doc = "# <weight>"] # [doc = "- `O(1)`."] # [doc = "- One storage mutation (codec `O(1)`)."] # [doc = "- One reserve operation."] # [doc = "- One event."] # [doc = "-------------------"] # [doc = "- DB Weight: 1 Read/Write (Accounts)"] # [doc = "# </weight>"] pub fn free (& self , index : :: core :: primitive :: u32 ,) -> Result < :: subxt :: SubmittableExtrinsic < 'a , T , X , Free , DispatchError , root_mod :: Event > , :: subxt :: BasicError > { if self . client . metadata () . call_hash :: < Free > () ? == [153u8 , 143u8 , 162u8 , 33u8 , 229u8 , 3u8 , 159u8 , 153u8 , 111u8 , 100u8 , 160u8 , 250u8 , 227u8 , 24u8 , 157u8 , 226u8 , 173u8 , 39u8 , 25u8 , 200u8 , 137u8 , 147u8 , 232u8 , 213u8 , 182u8 , 49u8 , 142u8 , 250u8 , 139u8 , 155u8 , 84u8 , 214u8 ,] { let call = Free { index , } ; Ok (:: subxt :: SubmittableExtrinsic :: new (self . client , call)) } else { Err (:: subxt :: MetadataError :: IncompatibleMetadata . into ()) } } # [doc = "Force an index to an account. This doesn't require a deposit. If the index is already"] # [doc = "held, then any deposit is reimbursed to its current owner."] # [doc = ""] # [doc = "The dispatch origin for this call must be _Root_."] # [doc = ""] # [doc = "- `index`: the index to be (re-)assigned."] # [doc = "- `new`: the new owner of the index. This function is a no-op if it is equal to sender."] # [doc = "- `freeze`: if set to `true`, will freeze the index so it cannot be transferred."] # [doc = ""] # [doc = "Emits `IndexAssigned` if successful."] # [doc = ""] # [doc = "# <weight>"] # [doc = "- `O(1)`."] # [doc = "- One storage mutation (codec `O(1)`)."] # [doc = "- Up to one reserve operation."] # [doc = "- One event."] # [doc = "-------------------"] # [doc = "- DB Weight:"] # [doc = "   - Reads: Indices Accounts, System Account (original owner)"] # [doc = "   - Writes: Indices Accounts, System Account (original owner)"] # [doc = "# </weight>"] pub fn force_transfer (& self , new : :: subxt :: sp_core :: crypto :: AccountId32 , index : :: core :: primitive :: u32 , freeze : :: core :: primitive :: bool ,) -> Result < :: subxt :: SubmittableExtrinsic < 'a , T , X , ForceTransfer , DispatchError , root_mod :: Event > , :: subxt :: BasicError > { if self . client . metadata () . call_hash :: < ForceTransfer > () ? == [181u8 , 143u8 , 90u8 , 135u8 , 132u8 , 11u8 , 145u8 , 85u8 , 4u8 , 211u8 , 56u8 , 110u8 , 213u8 , 153u8 , 224u8 , 106u8 , 198u8 , 250u8 , 130u8 , 253u8 , 72u8 , 58u8 , 133u8 , 150u8 , 102u8 , 119u8 , 177u8 , 175u8 , 77u8 , 106u8 , 253u8 , 99u8 ,] { let call = ForceTransfer { new , index , freeze , } ; Ok (:: subxt :: SubmittableExtrinsic :: new (self . client , call)) } else { Err (:: subxt :: MetadataError :: IncompatibleMetadata . into ()) } } # [doc = "Freeze an index so it will always point to the sender account. This consumes the"] # [doc = "deposit."] # [doc = ""] # [doc = "The dispatch origin for this call must be _Signed_ and the signing account must have a"] # [doc = "non-frozen account `index`."] # [doc = ""] # [doc = "- `index`: the index to be frozen in place."] # [doc = ""] # [doc = "Emits `IndexFrozen` if successful."] # [doc = ""] # [doc = "# <weight>"] # [doc = "- `O(1)`."] # [doc = "- One storage mutation (codec `O(1)`)."] # [doc = "- Up to one slash operation."] # [doc = "- One event."] # [doc = "-------------------"] # [doc = "- DB Weight: 1 Read/Write (Accounts)"] # [doc = "# </weight>"] pub fn freeze (& self , index : :: core :: primitive :: u32 ,) -> Result < :: subxt :: SubmittableExtrinsic < 'a , T , X , Freeze , DispatchError , root_mod :: Event > , :: subxt :: BasicError > { if self . client . metadata () . call_hash :: < Freeze > () ? == [204u8 , 127u8 , 214u8 , 137u8 , 138u8 , 28u8 , 171u8 , 169u8 , 184u8 , 164u8 , 235u8 , 114u8 , 132u8 , 176u8 , 14u8 , 207u8 , 72u8 , 39u8 , 179u8 , 231u8 , 137u8 , 243u8 , 242u8 , 57u8 , 89u8 , 57u8 , 213u8 , 210u8 , 87u8 , 12u8 , 253u8 , 159u8 ,] { let call = Freeze { index , } ; Ok (:: subxt :: SubmittableExtrinsic :: new (self . client , call)) } else { Err (:: subxt :: MetadataError :: IncompatibleMetadata . into ()) } } } } pub type Event = runtime_types :: pallet_indices :: pallet :: Event ; pub mod events { use super :: runtime_types ; # [derive (:: subxt :: codec :: Decode , :: subxt :: codec :: Encode , Clone , Debug , Eq , PartialEq)] # [doc = "A account index was assigned."] pub struct IndexAssigned { pub who : :: subxt :: sp_core :: crypto :: AccountId32 , pub index : :: core :: primitive :: u32 , } impl :: subxt :: Event for IndexAssigned { const PALLET : & 'static str = "Indices" ; const EVENT : & 'static str = "IndexAssigned" ; } # [derive (:: subxt :: codec :: CompactAs , :: subxt :: codec :: Decode , :: subxt :: codec :: Encode , Clone , Debug , Eq , PartialEq)] # [doc = "A account index has been freed up (unassigned)."] pub struct IndexFreed { pub index : :: core :: primitive :: u32 , } impl :: subxt :: Event for IndexFreed { const PALLET : & 'static str = "Indices" ; const EVENT : & 'static str = "IndexFreed" ; } # [derive (:: subxt :: codec :: Decode , :: subxt :: codec :: Encode , Clone , Debug , Eq , PartialEq)] # [doc = "A account index has been frozen to its current account ID."] pub struct IndexFrozen { pub index : :: core :: primitive :: u32 , pub who : :: subxt :: sp_core :: crypto :: AccountId32 , } impl :: subxt :: Event for IndexFrozen { const PALLET : & 'static str = "Indices" ; const EVENT : & 'static str = "IndexFrozen" ; } } pub mod storage { use super :: runtime_types ; pub struct Accounts < 'a > (pub & 'a :: core :: primitive :: u32) ; impl :: subxt :: StorageEntry for Accounts < '_ > { const PALLET : & 'static str = "Indices" ; const STORAGE : & 'static str = "Accounts" ; type Value = (:: subxt :: sp_core :: crypto :: AccountId32 , :: core :: primitive :: u128 , :: core :: primitive :: bool ,) ; fn key (& self) -> :: subxt :: StorageEntryKey { :: subxt :: StorageEntryKey :: Map (vec ! [:: subxt :: StorageMapKey :: new (& self . 0 , :: subxt :: StorageHasher :: Blake2_128Concat)]) } } pub struct StorageApi < 'a , T : :: subxt :: Config > { client : & 'a :: subxt :: Client < T > , } impl < 'a , T : :: subxt :: Config > StorageApi < 'a , T > { pub fn new (client : & 'a :: subxt :: Client < T >) -> Self { Self { client } } # [doc = " The lookup from index to account."] pub async fn accounts (& self , _0 : & :: core :: primitive :: u32 , block_hash : :: core :: option :: Option < T :: Hash > ,) -> :: core :: result :: Result < :: core :: option :: Option < (:: subxt :: sp_core :: crypto :: AccountId32 , :: core :: primitive :: u128 , :: core :: primitive :: bool ,) > , :: subxt :: BasicError > { if self . client . metadata () . storage_hash :: < Accounts > () ? == [105u8 , 208u8 , 81u8 , 30u8 , 157u8 , 108u8 , 22u8 , 122u8 , 152u8 , 220u8 , 40u8 , 97u8 , 255u8 , 166u8 , 222u8 , 11u8 , 81u8 , 245u8 , 143u8 , 79u8 , 57u8 , 19u8 , 174u8 , 164u8 , 220u8 , 59u8 , 77u8 , 117u8 , 39u8 , 72u8 , 251u8 , 234u8 ,] { let entry = Accounts (_0) ; self . client . storage () . fetch (& entry , block_hash) . await } else { Err (:: subxt :: MetadataError :: IncompatibleMetadata . into ()) } } # [doc = " The lookup from index to account."] pub async fn accounts_iter (& self , block_hash : :: core :: option :: Option < T :: Hash > ,) -> :: core :: result :: Result < :: subxt :: KeyIter < 'a , T , Accounts < 'a > > , :: subxt :: BasicError > { if self . client . metadata () . storage_hash :: < Accounts > () ? == [105u8 , 208u8 , 81u8 , 30u8 , 157u8 , 108u8 , 22u8 , 122u8 , 152u8 , 220u8 , 40u8 , 97u8 , 255u8 , 166u8 , 222u8 , 11u8 , 81u8 , 245u8 , 143u8 , 79u8 , 57u8 , 19u8 , 174u8 , 164u8 , 220u8 , 59u8 , 77u8 , 117u8 , 39u8 , 72u8 , 251u8 , 234u8 ,] { self . client . storage () . iter (block_hash) . await } else { Err (:: subxt :: MetadataError :: IncompatibleMetadata . into ()) } } } } pub mod constants { use super :: runtime_types ; pub struct ConstantsApi < 'a , T : :: subxt :: Config > { client : & 'a :: subxt :: Client < T > , } impl < 'a , T : :: subxt :: Config > ConstantsApi < 'a , T > { pub fn new (client : & 'a :: subxt :: Client < T >) -> Self { Self { client } } # [doc = " The deposit needed for reserving an index."] pub fn deposit (& self) -> :: core :: result :: Result < :: core :: primitive :: u128 , :: subxt :: BasicError > { if self . client . metadata () . constant_hash ("Indices" , "Deposit") ? == [217u8 , 97u8 , 70u8 , 109u8 , 180u8 , 214u8 , 183u8 , 67u8 , 253u8 , 148u8 , 245u8 , 108u8 , 187u8 , 95u8 , 0u8 , 15u8 , 167u8 , 149u8 , 163u8 , 194u8 , 206u8 , 220u8 , 164u8 , 101u8 , 1u8 , 99u8 , 206u8 , 165u8 , 63u8 , 141u8 , 109u8 , 1u8 ,] { let pallet = self . client . metadata () . pallet ("Indices") ? ; let constant = pallet . constant ("Deposit") ? ; let value = :: subxt :: codec :: Decode :: decode (& mut & constant . value [..]) ? ; Ok (value) } else { Err (:: subxt :: MetadataError :: IncompatibleMetadata . into ()) } } } } } pub mod democracy { use super :: root_mod ; use super :: runtime_types ; pub mod calls { use super :: root_mod ; use super :: runtime_types ; type DispatchError = runtime_types :: sp_runtime :: DispatchError ; # [derive (:: subxt :: codec :: Decode , :: subxt :: codec :: Encode , Clone , Debug , Eq , PartialEq)] pub struct Propose { pub proposal_hash : :: subxt :: sp_core :: H256 , # [codec (compact)] pub value : :: core :: primitive :: u128 , } impl :: subxt :: Call for Propose { const PALLET : & 'static str = "Democracy" ; const FUNCTION : & 'static str = "propose" ; } # [derive (:: subxt :: codec :: Decode , :: subxt :: codec :: Encode , Clone , Debug , Eq , PartialEq)] pub struct Second { # [codec (compact)] pub proposal : :: core :: primitive :: u32 , # [codec (compact)] pub seconds_upper_bound : :: core :: primitive :: u32 , } impl :: subxt :: Call for Second { const PALLET : & 'static str = "Democracy" ; const FUNCTION : & 'static str = "second" ; } # [derive (:: subxt :: codec :: Decode , :: subxt :: codec :: Encode , Clone , Debug , Eq , PartialEq)] pub struct Vote { # [codec (compact)] pub ref_index : :: core :: primitive :: u32 , pub vote : runtime_types :: pallet_democracy :: vote :: AccountVote < :: core :: primitive :: u128 > , } impl :: subxt :: Call for Vote { const PALLET : & 'static str = "Democracy" ; const FUNCTION : & 'static str = "vote" ; } # [derive (:: subxt :: codec :: CompactAs , :: subxt :: codec :: Decode , :: subxt :: codec :: Encode , Clone , Debug , Eq , PartialEq)] pub struct EmergencyCancel { pub ref_index : :: core :: primitive :: u32 , } impl :: subxt :: Call for EmergencyCancel { const PALLET : & 'static str = "Democracy" ; const FUNCTION : & 'static str = "emergency_cancel" ; } # [derive (:: subxt :: codec :: Decode , :: subxt :: codec :: Encode , Clone , Debug , Eq , PartialEq)] pub struct ExternalPropose { pub proposal_hash : :: subxt :: sp_core :: H256 , } impl :: subxt :: Call for ExternalPropose { const PALLET : & 'static str = "Democracy" ; const FUNCTION : & 'static str = "external_propose" ; } # [derive (:: subxt :: codec :: Decode , :: subxt :: codec :: Encode , Clone , Debug , Eq , PartialEq)] pub struct ExternalProposeMajority { pub proposal_hash : :: subxt :: sp_core :: H256 , } impl :: subxt :: Call for ExternalProposeMajority { const PALLET : & 'static str = "Democracy" ; const FUNCTION : & 'static str = "external_propose_majority" ; } # [derive (:: subxt :: codec :: Decode , :: subxt :: codec :: Encode , Clone , Debug , Eq , PartialEq)] pub struct ExternalProposeDefault { pub proposal_hash : :: subxt :: sp_core :: H256 , } impl :: subxt :: Call for ExternalProposeDefault { const PALLET : & 'static str = "Democracy" ; const FUNCTION : & 'static str = "external_propose_default" ; } # [derive (:: subxt :: codec :: Decode , :: subxt :: codec :: Encode , Clone , Debug , Eq , PartialEq)] pub struct FastTrack { pub proposal_hash : :: subxt :: sp_core :: H256 , pub voting_period : :: core :: primitive :: u32 , pub delay : :: core :: primitive :: u32 , } impl :: subxt :: Call for FastTrack { const PALLET : & 'static str = "Democracy" ; const FUNCTION : & 'static str = "fast_track" ; } # [derive (:: subxt :: codec :: Decode , :: subxt :: codec :: Encode , Clone , Debug , Eq , PartialEq)] pub struct VetoExternal { pub proposal_hash : :: subxt :: sp_core :: H256 , } impl :: subxt :: Call for VetoExternal { const PALLET : & 'static str = "Democracy" ; const FUNCTION : & 'static str = "veto_external" ; } # [derive (:: subxt :: codec :: Decode , :: subxt :: codec :: Encode , Clone , Debug , Eq , PartialEq)] pub struct CancelReferendum { # [codec (compact)] pub ref_index : :: core :: primitive :: u32 , } impl :: subxt :: Call for CancelReferendum { const PALLET : & 'static str = "Democracy" ; const FUNCTION : & 'static str = "cancel_referendum" ; } # [derive (:: subxt :: codec :: CompactAs , :: subxt :: codec :: Decode , :: subxt :: codec :: Encode , Clone , Debug , Eq , PartialEq)] pub struct CancelQueued { pub which : :: core :: primitive :: u32 , } impl :: subxt :: Call for CancelQueued { const PALLET : & 'static str = "Democracy" ; const FUNCTION : & 'static str = "cancel_queued" ; } # [derive (:: subxt :: codec :: Decode , :: subxt :: codec :: Encode , Clone , Debug , Eq , PartialEq)] pub struct Delegate { pub to : :: subxt :: sp_core :: crypto :: AccountId32 , pub conviction : runtime_types :: pallet_democracy :: conviction :: Conviction , pub balance : :: core :: primitive :: u128 , } impl :: subxt :: Call for Delegate { const PALLET : & 'static str = "Democracy" ; const FUNCTION : & 'static str = "delegate" ; } # [derive (:: subxt :: codec :: Decode , :: subxt :: codec :: Encode , Clone , Debug , Eq , PartialEq)] pub struct Undelegate ; impl :: subxt :: Call for Undelegate { const PALLET : & 'static str = "Democracy" ; const FUNCTION : & 'static str = "undelegate" ; } # [derive (:: subxt :: codec :: Decode , :: subxt :: codec :: Encode , Clone , Debug , Eq , PartialEq)] pub struct ClearPublicProposals ; impl :: subxt :: Call for ClearPublicProposals { const PALLET : & 'static str = "Democracy" ; const FUNCTION : & 'static str = "clear_public_proposals" ; } # [derive (:: subxt :: codec :: Decode , :: subxt :: codec :: Encode , Clone , Debug , Eq , PartialEq)] pub struct NotePreimage { pub encoded_proposal : :: std :: vec :: Vec < :: core :: primitive :: u8 > , } impl :: subxt :: Call for NotePreimage { const PALLET : & 'static str = "Democracy" ; const FUNCTION : & 'static str = "note_preimage" ; } # [derive (:: subxt :: codec :: Decode , :: subxt :: codec :: Encode , Clone , Debug , Eq , PartialEq)] pub struct NotePreimageOperational { pub encoded_proposal : :: std :: vec :: Vec < :: core :: primitive :: u8 > , } impl :: subxt :: Call for NotePreimageOperational { const PALLET : & 'static str = "Democracy" ; const FUNCTION : & 'static str = "note_preimage_operational" ; } # [derive (:: subxt :: codec :: Decode , :: subxt :: codec :: Encode , Clone , Debug , Eq , PartialEq)] pub struct NoteImminentPreimage { pub encoded_proposal : :: std :: vec :: Vec < :: core :: primitive :: u8 > , } impl :: subxt :: Call for NoteImminentPreimage { const PALLET : & 'static str = "Democracy" ; const FUNCTION : & 'static str = "note_imminent_preimage" ; } # [derive (:: subxt :: codec :: Decode , :: subxt :: codec :: Encode , Clone , Debug , Eq , PartialEq)] pub struct NoteImminentPreimageOperational { pub encoded_proposal : :: std :: vec :: Vec < :: core :: primitive :: u8 > , } impl :: subxt :: Call for NoteImminentPreimageOperational { const PALLET : & 'static str = "Democracy" ; const FUNCTION : & 'static str = "note_imminent_preimage_operational" ; } # [derive (:: subxt :: codec :: Decode , :: subxt :: codec :: Encode , Clone , Debug , Eq , PartialEq)] pub struct ReapPreimage { pub proposal_hash : :: subxt :: sp_core :: H256 , # [codec (compact)] pub proposal_len_upper_bound : :: core :: primitive :: u32 , } impl :: subxt :: Call for ReapPreimage { const PALLET : & 'static str = "Democracy" ; const FUNCTION : & 'static str = "reap_preimage" ; } # [derive (:: subxt :: codec :: Decode , :: subxt :: codec :: Encode , Clone , Debug , Eq , PartialEq)] pub struct Unlock { pub target : :: subxt :: sp_core :: crypto :: AccountId32 , } impl :: subxt :: Call for Unlock { const PALLET : & 'static str = "Democracy" ; const FUNCTION : & 'static str = "unlock" ; } # [derive (:: subxt :: codec :: CompactAs , :: subxt :: codec :: Decode , :: subxt :: codec :: Encode , Clone , Debug , Eq , PartialEq)] pub struct RemoveVote { pub index : :: core :: primitive :: u32 , } impl :: subxt :: Call for RemoveVote { const PALLET : & 'static str = "Democracy" ; const FUNCTION : & 'static str = "remove_vote" ; } # [derive (:: subxt :: codec :: Decode , :: subxt :: codec :: Encode , Clone , Debug , Eq , PartialEq)] pub struct RemoveOtherVote { pub target : :: subxt :: sp_core :: crypto :: AccountId32 , pub index : :: core :: primitive :: u32 , } impl :: subxt :: Call for RemoveOtherVote { const PALLET : & 'static str = "Democracy" ; const FUNCTION : & 'static str = "remove_other_vote" ; } # [derive (:: subxt :: codec :: Decode , :: subxt :: codec :: Encode , Clone , Debug , Eq , PartialEq)] pub struct EnactProposal { pub proposal_hash : :: subxt :: sp_core :: H256 , pub index : :: core :: primitive :: u32 , } impl :: subxt :: Call for EnactProposal { const PALLET : & 'static str = "Democracy" ; const FUNCTION : & 'static str = "enact_proposal" ; } # [derive (:: subxt :: codec :: Decode , :: subxt :: codec :: Encode , Clone , Debug , Eq , PartialEq)] pub struct Blacklist { pub proposal_hash : :: subxt :: sp_core :: H256 , pub maybe_ref_index : :: core :: option :: Option < :: core :: primitive :: u32 > , } impl :: subxt :: Call for Blacklist { const PALLET : & 'static str = "Democracy" ; const FUNCTION : & 'static str = "blacklist" ; } # [derive (:: subxt :: codec :: Decode , :: subxt :: codec :: Encode , Clone , Debug , Eq , PartialEq)] pub struct CancelProposal { # [codec (compact)] pub prop_index : :: core :: primitive :: u32 , } impl :: subxt :: Call for CancelProposal { const PALLET : & 'static str = "Democracy" ; const FUNCTION : & 'static str = "cancel_proposal" ; } pub struct TransactionApi < 'a , T : :: subxt :: Config , X > { client : & 'a :: subxt :: Client < T > , marker : :: core :: marker :: PhantomData < X > , } impl < 'a , T , X > TransactionApi < 'a , T , X > where T : :: subxt :: Config , X : :: subxt :: extrinsic :: ExtrinsicParams < T > , { pub fn new (client : & 'a :: subxt :: Client < T >) -> Self { Self { client , marker : :: core :: marker :: PhantomData } } # [doc = "Propose a sensitive action to be taken."] # [doc = ""] # [doc = "The dispatch origin of this call must be _Signed_ and the sender must"] # [doc = "have funds to cover the deposit."] # [doc = ""] # [doc = "- `proposal_hash`: The hash of the proposal preimage."] # [doc = "- `value`: The amount of deposit (must be at least `MinimumDeposit`)."] # [doc = ""] # [doc = "Emits `Proposed`."] # [doc = ""] # [doc = "Weight: `O(p)`"] pub fn propose (& self , proposal_hash : :: subxt :: sp_core :: H256 , value : :: core :: primitive :: u128 ,) -> Result < :: subxt :: SubmittableExtrinsic < 'a , T , X , Propose , DispatchError , root_mod :: Event > , :: subxt :: BasicError > { if self . client . metadata () . call_hash :: < Propose > () ? == [149u8 , 60u8 , 16u8 , 143u8 , 114u8 , 16u8 , 124u8 , 96u8 , 97u8 , 5u8 , 176u8 , 137u8 , 188u8 , 164u8 , 65u8 , 145u8 , 142u8 , 104u8 , 74u8 , 120u8 , 248u8 , 90u8 , 109u8 , 112u8 , 29u8 , 226u8 , 208u8 , 230u8 , 101u8 , 8u8 , 79u8 , 12u8 ,] { let call = Propose { proposal_hash , value , } ; Ok (:: subxt :: SubmittableExtrinsic :: new (self . client , call)) } else { Err (:: subxt :: MetadataError :: IncompatibleMetadata . into ()) } } # [doc = "Signals agreement with a particular proposal."] # [doc = ""] # [doc = "The dispatch origin of this call must be _Signed_ and the sender"] # [doc = "must have funds to cover the deposit, equal to the original deposit."] # [doc = ""] # [doc = "- `proposal`: The index of the proposal to second."] # [doc = "- `seconds_upper_bound`: an upper bound on the current number of seconds on this"] # [doc = "  proposal. Extrinsic is weighted according to this value with no refund."] # [doc = ""] # [doc = "Weight: `O(S)` where S is the number of seconds a proposal already has."] pub fn second (& self , proposal : :: core :: primitive :: u32 , seconds_upper_bound : :: core :: primitive :: u32 ,) -> Result < :: subxt :: SubmittableExtrinsic < 'a , T , X , Second , DispatchError , root_mod :: Event > , :: subxt :: BasicError > { if self . client . metadata () . call_hash :: < Second > () ? == [37u8 , 226u8 , 138u8 , 26u8 , 138u8 , 46u8 , 39u8 , 147u8 , 22u8 , 32u8 , 245u8 , 40u8 , 49u8 , 228u8 , 218u8 , 225u8 , 72u8 , 89u8 , 37u8 , 90u8 , 132u8 , 31u8 , 52u8 , 22u8 , 234u8 , 124u8 , 254u8 , 223u8 , 56u8 , 215u8 , 255u8 , 79u8 ,] { let call = Second { proposal , seconds_upper_bound , } ; Ok (:: subxt :: SubmittableExtrinsic :: new (self . client , call)) } else { Err (:: subxt :: MetadataError :: IncompatibleMetadata . into ()) } } # [doc = "Vote in a referendum. If `vote.is_aye()`, the vote is to enact the proposal;"] # [doc = "otherwise it is a vote to keep the status quo."] # [doc = ""] # [doc = "The dispatch origin of this call must be _Signed_."] # [doc = ""] # [doc = "- `ref_index`: The index of the referendum to vote for."] # [doc = "- `vote`: The vote configuration."] # [doc = ""] # [doc = "Weight: `O(R)` where R is the number of referendums the voter has voted on."] pub fn vote (& self , ref_index : :: core :: primitive :: u32 , vote : runtime_types :: pallet_democracy :: vote :: AccountVote < :: core :: primitive :: u128 > ,) -> Result < :: subxt :: SubmittableExtrinsic < 'a , T , X , Vote , DispatchError , root_mod :: Event > , :: subxt :: BasicError > { if self . client . metadata () . call_hash :: < Vote > () ? == [1u8 , 235u8 , 77u8 , 58u8 , 54u8 , 224u8 , 30u8 , 168u8 , 150u8 , 169u8 , 20u8 , 172u8 , 137u8 , 191u8 , 189u8 , 184u8 , 28u8 , 118u8 , 204u8 , 233u8 , 146u8 , 212u8 , 45u8 , 139u8 , 58u8 , 175u8 , 231u8 , 169u8 , 43u8 , 164u8 , 149u8 , 16u8 ,] { let call = Vote { ref_index , vote , } ; Ok (:: subxt :: SubmittableExtrinsic :: new (self . client , call)) } else { Err (:: subxt :: MetadataError :: IncompatibleMetadata . into ()) } } # [doc = "Schedule an emergency cancellation of a referendum. Cannot happen twice to the same"] # [doc = "referendum."] # [doc = ""] # [doc = "The dispatch origin of this call must be `CancellationOrigin`."] # [doc = ""] # [doc = "-`ref_index`: The index of the referendum to cancel."] # [doc = ""] # [doc = "Weight: `O(1)`."] pub fn emergency_cancel (& self , ref_index : :: core :: primitive :: u32 ,) -> Result < :: subxt :: SubmittableExtrinsic < 'a , T , X , EmergencyCancel , DispatchError , root_mod :: Event > , :: subxt :: BasicError > { if self . client . metadata () . call_hash :: < EmergencyCancel > () ? == [4u8 , 129u8 , 205u8 , 102u8 , 202u8 , 197u8 , 75u8 , 155u8 , 24u8 , 125u8 , 157u8 , 73u8 , 50u8 , 243u8 , 173u8 , 103u8 , 49u8 , 60u8 , 50u8 , 63u8 , 54u8 , 40u8 , 34u8 , 227u8 , 29u8 , 247u8 , 179u8 , 102u8 , 107u8 , 177u8 , 117u8 , 161u8 ,] { let call = EmergencyCancel { ref_index , } ; Ok (:: subxt :: SubmittableExtrinsic :: new (self . client , call)) } else { Err (:: subxt :: MetadataError :: IncompatibleMetadata . into ()) } } # [doc = "Schedule a referendum to be tabled once it is legal to schedule an external"] # [doc = "referendum."] # [doc = ""] # [doc = "The dispatch origin of this call must be `ExternalOrigin`."] # [doc = ""] # [doc = "- `proposal_hash`: The preimage hash of the proposal."] # [doc = ""] # [doc = "Weight: `O(V)` with V number of vetoers in the blacklist of proposal."] # [doc = "  Decoding vec of length V. Charged as maximum"] pub fn external_propose (& self , proposal_hash : :: subxt :: sp_core :: H256 ,) -> Result < :: subxt :: SubmittableExtrinsic < 'a , T , X , ExternalPropose , DispatchError , root_mod :: Event > , :: subxt :: BasicError > { if self . client . metadata () . call_hash :: < ExternalPropose > () ? == [50u8 , 82u8 , 155u8 , 206u8 , 57u8 , 61u8 , 64u8 , 43u8 , 30u8 , 71u8 , 89u8 , 91u8 , 221u8 , 46u8 , 15u8 , 222u8 , 15u8 , 211u8 , 56u8 , 176u8 , 84u8 , 225u8 , 192u8 , 92u8 , 253u8 , 56u8 , 207u8 , 29u8 , 252u8 , 77u8 , 245u8 , 113u8 ,] { let call = ExternalPropose { proposal_hash , } ; Ok (:: subxt :: SubmittableExtrinsic :: new (self . client , call)) } else { Err (:: subxt :: MetadataError :: IncompatibleMetadata . into ()) } } # [doc = "Schedule a majority-carries referendum to be tabled next once it is legal to schedule"] # [doc = "an external referendum."] # [doc = ""] # [doc = "The dispatch of this call must be `ExternalMajorityOrigin`."] # [doc = ""] # [doc = "- `proposal_hash`: The preimage hash of the proposal."] # [doc = ""] # [doc = "Unlike `external_propose`, blacklisting has no effect on this and it may replace a"] # [doc = "pre-scheduled `external_propose` call."] # [doc = ""] # [doc = "Weight: `O(1)`"] pub fn external_propose_majority (& self , proposal_hash : :: subxt :: sp_core :: H256 ,) -> Result < :: subxt :: SubmittableExtrinsic < 'a , T , X , ExternalProposeMajority , DispatchError , root_mod :: Event > , :: subxt :: BasicError > { if self . client . metadata () . call_hash :: < ExternalProposeMajority > () ? == [18u8 , 92u8 , 204u8 , 120u8 , 189u8 , 60u8 , 223u8 , 166u8 , 213u8 , 49u8 , 20u8 , 131u8 , 202u8 , 1u8 , 87u8 , 226u8 , 168u8 , 156u8 , 144u8 , 110u8 , 118u8 , 125u8 , 81u8 , 111u8 , 229u8 , 244u8 , 89u8 , 93u8 , 202u8 , 140u8 , 16u8 , 220u8 ,] { let call = ExternalProposeMajority { proposal_hash , } ; Ok (:: subxt :: SubmittableExtrinsic :: new (self . client , call)) } else { Err (:: subxt :: MetadataError :: IncompatibleMetadata . into ()) } } # [doc = "Schedule a negative-turnout-bias referendum to be tabled next once it is legal to"] # [doc = "schedule an external referendum."] # [doc = ""] # [doc = "The dispatch of this call must be `ExternalDefaultOrigin`."] # [doc = ""] # [doc = "- `proposal_hash`: The preimage hash of the proposal."] # [doc = ""] # [doc = "Unlike `external_propose`, blacklisting has no effect on this and it may replace a"] # [doc = "pre-scheduled `external_propose` call."] # [doc = ""] # [doc = "Weight: `O(1)`"] pub fn external_propose_default (& self , proposal_hash : :: subxt :: sp_core :: H256 ,) -> Result < :: subxt :: SubmittableExtrinsic < 'a , T , X , ExternalProposeDefault , DispatchError , root_mod :: Event > , :: subxt :: BasicError > { if self . client . metadata () . call_hash :: < ExternalProposeDefault > () ? == [51u8 , 75u8 , 236u8 , 51u8 , 53u8 , 39u8 , 26u8 , 231u8 , 212u8 , 191u8 , 175u8 , 233u8 , 181u8 , 156u8 , 210u8 , 221u8 , 181u8 , 182u8 , 113u8 , 69u8 , 171u8 , 70u8 , 219u8 , 133u8 , 88u8 , 78u8 , 87u8 , 228u8 , 177u8 , 53u8 , 111u8 , 115u8 ,] { let call = ExternalProposeDefault { proposal_hash , } ; Ok (:: subxt :: SubmittableExtrinsic :: new (self . client , call)) } else { Err (:: subxt :: MetadataError :: IncompatibleMetadata . into ()) } } # [doc = "Schedule the currently externally-proposed majority-carries referendum to be tabled"] # [doc = "immediately. If there is no externally-proposed referendum currently, or if there is one"] # [doc = "but it is not a majority-carries referendum then it fails."] # [doc = ""] # [doc = "The dispatch of this call must be `FastTrackOrigin`."] # [doc = ""] # [doc = "- `proposal_hash`: The hash of the current external proposal."] # [doc = "- `voting_period`: The period that is allowed for voting on this proposal."] # [doc = "\tMust be always greater than zero."] # [doc = "\tFor `FastTrackOrigin` must be equal or greater than `FastTrackVotingPeriod`."] # [doc = "- `delay`: The number of block after voting has ended in approval and this should be"] # [doc = "  enacted. This doesn't have a minimum amount."] # [doc = ""] # [doc = "Emits `Started`."] # [doc = ""] # [doc = "Weight: `O(1)`"] pub fn fast_track (& self , proposal_hash : :: subxt :: sp_core :: H256 , voting_period : :: core :: primitive :: u32 , delay : :: core :: primitive :: u32 ,) -> Result < :: subxt :: SubmittableExtrinsic < 'a , T , X , FastTrack , DispatchError , root_mod :: Event > , :: subxt :: BasicError > { if self . client . metadata () . call_hash :: < FastTrack > () ? == [232u8 , 255u8 , 150u8 , 13u8 , 151u8 , 28u8 , 253u8 , 37u8 , 183u8 , 127u8 , 53u8 , 228u8 , 160u8 , 11u8 , 223u8 , 48u8 , 74u8 , 5u8 , 37u8 , 3u8 , 84u8 , 224u8 , 79u8 , 172u8 , 120u8 , 220u8 , 158u8 , 191u8 , 127u8 , 55u8 , 126u8 , 135u8 ,] { let call = FastTrack { proposal_hash , voting_period , delay , } ; Ok (:: subxt :: SubmittableExtrinsic :: new (self . client , call)) } else { Err (:: subxt :: MetadataError :: IncompatibleMetadata . into ()) } } # [doc = "Veto and blacklist the external proposal hash."] # [doc = ""] # [doc = "The dispatch origin of this call must be `VetoOrigin`."] # [doc = ""] # [doc = "- `proposal_hash`: The preimage hash of the proposal to veto and blacklist."] # [doc = ""] # [doc = "Emits `Vetoed`."] # [doc = ""] # [doc = "Weight: `O(V + log(V))` where V is number of `existing vetoers`"] pub fn veto_external (& self , proposal_hash : :: subxt :: sp_core :: H256 ,) -> Result < :: subxt :: SubmittableExtrinsic < 'a , T , X , VetoExternal , DispatchError , root_mod :: Event > , :: subxt :: BasicError > { if self . client . metadata () . call_hash :: < VetoExternal > () ? == [230u8 , 207u8 , 43u8 , 137u8 , 173u8 , 97u8 , 143u8 , 183u8 , 193u8 , 78u8 , 252u8 , 104u8 , 237u8 , 32u8 , 151u8 , 164u8 , 91u8 , 247u8 , 233u8 , 36u8 , 198u8 , 88u8 , 63u8 , 176u8 , 77u8 , 87u8 , 26u8 , 242u8 , 211u8 , 47u8 , 193u8 , 180u8 ,] { let call = VetoExternal { proposal_hash , } ; Ok (:: subxt :: SubmittableExtrinsic :: new (self . client , call)) } else { Err (:: subxt :: MetadataError :: IncompatibleMetadata . into ()) } } # [doc = "Remove a referendum."] # [doc = ""] # [doc = "The dispatch origin of this call must be _Root_."] # [doc = ""] # [doc = "- `ref_index`: The index of the referendum to cancel."] # [doc = ""] # [doc = "# Weight: `O(1)`."] pub fn cancel_referendum (& self , ref_index : :: core :: primitive :: u32 ,) -> Result < :: subxt :: SubmittableExtrinsic < 'a , T , X , CancelReferendum , DispatchError , root_mod :: Event > , :: subxt :: BasicError > { if self . client . metadata () . call_hash :: < CancelReferendum > () ? == [107u8 , 144u8 , 114u8 , 224u8 , 39u8 , 217u8 , 156u8 , 202u8 , 62u8 , 4u8 , 196u8 , 63u8 , 145u8 , 196u8 , 107u8 , 241u8 , 3u8 , 61u8 , 202u8 , 20u8 , 123u8 , 158u8 , 153u8 , 45u8 , 192u8 , 192u8 , 244u8 , 42u8 , 224u8 , 23u8 , 243u8 , 225u8 ,] { let call = CancelReferendum { ref_index , } ; Ok (:: subxt :: SubmittableExtrinsic :: new (self . client , call)) } else { Err (:: subxt :: MetadataError :: IncompatibleMetadata . into ()) } } # [doc = "Cancel a proposal queued for enactment."] # [doc = ""] # [doc = "The dispatch origin of this call must be _Root_."] # [doc = ""] # [doc = "- `which`: The index of the referendum to cancel."] # [doc = ""] # [doc = "Weight: `O(D)` where `D` is the items in the dispatch queue. Weighted as `D = 10`."] pub fn cancel_queued (& self , which : :: core :: primitive :: u32 ,) -> Result < :: subxt :: SubmittableExtrinsic < 'a , T , X , CancelQueued , DispatchError , root_mod :: Event > , :: subxt :: BasicError > { if self . client . metadata () . call_hash :: < CancelQueued > () ? == [130u8 , 218u8 , 212u8 , 143u8 , 89u8 , 134u8 , 207u8 , 161u8 , 165u8 , 202u8 , 237u8 , 237u8 , 81u8 , 125u8 , 165u8 , 147u8 , 222u8 , 198u8 , 236u8 , 1u8 , 223u8 , 74u8 , 200u8 , 6u8 , 208u8 , 128u8 , 215u8 , 50u8 , 46u8 , 117u8 , 16u8 , 143u8 ,] { let call = CancelQueued { which , } ; Ok (:: subxt :: SubmittableExtrinsic :: new (self . client , call)) } else { Err (:: subxt :: MetadataError :: IncompatibleMetadata . into ()) } } # [doc = "Delegate the voting power (with some given conviction) of the sending account."] # [doc = ""] # [doc = "The balance delegated is locked for as long as it's delegated, and thereafter for the"] # [doc = "time appropriate for the conviction's lock period."] # [doc = ""] # [doc = "The dispatch origin of this call must be _Signed_, and the signing account must either:"] # [doc = "  - be delegating already; or"] # [doc = "  - have no voting activity (if there is, then it will need to be removed/consolidated"] # [doc = "    through `reap_vote` or `unvote`)."] # [doc = ""] # [doc = "- `to`: The account whose voting the `target` account's voting power will follow."] # [doc = "- `conviction`: The conviction that will be attached to the delegated votes. When the"] # [doc = "  account is undelegated, the funds will be locked for the corresponding period."] # [doc = "- `balance`: The amount of the account's balance to be used in delegating. This must not"] # [doc = "  be more than the account's current balance."] # [doc = ""] # [doc = "Emits `Delegated`."] # [doc = ""] # [doc = "Weight: `O(R)` where R is the number of referendums the voter delegating to has"] # [doc = "  voted on. Weight is charged as if maximum votes."] pub fn delegate (& self , to : :: subxt :: sp_core :: crypto :: AccountId32 , conviction : runtime_types :: pallet_democracy :: conviction :: Conviction , balance : :: core :: primitive :: u128 ,) -> Result < :: subxt :: SubmittableExtrinsic < 'a , T , X , Delegate , DispatchError , root_mod :: Event > , :: subxt :: BasicError > { if self . client . metadata () . call_hash :: < Delegate > () ? == [33u8 , 155u8 , 180u8 , 53u8 , 39u8 , 251u8 , 59u8 , 100u8 , 16u8 , 124u8 , 209u8 , 40u8 , 42u8 , 152u8 , 3u8 , 109u8 , 97u8 , 211u8 , 129u8 , 151u8 , 82u8 , 45u8 , 16u8 , 98u8 , 114u8 , 250u8 , 145u8 , 176u8 , 244u8 , 39u8 , 64u8 , 11u8 ,] { let call = Delegate { to , conviction , balance , } ; Ok (:: subxt :: SubmittableExtrinsic :: new (self . client , call)) } else { Err (:: subxt :: MetadataError :: IncompatibleMetadata . into ()) } } # [doc = "Undelegate the voting power of the sending account."] # [doc = ""] # [doc = "Tokens may be unlocked following once an amount of time consistent with the lock period"] # [doc = "of the conviction with which the delegation was issued."] # [doc = ""] # [doc = "The dispatch origin of this call must be _Signed_ and the signing account must be"] # [doc = "currently delegating."] # [doc = ""] # [doc = "Emits `Undelegated`."] # [doc = ""] # [doc = "Weight: `O(R)` where R is the number of referendums the voter delegating to has"] # [doc = "  voted on. Weight is charged as if maximum votes."] pub fn undelegate (& self ,) -> Result < :: subxt :: SubmittableExtrinsic < 'a , T , X , Undelegate , DispatchError , root_mod :: Event > , :: subxt :: BasicError > { if self . client . metadata () . call_hash :: < Undelegate > () ? == [165u8 , 40u8 , 183u8 , 209u8 , 57u8 , 153u8 , 111u8 , 29u8 , 114u8 , 109u8 , 107u8 , 235u8 , 97u8 , 61u8 , 53u8 , 155u8 , 44u8 , 245u8 , 28u8 , 220u8 , 56u8 , 134u8 , 43u8 , 122u8 , 248u8 , 156u8 , 191u8 , 154u8 , 4u8 , 121u8 , 152u8 , 153u8 ,] { let call = Undelegate { } ; Ok (:: subxt :: SubmittableExtrinsic :: new (self . client , call)) } else { Err (:: subxt :: MetadataError :: IncompatibleMetadata . into ()) } } # [doc = "Clears all public proposals."] # [doc = ""] # [doc = "The dispatch origin of this call must be _Root_."] # [doc = ""] # [doc = "Weight: `O(1)`."] pub fn clear_public_proposals (& self ,) -> Result < :: subxt :: SubmittableExtrinsic < 'a , T , X , ClearPublicProposals , DispatchError , root_mod :: Event > , :: subxt :: BasicError > { if self . client . metadata () . call_hash :: < ClearPublicProposals > () ? == [59u8 , 126u8 , 254u8 , 223u8 , 252u8 , 225u8 , 75u8 , 185u8 , 188u8 , 181u8 , 42u8 , 179u8 , 211u8 , 73u8 , 12u8 , 141u8 , 243u8 , 197u8 , 46u8 , 130u8 , 215u8 , 196u8 , 225u8 , 88u8 , 48u8 , 199u8 , 231u8 , 249u8 , 195u8 , 53u8 , 184u8 , 204u8 ,] { let call = ClearPublicProposals { } ; Ok (:: subxt :: SubmittableExtrinsic :: new (self . client , call)) } else { Err (:: subxt :: MetadataError :: IncompatibleMetadata . into ()) } } # [doc = "Register the preimage for an upcoming proposal. This doesn't require the proposal to be"] # [doc = "in the dispatch queue but does require a deposit, returned once enacted."] # [doc = ""] # [doc = "The dispatch origin of this call must be _Signed_."] # [doc = ""] # [doc = "- `encoded_proposal`: The preimage of a proposal."] # [doc = ""] # [doc = "Emits `PreimageNoted`."] # [doc = ""] # [doc = "Weight: `O(E)` with E size of `encoded_proposal` (protected by a required deposit)."] pub fn note_preimage (& self , encoded_proposal : :: std :: vec :: Vec < :: core :: primitive :: u8 > ,) -> Result < :: subxt :: SubmittableExtrinsic < 'a , T , X , NotePreimage , DispatchError , root_mod :: Event > , :: subxt :: BasicError > { if self . client . metadata () . call_hash :: < NotePreimage > () ? == [121u8 , 179u8 , 204u8 , 32u8 , 104u8 , 133u8 , 99u8 , 153u8 , 226u8 , 190u8 , 89u8 , 121u8 , 232u8 , 154u8 , 89u8 , 133u8 , 124u8 , 222u8 , 237u8 , 39u8 , 50u8 , 128u8 , 80u8 , 115u8 , 186u8 , 180u8 , 151u8 , 139u8 , 73u8 , 112u8 , 148u8 , 232u8 ,] { let call = NotePreimage { encoded_proposal , } ; Ok (:: subxt :: SubmittableExtrinsic :: new (self . client , call)) } else { Err (:: subxt :: MetadataError :: IncompatibleMetadata . into ()) } } # [doc = "Same as `note_preimage` but origin is `OperationalPreimageOrigin`."] pub fn note_preimage_operational (& self , encoded_proposal : :: std :: vec :: Vec < :: core :: primitive :: u8 > ,) -> Result < :: subxt :: SubmittableExtrinsic < 'a , T , X , NotePreimageOperational , DispatchError , root_mod :: Event > , :: subxt :: BasicError > { if self . client . metadata () . call_hash :: < NotePreimageOperational > () ? == [102u8 , 20u8 , 213u8 , 32u8 , 64u8 , 28u8 , 150u8 , 241u8 , 173u8 , 182u8 , 201u8 , 70u8 , 52u8 , 211u8 , 95u8 , 211u8 , 127u8 , 12u8 , 249u8 , 57u8 , 128u8 , 64u8 , 185u8 , 239u8 , 255u8 , 191u8 , 203u8 , 222u8 , 123u8 , 187u8 , 106u8 , 12u8 ,] { let call = NotePreimageOperational { encoded_proposal , } ; Ok (:: subxt :: SubmittableExtrinsic :: new (self . client , call)) } else { Err (:: subxt :: MetadataError :: IncompatibleMetadata . into ()) } } # [doc = "Register the preimage for an upcoming proposal. This requires the proposal to be"] # [doc = "in the dispatch queue. No deposit is needed. When this call is successful, i.e."] # [doc = "the preimage has not been uploaded before and matches some imminent proposal,"] # [doc = "no fee is paid."] # [doc = ""] # [doc = "The dispatch origin of this call must be _Signed_."] # [doc = ""] # [doc = "- `encoded_proposal`: The preimage of a proposal."] # [doc = ""] # [doc = "Emits `PreimageNoted`."] # [doc = ""] # [doc = "Weight: `O(E)` with E size of `encoded_proposal` (protected by a required deposit)."] pub fn note_imminent_preimage (& self , encoded_proposal : :: std :: vec :: Vec < :: core :: primitive :: u8 > ,) -> Result < :: subxt :: SubmittableExtrinsic < 'a , T , X , NoteImminentPreimage , DispatchError , root_mod :: Event > , :: subxt :: BasicError > { if self . client . metadata () . call_hash :: < NoteImminentPreimage > () ? == [240u8 , 77u8 , 42u8 , 178u8 , 110u8 , 117u8 , 152u8 , 158u8 , 64u8 , 26u8 , 49u8 , 37u8 , 177u8 , 178u8 , 203u8 , 227u8 , 23u8 , 251u8 , 242u8 , 112u8 , 184u8 , 234u8 , 95u8 , 73u8 , 86u8 , 37u8 , 148u8 , 150u8 , 6u8 , 50u8 , 239u8 , 64u8 ,] { let call = NoteImminentPreimage { encoded_proposal , } ; Ok (:: subxt :: SubmittableExtrinsic :: new (self . client , call)) } else { Err (:: subxt :: MetadataError :: IncompatibleMetadata . into ()) } } # [doc = "Same as `note_imminent_preimage` but origin is `OperationalPreimageOrigin`."] pub fn note_imminent_preimage_operational (& self , encoded_proposal : :: std :: vec :: Vec < :: core :: primitive :: u8 > ,) -> Result < :: subxt :: SubmittableExtrinsic < 'a , T , X , NoteImminentPreimageOperational , DispatchError , root_mod :: Event > , :: subxt :: BasicError > { if self . client . metadata () . call_hash :: < NoteImminentPreimageOperational > () ? == [119u8 , 17u8 , 140u8 , 81u8 , 7u8 , 103u8 , 162u8 , 112u8 , 160u8 , 179u8 , 116u8 , 34u8 , 126u8 , 150u8 , 64u8 , 117u8 , 93u8 , 225u8 , 197u8 , 40u8 , 62u8 , 238u8 , 174u8 , 63u8 , 148u8 , 248u8 , 214u8 , 212u8 , 228u8 , 86u8 , 87u8 , 195u8 ,] { let call = NoteImminentPreimageOperational { encoded_proposal , } ; Ok (:: subxt :: SubmittableExtrinsic :: new (self . client , call)) } else { Err (:: subxt :: MetadataError :: IncompatibleMetadata . into ()) } } # [doc = "Remove an expired proposal preimage and collect the deposit."] # [doc = ""] # [doc = "The dispatch origin of this call must be _Signed_."] # [doc = ""] # [doc = "- `proposal_hash`: The preimage hash of a proposal."] # [doc = "- `proposal_length_upper_bound`: an upper bound on length of the proposal. Extrinsic is"] # [doc = "  weighted according to this value with no refund."] # [doc = ""] # [doc = "This will only work after `VotingPeriod` blocks from the time that the preimage was"] # [doc = "noted, if it's the same account doing it. If it's a different account, then it'll only"] # [doc = "work an additional `EnactmentPeriod` later."] # [doc = ""] # [doc = "Emits `PreimageReaped`."] # [doc = ""] # [doc = "Weight: `O(D)` where D is length of proposal."] pub fn reap_preimage (& self , proposal_hash : :: subxt :: sp_core :: H256 , proposal_len_upper_bound : :: core :: primitive :: u32 ,) -> Result < :: subxt :: SubmittableExtrinsic < 'a , T , X , ReapPreimage , DispatchError , root_mod :: Event > , :: subxt :: BasicError > { if self . client . metadata () . call_hash :: < ReapPreimage > () ? == [45u8 , 191u8 , 46u8 , 19u8 , 87u8 , 216u8 , 48u8 , 29u8 , 124u8 , 205u8 , 39u8 , 178u8 , 158u8 , 95u8 , 163u8 , 116u8 , 232u8 , 58u8 , 6u8 , 242u8 , 52u8 , 215u8 , 251u8 , 49u8 , 1u8 , 234u8 , 99u8 , 142u8 , 76u8 , 182u8 , 134u8 , 173u8 ,] { let call = ReapPreimage { proposal_hash , proposal_len_upper_bound , } ; Ok (:: subxt :: SubmittableExtrinsic :: new (self . client , call)) } else { Err (:: subxt :: MetadataError :: IncompatibleMetadata . into ()) } } # [doc = "Unlock tokens that have an expired lock."] # [doc = ""] # [doc = "The dispatch origin of this call must be _Signed_."] # [doc = ""] # [doc = "- `target`: The account to remove the lock on."] # [doc = ""] # [doc = "Weight: `O(R)` with R number of vote of target."] pub fn unlock (& self , target : :: subxt :: sp_core :: crypto :: AccountId32 ,) -> Result < :: subxt :: SubmittableExtrinsic < 'a , T , X , Unlock , DispatchError , root_mod :: Event > , :: subxt :: BasicError > { if self . client . metadata () . call_hash :: < Unlock > () ? == [106u8 , 17u8 , 189u8 , 71u8 , 208u8 , 26u8 , 49u8 , 71u8 , 162u8 , 196u8 , 126u8 , 192u8 , 242u8 , 239u8 , 77u8 , 196u8 , 62u8 , 171u8 , 58u8 , 176u8 , 157u8 , 81u8 , 65u8 , 246u8 , 210u8 , 43u8 , 1u8 , 226u8 , 143u8 , 149u8 , 210u8 , 192u8 ,] { let call = Unlock { target , } ; Ok (:: subxt :: SubmittableExtrinsic :: new (self . client , call)) } else { Err (:: subxt :: MetadataError :: IncompatibleMetadata . into ()) } } # [doc = "Remove a vote for a referendum."] # [doc = ""] # [doc = "If:"] # [doc = "- the referendum was cancelled, or"] # [doc = "- the referendum is ongoing, or"] # [doc = "- the referendum has ended such that"] # [doc = "  - the vote of the account was in opposition to the result; or"] # [doc = "  - there was no conviction to the account's vote; or"] # [doc = "  - the account made a split vote"] # [doc = "...then the vote is removed cleanly and a following call to `unlock` may result in more"] # [doc = "funds being available."] # [doc = ""] # [doc = "If, however, the referendum has ended and:"] # [doc = "- it finished corresponding to the vote of the account, and"] # [doc = "- the account made a standard vote with conviction, and"] # [doc = "- the lock period of the conviction is not over"] # [doc = "...then the lock will be aggregated into the overall account's lock, which may involve"] # [doc = "*overlocking* (where the two locks are combined into a single lock that is the maximum"] # [doc = "of both the amount locked and the time is it locked for)."] # [doc = ""] # [doc = "The dispatch origin of this call must be _Signed_, and the signer must have a vote"] # [doc = "registered for referendum `index`."] # [doc = ""] # [doc = "- `index`: The index of referendum of the vote to be removed."] # [doc = ""] # [doc = "Weight: `O(R + log R)` where R is the number of referenda that `target` has voted on."] # [doc = "  Weight is calculated for the maximum number of vote."] pub fn remove_vote (& self , index : :: core :: primitive :: u32 ,) -> Result < :: subxt :: SubmittableExtrinsic < 'a , T , X , RemoveVote , DispatchError , root_mod :: Event > , :: subxt :: BasicError > { if self . client . metadata () . call_hash :: < RemoveVote > () ? == [33u8 , 72u8 , 14u8 , 166u8 , 152u8 , 18u8 , 232u8 , 153u8 , 163u8 , 96u8 , 146u8 , 180u8 , 98u8 , 155u8 , 119u8 , 75u8 , 247u8 , 175u8 , 246u8 , 183u8 , 182u8 , 108u8 , 250u8 , 80u8 , 148u8 , 86u8 , 255u8 , 59u8 , 93u8 , 197u8 , 209u8 , 226u8 ,] { let call = RemoveVote { index , } ; Ok (:: subxt :: SubmittableExtrinsic :: new (self . client , call)) } else { Err (:: subxt :: MetadataError :: IncompatibleMetadata . into ()) } } # [doc = "Remove a vote for a referendum."] # [doc = ""] # [doc = "If the `target` is equal to the signer, then this function is exactly equivalent to"] # [doc = "`remove_vote`. If not equal to the signer, then the vote must have expired,"] # [doc = "either because the referendum was cancelled, because the voter lost the referendum or"] # [doc = "because the conviction period is over."] # [doc = ""] # [doc = "The dispatch origin of this call must be _Signed_."] # [doc = ""] # [doc = "- `target`: The account of the vote to be removed; this account must have voted for"] # [doc = "  referendum `index`."] # [doc = "- `index`: The index of referendum of the vote to be removed."] # [doc = ""] # [doc = "Weight: `O(R + log R)` where R is the number of referenda that `target` has voted on."] # [doc = "  Weight is calculated for the maximum number of vote."] pub fn remove_other_vote (& self , target : :: subxt :: sp_core :: crypto :: AccountId32 , index : :: core :: primitive :: u32 ,) -> Result < :: subxt :: SubmittableExtrinsic < 'a , T , X , RemoveOtherVote , DispatchError , root_mod :: Event > , :: subxt :: BasicError > { if self . client . metadata () . call_hash :: < RemoveOtherVote > () ? == [43u8 , 194u8 , 32u8 , 219u8 , 87u8 , 143u8 , 240u8 , 34u8 , 236u8 , 232u8 , 128u8 , 7u8 , 99u8 , 113u8 , 106u8 , 124u8 , 92u8 , 115u8 , 75u8 , 228u8 , 39u8 , 234u8 , 192u8 , 134u8 , 69u8 , 109u8 , 119u8 , 133u8 , 194u8 , 110u8 , 167u8 , 244u8 ,] { let call = RemoveOtherVote { target , index , } ; Ok (:: subxt :: SubmittableExtrinsic :: new (self . client , call)) } else { Err (:: subxt :: MetadataError :: IncompatibleMetadata . into ()) } } # [doc = "Enact a proposal from a referendum. For now we just make the weight be the maximum."] pub fn enact_proposal (& self , proposal_hash : :: subxt :: sp_core :: H256 , index : :: core :: primitive :: u32 ,) -> Result < :: subxt :: SubmittableExtrinsic < 'a , T , X , EnactProposal , DispatchError , root_mod :: Event > , :: subxt :: BasicError > { if self . client . metadata () . call_hash :: < EnactProposal > () ? == [246u8 , 188u8 , 9u8 , 244u8 , 56u8 , 81u8 , 201u8 , 59u8 , 212u8 , 11u8 , 204u8 , 7u8 , 173u8 , 7u8 , 212u8 , 34u8 , 173u8 , 248u8 , 83u8 , 225u8 , 209u8 , 105u8 , 249u8 , 167u8 , 243u8 , 49u8 , 119u8 , 167u8 , 28u8 , 31u8 , 60u8 , 75u8 ,] { let call = EnactProposal { proposal_hash , index , } ; Ok (:: subxt :: SubmittableExtrinsic :: new (self . client , call)) } else { Err (:: subxt :: MetadataError :: IncompatibleMetadata . into ()) } } # [doc = "Permanently place a proposal into the blacklist. This prevents it from ever being"] # [doc = "proposed again."] # [doc = ""] # [doc = "If called on a queued public or external proposal, then this will result in it being"] # [doc = "removed. If the `ref_index` supplied is an active referendum with the proposal hash,"] # [doc = "then it will be cancelled."] # [doc = ""] # [doc = "The dispatch origin of this call must be `BlacklistOrigin`."] # [doc = ""] # [doc = "- `proposal_hash`: The proposal hash to blacklist permanently."] # [doc = "- `ref_index`: An ongoing referendum whose hash is `proposal_hash`, which will be"] # [doc = "cancelled."] # [doc = ""] # [doc = "Weight: `O(p)` (though as this is an high-privilege dispatch, we assume it has a"] # [doc = "  reasonable value)."] pub fn blacklist (& self , proposal_hash : :: subxt :: sp_core :: H256 , maybe_ref_index : :: core :: option :: Option < :: core :: primitive :: u32 > ,) -> Result < :: subxt :: SubmittableExtrinsic < 'a , T , X , Blacklist , DispatchError , root_mod :: Event > , :: subxt :: BasicError > { if self . client . metadata () . call_hash :: < Blacklist > () ? == [105u8 , 99u8 , 153u8 , 150u8 , 122u8 , 234u8 , 105u8 , 238u8 , 152u8 , 152u8 , 121u8 , 181u8 , 133u8 , 246u8 , 159u8 , 35u8 , 8u8 , 65u8 , 15u8 , 203u8 , 206u8 , 75u8 , 28u8 , 214u8 , 111u8 , 26u8 , 40u8 , 141u8 , 68u8 , 57u8 , 217u8 , 244u8 ,] { let call = Blacklist { proposal_hash , maybe_ref_index , } ; Ok (:: subxt :: SubmittableExtrinsic :: new (self . client , call)) } else { Err (:: subxt :: MetadataError :: IncompatibleMetadata . into ()) } } # [doc = "Remove a proposal."] # [doc = ""] # [doc = "The dispatch origin of this call must be `CancelProposalOrigin`."] # [doc = ""] # [doc = "- `prop_index`: The index of the proposal to cancel."] # [doc = ""] # [doc = "Weight: `O(p)` where `p = PublicProps::<T>::decode_len()`"] pub fn cancel_proposal (& self , prop_index : :: core :: primitive :: u32 ,) -> Result < :: subxt :: SubmittableExtrinsic < 'a , T , X , CancelProposal , DispatchError , root_mod :: Event > , :: subxt :: BasicError > { if self . client . metadata () . call_hash :: < CancelProposal > () ? == [26u8 , 117u8 , 180u8 , 24u8 , 12u8 , 177u8 , 77u8 , 254u8 , 113u8 , 53u8 , 146u8 , 48u8 , 164u8 , 255u8 , 45u8 , 205u8 , 207u8 , 46u8 , 74u8 , 184u8 , 73u8 , 95u8 , 216u8 , 190u8 , 240u8 , 64u8 , 121u8 , 104u8 , 147u8 , 141u8 , 128u8 , 82u8 ,] { let call = CancelProposal { prop_index , } ; Ok (:: subxt :: SubmittableExtrinsic :: new (self . client , call)) } else { Err (:: subxt :: MetadataError :: IncompatibleMetadata . into ()) } } } } pub type Event = runtime_types :: pallet_democracy :: pallet :: Event ; pub mod events { use super :: runtime_types ; # [derive (:: subxt :: codec :: Decode , :: subxt :: codec :: Encode , Clone , Debug , Eq , PartialEq)] # [doc = "A motion has been proposed by a public account."] pub struct Proposed { pub proposal_index : :: core :: primitive :: u32 , pub deposit : :: core :: primitive :: u128 , } impl :: subxt :: Event for Proposed { const PALLET : & 'static str = "Democracy" ; const EVENT : & 'static str = "Proposed" ; } # [derive (:: subxt :: codec :: Decode , :: subxt :: codec :: Encode , Clone , Debug , Eq , PartialEq)] # [doc = "A public proposal has been tabled for referendum vote."] pub struct Tabled { pub proposal_index : :: core :: primitive :: u32 , pub deposit : :: core :: primitive :: u128 , pub depositors : :: std :: vec :: Vec < :: subxt :: sp_core :: crypto :: AccountId32 > , } impl :: subxt :: Event for Tabled { const PALLET : & 'static str = "Democracy" ; const EVENT : & 'static str = "Tabled" ; } # [derive (:: subxt :: codec :: Decode , :: subxt :: codec :: Encode , Clone , Debug , Eq , PartialEq)] # [doc = "An external proposal has been tabled."] pub struct ExternalTabled ; impl :: subxt :: Event for ExternalTabled { const PALLET : & 'static str = "Democracy" ; const EVENT : & 'static str = "ExternalTabled" ; } # [derive (:: subxt :: codec :: Decode , :: subxt :: codec :: Encode , Clone , Debug , Eq , PartialEq)] # [doc = "A referendum has begun."] pub struct Started { pub ref_index : :: core :: primitive :: u32 , pub threshold : runtime_types :: pallet_democracy :: vote_threshold :: VoteThreshold , } impl :: subxt :: Event for Started { const PALLET : & 'static str = "Democracy" ; const EVENT : & 'static str = "Started" ; } # [derive (:: subxt :: codec :: CompactAs , :: subxt :: codec :: Decode , :: subxt :: codec :: Encode , Clone , Debug , Eq , PartialEq)] # [doc = "A proposal has been approved by referendum."] pub struct Passed { pub ref_index : :: core :: primitive :: u32 , } impl :: subxt :: Event for Passed { const PALLET : & 'static str = "Democracy" ; const EVENT : & 'static str = "Passed" ; } # [derive (:: subxt :: codec :: CompactAs , :: subxt :: codec :: Decode , :: subxt :: codec :: Encode , Clone , Debug , Eq , PartialEq)] # [doc = "A proposal has been rejected by referendum."] pub struct NotPassed { pub ref_index : :: core :: primitive :: u32 , } impl :: subxt :: Event for NotPassed { const PALLET : & 'static str = "Democracy" ; const EVENT : & 'static str = "NotPassed" ; } # [derive (:: subxt :: codec :: CompactAs , :: subxt :: codec :: Decode , :: subxt :: codec :: Encode , Clone , Debug , Eq , PartialEq)] # [doc = "A referendum has been cancelled."] pub struct Cancelled { pub ref_index : :: core :: primitive :: u32 , } impl :: subxt :: Event for Cancelled { const PALLET : & 'static str = "Democracy" ; const EVENT : & 'static str = "Cancelled" ; } # [derive (:: subxt :: codec :: Decode , :: subxt :: codec :: Encode , Clone , Debug , Eq , PartialEq)] # [doc = "A proposal has been enacted."] pub struct Executed { pub ref_index : :: core :: primitive :: u32 , pub result : :: core :: result :: Result < () , runtime_types :: sp_runtime :: DispatchError > , } impl :: subxt :: Event for Executed { const PALLET : & 'static str = "Democracy" ; const EVENT : & 'static str = "Executed" ; } # [derive (:: subxt :: codec :: Decode , :: subxt :: codec :: Encode , Clone , Debug , Eq , PartialEq)] # [doc = "An account has delegated their vote to another account."] pub struct Delegated { pub who : :: subxt :: sp_core :: crypto :: AccountId32 , pub target : :: subxt :: sp_core :: crypto :: AccountId32 , } impl :: subxt :: Event for Delegated { const PALLET : & 'static str = "Democracy" ; const EVENT : & 'static str = "Delegated" ; } # [derive (:: subxt :: codec :: Decode , :: subxt :: codec :: Encode , Clone , Debug , Eq , PartialEq)] # [doc = "An account has cancelled a previous delegation operation."] pub struct Undelegated { pub account : :: subxt :: sp_core :: crypto :: AccountId32 , } impl :: subxt :: Event for Undelegated { const PALLET : & 'static str = "Democracy" ; const EVENT : & 'static str = "Undelegated" ; } # [derive (:: subxt :: codec :: Decode , :: subxt :: codec :: Encode , Clone , Debug , Eq , PartialEq)] # [doc = "An external proposal has been vetoed."] pub struct Vetoed { pub who : :: subxt :: sp_core :: crypto :: AccountId32 , pub proposal_hash : :: subxt :: sp_core :: H256 , pub until : :: core :: primitive :: u32 , } impl :: subxt :: Event for Vetoed { const PALLET : & 'static str = "Democracy" ; const EVENT : & 'static str = "Vetoed" ; } # [derive (:: subxt :: codec :: Decode , :: subxt :: codec :: Encode , Clone , Debug , Eq , PartialEq)] # [doc = "A proposal's preimage was noted, and the deposit taken."] pub struct PreimageNoted { pub proposal_hash : :: subxt :: sp_core :: H256 , pub who : :: subxt :: sp_core :: crypto :: AccountId32 , pub deposit : :: core :: primitive :: u128 , } impl :: subxt :: Event for PreimageNoted { const PALLET : & 'static str = "Democracy" ; const EVENT : & 'static str = "PreimageNoted" ; } # [derive (:: subxt :: codec :: Decode , :: subxt :: codec :: Encode , Clone , Debug , Eq , PartialEq)] # [doc = "A proposal preimage was removed and used (the deposit was returned)."] pub struct PreimageUsed { pub proposal_hash : :: subxt :: sp_core :: H256 , pub provider : :: subxt :: sp_core :: crypto :: AccountId32 , pub deposit : :: core :: primitive :: u128 , } impl :: subxt :: Event for PreimageUsed { const PALLET : & 'static str = "Democracy" ; const EVENT : & 'static str = "PreimageUsed" ; } # [derive (:: subxt :: codec :: Decode , :: subxt :: codec :: Encode , Clone , Debug , Eq , PartialEq)] # [doc = "A proposal could not be executed because its preimage was invalid."] pub struct PreimageInvalid { pub proposal_hash : :: subxt :: sp_core :: H256 , pub ref_index : :: core :: primitive :: u32 , } impl :: subxt :: Event for PreimageInvalid { const PALLET : & 'static str = "Democracy" ; const EVENT : & 'static str = "PreimageInvalid" ; } # [derive (:: subxt :: codec :: Decode , :: subxt :: codec :: Encode , Clone , Debug , Eq , PartialEq)] # [doc = "A proposal could not be executed because its preimage was missing."] pub struct PreimageMissing { pub proposal_hash : :: subxt :: sp_core :: H256 , pub ref_index : :: core :: primitive :: u32 , } impl :: subxt :: Event for PreimageMissing { const PALLET : & 'static str = "Democracy" ; const EVENT : & 'static str = "PreimageMissing" ; } # [derive (:: subxt :: codec :: Decode , :: subxt :: codec :: Encode , Clone , Debug , Eq , PartialEq)] # [doc = "A registered preimage was removed and the deposit collected by the reaper."] pub struct PreimageReaped { pub proposal_hash : :: subxt :: sp_core :: H256 , pub provider : :: subxt :: sp_core :: crypto :: AccountId32 , pub deposit : :: core :: primitive :: u128 , pub reaper : :: subxt :: sp_core :: crypto :: AccountId32 , } impl :: subxt :: Event for PreimageReaped { const PALLET : & 'static str = "Democracy" ; const EVENT : & 'static str = "PreimageReaped" ; } # [derive (:: subxt :: codec :: Decode , :: subxt :: codec :: Encode , Clone , Debug , Eq , PartialEq)] # [doc = "A proposal_hash has been blacklisted permanently."] pub struct Blacklisted { pub proposal_hash : :: subxt :: sp_core :: H256 , } impl :: subxt :: Event for Blacklisted { const PALLET : & 'static str = "Democracy" ; const EVENT : & 'static str = "Blacklisted" ; } # [derive (:: subxt :: codec :: Decode , :: subxt :: codec :: Encode , Clone , Debug , Eq , PartialEq)] # [doc = "An account has voted in a referendum"] pub struct Voted { pub voter : :: subxt :: sp_core :: crypto :: AccountId32 , pub ref_index : :: core :: primitive :: u32 , pub vote : runtime_types :: pallet_democracy :: vote :: AccountVote < :: core :: primitive :: u128 > , } impl :: subxt :: Event for Voted { const PALLET : & 'static str = "Democracy" ; const EVENT : & 'static str = "Voted" ; } # [derive (:: subxt :: codec :: Decode , :: subxt :: codec :: Encode , Clone , Debug , Eq , PartialEq)] # [doc = "An account has secconded a proposal"] pub struct Seconded { pub seconder : :: subxt :: sp_core :: crypto :: AccountId32 , pub prop_index : :: core :: primitive :: u32 , } impl :: subxt :: Event for Seconded { const PALLET : & 'static str = "Democracy" ; const EVENT : & 'static str = "Seconded" ; } # [derive (:: subxt :: codec :: CompactAs , :: subxt :: codec :: Decode , :: subxt :: codec :: Encode , Clone , Debug , Eq , PartialEq)] # [doc = "A proposal got canceled."] pub struct ProposalCanceled { pub prop_index : :: core :: primitive :: u32 , } impl :: subxt :: Event for ProposalCanceled { const PALLET : & 'static str = "Democracy" ; const EVENT : & 'static str = "ProposalCanceled" ; } } pub mod storage { use super :: runtime_types ; pub struct PublicPropCount ; impl :: subxt :: StorageEntry for PublicPropCount { const PALLET : & 'static str = "Democracy" ; const STORAGE : & 'static str = "PublicPropCount" ; type Value = :: core :: primitive :: u32 ; fn key (& self) -> :: subxt :: StorageEntryKey { :: subxt :: StorageEntryKey :: Plain } } pub struct PublicProps ; impl :: subxt :: StorageEntry for PublicProps { const PALLET : & 'static str = "Democracy" ; const STORAGE : & 'static str = "PublicProps" ; type Value = :: std :: vec :: Vec < (:: core :: primitive :: u32 , :: subxt :: sp_core :: H256 , :: subxt :: sp_core :: crypto :: AccountId32 ,) > ; fn key (& self) -> :: subxt :: StorageEntryKey { :: subxt :: StorageEntryKey :: Plain } } pub struct DepositOf < 'a > (pub & 'a :: core :: primitive :: u32) ; impl :: subxt :: StorageEntry for DepositOf < '_ > { const PALLET : & 'static str = "Democracy" ; const STORAGE : & 'static str = "DepositOf" ; type Value = (:: std :: vec :: Vec < :: subxt :: sp_core :: crypto :: AccountId32 > , :: core :: primitive :: u128 ,) ; fn key (& self) -> :: subxt :: StorageEntryKey { :: subxt :: StorageEntryKey :: Map (vec ! [:: subxt :: StorageMapKey :: new (& self . 0 , :: subxt :: StorageHasher :: Twox64Concat)]) } } pub struct Preimages < 'a > (pub & 'a :: subxt :: sp_core :: H256) ; impl :: subxt :: StorageEntry for Preimages < '_ > { const PALLET : & 'static str = "Democracy" ; const STORAGE : & 'static str = "Preimages" ; type Value = runtime_types :: pallet_democracy :: PreimageStatus < :: subxt :: sp_core :: crypto :: AccountId32 , :: core :: primitive :: u128 , :: core :: primitive :: u32 > ; fn key (& self) -> :: subxt :: StorageEntryKey { :: subxt :: StorageEntryKey :: Map (vec ! [:: subxt :: StorageMapKey :: new (& self . 0 , :: subxt :: StorageHasher :: Identity)]) } } pub struct ReferendumCount ; impl :: subxt :: StorageEntry for ReferendumCount { const PALLET : & 'static str = "Democracy" ; const STORAGE : & 'static str = "ReferendumCount" ; type Value = :: core :: primitive :: u32 ; fn key (& self) -> :: subxt :: StorageEntryKey { :: subxt :: StorageEntryKey :: Plain } } pub struct LowestUnbaked ; impl :: subxt :: StorageEntry for LowestUnbaked { const PALLET : & 'static str = "Democracy" ; const STORAGE : & 'static str = "LowestUnbaked" ; type Value = :: core :: primitive :: u32 ; fn key (& self) -> :: subxt :: StorageEntryKey { :: subxt :: StorageEntryKey :: Plain } } pub struct ReferendumInfoOf < 'a > (pub & 'a :: core :: primitive :: u32) ; impl :: subxt :: StorageEntry for ReferendumInfoOf < '_ > { const PALLET : & 'static str = "Democracy" ; const STORAGE : & 'static str = "ReferendumInfoOf" ; type Value = runtime_types :: pallet_democracy :: types :: ReferendumInfo < :: core :: primitive :: u32 , :: subxt :: sp_core :: H256 , :: core :: primitive :: u128 > ; fn key (& self) -> :: subxt :: StorageEntryKey { :: subxt :: StorageEntryKey :: Map (vec ! [:: subxt :: StorageMapKey :: new (& self . 0 , :: subxt :: StorageHasher :: Twox64Concat)]) } } pub struct VotingOf < 'a > (pub & 'a :: subxt :: sp_core :: crypto :: AccountId32) ; impl :: subxt :: StorageEntry for VotingOf < '_ > { const PALLET : & 'static str = "Democracy" ; const STORAGE : & 'static str = "VotingOf" ; type Value = runtime_types :: pallet_democracy :: vote :: Voting < :: core :: primitive :: u128 , :: subxt :: sp_core :: crypto :: AccountId32 , :: core :: primitive :: u32 > ; fn key (& self) -> :: subxt :: StorageEntryKey { :: subxt :: StorageEntryKey :: Map (vec ! [:: subxt :: StorageMapKey :: new (& self . 0 , :: subxt :: StorageHasher :: Twox64Concat)]) } } pub struct LastTabledWasExternal ; impl :: subxt :: StorageEntry for LastTabledWasExternal { const PALLET : & 'static str = "Democracy" ; const STORAGE : & 'static str = "LastTabledWasExternal" ; type Value = :: core :: primitive :: bool ; fn key (& self) -> :: subxt :: StorageEntryKey { :: subxt :: StorageEntryKey :: Plain } } pub struct NextExternal ; impl :: subxt :: StorageEntry for NextExternal { const PALLET : & 'static str = "Democracy" ; const STORAGE : & 'static str = "NextExternal" ; type Value = (:: subxt :: sp_core :: H256 , runtime_types :: pallet_democracy :: vote_threshold :: VoteThreshold ,) ; fn key (& self) -> :: subxt :: StorageEntryKey { :: subxt :: StorageEntryKey :: Plain } } pub struct Blacklist < 'a > (pub & 'a :: subxt :: sp_core :: H256) ; impl :: subxt :: StorageEntry for Blacklist < '_ > { const PALLET : & 'static str = "Democracy" ; const STORAGE : & 'static str = "Blacklist" ; type Value = (:: core :: primitive :: u32 , :: std :: vec :: Vec < :: subxt :: sp_core :: crypto :: AccountId32 > ,) ; fn key (& self) -> :: subxt :: StorageEntryKey { :: subxt :: StorageEntryKey :: Map (vec ! [:: subxt :: StorageMapKey :: new (& self . 0 , :: subxt :: StorageHasher :: Identity)]) } } pub struct Cancellations < 'a > (pub & 'a :: subxt :: sp_core :: H256) ; impl :: subxt :: StorageEntry for Cancellations < '_ > { const PALLET : & 'static str = "Democracy" ; const STORAGE : & 'static str = "Cancellations" ; type Value = :: core :: primitive :: bool ; fn key (& self) -> :: subxt :: StorageEntryKey { :: subxt :: StorageEntryKey :: Map (vec ! [:: subxt :: StorageMapKey :: new (& self . 0 , :: subxt :: StorageHasher :: Identity)]) } } pub struct StorageVersion ; impl :: subxt :: StorageEntry for StorageVersion { const PALLET : & 'static str = "Democracy" ; const STORAGE : & 'static str = "StorageVersion" ; type Value = runtime_types :: pallet_democracy :: Releases ; fn key (& self) -> :: subxt :: StorageEntryKey { :: subxt :: StorageEntryKey :: Plain } } pub struct StorageApi < 'a , T : :: subxt :: Config > { client : & 'a :: subxt :: Client < T > , } impl < 'a , T : :: subxt :: Config > StorageApi < 'a , T > { pub fn new (client : & 'a :: subxt :: Client < T >) -> Self { Self { client } } # [doc = " The number of (public) proposals that have been made so far."] pub async fn public_prop_count (& self , block_hash : :: core :: option :: Option < T :: Hash > ,) -> :: core :: result :: Result < :: core :: primitive :: u32 , :: subxt :: BasicError > { if self . client . metadata () . storage_hash :: < PublicPropCount > () ? == [91u8 , 14u8 , 171u8 , 94u8 , 37u8 , 157u8 , 46u8 , 157u8 , 254u8 , 13u8 , 68u8 , 144u8 , 23u8 , 146u8 , 128u8 , 159u8 , 9u8 , 174u8 , 74u8 , 174u8 , 218u8 , 197u8 , 23u8 , 235u8 , 152u8 , 226u8 , 216u8 , 4u8 , 120u8 , 121u8 , 27u8 , 138u8 ,] { let entry = PublicPropCount ; self . client . storage () . fetch_or_default (& entry , block_hash) . await } else { Err (:: subxt :: MetadataError :: IncompatibleMetadata . into ()) } } # [doc = " The public proposals. Unsorted. The second item is the proposal's hash."] pub async fn public_props (& self , block_hash : :: core :: option :: Option < T :: Hash > ,) -> :: core :: result :: Result < :: std :: vec :: Vec < (:: core :: primitive :: u32 , :: subxt :: sp_core :: H256 , :: subxt :: sp_core :: crypto :: AccountId32 ,) > , :: subxt :: BasicError > { if self . client . metadata () . storage_hash :: < PublicProps > () ? == [78u8 , 208u8 , 211u8 , 20u8 , 85u8 , 237u8 , 161u8 , 149u8 , 99u8 , 158u8 , 6u8 , 54u8 , 204u8 , 228u8 , 132u8 , 10u8 , 75u8 , 247u8 , 148u8 , 155u8 , 101u8 , 183u8 , 58u8 , 169u8 , 21u8 , 172u8 , 10u8 , 110u8 , 130u8 , 74u8 , 88u8 , 52u8 ,] { let entry = PublicProps ; self . client . storage () . fetch_or_default (& entry , block_hash) . await } else { Err (:: subxt :: MetadataError :: IncompatibleMetadata . into ()) } } # [doc = " Those who have locked a deposit."] # [doc = ""] # [doc = " TWOX-NOTE: Safe, as increasing integer keys are safe."] pub async fn deposit_of (& self , _0 : & :: core :: primitive :: u32 , block_hash : :: core :: option :: Option < T :: Hash > ,) -> :: core :: result :: Result < :: core :: option :: Option < (:: std :: vec :: Vec < :: subxt :: sp_core :: crypto :: AccountId32 > , :: core :: primitive :: u128 ,) > , :: subxt :: BasicError > { if self . client . metadata () . storage_hash :: < DepositOf > () ? == [116u8 , 57u8 , 200u8 , 96u8 , 150u8 , 62u8 , 162u8 , 169u8 , 28u8 , 18u8 , 134u8 , 161u8 , 210u8 , 217u8 , 80u8 , 225u8 , 22u8 , 185u8 , 177u8 , 166u8 , 243u8 , 232u8 , 193u8 , 64u8 , 170u8 , 89u8 , 216u8 , 198u8 , 43u8 , 102u8 , 178u8 , 55u8 ,] { let entry = DepositOf (_0) ; self . client . storage () . fetch (& entry , block_hash) . await } else { Err (:: subxt :: MetadataError :: IncompatibleMetadata . into ()) } } # [doc = " Those who have locked a deposit."] # [doc = ""] # [doc = " TWOX-NOTE: Safe, as increasing integer keys are safe."] pub async fn deposit_of_iter (& self , block_hash : :: core :: option :: Option < T :: Hash > ,) -> :: core :: result :: Result < :: subxt :: KeyIter < 'a , T , DepositOf < 'a > > , :: subxt :: BasicError > { if self . client . metadata () . storage_hash :: < DepositOf > () ? == [116u8 , 57u8 , 200u8 , 96u8 , 150u8 , 62u8 , 162u8 , 169u8 , 28u8 , 18u8 , 134u8 , 161u8 , 210u8 , 217u8 , 80u8 , 225u8 , 22u8 , 185u8 , 177u8 , 166u8 , 243u8 , 232u8 , 193u8 , 64u8 , 170u8 , 89u8 , 216u8 , 198u8 , 43u8 , 102u8 , 178u8 , 55u8 ,] { self . client . storage () . iter (block_hash) . await } else { Err (:: subxt :: MetadataError :: IncompatibleMetadata . into ()) } } # [doc = " Map of hashes to the proposal preimage, along with who registered it and their deposit."] # [doc = " The block number is the block at which it was deposited."] pub async fn preimages (& self , _0 : & :: subxt :: sp_core :: H256 , block_hash : :: core :: option :: Option < T :: Hash > ,) -> :: core :: result :: Result < :: core :: option :: Option < runtime_types :: pallet_democracy :: PreimageStatus < :: subxt :: sp_core :: crypto :: AccountId32 , :: core :: primitive :: u128 , :: core :: primitive :: u32 > > , :: subxt :: BasicError > { if self . client . metadata () . storage_hash :: < Preimages > () ? == [20u8 , 82u8 , 223u8 , 51u8 , 178u8 , 115u8 , 71u8 , 83u8 , 23u8 , 15u8 , 85u8 , 66u8 , 0u8 , 69u8 , 68u8 , 20u8 , 28u8 , 159u8 , 74u8 , 41u8 , 225u8 , 145u8 , 247u8 , 23u8 , 36u8 , 155u8 , 101u8 , 229u8 , 27u8 , 24u8 , 93u8 , 215u8 ,] { let entry = Preimages (_0) ; self . client . storage () . fetch (& entry , block_hash) . await } else { Err (:: subxt :: MetadataError :: IncompatibleMetadata . into ()) } } # [doc = " Map of hashes to the proposal preimage, along with who registered it and their deposit."] # [doc = " The block number is the block at which it was deposited."] pub async fn preimages_iter (& self , block_hash : :: core :: option :: Option < T :: Hash > ,) -> :: core :: result :: Result < :: subxt :: KeyIter < 'a , T , Preimages < 'a > > , :: subxt :: BasicError > { if self . client . metadata () . storage_hash :: < Preimages > () ? == [20u8 , 82u8 , 223u8 , 51u8 , 178u8 , 115u8 , 71u8 , 83u8 , 23u8 , 15u8 , 85u8 , 66u8 , 0u8 , 69u8 , 68u8 , 20u8 , 28u8 , 159u8 , 74u8 , 41u8 , 225u8 , 145u8 , 247u8 , 23u8 , 36u8 , 155u8 , 101u8 , 229u8 , 27u8 , 24u8 , 93u8 , 215u8 ,] { self . client . storage () . iter (block_hash) . await } else { Err (:: subxt :: MetadataError :: IncompatibleMetadata . into ()) } } # [doc = " The next free referendum index, aka the number of referenda started so far."] pub async fn referendum_count (& self , block_hash : :: core :: option :: Option < T :: Hash > ,) -> :: core :: result :: Result < :: core :: primitive :: u32 , :: subxt :: BasicError > { if self . client . metadata () . storage_hash :: < ReferendumCount > () ? == [153u8 , 210u8 , 106u8 , 244u8 , 156u8 , 70u8 , 124u8 , 251u8 , 123u8 , 75u8 , 7u8 , 189u8 , 199u8 , 145u8 , 95u8 , 119u8 , 137u8 , 11u8 , 240u8 , 160u8 , 151u8 , 248u8 , 229u8 , 231u8 , 89u8 , 222u8 , 18u8 , 237u8 , 144u8 , 78u8 , 99u8 , 58u8 ,] { let entry = ReferendumCount ; self . client . storage () . fetch_or_default (& entry , block_hash) . await } else { Err (:: subxt :: MetadataError :: IncompatibleMetadata . into ()) } } # [doc = " The lowest referendum index representing an unbaked referendum. Equal to"] # [doc = " `ReferendumCount` if there isn't a unbaked referendum."] pub async fn lowest_unbaked (& self , block_hash : :: core :: option :: Option < T :: Hash > ,) -> :: core :: result :: Result < :: core :: primitive :: u32 , :: subxt :: BasicError > { if self . client . metadata () . storage_hash :: < LowestUnbaked > () ? == [4u8 , 51u8 , 108u8 , 11u8 , 48u8 , 165u8 , 19u8 , 251u8 , 182u8 , 76u8 , 163u8 , 73u8 , 227u8 , 2u8 , 212u8 , 74u8 , 128u8 , 27u8 , 165u8 , 164u8 , 111u8 , 22u8 , 209u8 , 190u8 , 103u8 , 7u8 , 116u8 , 16u8 , 160u8 , 144u8 , 123u8 , 64u8 ,] { let entry = LowestUnbaked ; self . client . storage () . fetch_or_default (& entry , block_hash) . await } else { Err (:: subxt :: MetadataError :: IncompatibleMetadata . into ()) } } # [doc = " Information concerning any given referendum."] # [doc = ""] # [doc = " TWOX-NOTE: SAFE as indexes are not under an attackers control."] pub async fn referendum_info_of (& self , _0 : & :: core :: primitive :: u32 , block_hash : :: core :: option :: Option < T :: Hash > ,) -> :: core :: result :: Result < :: core :: option :: Option < runtime_types :: pallet_democracy :: types :: ReferendumInfo < :: core :: primitive :: u32 , :: subxt :: sp_core :: H256 , :: core :: primitive :: u128 > > , :: subxt :: BasicError > { if self . client . metadata () . storage_hash :: < ReferendumInfoOf > () ? == [112u8 , 206u8 , 173u8 , 93u8 , 255u8 , 76u8 , 85u8 , 122u8 , 24u8 , 97u8 , 177u8 , 67u8 , 44u8 , 143u8 , 53u8 , 159u8 , 206u8 , 135u8 , 63u8 , 74u8 , 230u8 , 47u8 , 27u8 , 224u8 , 138u8 , 217u8 , 194u8 , 229u8 , 148u8 , 249u8 , 230u8 , 114u8 ,] { let entry = ReferendumInfoOf (_0) ; self . client . storage () . fetch (& entry , block_hash) . await } else { Err (:: subxt :: MetadataError :: IncompatibleMetadata . into ()) } } # [doc = " Information concerning any given referendum."] # [doc = ""] # [doc = " TWOX-NOTE: SAFE as indexes are not under an attackers control."] pub async fn referendum_info_of_iter (& self , block_hash : :: core :: option :: Option < T :: Hash > ,) -> :: core :: result :: Result < :: subxt :: KeyIter < 'a , T , ReferendumInfoOf < 'a > > , :: subxt :: BasicError > { if self . client . metadata () . storage_hash :: < ReferendumInfoOf > () ? == [112u8 , 206u8 , 173u8 , 93u8 , 255u8 , 76u8 , 85u8 , 122u8 , 24u8 , 97u8 , 177u8 , 67u8 , 44u8 , 143u8 , 53u8 , 159u8 , 206u8 , 135u8 , 63u8 , 74u8 , 230u8 , 47u8 , 27u8 , 224u8 , 138u8 , 217u8 , 194u8 , 229u8 , 148u8 , 249u8 , 230u8 , 114u8 ,] { self . client . storage () . iter (block_hash) . await } else { Err (:: subxt :: MetadataError :: IncompatibleMetadata . into ()) } } # [doc = " All votes for a particular voter. We store the balance for the number of votes that we"] # [doc = " have recorded. The second item is the total amount of delegations, that will be added."] # [doc = ""] # [doc = " TWOX-NOTE: SAFE as `AccountId`s are crypto hashes anyway."] pub async fn voting_of (& self , _0 : & :: subxt :: sp_core :: crypto :: AccountId32 , block_hash : :: core :: option :: Option < T :: Hash > ,) -> :: core :: result :: Result < runtime_types :: pallet_democracy :: vote :: Voting < :: core :: primitive :: u128 , :: subxt :: sp_core :: crypto :: AccountId32 , :: core :: primitive :: u32 > , :: subxt :: BasicError > { if self . client . metadata () . storage_hash :: < VotingOf > () ? == [194u8 , 13u8 , 151u8 , 207u8 , 194u8 , 79u8 , 233u8 , 214u8 , 193u8 , 52u8 , 78u8 , 62u8 , 71u8 , 35u8 , 139u8 , 11u8 , 41u8 , 163u8 , 143u8 , 156u8 , 236u8 , 207u8 , 132u8 , 138u8 , 2u8 , 176u8 , 56u8 , 224u8 , 67u8 , 39u8 , 190u8 , 13u8 ,] { let entry = VotingOf (_0) ; self . client . storage () . fetch_or_default (& entry , block_hash) . await } else { Err (:: subxt :: MetadataError :: IncompatibleMetadata . into ()) } } # [doc = " All votes for a particular voter. We store the balance for the number of votes that we"] # [doc = " have recorded. The second item is the total amount of delegations, that will be added."] # [doc = ""] # [doc = " TWOX-NOTE: SAFE as `AccountId`s are crypto hashes anyway."] pub async fn voting_of_iter (& self , block_hash : :: core :: option :: Option < T :: Hash > ,) -> :: core :: result :: Result < :: subxt :: KeyIter < 'a , T , VotingOf < 'a > > , :: subxt :: BasicError > { if self . client . metadata () . storage_hash :: < VotingOf > () ? == [194u8 , 13u8 , 151u8 , 207u8 , 194u8 , 79u8 , 233u8 , 214u8 , 193u8 , 52u8 , 78u8 , 62u8 , 71u8 , 35u8 , 139u8 , 11u8 , 41u8 , 163u8 , 143u8 , 156u8 , 236u8 , 207u8 , 132u8 , 138u8 , 2u8 , 176u8 , 56u8 , 224u8 , 67u8 , 39u8 , 190u8 , 13u8 ,] { self . client . storage () . iter (block_hash) . await } else { Err (:: subxt :: MetadataError :: IncompatibleMetadata . into ()) } } # [doc = " True if the last referendum tabled was submitted externally. False if it was a public"] # [doc = " proposal."] pub async fn last_tabled_was_external (& self , block_hash : :: core :: option :: Option < T :: Hash > ,) -> :: core :: result :: Result < :: core :: primitive :: bool , :: subxt :: BasicError > { if self . client . metadata () . storage_hash :: < LastTabledWasExternal > () ? == [3u8 , 67u8 , 106u8 , 1u8 , 89u8 , 204u8 , 4u8 , 145u8 , 121u8 , 44u8 , 34u8 , 76u8 , 18u8 , 206u8 , 65u8 , 214u8 , 222u8 , 82u8 , 31u8 , 223u8 , 144u8 , 169u8 , 17u8 , 6u8 , 138u8 , 36u8 , 113u8 , 155u8 , 241u8 , 106u8 , 189u8 , 218u8 ,] { let entry = LastTabledWasExternal ; self . client . storage () . fetch_or_default (& entry , block_hash) . await } else { Err (:: subxt :: MetadataError :: IncompatibleMetadata . into ()) } } # [doc = " The referendum to be tabled whenever it would be valid to table an external proposal."] # [doc = " This happens when a referendum needs to be tabled and one of two conditions are met:"] # [doc = " - `LastTabledWasExternal` is `false`; or"] # [doc = " - `PublicProps` is empty."] pub async fn next_external (& self , block_hash : :: core :: option :: Option < T :: Hash > ,) -> :: core :: result :: Result < :: core :: option :: Option < (:: subxt :: sp_core :: H256 , runtime_types :: pallet_democracy :: vote_threshold :: VoteThreshold ,) > , :: subxt :: BasicError > { if self . client . metadata () . storage_hash :: < NextExternal > () ? == [167u8 , 226u8 , 113u8 , 10u8 , 12u8 , 157u8 , 190u8 , 117u8 , 233u8 , 177u8 , 254u8 , 126u8 , 2u8 , 55u8 , 100u8 , 249u8 , 78u8 , 127u8 , 148u8 , 239u8 , 193u8 , 246u8 , 123u8 , 58u8 , 150u8 , 132u8 , 209u8 , 228u8 , 105u8 , 195u8 , 217u8 , 99u8 ,] { let entry = NextExternal ; self . client . storage () . fetch (& entry , block_hash) . await } else { Err (:: subxt :: MetadataError :: IncompatibleMetadata . into ()) } } # [doc = " A record of who vetoed what. Maps proposal hash to a possible existent block number"] # [doc = " (until when it may not be resubmitted) and who vetoed it."] pub async fn blacklist (& self , _0 : & :: subxt :: sp_core :: H256 , block_hash : :: core :: option :: Option < T :: Hash > ,) -> :: core :: result :: Result < :: core :: option :: Option < (:: core :: primitive :: u32 , :: std :: vec :: Vec < :: subxt :: sp_core :: crypto :: AccountId32 > ,) > , :: subxt :: BasicError > { if self . client . metadata () . storage_hash :: < Blacklist > () ? == [9u8 , 76u8 , 174u8 , 143u8 , 210u8 , 103u8 , 197u8 , 219u8 , 152u8 , 134u8 , 67u8 , 78u8 , 109u8 , 39u8 , 246u8 , 214u8 , 3u8 , 51u8 , 69u8 , 208u8 , 32u8 , 69u8 , 247u8 , 14u8 , 236u8 , 37u8 , 112u8 , 226u8 , 146u8 , 169u8 , 153u8 , 217u8 ,] { let entry = Blacklist (_0) ; self . client . storage () . fetch (& entry , block_hash) . await } else { Err (:: subxt :: MetadataError :: IncompatibleMetadata . into ()) } } # [doc = " A record of who vetoed what. Maps proposal hash to a possible existent block number"] # [doc = " (until when it may not be resubmitted) and who vetoed it."] pub async fn blacklist_iter (& self , block_hash : :: core :: option :: Option < T :: Hash > ,) -> :: core :: result :: Result < :: subxt :: KeyIter < 'a , T , Blacklist < 'a > > , :: subxt :: BasicError > { if self . client . metadata () . storage_hash :: < Blacklist > () ? == [9u8 , 76u8 , 174u8 , 143u8 , 210u8 , 103u8 , 197u8 , 219u8 , 152u8 , 134u8 , 67u8 , 78u8 , 109u8 , 39u8 , 246u8 , 214u8 , 3u8 , 51u8 , 69u8 , 208u8 , 32u8 , 69u8 , 247u8 , 14u8 , 236u8 , 37u8 , 112u8 , 226u8 , 146u8 , 169u8 , 153u8 , 217u8 ,] { self . client . storage () . iter (block_hash) . await } else { Err (:: subxt :: MetadataError :: IncompatibleMetadata . into ()) } } # [doc = " Record of all proposals that have been subject to emergency cancellation."] pub async fn cancellations (& self , _0 : & :: subxt :: sp_core :: H256 , block_hash : :: core :: option :: Option < T :: Hash > ,) -> :: core :: result :: Result < :: core :: primitive :: bool , :: subxt :: BasicError > { if self . client . metadata () . storage_hash :: < Cancellations > () ? == [176u8 , 55u8 , 142u8 , 79u8 , 35u8 , 110u8 , 215u8 , 163u8 , 134u8 , 172u8 , 171u8 , 71u8 , 180u8 , 175u8 , 7u8 , 29u8 , 126u8 , 141u8 , 236u8 , 234u8 , 214u8 , 132u8 , 192u8 , 197u8 , 205u8 , 31u8 , 106u8 , 122u8 , 204u8 , 71u8 , 155u8 , 18u8 ,] { let entry = Cancellations (_0) ; self . client . storage () . fetch_or_default (& entry , block_hash) . await } else { Err (:: subxt :: MetadataError :: IncompatibleMetadata . into ()) } } # [doc = " Record of all proposals that have been subject to emergency cancellation."] pub async fn cancellations_iter (& self , block_hash : :: core :: option :: Option < T :: Hash > ,) -> :: core :: result :: Result < :: subxt :: KeyIter < 'a , T , Cancellations < 'a > > , :: subxt :: BasicError > { if self . client . metadata () . storage_hash :: < Cancellations > () ? == [176u8 , 55u8 , 142u8 , 79u8 , 35u8 , 110u8 , 215u8 , 163u8 , 134u8 , 172u8 , 171u8 , 71u8 , 180u8 , 175u8 , 7u8 , 29u8 , 126u8 , 141u8 , 236u8 , 234u8 , 214u8 , 132u8 , 192u8 , 197u8 , 205u8 , 31u8 , 106u8 , 122u8 , 204u8 , 71u8 , 155u8 , 18u8 ,] { self . client . storage () . iter (block_hash) . await } else { Err (:: subxt :: MetadataError :: IncompatibleMetadata . into ()) } } # [doc = " Storage version of the pallet."] # [doc = ""] # [doc = " New networks start with last version."] pub async fn storage_version (& self , block_hash : :: core :: option :: Option < T :: Hash > ,) -> :: core :: result :: Result < :: core :: option :: Option < runtime_types :: pallet_democracy :: Releases > , :: subxt :: BasicError > { if self . client . metadata () . storage_hash :: < StorageVersion > () ? == [39u8 , 219u8 , 134u8 , 64u8 , 250u8 , 96u8 , 95u8 , 156u8 , 100u8 , 236u8 , 18u8 , 78u8 , 59u8 , 146u8 , 5u8 , 245u8 , 113u8 , 125u8 , 220u8 , 140u8 , 125u8 , 5u8 , 194u8 , 134u8 , 248u8 , 95u8 , 250u8 , 108u8 , 142u8 , 230u8 , 21u8 , 120u8 ,] { let entry = StorageVersion ; self . client . storage () . fetch (& entry , block_hash) . await } else { Err (:: subxt :: MetadataError :: IncompatibleMetadata . into ()) } } } } pub mod constants { use super :: runtime_types ; pub struct ConstantsApi < 'a , T : :: subxt :: Config > { client : & 'a :: subxt :: Client < T > , } impl < 'a , T : :: subxt :: Config > ConstantsApi < 'a , T > { pub fn new (client : & 'a :: subxt :: Client < T >) -> Self { Self { client } } # [doc = " The period between a proposal being approved and enacted."] # [doc = ""] # [doc = " It should generally be a little more than the unstake period to ensure that"] # [doc = " voting stakers have an opportunity to remove themselves from the system in the case"] # [doc = " where they are on the losing side of a vote."] pub fn enactment_period (& self) -> :: core :: result :: Result < :: core :: primitive :: u32 , :: subxt :: BasicError > { if self . client . metadata () . constant_hash ("Democracy" , "EnactmentPeriod") ? == [53u8 , 169u8 , 103u8 , 26u8 , 136u8 , 76u8 , 19u8 , 208u8 , 100u8 , 54u8 , 54u8 , 161u8 , 212u8 , 23u8 , 106u8 , 37u8 , 181u8 , 215u8 , 11u8 , 51u8 , 248u8 , 140u8 , 233u8 , 159u8 , 51u8 , 157u8 , 207u8 , 114u8 , 146u8 , 126u8 , 232u8 , 236u8 ,] { let pallet = self . client . metadata () . pallet ("Democracy") ? ; let constant = pallet . constant ("EnactmentPeriod") ? ; let value = :: subxt :: codec :: Decode :: decode (& mut & constant . value [..]) ? ; Ok (value) } else { Err (:: subxt :: MetadataError :: IncompatibleMetadata . into ()) } } # [doc = " How often (in blocks) new public referenda are launched."] pub fn launch_period (& self) -> :: core :: result :: Result < :: core :: primitive :: u32 , :: subxt :: BasicError > { if self . client . metadata () . constant_hash ("Democracy" , "LaunchPeriod") ? == [252u8 , 206u8 , 16u8 , 236u8 , 38u8 , 19u8 , 12u8 , 162u8 , 243u8 , 152u8 , 175u8 , 255u8 , 26u8 , 68u8 , 64u8 , 73u8 , 235u8 , 203u8 , 185u8 , 211u8 , 222u8 , 111u8 , 100u8 , 63u8 , 106u8 , 120u8 , 25u8 , 160u8 , 15u8 , 248u8 , 226u8 , 216u8 ,] { let pallet = self . client . metadata () . pallet ("Democracy") ? ; let constant = pallet . constant ("LaunchPeriod") ? ; let value = :: subxt :: codec :: Decode :: decode (& mut & constant . value [..]) ? ; Ok (value) } else { Err (:: subxt :: MetadataError :: IncompatibleMetadata . into ()) } } # [doc = " How often (in blocks) to check for new votes."] pub fn voting_period (& self) -> :: core :: result :: Result < :: core :: primitive :: u32 , :: subxt :: BasicError > { if self . client . metadata () . constant_hash ("Democracy" , "VotingPeriod") ? == [162u8 , 140u8 , 32u8 , 101u8 , 242u8 , 108u8 , 34u8 , 70u8 , 154u8 , 223u8 , 198u8 , 71u8 , 210u8 , 138u8 , 120u8 , 100u8 , 240u8 , 128u8 , 63u8 , 140u8 , 207u8 , 91u8 , 37u8 , 242u8 , 53u8 , 41u8 , 237u8 , 226u8 , 147u8 , 59u8 , 63u8 , 23u8 ,] { let pallet = self . client . metadata () . pallet ("Democracy") ? ; let constant = pallet . constant ("VotingPeriod") ? ; let value = :: subxt :: codec :: Decode :: decode (& mut & constant . value [..]) ? ; Ok (value) } else { Err (:: subxt :: MetadataError :: IncompatibleMetadata . into ()) } } # [doc = " The minimum period of vote locking."] # [doc = ""] # [doc = " It should be no shorter than enactment period to ensure that in the case of an approval,"] # [doc = " those successful voters are locked into the consequences that their votes entail."] pub fn vote_locking_period (& self) -> :: core :: result :: Result < :: core :: primitive :: u32 , :: subxt :: BasicError > { if self . client . metadata () . constant_hash ("Democracy" , "VoteLockingPeriod") ? == [200u8 , 167u8 , 198u8 , 39u8 , 141u8 , 171u8 , 187u8 , 217u8 , 43u8 , 112u8 , 36u8 , 132u8 , 192u8 , 135u8 , 23u8 , 161u8 , 87u8 , 71u8 , 29u8 , 144u8 , 55u8 , 176u8 , 63u8 , 150u8 , 6u8 , 48u8 , 44u8 , 47u8 , 219u8 , 87u8 , 45u8 , 169u8 ,] { let pallet = self . client . metadata () . pallet ("Democracy") ? ; let constant = pallet . constant ("VoteLockingPeriod") ? ; let value = :: subxt :: codec :: Decode :: decode (& mut & constant . value [..]) ? ; Ok (value) } else { Err (:: subxt :: MetadataError :: IncompatibleMetadata . into ()) } } # [doc = " The minimum amount to be used as a deposit for a public referendum proposal."] pub fn minimum_deposit (& self) -> :: core :: result :: Result < :: core :: primitive :: u128 , :: subxt :: BasicError > { if self . client . metadata () . constant_hash ("Democracy" , "MinimumDeposit") ? == [121u8 , 234u8 , 23u8 , 29u8 , 240u8 , 133u8 , 174u8 , 115u8 , 158u8 , 231u8 , 16u8 , 152u8 , 230u8 , 36u8 , 211u8 , 29u8 , 232u8 , 222u8 , 8u8 , 19u8 , 140u8 , 236u8 , 140u8 , 225u8 , 144u8 , 190u8 , 110u8 , 76u8 , 220u8 , 219u8 , 81u8 , 130u8 ,] { let pallet = self . client . metadata () . pallet ("Democracy") ? ; let constant = pallet . constant ("MinimumDeposit") ? ; let value = :: subxt :: codec :: Decode :: decode (& mut & constant . value [..]) ? ; Ok (value) } else { Err (:: subxt :: MetadataError :: IncompatibleMetadata . into ()) } } # [doc = " Indicator for whether an emergency origin is even allowed to happen. Some chains may"] # [doc = " want to set this permanently to `false`, others may want to condition it on things such"] # [doc = " as an upgrade having happened recently."] pub fn instant_allowed (& self) -> :: core :: result :: Result < :: core :: primitive :: bool , :: subxt :: BasicError > { if self . client . metadata () . constant_hash ("Democracy" , "InstantAllowed") ? == [66u8 , 19u8 , 43u8 , 75u8 , 149u8 , 2u8 , 157u8 , 136u8 , 33u8 , 102u8 , 57u8 , 127u8 , 246u8 , 72u8 , 14u8 , 94u8 , 240u8 , 2u8 , 162u8 , 86u8 , 232u8 , 70u8 , 22u8 , 133u8 , 209u8 , 205u8 , 115u8 , 236u8 , 17u8 , 9u8 , 37u8 , 14u8 ,] { let pallet = self . client . metadata () . pallet ("Democracy") ? ; let constant = pallet . constant ("InstantAllowed") ? ; let value = :: subxt :: codec :: Decode :: decode (& mut & constant . value [..]) ? ; Ok (value) } else { Err (:: subxt :: MetadataError :: IncompatibleMetadata . into ()) } } # [doc = " Minimum voting period allowed for a fast-track referendum."] pub fn fast_track_voting_period (& self) -> :: core :: result :: Result < :: core :: primitive :: u32 , :: subxt :: BasicError > { if self . client . metadata () . constant_hash ("Democracy" , "FastTrackVotingPeriod") ? == [80u8 , 102u8 , 234u8 , 71u8 , 178u8 , 68u8 , 22u8 , 97u8 , 69u8 , 190u8 , 248u8 , 155u8 , 93u8 , 161u8 , 170u8 , 77u8 , 176u8 , 35u8 , 2u8 , 197u8 , 226u8 , 193u8 , 235u8 , 115u8 , 75u8 , 162u8 , 127u8 , 181u8 , 55u8 , 223u8 , 214u8 , 231u8 ,] { let pallet = self . client . metadata () . pallet ("Democracy") ? ; let constant = pallet . constant ("FastTrackVotingPeriod") ? ; let value = :: subxt :: codec :: Decode :: decode (& mut & constant . value [..]) ? ; Ok (value) } else { Err (:: subxt :: MetadataError :: IncompatibleMetadata . into ()) } } # [doc = " Period in blocks where an external proposal may not be re-submitted after being vetoed."] pub fn cooloff_period (& self) -> :: core :: result :: Result < :: core :: primitive :: u32 , :: subxt :: BasicError > { if self . client . metadata () . constant_hash ("Democracy" , "CooloffPeriod") ? == [20u8 , 89u8 , 153u8 , 236u8 , 25u8 , 39u8 , 151u8 , 136u8 , 198u8 , 116u8 , 76u8 , 179u8 , 107u8 , 69u8 , 244u8 , 68u8 , 206u8 , 41u8 , 14u8 , 80u8 , 127u8 , 184u8 , 164u8 , 116u8 , 114u8 , 248u8 , 41u8 , 170u8 , 154u8 , 157u8 , 120u8 , 93u8 ,] { let pallet = self . client . metadata () . pallet ("Democracy") ? ; let constant = pallet . constant ("CooloffPeriod") ? ; let value = :: subxt :: codec :: Decode :: decode (& mut & constant . value [..]) ? ; Ok (value) } else { Err (:: subxt :: MetadataError :: IncompatibleMetadata . into ()) } } # [doc = " The amount of balance that must be deposited per byte of preimage stored."] pub fn preimage_byte_deposit (& self) -> :: core :: result :: Result < :: core :: primitive :: u128 , :: subxt :: BasicError > { if self . client . metadata () . constant_hash ("Democracy" , "PreimageByteDeposit") ? == [134u8 , 27u8 , 148u8 , 195u8 , 17u8 , 149u8 , 93u8 , 9u8 , 81u8 , 211u8 , 94u8 , 125u8 , 44u8 , 158u8 , 252u8 , 133u8 , 178u8 , 145u8 , 34u8 , 123u8 , 222u8 , 229u8 , 197u8 , 237u8 , 76u8 , 105u8 , 251u8 , 177u8 , 98u8 , 101u8 , 68u8 , 5u8 ,] { let pallet = self . client . metadata () . pallet ("Democracy") ? ; let constant = pallet . constant ("PreimageByteDeposit") ? ; let value = :: subxt :: codec :: Decode :: decode (& mut & constant . value [..]) ? ; Ok (value) } else { Err (:: subxt :: MetadataError :: IncompatibleMetadata . into ()) } } # [doc = " The maximum number of votes for an account."] # [doc = ""] # [doc = " Also used to compute weight, an overly big value can"] # [doc = " lead to extrinsic with very big weight: see `delegate` for instance."] pub fn max_votes (& self) -> :: core :: result :: Result < :: core :: primitive :: u32 , :: subxt :: BasicError > { if self . client . metadata () . constant_hash ("Democracy" , "MaxVotes") ? == [218u8 , 111u8 , 73u8 , 160u8 , 254u8 , 247u8 , 22u8 , 113u8 , 78u8 , 79u8 , 145u8 , 255u8 , 29u8 , 155u8 , 89u8 , 144u8 , 4u8 , 167u8 , 134u8 , 190u8 , 232u8 , 124u8 , 36u8 , 207u8 , 7u8 , 204u8 , 40u8 , 32u8 , 38u8 , 216u8 , 249u8 , 29u8 ,] { let pallet = self . client . metadata () . pallet ("Democracy") ? ; let constant = pallet . constant ("MaxVotes") ? ; let value = :: subxt :: codec :: Decode :: decode (& mut & constant . value [..]) ? ; Ok (value) } else { Err (:: subxt :: MetadataError :: IncompatibleMetadata . into ()) } } # [doc = " The maximum number of public proposals that can exist at any time."] pub fn max_proposals (& self) -> :: core :: result :: Result < :: core :: primitive :: u32 , :: subxt :: BasicError > { if self . client . metadata () . constant_hash ("Democracy" , "MaxProposals") ? == [125u8 , 103u8 , 31u8 , 211u8 , 29u8 , 50u8 , 100u8 , 13u8 , 229u8 , 120u8 , 216u8 , 228u8 , 4u8 , 121u8 , 229u8 , 90u8 , 172u8 , 228u8 , 86u8 , 73u8 , 64u8 , 153u8 , 249u8 , 48u8 , 232u8 , 150u8 , 150u8 , 65u8 , 205u8 , 182u8 , 12u8 , 81u8 ,] { let pallet = self . client . metadata () . pallet ("Democracy") ? ; let constant = pallet . constant ("MaxProposals") ? ; let value = :: subxt :: codec :: Decode :: decode (& mut & constant . value [..]) ? ; Ok (value) } else { Err (:: subxt :: MetadataError :: IncompatibleMetadata . into ()) } } } } } pub mod council { use super :: root_mod ; use super :: runtime_types ; pub mod calls { use super :: root_mod ; use super :: runtime_types ; type DispatchError = runtime_types :: sp_runtime :: DispatchError ; # [derive (:: subxt :: codec :: Decode , :: subxt :: codec :: Encode , Clone , Debug , Eq , PartialEq)] pub struct SetMembers { pub new_members : :: std :: vec :: Vec < :: subxt :: sp_core :: crypto :: AccountId32 > , pub prime : :: core :: option :: Option < :: subxt :: sp_core :: crypto :: AccountId32 > , pub old_count : :: core :: primitive :: u32 , } impl :: subxt :: Call for SetMembers { const PALLET : & 'static str = "Council" ; const FUNCTION : & 'static str = "set_members" ; } # [derive (:: subxt :: codec :: Decode , :: subxt :: codec :: Encode , Clone , Debug , Eq , PartialEq)] pub struct Execute { pub proposal : :: std :: boxed :: Box < runtime_types :: egg_standalone_runtime :: Call > , # [codec (compact)] pub length_bound : :: core :: primitive :: u32 , } impl :: subxt :: Call for Execute { const PALLET : & 'static str = "Council" ; const FUNCTION : & 'static str = "execute" ; } # [derive (:: subxt :: codec :: Decode , :: subxt :: codec :: Encode , Clone , Debug , Eq , PartialEq)] pub struct Propose { # [codec (compact)] pub threshold : :: core :: primitive :: u32 , pub proposal : :: std :: boxed :: Box < runtime_types :: egg_standalone_runtime :: Call > , # [codec (compact)] pub length_bound : :: core :: primitive :: u32 , } impl :: subxt :: Call for Propose { const PALLET : & 'static str = "Council" ; const FUNCTION : & 'static str = "propose" ; } # [derive (:: subxt :: codec :: Decode , :: subxt :: codec :: Encode , Clone , Debug , Eq , PartialEq)] pub struct Vote { pub proposal : :: subxt :: sp_core :: H256 , # [codec (compact)] pub index : :: core :: primitive :: u32 , pub approve : :: core :: primitive :: bool , } impl :: subxt :: Call for Vote { const PALLET : & 'static str = "Council" ; const FUNCTION : & 'static str = "vote" ; } # [derive (:: subxt :: codec :: Decode , :: subxt :: codec :: Encode , Clone , Debug , Eq , PartialEq)] pub struct Close { pub proposal_hash : :: subxt :: sp_core :: H256 , # [codec (compact)] pub index : :: core :: primitive :: u32 , # [codec (compact)] pub proposal_weight_bound : :: core :: primitive :: u64 , # [codec (compact)] pub length_bound : :: core :: primitive :: u32 , } impl :: subxt :: Call for Close { const PALLET : & 'static str = "Council" ; const FUNCTION : & 'static str = "close" ; } # [derive (:: subxt :: codec :: Decode , :: subxt :: codec :: Encode , Clone , Debug , Eq , PartialEq)] pub struct DisapproveProposal { pub proposal_hash : :: subxt :: sp_core :: H256 , } impl :: subxt :: Call for DisapproveProposal { const PALLET : & 'static str = "Council" ; const FUNCTION : & 'static str = "disapprove_proposal" ; } pub struct TransactionApi < 'a , T : :: subxt :: Config , X > { client : & 'a :: subxt :: Client < T > , marker : :: core :: marker :: PhantomData < X > , } impl < 'a , T , X > TransactionApi < 'a , T , X > where T : :: subxt :: Config , X : :: subxt :: extrinsic :: ExtrinsicParams < T > , { pub fn new (client : & 'a :: subxt :: Client < T >) -> Self { Self { client , marker : :: core :: marker :: PhantomData } } # [doc = "Set the collective's membership."] # [doc = ""] # [doc = "- `new_members`: The new member list. Be nice to the chain and provide it sorted."] # [doc = "- `prime`: The prime member whose vote sets the default."] # [doc = "- `old_count`: The upper bound for the previous number of members in storage. Used for"] # [doc = "  weight estimation."] # [doc = ""] # [doc = "Requires root origin."] # [doc = ""] # [doc = "NOTE: Does not enforce the expected `MaxMembers` limit on the amount of members, but"] # [doc = "      the weight estimations rely on it to estimate dispatchable weight."] # [doc = ""] # [doc = "# WARNING:"] # [doc = ""] # [doc = "The `pallet-collective` can also be managed by logic outside of the pallet through the"] # [doc = "implementation of the trait [`ChangeMembers`]."] # [doc = "Any call to `set_members` must be careful that the member set doesn't get out of sync"] # [doc = "with other logic managing the member set."] # [doc = ""] # [doc = "# <weight>"] # [doc = "## Weight"] # [doc = "- `O(MP + N)` where:"] # [doc = "  - `M` old-members-count (code- and governance-bounded)"] # [doc = "  - `N` new-members-count (code- and governance-bounded)"] # [doc = "  - `P` proposals-count (code-bounded)"] # [doc = "- DB:"] # [doc = "  - 1 storage mutation (codec `O(M)` read, `O(N)` write) for reading and writing the"] # [doc = "    members"] # [doc = "  - 1 storage read (codec `O(P)`) for reading the proposals"] # [doc = "  - `P` storage mutations (codec `O(M)`) for updating the votes for each proposal"] # [doc = "  - 1 storage write (codec `O(1)`) for deleting the old `prime` and setting the new one"] # [doc = "# </weight>"] pub fn set_members (& self , new_members : :: std :: vec :: Vec < :: subxt :: sp_core :: crypto :: AccountId32 > , prime : :: core :: option :: Option < :: subxt :: sp_core :: crypto :: AccountId32 > , old_count : :: core :: primitive :: u32 ,) -> Result < :: subxt :: SubmittableExtrinsic < 'a , T , X , SetMembers , DispatchError , root_mod :: Event > , :: subxt :: BasicError > { if self . client . metadata () . call_hash :: < SetMembers > () ? == [228u8 , 186u8 , 17u8 , 12u8 , 231u8 , 231u8 , 139u8 , 15u8 , 96u8 , 200u8 , 68u8 , 27u8 , 61u8 , 106u8 , 245u8 , 199u8 , 120u8 , 141u8 , 95u8 , 215u8 , 36u8 , 49u8 , 0u8 , 163u8 , 172u8 , 252u8 , 221u8 , 9u8 , 1u8 , 222u8 , 44u8 , 214u8 ,] { let call = SetMembers { new_members , prime , old_count , } ; Ok (:: subxt :: SubmittableExtrinsic :: new (self . client , call)) } else { Err (:: subxt :: MetadataError :: IncompatibleMetadata . into ()) } } # [doc = "Dispatch a proposal from a member using the `Member` origin."] # [doc = ""] # [doc = "Origin must be a member of the collective."] # [doc = ""] # [doc = "# <weight>"] # [doc = "## Weight"] # [doc = "- `O(M + P)` where `M` members-count (code-bounded) and `P` complexity of dispatching"] # [doc = "  `proposal`"] # [doc = "- DB: 1 read (codec `O(M)`) + DB access of `proposal`"] # [doc = "- 1 event"] # [doc = "# </weight>"] pub fn execute (& self , proposal : runtime_types :: egg_standalone_runtime :: Call , length_bound : :: core :: primitive :: u32 ,) -> Result < :: subxt :: SubmittableExtrinsic < 'a , T , X , Execute , DispatchError , root_mod :: Event > , :: subxt :: BasicError > { if self . client . metadata () . call_hash :: < Execute > () ? == [148u8 , 233u8 , 136u8 , 57u8 , 223u8 , 134u8 , 11u8 , 28u8 , 46u8 , 91u8 , 234u8 , 197u8 , 102u8 , 99u8 , 31u8 , 25u8 , 172u8 , 244u8 , 194u8 , 167u8 , 204u8 , 139u8 , 116u8 , 254u8 , 15u8 , 249u8 , 159u8 , 38u8 , 136u8 , 201u8 , 105u8 , 231u8 ,] { let call = Execute { proposal : :: std :: boxed :: Box :: new (proposal) , length_bound , } ; Ok (:: subxt :: SubmittableExtrinsic :: new (self . client , call)) } else { Err (:: subxt :: MetadataError :: IncompatibleMetadata . into ()) } } # [doc = "Add a new proposal to either be voted on or executed directly."] # [doc = ""] # [doc = "Requires the sender to be member."] # [doc = ""] # [doc = "`threshold` determines whether `proposal` is executed directly (`threshold < 2`)"] # [doc = "or put up for voting."] # [doc = ""] # [doc = "# <weight>"] # [doc = "## Weight"] # [doc = "- `O(B + M + P1)` or `O(B + M + P2)` where:"] # [doc = "  - `B` is `proposal` size in bytes (length-fee-bounded)"] # [doc = "  - `M` is members-count (code- and governance-bounded)"] # [doc = "  - branching is influenced by `threshold` where:"] # [doc = "    - `P1` is proposal execution complexity (`threshold < 2`)"] # [doc = "    - `P2` is proposals-count (code-bounded) (`threshold >= 2`)"] # [doc = "- DB:"] # [doc = "  - 1 storage read `is_member` (codec `O(M)`)"] # [doc = "  - 1 storage read `ProposalOf::contains_key` (codec `O(1)`)"] # [doc = "  - DB accesses influenced by `threshold`:"] # [doc = "    - EITHER storage accesses done by `proposal` (`threshold < 2`)"] # [doc = "    - OR proposal insertion (`threshold <= 2`)"] # [doc = "      - 1 storage mutation `Proposals` (codec `O(P2)`)"] # [doc = "      - 1 storage mutation `ProposalCount` (codec `O(1)`)"] # [doc = "      - 1 storage write `ProposalOf` (codec `O(B)`)"] # [doc = "      - 1 storage write `Voting` (codec `O(M)`)"] # [doc = "  - 1 event"] # [doc = "# </weight>"] pub fn propose (& self , threshold : :: core :: primitive :: u32 , proposal : runtime_types :: egg_standalone_runtime :: Call , length_bound : :: core :: primitive :: u32 ,) -> Result < :: subxt :: SubmittableExtrinsic < 'a , T , X , Propose , DispatchError , root_mod :: Event > , :: subxt :: BasicError > { if self . client . metadata () . call_hash :: < Propose > () ? == [201u8 , 196u8 , 55u8 , 36u8 , 252u8 , 156u8 , 188u8 , 117u8 , 8u8 , 121u8 , 203u8 , 232u8 , 70u8 , 210u8 , 128u8 , 93u8 , 183u8 , 145u8 , 126u8 , 116u8 , 78u8 , 200u8 , 20u8 , 174u8 , 182u8 , 71u8 , 16u8 , 225u8 , 230u8 , 112u8 , 5u8 , 170u8 ,] { let call = Propose { threshold , proposal : :: std :: boxed :: Box :: new (proposal) , length_bound , } ; Ok (:: subxt :: SubmittableExtrinsic :: new (self . client , call)) } else { Err (:: subxt :: MetadataError :: IncompatibleMetadata . into ()) } } # [doc = "Add an aye or nay vote for the sender to the given proposal."] # [doc = ""] # [doc = "Requires the sender to be a member."] # [doc = ""] # [doc = "Transaction fees will be waived if the member is voting on any particular proposal"] # [doc = "for the first time and the call is successful. Subsequent vote changes will charge a"] # [doc = "fee."] # [doc = "# <weight>"] # [doc = "## Weight"] # [doc = "- `O(M)` where `M` is members-count (code- and governance-bounded)"] # [doc = "- DB:"] # [doc = "  - 1 storage read `Members` (codec `O(M)`)"] # [doc = "  - 1 storage mutation `Voting` (codec `O(M)`)"] # [doc = "- 1 event"] # [doc = "# </weight>"] pub fn vote (& self , proposal : :: subxt :: sp_core :: H256 , index : :: core :: primitive :: u32 , approve : :: core :: primitive :: bool ,) -> Result < :: subxt :: SubmittableExtrinsic < 'a , T , X , Vote , DispatchError , root_mod :: Event > , :: subxt :: BasicError > { if self . client . metadata () . call_hash :: < Vote > () ? == [184u8 , 236u8 , 80u8 , 133u8 , 26u8 , 207u8 , 3u8 , 2u8 , 120u8 , 27u8 , 38u8 , 135u8 , 195u8 , 86u8 , 169u8 , 229u8 , 125u8 , 253u8 , 220u8 , 120u8 , 231u8 , 181u8 , 101u8 , 84u8 , 151u8 , 161u8 , 39u8 , 154u8 , 183u8 , 142u8 , 165u8 , 161u8 ,] { let call = Vote { proposal , index , approve , } ; Ok (:: subxt :: SubmittableExtrinsic :: new (self . client , call)) } else { Err (:: subxt :: MetadataError :: IncompatibleMetadata . into ()) } } # [doc = "Close a vote that is either approved, disapproved or whose voting period has ended."] # [doc = ""] # [doc = "May be called by any signed account in order to finish voting and close the proposal."] # [doc = ""] # [doc = "If called before the end of the voting period it will only close the vote if it is"] # [doc = "has enough votes to be approved or disapproved."] # [doc = ""] # [doc = "If called after the end of the voting period abstentions are counted as rejections"] # [doc = "unless there is a prime member set and the prime member cast an approval."] # [doc = ""] # [doc = "If the close operation completes successfully with disapproval, the transaction fee will"] # [doc = "be waived. Otherwise execution of the approved operation will be charged to the caller."] # [doc = ""] # [doc = "+ `proposal_weight_bound`: The maximum amount of weight consumed by executing the closed"] # [doc = "proposal."] # [doc = "+ `length_bound`: The upper bound for the length of the proposal in storage. Checked via"] # [doc = "`storage::read` so it is `size_of::<u32>() == 4` larger than the pure length."] # [doc = ""] # [doc = "# <weight>"] # [doc = "## Weight"] # [doc = "- `O(B + M + P1 + P2)` where:"] # [doc = "  - `B` is `proposal` size in bytes (length-fee-bounded)"] # [doc = "  - `M` is members-count (code- and governance-bounded)"] # [doc = "  - `P1` is the complexity of `proposal` preimage."] # [doc = "  - `P2` is proposal-count (code-bounded)"] # [doc = "- DB:"] # [doc = " - 2 storage reads (`Members`: codec `O(M)`, `Prime`: codec `O(1)`)"] # [doc = " - 3 mutations (`Voting`: codec `O(M)`, `ProposalOf`: codec `O(B)`, `Proposals`: codec"] # [doc = "   `O(P2)`)"] # [doc = " - any mutations done while executing `proposal` (`P1`)"] # [doc = "- up to 3 events"] # [doc = "# </weight>"] pub fn close (& self , proposal_hash : :: subxt :: sp_core :: H256 , index : :: core :: primitive :: u32 , proposal_weight_bound : :: core :: primitive :: u64 , length_bound : :: core :: primitive :: u32 ,) -> Result < :: subxt :: SubmittableExtrinsic < 'a , T , X , Close , DispatchError , root_mod :: Event > , :: subxt :: BasicError > { if self . client . metadata () . call_hash :: < Close > () ? == [242u8 , 208u8 , 108u8 , 202u8 , 24u8 , 139u8 , 8u8 , 150u8 , 108u8 , 217u8 , 30u8 , 209u8 , 178u8 , 1u8 , 80u8 , 25u8 , 154u8 , 146u8 , 173u8 , 172u8 , 227u8 , 4u8 , 140u8 , 228u8 , 58u8 , 221u8 , 189u8 , 135u8 , 203u8 , 69u8 , 105u8 , 47u8 ,] { let call = Close { proposal_hash , index , proposal_weight_bound , length_bound , } ; Ok (:: subxt :: SubmittableExtrinsic :: new (self . client , call)) } else { Err (:: subxt :: MetadataError :: IncompatibleMetadata . into ()) } } # [doc = "Disapprove a proposal, close, and remove it from the system, regardless of its current"] # [doc = "state."] # [doc = ""] # [doc = "Must be called by the Root origin."] # [doc = ""] # [doc = "Parameters:"] # [doc = "* `proposal_hash`: The hash of the proposal that should be disapproved."] # [doc = ""] # [doc = "# <weight>"] # [doc = "Complexity: O(P) where P is the number of max proposals"] # [doc = "DB Weight:"] # [doc = "* Reads: Proposals"] # [doc = "* Writes: Voting, Proposals, ProposalOf"] # [doc = "# </weight>"] pub fn disapprove_proposal (& self , proposal_hash : :: subxt :: sp_core :: H256 ,) -> Result < :: subxt :: SubmittableExtrinsic < 'a , T , X , DisapproveProposal , DispatchError , root_mod :: Event > , :: subxt :: BasicError > { if self . client . metadata () . call_hash :: < DisapproveProposal > () ? == [199u8 , 113u8 , 221u8 , 167u8 , 60u8 , 241u8 , 77u8 , 166u8 , 205u8 , 191u8 , 183u8 , 121u8 , 191u8 , 206u8 , 230u8 , 212u8 , 215u8 , 219u8 , 30u8 , 51u8 , 123u8 , 18u8 , 17u8 , 218u8 , 77u8 , 227u8 , 197u8 , 95u8 , 232u8 , 59u8 , 169u8 , 133u8 ,] { let call = DisapproveProposal { proposal_hash , } ; Ok (:: subxt :: SubmittableExtrinsic :: new (self . client , call)) } else { Err (:: subxt :: MetadataError :: IncompatibleMetadata . into ()) } } } } pub type Event = runtime_types :: pallet_collective :: pallet :: Event ; pub mod events { use super :: runtime_types ; # [derive (:: subxt :: codec :: Decode , :: subxt :: codec :: Encode , Clone , Debug , Eq , PartialEq)] # [doc = "A motion (given hash) has been proposed (by given account) with a threshold (given"] # [doc = "`MemberCount`)."] pub struct Proposed { pub account : :: subxt :: sp_core :: crypto :: AccountId32 , pub proposal_index : :: core :: primitive :: u32 , pub proposal_hash : :: subxt :: sp_core :: H256 , pub threshold : :: core :: primitive :: u32 , } impl :: subxt :: Event for Proposed { const PALLET : & 'static str = "Council" ; const EVENT : & 'static str = "Proposed" ; } # [derive (:: subxt :: codec :: Decode , :: subxt :: codec :: Encode , Clone , Debug , Eq , PartialEq)] # [doc = "A motion (given hash) has been voted on by given account, leaving"] # [doc = "a tally (yes votes and no votes given respectively as `MemberCount`)."] pub struct Voted { pub account : :: subxt :: sp_core :: crypto :: AccountId32 , pub proposal_hash : :: subxt :: sp_core :: H256 , pub voted : :: core :: primitive :: bool , pub yes : :: core :: primitive :: u32 , pub no : :: core :: primitive :: u32 , } impl :: subxt :: Event for Voted { const PALLET : & 'static str = "Council" ; const EVENT : & 'static str = "Voted" ; } # [derive (:: subxt :: codec :: Decode , :: subxt :: codec :: Encode , Clone , Debug , Eq , PartialEq)] # [doc = "A motion was approved by the required threshold."] pub struct Approved { pub proposal_hash : :: subxt :: sp_core :: H256 , } impl :: subxt :: Event for Approved { const PALLET : & 'static str = "Council" ; const EVENT : & 'static str = "Approved" ; } # [derive (:: subxt :: codec :: Decode , :: subxt :: codec :: Encode , Clone , Debug , Eq , PartialEq)] # [doc = "A motion was not approved by the required threshold."] pub struct Disapproved { pub proposal_hash : :: subxt :: sp_core :: H256 , } impl :: subxt :: Event for Disapproved { const PALLET : & 'static str = "Council" ; const EVENT : & 'static str = "Disapproved" ; } # [derive (:: subxt :: codec :: Decode , :: subxt :: codec :: Encode , Clone , Debug , Eq , PartialEq)] # [doc = "A motion was executed; result will be `Ok` if it returned without error."] pub struct Executed { pub proposal_hash : :: subxt :: sp_core :: H256 , pub result : :: core :: result :: Result < () , runtime_types :: sp_runtime :: DispatchError > , } impl :: subxt :: Event for Executed { const PALLET : & 'static str = "Council" ; const EVENT : & 'static str = "Executed" ; } # [derive (:: subxt :: codec :: Decode , :: subxt :: codec :: Encode , Clone , Debug , Eq , PartialEq)] # [doc = "A single member did some action; result will be `Ok` if it returned without error."] pub struct MemberExecuted { pub proposal_hash : :: subxt :: sp_core :: H256 , pub result : :: core :: result :: Result < () , runtime_types :: sp_runtime :: DispatchError > , } impl :: subxt :: Event for MemberExecuted { const PALLET : & 'static str = "Council" ; const EVENT : & 'static str = "MemberExecuted" ; } # [derive (:: subxt :: codec :: Decode , :: subxt :: codec :: Encode , Clone , Debug , Eq , PartialEq)] # [doc = "A proposal was closed because its threshold was reached or after its duration was up."] pub struct Closed { pub proposal_hash : :: subxt :: sp_core :: H256 , pub yes : :: core :: primitive :: u32 , pub no : :: core :: primitive :: u32 , } impl :: subxt :: Event for Closed { const PALLET : & 'static str = "Council" ; const EVENT : & 'static str = "Closed" ; } } pub mod storage { use super :: runtime_types ; pub struct Proposals ; impl :: subxt :: StorageEntry for Proposals { const PALLET : & 'static str = "Council" ; const STORAGE : & 'static str = "Proposals" ; type Value = runtime_types :: sp_runtime :: bounded :: bounded_vec :: BoundedVec < :: subxt :: sp_core :: H256 > ; fn key (& self) -> :: subxt :: StorageEntryKey { :: subxt :: StorageEntryKey :: Plain } } pub struct ProposalOf < 'a > (pub & 'a :: subxt :: sp_core :: H256) ; impl :: subxt :: StorageEntry for ProposalOf < '_ > { const PALLET : & 'static str = "Council" ; const STORAGE : & 'static str = "ProposalOf" ; type Value = runtime_types :: egg_standalone_runtime :: Call ; fn key (& self) -> :: subxt :: StorageEntryKey { :: subxt :: StorageEntryKey :: Map (vec ! [:: subxt :: StorageMapKey :: new (& self . 0 , :: subxt :: StorageHasher :: Identity)]) } } pub struct Voting < 'a > (pub & 'a :: subxt :: sp_core :: H256) ; impl :: subxt :: StorageEntry for Voting < '_ > { const PALLET : & 'static str = "Council" ; const STORAGE : & 'static str = "Voting" ; type Value = runtime_types :: pallet_collective :: Votes < :: subxt :: sp_core :: crypto :: AccountId32 , :: core :: primitive :: u32 > ; fn key (& self) -> :: subxt :: StorageEntryKey { :: subxt :: StorageEntryKey :: Map (vec ! [:: subxt :: StorageMapKey :: new (& self . 0 , :: subxt :: StorageHasher :: Identity)]) } } pub struct ProposalCount ; impl :: subxt :: StorageEntry for ProposalCount { const PALLET : & 'static str = "Council" ; const STORAGE : & 'static str = "ProposalCount" ; type Value = :: core :: primitive :: u32 ; fn key (& self) -> :: subxt :: StorageEntryKey { :: subxt :: StorageEntryKey :: Plain } } pub struct Members ; impl :: subxt :: StorageEntry for Members { const PALLET : & 'static str = "Council" ; const STORAGE : & 'static str = "Members" ; type Value = :: std :: vec :: Vec < :: subxt :: sp_core :: crypto :: AccountId32 > ; fn key (& self) -> :: subxt :: StorageEntryKey { :: subxt :: StorageEntryKey :: Plain } } pub struct Prime ; impl :: subxt :: StorageEntry for Prime { const PALLET : & 'static str = "Council" ; const STORAGE : & 'static str = "Prime" ; type Value = :: subxt :: sp_core :: crypto :: AccountId32 ; fn key (& self) -> :: subxt :: StorageEntryKey { :: subxt :: StorageEntryKey :: Plain } } pub struct StorageApi < 'a , T : :: subxt :: Config > { client : & 'a :: subxt :: Client < T > , } impl < 'a , T : :: subxt :: Config > StorageApi < 'a , T > { pub fn new (client : & 'a :: subxt :: Client < T >) -> Self { Self { client } } # [doc = " The hashes of the active proposals."] pub async fn proposals (& self , block_hash : :: core :: option :: Option < T :: Hash > ,) -> :: core :: result :: Result < runtime_types :: sp_runtime :: bounded :: bounded_vec :: BoundedVec < :: subxt :: sp_core :: H256 > , :: subxt :: BasicError > { if self . client . metadata () . storage_hash :: < Proposals > () ? == [174u8 , 75u8 , 108u8 , 245u8 , 86u8 , 50u8 , 107u8 , 212u8 , 244u8 , 113u8 , 232u8 , 168u8 , 194u8 , 33u8 , 247u8 , 97u8 , 54u8 , 115u8 , 236u8 , 189u8 , 59u8 , 2u8 , 252u8 , 84u8 , 199u8 , 127u8 , 197u8 , 72u8 , 23u8 , 1u8 , 118u8 , 95u8 ,] { let entry = Proposals ; self . client . storage () . fetch_or_default (& entry , block_hash) . await } else { Err (:: subxt :: MetadataError :: IncompatibleMetadata . into ()) } } # [doc = " Actual proposal for a given hash, if it's current."] pub async fn proposal_of (& self , _0 : & :: subxt :: sp_core :: H256 , block_hash : :: core :: option :: Option < T :: Hash > ,) -> :: core :: result :: Result < :: core :: option :: Option < runtime_types :: egg_standalone_runtime :: Call > , :: subxt :: BasicError > { if self . client . metadata () . storage_hash :: < ProposalOf > () ? == [60u8 , 169u8 , 99u8 , 70u8 , 205u8 , 254u8 , 160u8 , 31u8 , 43u8 , 180u8 , 125u8 , 127u8 , 83u8 , 84u8 , 102u8 , 246u8 , 28u8 , 235u8 , 22u8 , 154u8 , 51u8 , 18u8 , 242u8 , 76u8 , 24u8 , 61u8 , 68u8 , 205u8 , 147u8 , 142u8 , 205u8 , 158u8 ,] { let entry = ProposalOf (_0) ; self . client . storage () . fetch (& entry , block_hash) . await } else { Err (:: subxt :: MetadataError :: IncompatibleMetadata . into ()) } } # [doc = " Actual proposal for a given hash, if it's current."] pub async fn proposal_of_iter (& self , block_hash : :: core :: option :: Option < T :: Hash > ,) -> :: core :: result :: Result < :: subxt :: KeyIter < 'a , T , ProposalOf < 'a > > , :: subxt :: BasicError > { if self . client . metadata () . storage_hash :: < ProposalOf > () ? == [60u8 , 169u8 , 99u8 , 70u8 , 205u8 , 254u8 , 160u8 , 31u8 , 43u8 , 180u8 , 125u8 , 127u8 , 83u8 , 84u8 , 102u8 , 246u8 , 28u8 , 235u8 , 22u8 , 154u8 , 51u8 , 18u8 , 242u8 , 76u8 , 24u8 , 61u8 , 68u8 , 205u8 , 147u8 , 142u8 , 205u8 , 158u8 ,] { self . client . storage () . iter (block_hash) . await } else { Err (:: subxt :: MetadataError :: IncompatibleMetadata . into ()) } } # [doc = " Votes on a given proposal, if it is ongoing."] pub async fn voting (& self , _0 : & :: subxt :: sp_core :: H256 , block_hash : :: core :: option :: Option < T :: Hash > ,) -> :: core :: result :: Result < :: core :: option :: Option < runtime_types :: pallet_collective :: Votes < :: subxt :: sp_core :: crypto :: AccountId32 , :: core :: primitive :: u32 > > , :: subxt :: BasicError > { if self . client . metadata () . storage_hash :: < Voting > () ? == [145u8 , 223u8 , 203u8 , 2u8 , 137u8 , 33u8 , 22u8 , 239u8 , 175u8 , 149u8 , 254u8 , 185u8 , 0u8 , 139u8 , 71u8 , 134u8 , 109u8 , 95u8 , 45u8 , 75u8 , 33u8 , 228u8 , 127u8 , 67u8 , 53u8 , 119u8 , 188u8 , 198u8 , 11u8 , 92u8 , 4u8 , 177u8 ,] { let entry = Voting (_0) ; self . client . storage () . fetch (& entry , block_hash) . await } else { Err (:: subxt :: MetadataError :: IncompatibleMetadata . into ()) } } # [doc = " Votes on a given proposal, if it is ongoing."] pub async fn voting_iter (& self , block_hash : :: core :: option :: Option < T :: Hash > ,) -> :: core :: result :: Result < :: subxt :: KeyIter < 'a , T , Voting < 'a > > , :: subxt :: BasicError > { if self . client . metadata () . storage_hash :: < Voting > () ? == [145u8 , 223u8 , 203u8 , 2u8 , 137u8 , 33u8 , 22u8 , 239u8 , 175u8 , 149u8 , 254u8 , 185u8 , 0u8 , 139u8 , 71u8 , 134u8 , 109u8 , 95u8 , 45u8 , 75u8 , 33u8 , 228u8 , 127u8 , 67u8 , 53u8 , 119u8 , 188u8 , 198u8 , 11u8 , 92u8 , 4u8 , 177u8 ,] { self . client . storage () . iter (block_hash) . await } else { Err (:: subxt :: MetadataError :: IncompatibleMetadata . into ()) } } # [doc = " Proposals so far."] pub async fn proposal_count (& self , block_hash : :: core :: option :: Option < T :: Hash > ,) -> :: core :: result :: Result < :: core :: primitive :: u32 , :: subxt :: BasicError > { if self . client . metadata () . storage_hash :: < ProposalCount > () ? == [132u8 , 145u8 , 78u8 , 218u8 , 51u8 , 189u8 , 55u8 , 172u8 , 143u8 , 33u8 , 140u8 , 99u8 , 124u8 , 208u8 , 57u8 , 232u8 , 154u8 , 110u8 , 32u8 , 142u8 , 24u8 , 149u8 , 109u8 , 105u8 , 30u8 , 83u8 , 39u8 , 177u8 , 127u8 , 160u8 , 34u8 , 70u8 ,] { let entry = ProposalCount ; self . client . storage () . fetch_or_default (& entry , block_hash) . await } else { Err (:: subxt :: MetadataError :: IncompatibleMetadata . into ()) } } # [doc = " The current members of the collective. This is stored sorted (just by value)."] pub async fn members (& self , block_hash : :: core :: option :: Option < T :: Hash > ,) -> :: core :: result :: Result < :: std :: vec :: Vec < :: subxt :: sp_core :: crypto :: AccountId32 > , :: subxt :: BasicError > { if self . client . metadata () . storage_hash :: < Members > () ? == [136u8 , 91u8 , 140u8 , 173u8 , 238u8 , 221u8 , 4u8 , 132u8 , 238u8 , 99u8 , 195u8 , 142u8 , 10u8 , 35u8 , 210u8 , 227u8 , 22u8 , 72u8 , 218u8 , 222u8 , 227u8 , 51u8 , 55u8 , 31u8 , 252u8 , 78u8 , 195u8 , 11u8 , 195u8 , 242u8 , 171u8 , 75u8 ,] { let entry = Members ; self . client . storage () . fetch_or_default (& entry , block_hash) . await } else { Err (:: subxt :: MetadataError :: IncompatibleMetadata . into ()) } } # [doc = " The prime member that helps determine the default vote behavior in case of absentations."] pub async fn prime (& self , block_hash : :: core :: option :: Option < T :: Hash > ,) -> :: core :: result :: Result < :: core :: option :: Option < :: subxt :: sp_core :: crypto :: AccountId32 > , :: subxt :: BasicError > { if self . client . metadata () . storage_hash :: < Prime > () ? == [70u8 , 101u8 , 20u8 , 160u8 , 173u8 , 87u8 , 190u8 , 85u8 , 60u8 , 249u8 , 144u8 , 77u8 , 175u8 , 195u8 , 51u8 , 196u8 , 234u8 , 62u8 , 243u8 , 199u8 , 126u8 , 12u8 , 88u8 , 252u8 , 1u8 , 210u8 , 65u8 , 210u8 , 33u8 , 19u8 , 222u8 , 11u8 ,] { let entry = Prime ; self . client . storage () . fetch (& entry , block_hash) . await } else { Err (:: subxt :: MetadataError :: IncompatibleMetadata . into ()) } } } } } pub mod elections { use super :: root_mod ; use super :: runtime_types ; pub mod calls { use super :: root_mod ; use super :: runtime_types ; type DispatchError = runtime_types :: sp_runtime :: DispatchError ; # [derive (:: subxt :: codec :: Decode , :: subxt :: codec :: Encode , Clone , Debug , Eq , PartialEq)] pub struct Vote { pub votes : :: std :: vec :: Vec < :: subxt :: sp_core :: crypto :: AccountId32 > , # [codec (compact)] pub value : :: core :: primitive :: u128 , } impl :: subxt :: Call for Vote { const PALLET : & 'static str = "Elections" ; const FUNCTION : & 'static str = "vote" ; } # [derive (:: subxt :: codec :: Decode , :: subxt :: codec :: Encode , Clone , Debug , Eq , PartialEq)] pub struct RemoveVoter ; impl :: subxt :: Call for RemoveVoter { const PALLET : & 'static str = "Elections" ; const FUNCTION : & 'static str = "remove_voter" ; } # [derive (:: subxt :: codec :: Decode , :: subxt :: codec :: Encode , Clone , Debug , Eq , PartialEq)] pub struct SubmitCandidacy { # [codec (compact)] pub candidate_count : :: core :: primitive :: u32 , } impl :: subxt :: Call for SubmitCandidacy { const PALLET : & 'static str = "Elections" ; const FUNCTION : & 'static str = "submit_candidacy" ; } # [derive (:: subxt :: codec :: Decode , :: subxt :: codec :: Encode , Clone , Debug , Eq , PartialEq)] pub struct RenounceCandidacy { pub renouncing : runtime_types :: pallet_elections_phragmen :: Renouncing , } impl :: subxt :: Call for RenounceCandidacy { const PALLET : & 'static str = "Elections" ; const FUNCTION : & 'static str = "renounce_candidacy" ; } # [derive (:: subxt :: codec :: Decode , :: subxt :: codec :: Encode , Clone , Debug , Eq , PartialEq)] pub struct RemoveMember { pub who : :: subxt :: sp_runtime :: MultiAddress < :: subxt :: sp_core :: crypto :: AccountId32 , :: core :: primitive :: u32 > , pub has_replacement : :: core :: primitive :: bool , } impl :: subxt :: Call for RemoveMember { const PALLET : & 'static str = "Elections" ; const FUNCTION : & 'static str = "remove_member" ; } # [derive (:: subxt :: codec :: Decode , :: subxt :: codec :: Encode , Clone , Debug , Eq , PartialEq)] pub struct CleanDefunctVoters { pub num_voters : :: core :: primitive :: u32 , pub num_defunct : :: core :: primitive :: u32 , } impl :: subxt :: Call for CleanDefunctVoters { const PALLET : & 'static str = "Elections" ; const FUNCTION : & 'static str = "clean_defunct_voters" ; } pub struct TransactionApi < 'a , T : :: subxt :: Config , X > { client : & 'a :: subxt :: Client < T > , marker : :: core :: marker :: PhantomData < X > , } impl < 'a , T , X > TransactionApi < 'a , T , X > where T : :: subxt :: Config , X : :: subxt :: extrinsic :: ExtrinsicParams < T > , { pub fn new (client : & 'a :: subxt :: Client < T >) -> Self { Self { client , marker : :: core :: marker :: PhantomData } } # [doc = "Vote for a set of candidates for the upcoming round of election. This can be called to"] # [doc = "set the initial votes, or update already existing votes."] # [doc = ""] # [doc = "Upon initial voting, `value` units of `who`'s balance is locked and a deposit amount is"] # [doc = "reserved. The deposit is based on the number of votes and can be updated over time."] # [doc = ""] # [doc = "The `votes` should:"] # [doc = "  - not be empty."] # [doc = "  - be less than the number of possible candidates. Note that all current members and"] # [doc = "    runners-up are also automatically candidates for the next round."] # [doc = ""] # [doc = "If `value` is more than `who`'s free balance, then the maximum of the two is used."] # [doc = ""] # [doc = "The dispatch origin of this call must be signed."] # [doc = ""] # [doc = "### Warning"] # [doc = ""] # [doc = "It is the responsibility of the caller to **NOT** place all of their balance into the"] # [doc = "lock and keep some for further operations."] # [doc = ""] # [doc = "# <weight>"] # [doc = "We assume the maximum weight among all 3 cases: vote_equal, vote_more and vote_less."] # [doc = "# </weight>"] pub fn vote (& self , votes : :: std :: vec :: Vec < :: subxt :: sp_core :: crypto :: AccountId32 > , value : :: core :: primitive :: u128 ,) -> Result < :: subxt :: SubmittableExtrinsic < 'a , T , X , Vote , DispatchError , root_mod :: Event > , :: subxt :: BasicError > { if self . client . metadata () . call_hash :: < Vote > () ? == [245u8 , 122u8 , 160u8 , 64u8 , 234u8 , 121u8 , 191u8 , 224u8 , 12u8 , 16u8 , 153u8 , 70u8 , 41u8 , 236u8 , 211u8 , 145u8 , 238u8 , 112u8 , 11u8 , 94u8 , 92u8 , 160u8 , 67u8 , 176u8 , 126u8 , 232u8 , 63u8 , 226u8 , 207u8 , 205u8 , 90u8 , 61u8 ,] { let call = Vote { votes , value , } ; Ok (:: subxt :: SubmittableExtrinsic :: new (self . client , call)) } else { Err (:: subxt :: MetadataError :: IncompatibleMetadata . into ()) } } # [doc = "Remove `origin` as a voter."] # [doc = ""] # [doc = "This removes the lock and returns the deposit."] # [doc = ""] # [doc = "The dispatch origin of this call must be signed and be a voter."] pub fn remove_voter (& self ,) -> Result < :: subxt :: SubmittableExtrinsic < 'a , T , X , RemoveVoter , DispatchError , root_mod :: Event > , :: subxt :: BasicError > { if self . client . metadata () . call_hash :: < RemoveVoter > () ? == [254u8 , 46u8 , 140u8 , 4u8 , 218u8 , 45u8 , 150u8 , 72u8 , 67u8 , 131u8 , 108u8 , 201u8 , 46u8 , 157u8 , 104u8 , 161u8 , 53u8 , 155u8 , 130u8 , 50u8 , 88u8 , 149u8 , 255u8 , 12u8 , 17u8 , 85u8 , 95u8 , 69u8 , 153u8 , 130u8 , 221u8 , 1u8 ,] { let call = RemoveVoter { } ; Ok (:: subxt :: SubmittableExtrinsic :: new (self . client , call)) } else { Err (:: subxt :: MetadataError :: IncompatibleMetadata . into ()) } } # [doc = "Submit oneself for candidacy. A fixed amount of deposit is recorded."] # [doc = ""] # [doc = "All candidates are wiped at the end of the term. They either become a member/runner-up,"] # [doc = "or leave the system while their deposit is slashed."] # [doc = ""] # [doc = "The dispatch origin of this call must be signed."] # [doc = ""] # [doc = "### Warning"] # [doc = ""] # [doc = "Even if a candidate ends up being a member, they must call [`Call::renounce_candidacy`]"] # [doc = "to get their deposit back. Losing the spot in an election will always lead to a slash."] # [doc = ""] # [doc = "# <weight>"] # [doc = "The number of current candidates must be provided as witness data."] # [doc = "# </weight>"] pub fn submit_candidacy (& self , candidate_count : :: core :: primitive :: u32 ,) -> Result < :: subxt :: SubmittableExtrinsic < 'a , T , X , SubmitCandidacy , DispatchError , root_mod :: Event > , :: subxt :: BasicError > { if self . client . metadata () . call_hash :: < SubmitCandidacy > () ? == [100u8 , 38u8 , 146u8 , 5u8 , 234u8 , 101u8 , 193u8 , 9u8 , 245u8 , 237u8 , 220u8 , 21u8 , 36u8 , 64u8 , 205u8 , 103u8 , 11u8 , 194u8 , 18u8 , 96u8 , 44u8 , 231u8 , 125u8 , 82u8 , 63u8 , 51u8 , 51u8 , 183u8 , 28u8 , 33u8 , 121u8 , 89u8 ,] { let call = SubmitCandidacy { candidate_count , } ; Ok (:: subxt :: SubmittableExtrinsic :: new (self . client , call)) } else { Err (:: subxt :: MetadataError :: IncompatibleMetadata . into ()) } } # [doc = "Renounce one's intention to be a candidate for the next election round. 3 potential"] # [doc = "outcomes exist:"] # [doc = ""] # [doc = "- `origin` is a candidate and not elected in any set. In this case, the deposit is"] # [doc = "  unreserved, returned and origin is removed as a candidate."] # [doc = "- `origin` is a current runner-up. In this case, the deposit is unreserved, returned and"] # [doc = "  origin is removed as a runner-up."] # [doc = "- `origin` is a current member. In this case, the deposit is unreserved and origin is"] # [doc = "  removed as a member, consequently not being a candidate for the next round anymore."] # [doc = "  Similar to [`remove_member`](Self::remove_member), if replacement runners exists, they"] # [doc = "  are immediately used. If the prime is renouncing, then no prime will exist until the"] # [doc = "  next round."] # [doc = ""] # [doc = "The dispatch origin of this call must be signed, and have one of the above roles."] # [doc = ""] # [doc = "# <weight>"] # [doc = "The type of renouncing must be provided as witness data."] # [doc = "# </weight>"] pub fn renounce_candidacy (& self , renouncing : runtime_types :: pallet_elections_phragmen :: Renouncing ,) -> Result < :: subxt :: SubmittableExtrinsic < 'a , T , X , RenounceCandidacy , DispatchError , root_mod :: Event > , :: subxt :: BasicError > { if self . client . metadata () . call_hash :: < RenounceCandidacy > () ? == [184u8 , 45u8 , 220u8 , 198u8 , 21u8 , 54u8 , 15u8 , 235u8 , 192u8 , 78u8 , 96u8 , 172u8 , 12u8 , 152u8 , 147u8 , 183u8 , 172u8 , 85u8 , 26u8 , 243u8 , 250u8 , 248u8 , 104u8 , 76u8 , 88u8 , 150u8 , 197u8 , 130u8 , 221u8 , 234u8 , 53u8 , 174u8 ,] { let call = RenounceCandidacy { renouncing , } ; Ok (:: subxt :: SubmittableExtrinsic :: new (self . client , call)) } else { Err (:: subxt :: MetadataError :: IncompatibleMetadata . into ()) } } # [doc = "Remove a particular member from the set. This is effective immediately and the bond of"] # [doc = "the outgoing member is slashed."] # [doc = ""] # [doc = "If a runner-up is available, then the best runner-up will be removed and replaces the"] # [doc = "outgoing member. Otherwise, a new phragmen election is started."] # [doc = ""] # [doc = "The dispatch origin of this call must be root."] # [doc = ""] # [doc = "Note that this does not affect the designated block number of the next election."] # [doc = ""] # [doc = "# <weight>"] # [doc = "If we have a replacement, we use a small weight. Else, since this is a root call and"] # [doc = "will go into phragmen, we assume full block for now."] # [doc = "# </weight>"] pub fn remove_member (& self , who : :: subxt :: sp_runtime :: MultiAddress < :: subxt :: sp_core :: crypto :: AccountId32 , :: core :: primitive :: u32 > , has_replacement : :: core :: primitive :: bool ,) -> Result < :: subxt :: SubmittableExtrinsic < 'a , T , X , RemoveMember , DispatchError , root_mod :: Event > , :: subxt :: BasicError > { if self . client . metadata () . call_hash :: < RemoveMember > () ? == [59u8 , 246u8 , 128u8 , 178u8 , 45u8 , 235u8 , 111u8 , 84u8 , 111u8 , 45u8 , 207u8 , 168u8 , 247u8 , 13u8 , 181u8 , 209u8 , 94u8 , 224u8 , 186u8 , 92u8 , 217u8 , 7u8 , 252u8 , 131u8 , 12u8 , 197u8 , 43u8 , 216u8 , 60u8 , 103u8 , 43u8 , 110u8 ,] { let call = RemoveMember { who , has_replacement , } ; Ok (:: subxt :: SubmittableExtrinsic :: new (self . client , call)) } else { Err (:: subxt :: MetadataError :: IncompatibleMetadata . into ()) } } # [doc = "Clean all voters who are defunct (i.e. they do not serve any purpose at all). The"] # [doc = "deposit of the removed voters are returned."] # [doc = ""] # [doc = "This is an root function to be used only for cleaning the state."] # [doc = ""] # [doc = "The dispatch origin of this call must be root."] # [doc = ""] # [doc = "# <weight>"] # [doc = "The total number of voters and those that are defunct must be provided as witness data."] # [doc = "# </weight>"] pub fn clean_defunct_voters (& self , num_voters : :: core :: primitive :: u32 , num_defunct : :: core :: primitive :: u32 ,) -> Result < :: subxt :: SubmittableExtrinsic < 'a , T , X , CleanDefunctVoters , DispatchError , root_mod :: Event > , :: subxt :: BasicError > { if self . client . metadata () . call_hash :: < CleanDefunctVoters > () ? == [80u8 , 248u8 , 122u8 , 6u8 , 88u8 , 255u8 , 17u8 , 206u8 , 104u8 , 208u8 , 66u8 , 191u8 , 118u8 , 163u8 , 154u8 , 9u8 , 37u8 , 106u8 , 232u8 , 178u8 , 17u8 , 177u8 , 225u8 , 101u8 , 76u8 , 207u8 , 175u8 , 117u8 , 21u8 , 203u8 , 229u8 , 140u8 ,] { let call = CleanDefunctVoters { num_voters , num_defunct , } ; Ok (:: subxt :: SubmittableExtrinsic :: new (self . client , call)) } else { Err (:: subxt :: MetadataError :: IncompatibleMetadata . into ()) } } } } pub type Event = runtime_types :: pallet_elections_phragmen :: pallet :: Event ; pub mod events { use super :: runtime_types ; # [derive (:: subxt :: codec :: Decode , :: subxt :: codec :: Encode , Clone , Debug , Eq , PartialEq)] # [doc = "A new term with new_members. This indicates that enough candidates existed to run"] # [doc = "the election, not that enough have has been elected. The inner value must be examined"] # [doc = "for this purpose. A `NewTerm(\\[\\])` indicates that some candidates got their bond"] # [doc = "slashed and none were elected, whilst `EmptyTerm` means that no candidates existed to"] # [doc = "begin with."] pub struct NewTerm { pub new_members : :: std :: vec :: Vec < (:: subxt :: sp_core :: crypto :: AccountId32 , :: core :: primitive :: u128 ,) > , } impl :: subxt :: Event for NewTerm { const PALLET : & 'static str = "Elections" ; const EVENT : & 'static str = "NewTerm" ; } # [derive (:: subxt :: codec :: Decode , :: subxt :: codec :: Encode , Clone , Debug , Eq , PartialEq)] # [doc = "No (or not enough) candidates existed for this round. This is different from"] # [doc = "`NewTerm(\\[\\])`. See the description of `NewTerm`."] pub struct EmptyTerm ; impl :: subxt :: Event for EmptyTerm { const PALLET : & 'static str = "Elections" ; const EVENT : & 'static str = "EmptyTerm" ; } # [derive (:: subxt :: codec :: Decode , :: subxt :: codec :: Encode , Clone , Debug , Eq , PartialEq)] # [doc = "Internal error happened while trying to perform election."] pub struct ElectionError ; impl :: subxt :: Event for ElectionError { const PALLET : & 'static str = "Elections" ; const EVENT : & 'static str = "ElectionError" ; } # [derive (:: subxt :: codec :: Decode , :: subxt :: codec :: Encode , Clone , Debug , Eq , PartialEq)] # [doc = "A member has been removed. This should always be followed by either `NewTerm` or"] # [doc = "`EmptyTerm`."] pub struct MemberKicked { pub member : :: subxt :: sp_core :: crypto :: AccountId32 , } impl :: subxt :: Event for MemberKicked { const PALLET : & 'static str = "Elections" ; const EVENT : & 'static str = "MemberKicked" ; } # [derive (:: subxt :: codec :: Decode , :: subxt :: codec :: Encode , Clone , Debug , Eq , PartialEq)] # [doc = "Someone has renounced their candidacy."] pub struct Renounced { pub candidate : :: subxt :: sp_core :: crypto :: AccountId32 , } impl :: subxt :: Event for Renounced { const PALLET : & 'static str = "Elections" ; const EVENT : & 'static str = "Renounced" ; } # [derive (:: subxt :: codec :: Decode , :: subxt :: codec :: Encode , Clone , Debug , Eq , PartialEq)] # [doc = "A candidate was slashed by amount due to failing to obtain a seat as member or"] # [doc = "runner-up."] # [doc = ""] # [doc = "Note that old members and runners-up are also candidates."] pub struct CandidateSlashed { pub candidate : :: subxt :: sp_core :: crypto :: AccountId32 , pub amount : :: core :: primitive :: u128 , } impl :: subxt :: Event for CandidateSlashed { const PALLET : & 'static str = "Elections" ; const EVENT : & 'static str = "CandidateSlashed" ; } # [derive (:: subxt :: codec :: Decode , :: subxt :: codec :: Encode , Clone , Debug , Eq , PartialEq)] # [doc = "A seat holder was slashed by amount by being forcefully removed from the set."] pub struct SeatHolderSlashed { pub seat_holder : :: subxt :: sp_core :: crypto :: AccountId32 , pub amount : :: core :: primitive :: u128 , } impl :: subxt :: Event for SeatHolderSlashed { const PALLET : & 'static str = "Elections" ; const EVENT : & 'static str = "SeatHolderSlashed" ; } } pub mod storage { use super :: runtime_types ; pub struct Members ; impl :: subxt :: StorageEntry for Members { const PALLET : & 'static str = "Elections" ; const STORAGE : & 'static str = "Members" ; type Value = :: std :: vec :: Vec < runtime_types :: pallet_elections_phragmen :: SeatHolder < :: subxt :: sp_core :: crypto :: AccountId32 , :: core :: primitive :: u128 > > ; fn key (& self) -> :: subxt :: StorageEntryKey { :: subxt :: StorageEntryKey :: Plain } } pub struct RunnersUp ; impl :: subxt :: StorageEntry for RunnersUp { const PALLET : & 'static str = "Elections" ; const STORAGE : & 'static str = "RunnersUp" ; type Value = :: std :: vec :: Vec < runtime_types :: pallet_elections_phragmen :: SeatHolder < :: subxt :: sp_core :: crypto :: AccountId32 , :: core :: primitive :: u128 > > ; fn key (& self) -> :: subxt :: StorageEntryKey { :: subxt :: StorageEntryKey :: Plain } } pub struct Candidates ; impl :: subxt :: StorageEntry for Candidates { const PALLET : & 'static str = "Elections" ; const STORAGE : & 'static str = "Candidates" ; type Value = :: std :: vec :: Vec < (:: subxt :: sp_core :: crypto :: AccountId32 , :: core :: primitive :: u128 ,) > ; fn key (& self) -> :: subxt :: StorageEntryKey { :: subxt :: StorageEntryKey :: Plain } } pub struct ElectionRounds ; impl :: subxt :: StorageEntry for ElectionRounds { const PALLET : & 'static str = "Elections" ; const STORAGE : & 'static str = "ElectionRounds" ; type Value = :: core :: primitive :: u32 ; fn key (& self) -> :: subxt :: StorageEntryKey { :: subxt :: StorageEntryKey :: Plain } } pub struct Voting < 'a > (pub & 'a :: subxt :: sp_core :: crypto :: AccountId32) ; impl :: subxt :: StorageEntry for Voting < '_ > { const PALLET : & 'static str = "Elections" ; const STORAGE : & 'static str = "Voting" ; type Value = runtime_types :: pallet_elections_phragmen :: Voter < :: subxt :: sp_core :: crypto :: AccountId32 , :: core :: primitive :: u128 > ; fn key (& self) -> :: subxt :: StorageEntryKey { :: subxt :: StorageEntryKey :: Map (vec ! [:: subxt :: StorageMapKey :: new (& self . 0 , :: subxt :: StorageHasher :: Twox64Concat)]) } } pub struct StorageApi < 'a , T : :: subxt :: Config > { client : & 'a :: subxt :: Client < T > , } impl < 'a , T : :: subxt :: Config > StorageApi < 'a , T > { pub fn new (client : & 'a :: subxt :: Client < T >) -> Self { Self { client } } # [doc = " The current elected members."] # [doc = ""] # [doc = " Invariant: Always sorted based on account id."] pub async fn members (& self , block_hash : :: core :: option :: Option < T :: Hash > ,) -> :: core :: result :: Result < :: std :: vec :: Vec < runtime_types :: pallet_elections_phragmen :: SeatHolder < :: subxt :: sp_core :: crypto :: AccountId32 , :: core :: primitive :: u128 > > , :: subxt :: BasicError > { if self . client . metadata () . storage_hash :: < Members > () ? == [193u8 , 166u8 , 79u8 , 96u8 , 31u8 , 4u8 , 133u8 , 133u8 , 115u8 , 236u8 , 253u8 , 177u8 , 176u8 , 10u8 , 50u8 , 97u8 , 254u8 , 234u8 , 169u8 , 236u8 , 77u8 , 243u8 , 173u8 , 187u8 , 129u8 , 122u8 , 160u8 , 73u8 , 25u8 , 150u8 , 140u8 , 56u8 ,] { let entry = Members ; self . client . storage () . fetch_or_default (& entry , block_hash) . await } else { Err (:: subxt :: MetadataError :: IncompatibleMetadata . into ()) } } # [doc = " The current reserved runners-up."] # [doc = ""] # [doc = " Invariant: Always sorted based on rank (worse to best). Upon removal of a member, the"] # [doc = " last (i.e. _best_) runner-up will be replaced."] pub async fn runners_up (& self , block_hash : :: core :: option :: Option < T :: Hash > ,) -> :: core :: result :: Result < :: std :: vec :: Vec < runtime_types :: pallet_elections_phragmen :: SeatHolder < :: subxt :: sp_core :: crypto :: AccountId32 , :: core :: primitive :: u128 > > , :: subxt :: BasicError > { if self . client . metadata () . storage_hash :: < RunnersUp > () ? == [59u8 , 65u8 , 218u8 , 225u8 , 49u8 , 140u8 , 168u8 , 143u8 , 195u8 , 106u8 , 207u8 , 181u8 , 157u8 , 129u8 , 140u8 , 122u8 , 145u8 , 207u8 , 179u8 , 144u8 , 146u8 , 206u8 , 204u8 , 245u8 , 6u8 , 201u8 , 192u8 , 232u8 , 84u8 , 108u8 , 86u8 , 187u8 ,] { let entry = RunnersUp ; self . client . storage () . fetch_or_default (& entry , block_hash) . await } else { Err (:: subxt :: MetadataError :: IncompatibleMetadata . into ()) } } # [doc = " The present candidate list. A current member or runner-up can never enter this vector"] # [doc = " and is always implicitly assumed to be a candidate."] # [doc = ""] # [doc = " Second element is the deposit."] # [doc = ""] # [doc = " Invariant: Always sorted based on account id."] pub async fn candidates (& self , block_hash : :: core :: option :: Option < T :: Hash > ,) -> :: core :: result :: Result < :: std :: vec :: Vec < (:: subxt :: sp_core :: crypto :: AccountId32 , :: core :: primitive :: u128 ,) > , :: subxt :: BasicError > { if self . client . metadata () . storage_hash :: < Candidates > () ? == [172u8 , 196u8 , 249u8 , 114u8 , 195u8 , 161u8 , 43u8 , 219u8 , 208u8 , 127u8 , 144u8 , 87u8 , 13u8 , 253u8 , 114u8 , 209u8 , 199u8 , 65u8 , 77u8 , 7u8 , 131u8 , 166u8 , 212u8 , 94u8 , 253u8 , 166u8 , 234u8 , 42u8 , 36u8 , 175u8 , 100u8 , 14u8 ,] { let entry = Candidates ; self . client . storage () . fetch_or_default (& entry , block_hash) . await } else { Err (:: subxt :: MetadataError :: IncompatibleMetadata . into ()) } } # [doc = " The total number of vote rounds that have happened, excluding the upcoming one."] pub async fn election_rounds (& self , block_hash : :: core :: option :: Option < T :: Hash > ,) -> :: core :: result :: Result < :: core :: primitive :: u32 , :: subxt :: BasicError > { if self . client . metadata () . storage_hash :: < ElectionRounds > () ? == [144u8 , 146u8 , 10u8 , 32u8 , 149u8 , 147u8 , 59u8 , 205u8 , 61u8 , 246u8 , 28u8 , 169u8 , 130u8 , 136u8 , 143u8 , 104u8 , 253u8 , 86u8 , 228u8 , 68u8 , 19u8 , 184u8 , 166u8 , 214u8 , 58u8 , 103u8 , 176u8 , 160u8 , 240u8 , 249u8 , 117u8 , 115u8 ,] { let entry = ElectionRounds ; self . client . storage () . fetch_or_default (& entry , block_hash) . await } else { Err (:: subxt :: MetadataError :: IncompatibleMetadata . into ()) } } # [doc = " Votes and locked stake of a particular voter."] # [doc = ""] # [doc = " TWOX-NOTE: SAFE as `AccountId` is a crypto hash."] pub async fn voting (& self , _0 : & :: subxt :: sp_core :: crypto :: AccountId32 , block_hash : :: core :: option :: Option < T :: Hash > ,) -> :: core :: result :: Result < runtime_types :: pallet_elections_phragmen :: Voter < :: subxt :: sp_core :: crypto :: AccountId32 , :: core :: primitive :: u128 > , :: subxt :: BasicError > { if self . client . metadata () . storage_hash :: < Voting > () ? == [107u8 , 14u8 , 228u8 , 167u8 , 43u8 , 105u8 , 221u8 , 70u8 , 234u8 , 157u8 , 36u8 , 16u8 , 63u8 , 225u8 , 89u8 , 111u8 , 201u8 , 172u8 , 98u8 , 169u8 , 232u8 , 175u8 , 172u8 , 20u8 , 223u8 , 80u8 , 107u8 , 183u8 , 252u8 , 175u8 , 50u8 , 171u8 ,] { let entry = Voting (_0) ; self . client . storage () . fetch_or_default (& entry , block_hash) . await } else { Err (:: subxt :: MetadataError :: IncompatibleMetadata . into ()) } } # [doc = " Votes and locked stake of a particular voter."] # [doc = ""] # [doc = " TWOX-NOTE: SAFE as `AccountId` is a crypto hash."] pub async fn voting_iter (& self , block_hash : :: core :: option :: Option < T :: Hash > ,) -> :: core :: result :: Result < :: subxt :: KeyIter < 'a , T , Voting < 'a > > , :: subxt :: BasicError > { if self . client . metadata () . storage_hash :: < Voting > () ? == [107u8 , 14u8 , 228u8 , 167u8 , 43u8 , 105u8 , 221u8 , 70u8 , 234u8 , 157u8 , 36u8 , 16u8 , 63u8 , 225u8 , 89u8 , 111u8 , 201u8 , 172u8 , 98u8 , 169u8 , 232u8 , 175u8 , 172u8 , 20u8 , 223u8 , 80u8 , 107u8 , 183u8 , 252u8 , 175u8 , 50u8 , 171u8 ,] { self . client . storage () . iter (block_hash) . await } else { Err (:: subxt :: MetadataError :: IncompatibleMetadata . into ()) } } } } pub mod constants { use super :: runtime_types ; pub struct ConstantsApi < 'a , T : :: subxt :: Config > { client : & 'a :: subxt :: Client < T > , } impl < 'a , T : :: subxt :: Config > ConstantsApi < 'a , T > { pub fn new (client : & 'a :: subxt :: Client < T >) -> Self { Self { client } } # [doc = " Identifier for the elections-phragmen pallet's lock"] pub fn pallet_id (& self) -> :: core :: result :: Result < [:: core :: primitive :: u8 ; 8usize] , :: subxt :: BasicError > { if self . client . metadata () . constant_hash ("Elections" , "PalletId") ? == [95u8 , 63u8 , 229u8 , 200u8 , 231u8 , 11u8 , 95u8 , 106u8 , 62u8 , 240u8 , 37u8 , 146u8 , 230u8 , 74u8 , 169u8 , 185u8 , 160u8 , 90u8 , 136u8 , 209u8 , 127u8 , 221u8 , 173u8 , 200u8 , 243u8 , 198u8 , 18u8 , 226u8 , 144u8 , 188u8 , 105u8 , 230u8 ,] { let pallet = self . client . metadata () . pallet ("Elections") ? ; let constant = pallet . constant ("PalletId") ? ; let value = :: subxt :: codec :: Decode :: decode (& mut & constant . value [..]) ? ; Ok (value) } else { Err (:: subxt :: MetadataError :: IncompatibleMetadata . into ()) } } # [doc = " How much should be locked up in order to submit one's candidacy."] pub fn candidacy_bond (& self) -> :: core :: result :: Result < :: core :: primitive :: u128 , :: subxt :: BasicError > { if self . client . metadata () . constant_hash ("Elections" , "CandidacyBond") ? == [210u8 , 4u8 , 179u8 , 42u8 , 150u8 , 149u8 , 153u8 , 168u8 , 44u8 , 34u8 , 104u8 , 180u8 , 55u8 , 6u8 , 211u8 , 176u8 , 16u8 , 198u8 , 9u8 , 163u8 , 217u8 , 66u8 , 227u8 , 10u8 , 103u8 , 244u8 , 253u8 , 193u8 , 190u8 , 222u8 , 249u8 , 41u8 ,] { let pallet = self . client . metadata () . pallet ("Elections") ? ; let constant = pallet . constant ("CandidacyBond") ? ; let value = :: subxt :: codec :: Decode :: decode (& mut & constant . value [..]) ? ; Ok (value) } else { Err (:: subxt :: MetadataError :: IncompatibleMetadata . into ()) } } # [doc = " Base deposit associated with voting."] # [doc = ""] # [doc = " This should be sensibly high to economically ensure the pallet cannot be attacked by"] # [doc = " creating a gigantic number of votes."] pub fn voting_bond_base (& self) -> :: core :: result :: Result < :: core :: primitive :: u128 , :: subxt :: BasicError > { if self . client . metadata () . constant_hash ("Elections" , "VotingBondBase") ? == [201u8 , 172u8 , 218u8 , 43u8 , 125u8 , 254u8 , 154u8 , 226u8 , 95u8 , 220u8 , 143u8 , 32u8 , 83u8 , 182u8 , 25u8 , 67u8 , 206u8 , 12u8 , 222u8 , 18u8 , 27u8 , 159u8 , 114u8 , 3u8 , 247u8 , 34u8 , 250u8 , 245u8 , 200u8 , 124u8 , 60u8 , 20u8 ,] { let pallet = self . client . metadata () . pallet ("Elections") ? ; let constant = pallet . constant ("VotingBondBase") ? ; let value = :: subxt :: codec :: Decode :: decode (& mut & constant . value [..]) ? ; Ok (value) } else { Err (:: subxt :: MetadataError :: IncompatibleMetadata . into ()) } } # [doc = " The amount of bond that need to be locked for each vote (32 bytes)."] pub fn voting_bond_factor (& self) -> :: core :: result :: Result < :: core :: primitive :: u128 , :: subxt :: BasicError > { if self . client . metadata () . constant_hash ("Elections" , "VotingBondFactor") ? == [177u8 , 191u8 , 156u8 , 77u8 , 10u8 , 132u8 , 196u8 , 255u8 , 202u8 , 134u8 , 149u8 , 90u8 , 223u8 , 183u8 , 221u8 , 39u8 , 177u8 , 108u8 , 3u8 , 131u8 , 192u8 , 12u8 , 129u8 , 137u8 , 7u8 , 49u8 , 146u8 , 74u8 , 236u8 , 91u8 , 114u8 , 141u8 ,] { let pallet = self . client . metadata () . pallet ("Elections") ? ; let constant = pallet . constant ("VotingBondFactor") ? ; let value = :: subxt :: codec :: Decode :: decode (& mut & constant . value [..]) ? ; Ok (value) } else { Err (:: subxt :: MetadataError :: IncompatibleMetadata . into ()) } } # [doc = " Number of members to elect."] pub fn desired_members (& self) -> :: core :: result :: Result < :: core :: primitive :: u32 , :: subxt :: BasicError > { if self . client . metadata () . constant_hash ("Elections" , "DesiredMembers") ? == [202u8 , 93u8 , 82u8 , 184u8 , 101u8 , 152u8 , 110u8 , 247u8 , 155u8 , 43u8 , 205u8 , 219u8 , 41u8 , 184u8 , 141u8 , 32u8 , 33u8 , 30u8 , 129u8 , 33u8 , 132u8 , 18u8 , 172u8 , 114u8 , 226u8 , 81u8 , 21u8 , 55u8 , 197u8 , 42u8 , 65u8 , 162u8 ,] { let pallet = self . client . metadata () . pallet ("Elections") ? ; let constant = pallet . constant ("DesiredMembers") ? ; let value = :: subxt :: codec :: Decode :: decode (& mut & constant . value [..]) ? ; Ok (value) } else { Err (:: subxt :: MetadataError :: IncompatibleMetadata . into ()) } } # [doc = " Number of runners_up to keep."] pub fn desired_runners_up (& self) -> :: core :: result :: Result < :: core :: primitive :: u32 , :: subxt :: BasicError > { if self . client . metadata () . constant_hash ("Elections" , "DesiredRunnersUp") ? == [111u8 , 76u8 , 46u8 , 53u8 , 112u8 , 42u8 , 175u8 , 150u8 , 116u8 , 223u8 , 31u8 , 161u8 , 229u8 , 50u8 , 76u8 , 225u8 , 159u8 , 170u8 , 134u8 , 125u8 , 43u8 , 186u8 , 28u8 , 160u8 , 225u8 , 173u8 , 39u8 , 87u8 , 86u8 , 126u8 , 217u8 , 181u8 ,] { let pallet = self . client . metadata () . pallet ("Elections") ? ; let constant = pallet . constant ("DesiredRunnersUp") ? ; let value = :: subxt :: codec :: Decode :: decode (& mut & constant . value [..]) ? ; Ok (value) } else { Err (:: subxt :: MetadataError :: IncompatibleMetadata . into ()) } } # [doc = " How long each seat is kept. This defines the next block number at which an election"] # [doc = " round will happen. If set to zero, no elections are ever triggered and the module will"] # [doc = " be in passive mode."] pub fn term_duration (& self) -> :: core :: result :: Result < :: core :: primitive :: u32 , :: subxt :: BasicError > { if self . client . metadata () . constant_hash ("Elections" , "TermDuration") ? == [254u8 , 0u8 , 43u8 , 231u8 , 130u8 , 41u8 , 251u8 , 117u8 , 58u8 , 32u8 , 80u8 , 76u8 , 76u8 , 192u8 , 193u8 , 86u8 , 7u8 , 36u8 , 140u8 , 204u8 , 75u8 , 138u8 , 96u8 , 237u8 , 153u8 , 166u8 , 168u8 , 81u8 , 228u8 , 46u8 , 246u8 , 133u8 ,] { let pallet = self . client . metadata () . pallet ("Elections") ? ; let constant = pallet . constant ("TermDuration") ? ; let value = :: subxt :: codec :: Decode :: decode (& mut & constant . value [..]) ? ; Ok (value) } else { Err (:: subxt :: MetadataError :: IncompatibleMetadata . into ()) } } } } } pub mod election_provider_multi_phase { use super :: root_mod ; use super :: runtime_types ; pub mod calls { use super :: root_mod ; use super :: runtime_types ; type DispatchError = runtime_types :: sp_runtime :: DispatchError ; # [derive (:: subxt :: codec :: Decode , :: subxt :: codec :: Encode , Clone , Debug , Eq , PartialEq)] pub struct SubmitUnsigned { pub raw_solution : :: std :: boxed :: Box < runtime_types :: pallet_election_provider_multi_phase :: RawSolution < runtime_types :: egg_standalone_runtime :: NposSolution16 > > , pub witness : runtime_types :: pallet_election_provider_multi_phase :: SolutionOrSnapshotSize , } impl :: subxt :: Call for SubmitUnsigned { const PALLET : & 'static str = "ElectionProviderMultiPhase" ; const FUNCTION : & 'static str = "submit_unsigned" ; } # [derive (:: subxt :: codec :: Decode , :: subxt :: codec :: Encode , Clone , Debug , Eq , PartialEq)] pub struct SetMinimumUntrustedScore { pub maybe_next_score : :: core :: option :: Option < runtime_types :: sp_npos_elections :: ElectionScore > , } impl :: subxt :: Call for SetMinimumUntrustedScore { const PALLET : & 'static str = "ElectionProviderMultiPhase" ; const FUNCTION : & 'static str = "set_minimum_untrusted_score" ; } # [derive (:: subxt :: codec :: Decode , :: subxt :: codec :: Encode , Clone , Debug , Eq , PartialEq)] pub struct SetEmergencyElectionResult { pub supports : :: std :: vec :: Vec < (:: subxt :: sp_core :: crypto :: AccountId32 , runtime_types :: sp_npos_elections :: Support < :: subxt :: sp_core :: crypto :: AccountId32 > ,) > , } impl :: subxt :: Call for SetEmergencyElectionResult { const PALLET : & 'static str = "ElectionProviderMultiPhase" ; const FUNCTION : & 'static str = "set_emergency_election_result" ; } # [derive (:: subxt :: codec :: Decode , :: subxt :: codec :: Encode , Clone , Debug , Eq , PartialEq)] pub struct Submit { pub raw_solution : :: std :: boxed :: Box < runtime_types :: pallet_election_provider_multi_phase :: RawSolution < runtime_types :: egg_standalone_runtime :: NposSolution16 > > , } impl :: subxt :: Call for Submit { const PALLET : & 'static str = "ElectionProviderMultiPhase" ; const FUNCTION : & 'static str = "submit" ; } # [derive (:: subxt :: codec :: Decode , :: subxt :: codec :: Encode , Clone , Debug , Eq , PartialEq)] pub struct GovernanceFallback { pub maybe_max_voters : :: core :: option :: Option < :: core :: primitive :: u32 > , pub maybe_max_targets : :: core :: option :: Option < :: core :: primitive :: u32 > , } impl :: subxt :: Call for GovernanceFallback { const PALLET : & 'static str = "ElectionProviderMultiPhase" ; const FUNCTION : & 'static str = "governance_fallback" ; } pub struct TransactionApi < 'a , T : :: subxt :: Config , X > { client : & 'a :: subxt :: Client < T > , marker : :: core :: marker :: PhantomData < X > , } impl < 'a , T , X > TransactionApi < 'a , T , X > where T : :: subxt :: Config , X : :: subxt :: extrinsic :: ExtrinsicParams < T > , { pub fn new (client : & 'a :: subxt :: Client < T >) -> Self { Self { client , marker : :: core :: marker :: PhantomData } } # [doc = "Submit a solution for the unsigned phase."] # [doc = ""] # [doc = "The dispatch origin fo this call must be __none__."] # [doc = ""] # [doc = "This submission is checked on the fly. Moreover, this unsigned solution is only"] # [doc = "validated when submitted to the pool from the **local** node. Effectively, this means"] # [doc = "that only active validators can submit this transaction when authoring a block (similar"] # [doc = "to an inherent)."] # [doc = ""] # [doc = "To prevent any incorrect solution (and thus wasted time/weight), this transaction will"] # [doc = "panic if the solution submitted by the validator is invalid in any way, effectively"] # [doc = "putting their authoring reward at risk."] # [doc = ""] # [doc = "No deposit or reward is associated with this submission."] pub fn submit_unsigned (& self , raw_solution : runtime_types :: pallet_election_provider_multi_phase :: RawSolution < runtime_types :: egg_standalone_runtime :: NposSolution16 > , witness : runtime_types :: pallet_election_provider_multi_phase :: SolutionOrSnapshotSize ,) -> Result < :: subxt :: SubmittableExtrinsic < 'a , T , X , SubmitUnsigned , DispatchError , root_mod :: Event > , :: subxt :: BasicError > { if self . client . metadata () . call_hash :: < SubmitUnsigned > () ? == [212u8 , 126u8 , 4u8 , 62u8 , 15u8 , 223u8 , 54u8 , 80u8 , 27u8 , 96u8 , 170u8 , 169u8 , 238u8 , 149u8 , 139u8 , 190u8 , 179u8 , 158u8 , 126u8 , 191u8 , 50u8 , 201u8 , 108u8 , 200u8 , 78u8 , 139u8 , 92u8 , 69u8 , 50u8 , 239u8 , 51u8 , 18u8 ,] { let call = SubmitUnsigned { raw_solution : :: std :: boxed :: Box :: new (raw_solution) , witness , } ; Ok (:: subxt :: SubmittableExtrinsic :: new (self . client , call)) } else { Err (:: subxt :: MetadataError :: IncompatibleMetadata . into ()) } } # [doc = "Set a new value for `MinimumUntrustedScore`."] # [doc = ""] # [doc = "Dispatch origin must be aligned with `T::ForceOrigin`."] # [doc = ""] # [doc = "This check can be turned off by setting the value to `None`."] pub fn set_minimum_untrusted_score (& self , maybe_next_score : :: core :: option :: Option < runtime_types :: sp_npos_elections :: ElectionScore > ,) -> Result < :: subxt :: SubmittableExtrinsic < 'a , T , X , SetMinimumUntrustedScore , DispatchError , root_mod :: Event > , :: subxt :: BasicError > { if self . client . metadata () . call_hash :: < SetMinimumUntrustedScore > () ? == [207u8 , 31u8 , 247u8 , 72u8 , 55u8 , 18u8 , 99u8 , 157u8 , 155u8 , 89u8 , 59u8 , 156u8 , 254u8 , 3u8 , 181u8 , 85u8 , 48u8 , 42u8 , 73u8 , 243u8 , 35u8 , 90u8 , 142u8 , 14u8 , 62u8 , 48u8 , 15u8 , 125u8 , 194u8 , 103u8 , 2u8 , 175u8 ,] { let call = SetMinimumUntrustedScore { maybe_next_score , } ; Ok (:: subxt :: SubmittableExtrinsic :: new (self . client , call)) } else { Err (:: subxt :: MetadataError :: IncompatibleMetadata . into ()) } } # [doc = "Set a solution in the queue, to be handed out to the client of this pallet in the next"] # [doc = "call to `ElectionProvider::elect`."] # [doc = ""] # [doc = "This can only be set by `T::ForceOrigin`, and only when the phase is `Emergency`."] # [doc = ""] # [doc = "The solution is not checked for any feasibility and is assumed to be trustworthy, as any"] # [doc = "feasibility check itself can in principle cause the election process to fail (due to"] # [doc = "memory/weight constrains)."] pub fn set_emergency_election_result (& self , supports : :: std :: vec :: Vec < (:: subxt :: sp_core :: crypto :: AccountId32 , runtime_types :: sp_npos_elections :: Support < :: subxt :: sp_core :: crypto :: AccountId32 > ,) > ,) -> Result < :: subxt :: SubmittableExtrinsic < 'a , T , X , SetEmergencyElectionResult , DispatchError , root_mod :: Event > , :: subxt :: BasicError > { if self . client . metadata () . call_hash :: < SetEmergencyElectionResult > () ? == [195u8 , 164u8 , 133u8 , 193u8 , 58u8 , 154u8 , 182u8 , 83u8 , 231u8 , 217u8 , 199u8 , 27u8 , 239u8 , 143u8 , 60u8 , 103u8 , 139u8 , 253u8 , 49u8 , 242u8 , 8u8 , 41u8 , 160u8 , 192u8 , 123u8 , 98u8 , 137u8 , 13u8 , 170u8 , 167u8 , 246u8 , 175u8 ,] { let call = SetEmergencyElectionResult { supports , } ; Ok (:: subxt :: SubmittableExtrinsic :: new (self . client , call)) } else { Err (:: subxt :: MetadataError :: IncompatibleMetadata . into ()) } } # [doc = "Submit a solution for the signed phase."] # [doc = ""] # [doc = "The dispatch origin fo this call must be __signed__."] # [doc = ""] # [doc = "The solution is potentially queued, based on the claimed score and processed at the end"] # [doc = "of the signed phase."] # [doc = ""] # [doc = "A deposit is reserved and recorded for the solution. Based on the outcome, the solution"] # [doc = "might be rewarded, slashed, or get all or a part of the deposit back."] pub fn submit (& self , raw_solution : runtime_types :: pallet_election_provider_multi_phase :: RawSolution < runtime_types :: egg_standalone_runtime :: NposSolution16 > ,) -> Result < :: subxt :: SubmittableExtrinsic < 'a , T , X , Submit , DispatchError , root_mod :: Event > , :: subxt :: BasicError > { if self . client . metadata () . call_hash :: < Submit > () ? == [2u8 , 131u8 , 162u8 , 38u8 , 102u8 , 73u8 , 144u8 , 71u8 , 200u8 , 229u8 , 140u8 , 38u8 , 58u8 , 159u8 , 59u8 , 167u8 , 91u8 , 169u8 , 22u8 , 228u8 , 127u8 , 153u8 , 125u8 , 241u8 , 60u8 , 61u8 , 103u8 , 192u8 , 95u8 , 87u8 , 81u8 , 73u8 ,] { let call = Submit { raw_solution : :: std :: boxed :: Box :: new (raw_solution) , } ; Ok (:: subxt :: SubmittableExtrinsic :: new (self . client , call)) } else { Err (:: subxt :: MetadataError :: IncompatibleMetadata . into ()) } } # [doc = "Trigger the governance fallback."] # [doc = ""] # [doc = "This can only be called when [`Phase::Emergency`] is enabled, as an alternative to"] # [doc = "calling [`Call::set_emergency_election_result`]."] pub fn governance_fallback (& self , maybe_max_voters : :: core :: option :: Option < :: core :: primitive :: u32 > , maybe_max_targets : :: core :: option :: Option < :: core :: primitive :: u32 > ,) -> Result < :: subxt :: SubmittableExtrinsic < 'a , T , X , GovernanceFallback , DispatchError , root_mod :: Event > , :: subxt :: BasicError > { if self . client . metadata () . call_hash :: < GovernanceFallback > () ? == [195u8 , 190u8 , 140u8 , 94u8 , 209u8 , 100u8 , 92u8 , 194u8 , 78u8 , 226u8 , 16u8 , 168u8 , 52u8 , 117u8 , 88u8 , 178u8 , 84u8 , 248u8 , 117u8 , 38u8 , 152u8 , 71u8 , 37u8 , 158u8 , 77u8 , 204u8 , 59u8 , 184u8 , 22u8 , 239u8 , 92u8 , 209u8 ,] { let call = GovernanceFallback { maybe_max_voters , maybe_max_targets , } ; Ok (:: subxt :: SubmittableExtrinsic :: new (self . client , call)) } else { Err (:: subxt :: MetadataError :: IncompatibleMetadata . into ()) } } } } pub type Event = runtime_types :: pallet_election_provider_multi_phase :: pallet :: Event ; pub mod events { use super :: runtime_types ; # [derive (:: subxt :: codec :: Decode , :: subxt :: codec :: Encode , Clone , Debug , Eq , PartialEq)] # [doc = "A solution was stored with the given compute."] # [doc = ""] # [doc = "If the solution is signed, this means that it hasn't yet been processed. If the"] # [doc = "solution is unsigned, this means that it has also been processed."] # [doc = ""] # [doc = "The `bool` is `true` when a previous solution was ejected to make room for this one."] pub struct SolutionStored { pub election_compute : runtime_types :: pallet_election_provider_multi_phase :: ElectionCompute , pub prev_ejected : :: core :: primitive :: bool , } impl :: subxt :: Event for SolutionStored { const PALLET : & 'static str = "ElectionProviderMultiPhase" ; const EVENT : & 'static str = "SolutionStored" ; } # [derive (:: subxt :: codec :: Decode , :: subxt :: codec :: Encode , Clone , Debug , Eq , PartialEq)] # [doc = "The election has been finalized, with `Some` of the given computation, or else if the"] # [doc = "election failed, `None`."] pub struct ElectionFinalized { pub election_compute : :: core :: option :: Option < runtime_types :: pallet_election_provider_multi_phase :: ElectionCompute > , } impl :: subxt :: Event for ElectionFinalized { const PALLET : & 'static str = "ElectionProviderMultiPhase" ; const EVENT : & 'static str = "ElectionFinalized" ; } # [derive (:: subxt :: codec :: Decode , :: subxt :: codec :: Encode , Clone , Debug , Eq , PartialEq)] # [doc = "An account has been rewarded for their signed submission being finalized."] pub struct Rewarded { pub account : :: subxt :: sp_core :: crypto :: AccountId32 , pub value : :: core :: primitive :: u128 , } impl :: subxt :: Event for Rewarded { const PALLET : & 'static str = "ElectionProviderMultiPhase" ; const EVENT : & 'static str = "Rewarded" ; } # [derive (:: subxt :: codec :: Decode , :: subxt :: codec :: Encode , Clone , Debug , Eq , PartialEq)] # [doc = "An account has been slashed for submitting an invalid signed submission."] pub struct Slashed { pub account : :: subxt :: sp_core :: crypto :: AccountId32 , pub value : :: core :: primitive :: u128 , } impl :: subxt :: Event for Slashed { const PALLET : & 'static str = "ElectionProviderMultiPhase" ; const EVENT : & 'static str = "Slashed" ; } # [derive (:: subxt :: codec :: CompactAs , :: subxt :: codec :: Decode , :: subxt :: codec :: Encode , Clone , Debug , Eq , PartialEq)] # [doc = "The signed phase of the given round has started."] pub struct SignedPhaseStarted { pub round : :: core :: primitive :: u32 , } impl :: subxt :: Event for SignedPhaseStarted { const PALLET : & 'static str = "ElectionProviderMultiPhase" ; const EVENT : & 'static str = "SignedPhaseStarted" ; } # [derive (:: subxt :: codec :: CompactAs , :: subxt :: codec :: Decode , :: subxt :: codec :: Encode , Clone , Debug , Eq , PartialEq)] # [doc = "The unsigned phase of the given round has started."] pub struct UnsignedPhaseStarted { pub round : :: core :: primitive :: u32 , } impl :: subxt :: Event for UnsignedPhaseStarted { const PALLET : & 'static str = "ElectionProviderMultiPhase" ; const EVENT : & 'static str = "UnsignedPhaseStarted" ; } } pub mod storage { use super :: runtime_types ; pub struct Round ; impl :: subxt :: StorageEntry for Round { const PALLET : & 'static str = "ElectionProviderMultiPhase" ; const STORAGE : & 'static str = "Round" ; type Value = :: core :: primitive :: u32 ; fn key (& self) -> :: subxt :: StorageEntryKey { :: subxt :: StorageEntryKey :: Plain } } pub struct CurrentPhase ; impl :: subxt :: StorageEntry for CurrentPhase { const PALLET : & 'static str = "ElectionProviderMultiPhase" ; const STORAGE : & 'static str = "CurrentPhase" ; type Value = runtime_types :: pallet_election_provider_multi_phase :: Phase < :: core :: primitive :: u32 > ; fn key (& self) -> :: subxt :: StorageEntryKey { :: subxt :: StorageEntryKey :: Plain } } pub struct QueuedSolution ; impl :: subxt :: StorageEntry for QueuedSolution { const PALLET : & 'static str = "ElectionProviderMultiPhase" ; const STORAGE : & 'static str = "QueuedSolution" ; type Value = runtime_types :: pallet_election_provider_multi_phase :: ReadySolution < :: subxt :: sp_core :: crypto :: AccountId32 > ; fn key (& self) -> :: subxt :: StorageEntryKey { :: subxt :: StorageEntryKey :: Plain } } pub struct Snapshot ; impl :: subxt :: StorageEntry for Snapshot { const PALLET : & 'static str = "ElectionProviderMultiPhase" ; const STORAGE : & 'static str = "Snapshot" ; type Value = runtime_types :: pallet_election_provider_multi_phase :: RoundSnapshot ; fn key (& self) -> :: subxt :: StorageEntryKey { :: subxt :: StorageEntryKey :: Plain } } pub struct DesiredTargets ; impl :: subxt :: StorageEntry for DesiredTargets { const PALLET : & 'static str = "ElectionProviderMultiPhase" ; const STORAGE : & 'static str = "DesiredTargets" ; type Value = :: core :: primitive :: u32 ; fn key (& self) -> :: subxt :: StorageEntryKey { :: subxt :: StorageEntryKey :: Plain } } pub struct SnapshotMetadata ; impl :: subxt :: StorageEntry for SnapshotMetadata { const PALLET : & 'static str = "ElectionProviderMultiPhase" ; const STORAGE : & 'static str = "SnapshotMetadata" ; type Value = runtime_types :: pallet_election_provider_multi_phase :: SolutionOrSnapshotSize ; fn key (& self) -> :: subxt :: StorageEntryKey { :: subxt :: StorageEntryKey :: Plain } } pub struct SignedSubmissionNextIndex ; impl :: subxt :: StorageEntry for SignedSubmissionNextIndex { const PALLET : & 'static str = "ElectionProviderMultiPhase" ; const STORAGE : & 'static str = "SignedSubmissionNextIndex" ; type Value = :: core :: primitive :: u32 ; fn key (& self) -> :: subxt :: StorageEntryKey { :: subxt :: StorageEntryKey :: Plain } } pub struct SignedSubmissionIndices ; impl :: subxt :: StorageEntry for SignedSubmissionIndices { const PALLET : & 'static str = "ElectionProviderMultiPhase" ; const STORAGE : & 'static str = "SignedSubmissionIndices" ; type Value = runtime_types :: sp_runtime :: bounded :: bounded_btree_map :: BoundedBTreeMap < runtime_types :: sp_npos_elections :: ElectionScore , :: core :: primitive :: u32 > ; fn key (& self) -> :: subxt :: StorageEntryKey { :: subxt :: StorageEntryKey :: Plain } } pub struct SignedSubmissionsMap < 'a > (pub & 'a :: core :: primitive :: u32) ; impl :: subxt :: StorageEntry for SignedSubmissionsMap < '_ > { const PALLET : & 'static str = "ElectionProviderMultiPhase" ; const STORAGE : & 'static str = "SignedSubmissionsMap" ; type Value = runtime_types :: pallet_election_provider_multi_phase :: signed :: SignedSubmission < :: subxt :: sp_core :: crypto :: AccountId32 , :: core :: primitive :: u128 , runtime_types :: egg_standalone_runtime :: NposSolution16 > ; fn key (& self) -> :: subxt :: StorageEntryKey { :: subxt :: StorageEntryKey :: Map (vec ! [:: subxt :: StorageMapKey :: new (& self . 0 , :: subxt :: StorageHasher :: Twox64Concat)]) } } pub struct MinimumUntrustedScore ; impl :: subxt :: StorageEntry for MinimumUntrustedScore { const PALLET : & 'static str = "ElectionProviderMultiPhase" ; const STORAGE : & 'static str = "MinimumUntrustedScore" ; type Value = runtime_types :: sp_npos_elections :: ElectionScore ; fn key (& self) -> :: subxt :: StorageEntryKey { :: subxt :: StorageEntryKey :: Plain } } pub struct StorageApi < 'a , T : :: subxt :: Config > { client : & 'a :: subxt :: Client < T > , } impl < 'a , T : :: subxt :: Config > StorageApi < 'a , T > { pub fn new (client : & 'a :: subxt :: Client < T >) -> Self { Self { client } } # [doc = " Internal counter for the number of rounds."] # [doc = ""] # [doc = " This is useful for de-duplication of transactions submitted to the pool, and general"] # [doc = " diagnostics of the pallet."] # [doc = ""] # [doc = " This is merely incremented once per every time that an upstream `elect` is called."] pub async fn round (& self , block_hash : :: core :: option :: Option < T :: Hash > ,) -> :: core :: result :: Result < :: core :: primitive :: u32 , :: subxt :: BasicError > { if self . client . metadata () . storage_hash :: < Round > () ? == [16u8 , 49u8 , 176u8 , 52u8 , 202u8 , 111u8 , 120u8 , 8u8 , 217u8 , 96u8 , 35u8 , 14u8 , 233u8 , 130u8 , 47u8 , 98u8 , 34u8 , 44u8 , 166u8 , 188u8 , 199u8 , 210u8 , 21u8 , 19u8 , 70u8 , 96u8 , 139u8 , 8u8 , 53u8 , 82u8 , 165u8 , 239u8 ,] { let entry = Round ; self . client . storage () . fetch_or_default (& entry , block_hash) . await } else { Err (:: subxt :: MetadataError :: IncompatibleMetadata . into ()) } } # [doc = " Current phase."] pub async fn current_phase (& self , block_hash : :: core :: option :: Option < T :: Hash > ,) -> :: core :: result :: Result < runtime_types :: pallet_election_provider_multi_phase :: Phase < :: core :: primitive :: u32 > , :: subxt :: BasicError > { if self . client . metadata () . storage_hash :: < CurrentPhase > () ? == [162u8 , 177u8 , 133u8 , 63u8 , 175u8 , 78u8 , 85u8 , 0u8 , 233u8 , 84u8 , 10u8 , 250u8 , 190u8 , 39u8 , 101u8 , 11u8 , 52u8 , 31u8 , 129u8 , 151u8 , 63u8 , 179u8 , 120u8 , 28u8 , 70u8 , 61u8 , 91u8 , 153u8 , 95u8 , 32u8 , 33u8 , 157u8 ,] { let entry = CurrentPhase ; self . client . storage () . fetch_or_default (& entry , block_hash) . await } else { Err (:: subxt :: MetadataError :: IncompatibleMetadata . into ()) } } # [doc = " Current best solution, signed or unsigned, queued to be returned upon `elect`."] pub async fn queued_solution (& self , block_hash : :: core :: option :: Option < T :: Hash > ,) -> :: core :: result :: Result < :: core :: option :: Option < runtime_types :: pallet_election_provider_multi_phase :: ReadySolution < :: subxt :: sp_core :: crypto :: AccountId32 > > , :: subxt :: BasicError > { if self . client . metadata () . storage_hash :: < QueuedSolution > () ? == [145u8 , 177u8 , 147u8 , 52u8 , 30u8 , 135u8 , 33u8 , 145u8 , 204u8 , 82u8 , 1u8 , 165u8 , 208u8 , 39u8 , 181u8 , 2u8 , 96u8 , 236u8 , 19u8 , 144u8 , 87u8 , 197u8 , 25u8 , 164u8 , 116u8 , 0u8 , 120u8 , 245u8 , 154u8 , 30u8 , 191u8 , 155u8 ,] { let entry = QueuedSolution ; self . client . storage () . fetch (& entry , block_hash) . await } else { Err (:: subxt :: MetadataError :: IncompatibleMetadata . into ()) } } # [doc = " Snapshot data of the round."] # [doc = ""] # [doc = " This is created at the beginning of the signed phase and cleared upon calling `elect`."] pub async fn snapshot (& self , block_hash : :: core :: option :: Option < T :: Hash > ,) -> :: core :: result :: Result < :: core :: option :: Option < runtime_types :: pallet_election_provider_multi_phase :: RoundSnapshot > , :: subxt :: BasicError > { if self . client . metadata () . storage_hash :: < Snapshot > () ? == [28u8 , 163u8 , 105u8 , 94u8 , 66u8 , 226u8 , 134u8 , 29u8 , 210u8 , 211u8 , 182u8 , 236u8 , 180u8 , 109u8 , 203u8 , 44u8 , 1u8 , 50u8 , 112u8 , 201u8 , 200u8 , 12u8 , 88u8 , 248u8 , 253u8 , 182u8 , 56u8 , 156u8 , 169u8 , 179u8 , 19u8 , 161u8 ,] { let entry = Snapshot ; self . client . storage () . fetch (& entry , block_hash) . await } else { Err (:: subxt :: MetadataError :: IncompatibleMetadata . into ()) } } # [doc = " Desired number of targets to elect for this round."] # [doc = ""] # [doc = " Only exists when [`Snapshot`] is present."] pub async fn desired_targets (& self , block_hash : :: core :: option :: Option < T :: Hash > ,) -> :: core :: result :: Result < :: core :: option :: Option < :: core :: primitive :: u32 > , :: subxt :: BasicError > { if self . client . metadata () . storage_hash :: < DesiredTargets > () ? == [16u8 , 247u8 , 4u8 , 181u8 , 93u8 , 79u8 , 12u8 , 212u8 , 146u8 , 167u8 , 80u8 , 58u8 , 118u8 , 52u8 , 68u8 , 87u8 , 90u8 , 140u8 , 31u8 , 210u8 , 2u8 , 116u8 , 220u8 , 231u8 , 115u8 , 112u8 , 118u8 , 118u8 , 68u8 , 34u8 , 151u8 , 165u8 ,] { let entry = DesiredTargets ; self . client . storage () . fetch (& entry , block_hash) . await } else { Err (:: subxt :: MetadataError :: IncompatibleMetadata . into ()) } } # [doc = " The metadata of the [`RoundSnapshot`]"] # [doc = ""] # [doc = " Only exists when [`Snapshot`] is present."] pub async fn snapshot_metadata (& self , block_hash : :: core :: option :: Option < T :: Hash > ,) -> :: core :: result :: Result < :: core :: option :: Option < runtime_types :: pallet_election_provider_multi_phase :: SolutionOrSnapshotSize > , :: subxt :: BasicError > { if self . client . metadata () . storage_hash :: < SnapshotMetadata > () ? == [240u8 , 57u8 , 126u8 , 76u8 , 84u8 , 244u8 , 120u8 , 136u8 , 164u8 , 49u8 , 185u8 , 89u8 , 126u8 , 18u8 , 117u8 , 235u8 , 33u8 , 226u8 , 173u8 , 254u8 , 79u8 , 194u8 , 154u8 , 123u8 , 29u8 , 237u8 , 116u8 , 185u8 , 36u8 , 248u8 , 46u8 , 103u8 ,] { let entry = SnapshotMetadata ; self . client . storage () . fetch (& entry , block_hash) . await } else { Err (:: subxt :: MetadataError :: IncompatibleMetadata . into ()) } } # [doc = " The next index to be assigned to an incoming signed submission."] # [doc = ""] # [doc = " Every accepted submission is assigned a unique index; that index is bound to that particular"] # [doc = " submission for the duration of the election. On election finalization, the next index is"] # [doc = " reset to 0."] # [doc = ""] # [doc = " We can't just use `SignedSubmissionIndices.len()`, because that's a bounded set; past its"] # [doc = " capacity, it will simply saturate. We can't just iterate over `SignedSubmissionsMap`,"] # [doc = " because iteration is slow. Instead, we store the value here."] pub async fn signed_submission_next_index (& self , block_hash : :: core :: option :: Option < T :: Hash > ,) -> :: core :: result :: Result < :: core :: primitive :: u32 , :: subxt :: BasicError > { if self . client . metadata () . storage_hash :: < SignedSubmissionNextIndex > () ? == [242u8 , 11u8 , 157u8 , 105u8 , 96u8 , 7u8 , 31u8 , 20u8 , 51u8 , 141u8 , 182u8 , 180u8 , 13u8 , 172u8 , 155u8 , 59u8 , 42u8 , 238u8 , 115u8 , 8u8 , 6u8 , 137u8 , 45u8 , 2u8 , 123u8 , 187u8 , 53u8 , 215u8 , 19u8 , 129u8 , 54u8 , 22u8 ,] { let entry = SignedSubmissionNextIndex ; self . client . storage () . fetch_or_default (& entry , block_hash) . await } else { Err (:: subxt :: MetadataError :: IncompatibleMetadata . into ()) } } # [doc = " A sorted, bounded set of `(score, index)`, where each `index` points to a value in"] # [doc = " `SignedSubmissions`."] # [doc = ""] # [doc = " We never need to process more than a single signed submission at a time. Signed submissions"] # [doc = " can be quite large, so we're willing to pay the cost of multiple database accesses to access"] # [doc = " them one at a time instead of reading and decoding all of them at once."] pub async fn signed_submission_indices (& self , block_hash : :: core :: option :: Option < T :: Hash > ,) -> :: core :: result :: Result < runtime_types :: sp_runtime :: bounded :: bounded_btree_map :: BoundedBTreeMap < runtime_types :: sp_npos_elections :: ElectionScore , :: core :: primitive :: u32 > , :: subxt :: BasicError > { if self . client . metadata () . storage_hash :: < SignedSubmissionIndices > () ? == [191u8 , 143u8 , 241u8 , 251u8 , 74u8 , 9u8 , 145u8 , 136u8 , 135u8 , 76u8 , 182u8 , 85u8 , 140u8 , 252u8 , 58u8 , 183u8 , 217u8 , 121u8 , 213u8 , 200u8 , 167u8 , 89u8 , 15u8 , 212u8 , 62u8 , 90u8 , 192u8 , 214u8 , 130u8 , 196u8 , 14u8 , 175u8 ,] { let entry = SignedSubmissionIndices ; self . client . storage () . fetch_or_default (& entry , block_hash) . await } else { Err (:: subxt :: MetadataError :: IncompatibleMetadata . into ()) } } # [doc = " Unchecked, signed solutions."] # [doc = ""] # [doc = " Together with `SubmissionIndices`, this stores a bounded set of `SignedSubmissions` while"] # [doc = " allowing us to keep only a single one in memory at a time."] # [doc = ""] # [doc = " Twox note: the key of the map is an auto-incrementing index which users cannot inspect or"] # [doc = " affect; we shouldn't need a cryptographically secure hasher."] pub async fn signed_submissions_map (& self , _0 : & :: core :: primitive :: u32 , block_hash : :: core :: option :: Option < T :: Hash > ,) -> :: core :: result :: Result < :: core :: option :: Option < runtime_types :: pallet_election_provider_multi_phase :: signed :: SignedSubmission < :: subxt :: sp_core :: crypto :: AccountId32 , :: core :: primitive :: u128 , runtime_types :: egg_standalone_runtime :: NposSolution16 > > , :: subxt :: BasicError > { if self . client . metadata () . storage_hash :: < SignedSubmissionsMap > () ? == [75u8 , 2u8 , 76u8 , 74u8 , 73u8 , 167u8 , 243u8 , 1u8 , 31u8 , 26u8 , 48u8 , 196u8 , 177u8 , 21u8 , 233u8 , 66u8 , 251u8 , 11u8 , 11u8 , 252u8 , 63u8 , 206u8 , 115u8 , 116u8 , 73u8 , 232u8 , 241u8 , 179u8 , 249u8 , 34u8 , 61u8 , 171u8 ,] { let entry = SignedSubmissionsMap (_0) ; self . client . storage () . fetch (& entry , block_hash) . await } else { Err (:: subxt :: MetadataError :: IncompatibleMetadata . into ()) } } # [doc = " Unchecked, signed solutions."] # [doc = ""] # [doc = " Together with `SubmissionIndices`, this stores a bounded set of `SignedSubmissions` while"] # [doc = " allowing us to keep only a single one in memory at a time."] # [doc = ""] # [doc = " Twox note: the key of the map is an auto-incrementing index which users cannot inspect or"] # [doc = " affect; we shouldn't need a cryptographically secure hasher."] pub async fn signed_submissions_map_iter (& self , block_hash : :: core :: option :: Option < T :: Hash > ,) -> :: core :: result :: Result < :: subxt :: KeyIter < 'a , T , SignedSubmissionsMap < 'a > > , :: subxt :: BasicError > { if self . client . metadata () . storage_hash :: < SignedSubmissionsMap > () ? == [75u8 , 2u8 , 76u8 , 74u8 , 73u8 , 167u8 , 243u8 , 1u8 , 31u8 , 26u8 , 48u8 , 196u8 , 177u8 , 21u8 , 233u8 , 66u8 , 251u8 , 11u8 , 11u8 , 252u8 , 63u8 , 206u8 , 115u8 , 116u8 , 73u8 , 232u8 , 241u8 , 179u8 , 249u8 , 34u8 , 61u8 , 171u8 ,] { self . client . storage () . iter (block_hash) . await } else { Err (:: subxt :: MetadataError :: IncompatibleMetadata . into ()) } } # [doc = " The minimum score that each 'untrusted' solution must attain in order to be considered"] # [doc = " feasible."] # [doc = ""] # [doc = " Can be set via `set_minimum_untrusted_score`."] pub async fn minimum_untrusted_score (& self , block_hash : :: core :: option :: Option < T :: Hash > ,) -> :: core :: result :: Result < :: core :: option :: Option < runtime_types :: sp_npos_elections :: ElectionScore > , :: subxt :: BasicError > { if self . client . metadata () . storage_hash :: < MinimumUntrustedScore > () ? == [18u8 , 171u8 , 56u8 , 63u8 , 7u8 , 1u8 , 53u8 , 42u8 , 72u8 , 35u8 , 26u8 , 124u8 , 223u8 , 95u8 , 170u8 , 176u8 , 134u8 , 140u8 , 66u8 , 115u8 , 51u8 , 163u8 , 202u8 , 82u8 , 189u8 , 180u8 , 139u8 , 98u8 , 18u8 , 14u8 , 176u8 , 66u8 ,] { let entry = MinimumUntrustedScore ; self . client . storage () . fetch (& entry , block_hash) . await } else { Err (:: subxt :: MetadataError :: IncompatibleMetadata . into ()) } } } } pub mod constants { use super :: runtime_types ; pub struct ConstantsApi < 'a , T : :: subxt :: Config > { client : & 'a :: subxt :: Client < T > , } impl < 'a , T : :: subxt :: Config > ConstantsApi < 'a , T > { pub fn new (client : & 'a :: subxt :: Client < T >) -> Self { Self { client } } # [doc = " Duration of the unsigned phase."] pub fn unsigned_phase (& self) -> :: core :: result :: Result < :: core :: primitive :: u32 , :: subxt :: BasicError > { if self . client . metadata () . constant_hash ("ElectionProviderMultiPhase" , "UnsignedPhase") ? == [55u8 , 252u8 , 91u8 , 225u8 , 80u8 , 22u8 , 146u8 , 101u8 , 153u8 , 64u8 , 167u8 , 24u8 , 73u8 , 138u8 , 72u8 , 182u8 , 136u8 , 154u8 , 214u8 , 177u8 , 139u8 , 190u8 , 193u8 , 28u8 , 71u8 , 134u8 , 114u8 , 228u8 , 96u8 , 238u8 , 157u8 , 107u8 ,] { let pallet = self . client . metadata () . pallet ("ElectionProviderMultiPhase") ? ; let constant = pallet . constant ("UnsignedPhase") ? ; let value = :: subxt :: codec :: Decode :: decode (& mut & constant . value [..]) ? ; Ok (value) } else { Err (:: subxt :: MetadataError :: IncompatibleMetadata . into ()) } } # [doc = " Duration of the signed phase."] pub fn signed_phase (& self) -> :: core :: result :: Result < :: core :: primitive :: u32 , :: subxt :: BasicError > { if self . client . metadata () . constant_hash ("ElectionProviderMultiPhase" , "SignedPhase") ? == [244u8 , 201u8 , 13u8 , 15u8 , 42u8 , 112u8 , 171u8 , 164u8 , 218u8 , 245u8 , 176u8 , 90u8 , 157u8 , 254u8 , 152u8 , 249u8 , 74u8 , 37u8 , 99u8 , 250u8 , 26u8 , 181u8 , 41u8 , 69u8 , 75u8 , 40u8 , 103u8 , 51u8 , 189u8 , 115u8 , 20u8 , 125u8 ,] { let pallet = self . client . metadata () . pallet ("ElectionProviderMultiPhase") ? ; let constant = pallet . constant ("SignedPhase") ? ; let value = :: subxt :: codec :: Decode :: decode (& mut & constant . value [..]) ? ; Ok (value) } else { Err (:: subxt :: MetadataError :: IncompatibleMetadata . into ()) } } # [doc = " The minimum amount of improvement to the solution score that defines a solution as"] # [doc = " \"better\" in the Signed phase."] pub fn better_signed_threshold (& self) -> :: core :: result :: Result < runtime_types :: sp_arithmetic :: per_things :: Perbill , :: subxt :: BasicError > { if self . client . metadata () . constant_hash ("ElectionProviderMultiPhase" , "BetterSignedThreshold") ? == [77u8 , 124u8 , 224u8 , 100u8 , 113u8 , 25u8 , 159u8 , 166u8 , 136u8 , 195u8 , 84u8 , 168u8 , 142u8 , 209u8 , 89u8 , 249u8 , 7u8 , 218u8 , 51u8 , 240u8 , 211u8 , 135u8 , 183u8 , 192u8 , 194u8 , 195u8 , 107u8 , 37u8 , 23u8 , 191u8 , 254u8 , 185u8 ,] { let pallet = self . client . metadata () . pallet ("ElectionProviderMultiPhase") ? ; let constant = pallet . constant ("BetterSignedThreshold") ? ; let value = :: subxt :: codec :: Decode :: decode (& mut & constant . value [..]) ? ; Ok (value) } else { Err (:: subxt :: MetadataError :: IncompatibleMetadata . into ()) } } # [doc = " The minimum amount of improvement to the solution score that defines a solution as"] # [doc = " \"better\" in the Unsigned phase."] pub fn better_unsigned_threshold (& self) -> :: core :: result :: Result < runtime_types :: sp_arithmetic :: per_things :: Perbill , :: subxt :: BasicError > { if self . client . metadata () . constant_hash ("ElectionProviderMultiPhase" , "BetterUnsignedThreshold") ? == [93u8 , 84u8 , 240u8 , 225u8 , 208u8 , 133u8 , 114u8 , 15u8 , 241u8 , 94u8 , 244u8 , 112u8 , 32u8 , 48u8 , 250u8 , 94u8 , 33u8 , 111u8 , 118u8 , 81u8 , 20u8 , 158u8 , 17u8 , 58u8 , 83u8 , 138u8 , 61u8 , 158u8 , 244u8 , 27u8 , 152u8 , 179u8 ,] { let pallet = self . client . metadata () . pallet ("ElectionProviderMultiPhase") ? ; let constant = pallet . constant ("BetterUnsignedThreshold") ? ; let value = :: subxt :: codec :: Decode :: decode (& mut & constant . value [..]) ? ; Ok (value) } else { Err (:: subxt :: MetadataError :: IncompatibleMetadata . into ()) } } # [doc = " The repeat threshold of the offchain worker."] # [doc = ""] # [doc = " For example, if it is 5, that means that at least 5 blocks will elapse between attempts"] # [doc = " to submit the worker's solution."] pub fn offchain_repeat (& self) -> :: core :: result :: Result < :: core :: primitive :: u32 , :: subxt :: BasicError > { if self . client . metadata () . constant_hash ("ElectionProviderMultiPhase" , "OffchainRepeat") ? == [198u8 , 126u8 , 79u8 , 166u8 , 112u8 , 27u8 , 163u8 , 219u8 , 1u8 , 137u8 , 210u8 , 16u8 , 193u8 , 225u8 , 76u8 , 219u8 , 59u8 , 101u8 , 224u8 , 90u8 , 27u8 , 177u8 , 194u8 , 232u8 , 208u8 , 85u8 , 113u8 , 199u8 , 80u8 , 108u8 , 187u8 , 35u8 ,] { let pallet = self . client . metadata () . pallet ("ElectionProviderMultiPhase") ? ; let constant = pallet . constant ("OffchainRepeat") ? ; let value = :: subxt :: codec :: Decode :: decode (& mut & constant . value [..]) ? ; Ok (value) } else { Err (:: subxt :: MetadataError :: IncompatibleMetadata . into ()) } } # [doc = " The priority of the unsigned transaction submitted in the unsigned-phase"] pub fn miner_tx_priority (& self) -> :: core :: result :: Result < :: core :: primitive :: u64 , :: subxt :: BasicError > { if self . client . metadata () . constant_hash ("ElectionProviderMultiPhase" , "MinerTxPriority") ? == [15u8 , 81u8 , 149u8 , 184u8 , 36u8 , 21u8 , 64u8 , 25u8 , 116u8 , 128u8 , 74u8 , 24u8 , 36u8 , 191u8 , 9u8 , 133u8 , 85u8 , 75u8 , 248u8 , 53u8 , 94u8 , 15u8 , 249u8 , 145u8 , 147u8 , 82u8 , 255u8 , 125u8 , 79u8 , 182u8 , 143u8 , 27u8 ,] { let pallet = self . client . metadata () . pallet ("ElectionProviderMultiPhase") ? ; let constant = pallet . constant ("MinerTxPriority") ? ; let value = :: subxt :: codec :: Decode :: decode (& mut & constant . value [..]) ? ; Ok (value) } else { Err (:: subxt :: MetadataError :: IncompatibleMetadata . into ()) } } # [doc = " Maximum number of signed submissions that can be queued."] # [doc = ""] # [doc = " It is best to avoid adjusting this during an election, as it impacts downstream data"] # [doc = " structures. In particular, `SignedSubmissionIndices<T>` is bounded on this value. If you"] # [doc = " update this value during an election, you _must_ ensure that"] # [doc = " `SignedSubmissionIndices.len()` is less than or equal to the new value. Otherwise,"] # [doc = " attempts to submit new solutions may cause a runtime panic."] pub fn signed_max_submissions (& self) -> :: core :: result :: Result < :: core :: primitive :: u32 , :: subxt :: BasicError > { if self . client . metadata () . constant_hash ("ElectionProviderMultiPhase" , "SignedMaxSubmissions") ? == [243u8 , 243u8 , 18u8 , 226u8 , 191u8 , 223u8 , 139u8 , 24u8 , 207u8 , 71u8 , 5u8 , 168u8 , 161u8 , 144u8 , 132u8 , 124u8 , 250u8 , 233u8 , 3u8 , 162u8 , 88u8 , 208u8 , 186u8 , 52u8 , 254u8 , 94u8 , 60u8 , 143u8 , 65u8 , 195u8 , 33u8 , 150u8 ,] { let pallet = self . client . metadata () . pallet ("ElectionProviderMultiPhase") ? ; let constant = pallet . constant ("SignedMaxSubmissions") ? ; let value = :: subxt :: codec :: Decode :: decode (& mut & constant . value [..]) ? ; Ok (value) } else { Err (:: subxt :: MetadataError :: IncompatibleMetadata . into ()) } } # [doc = " Maximum weight of a signed solution."] # [doc = ""] # [doc = " If [`Config::MinerConfig`] is being implemented to submit signed solutions (outside of"] # [doc = " this pallet), then [`MinerConfig::solution_weight`] is used to compare against"] # [doc = " this value."] pub fn signed_max_weight (& self) -> :: core :: result :: Result < :: core :: primitive :: u64 , :: subxt :: BasicError > { if self . client . metadata () . constant_hash ("ElectionProviderMultiPhase" , "SignedMaxWeight") ? == [142u8 , 59u8 , 200u8 , 235u8 , 172u8 , 60u8 , 10u8 , 250u8 , 77u8 , 96u8 , 166u8 , 205u8 , 181u8 , 164u8 , 220u8 , 20u8 , 135u8 , 1u8 , 23u8 , 208u8 , 182u8 , 63u8 , 139u8 , 16u8 , 23u8 , 50u8 , 185u8 , 150u8 , 179u8 , 39u8 , 207u8 , 17u8 ,] { let pallet = self . client . metadata () . pallet ("ElectionProviderMultiPhase") ? ; let constant = pallet . constant ("SignedMaxWeight") ? ; let value = :: subxt :: codec :: Decode :: decode (& mut & constant . value [..]) ? ; Ok (value) } else { Err (:: subxt :: MetadataError :: IncompatibleMetadata . into ()) } } # [doc = " The maximum amount of unchecked solutions to refund the call fee for."] pub fn signed_max_refunds (& self) -> :: core :: result :: Result < :: core :: primitive :: u32 , :: subxt :: BasicError > { if self . client . metadata () . constant_hash ("ElectionProviderMultiPhase" , "SignedMaxRefunds") ? == [48u8 , 253u8 , 71u8 , 149u8 , 154u8 , 26u8 , 213u8 , 153u8 , 196u8 , 209u8 , 17u8 , 184u8 , 45u8 , 227u8 , 114u8 , 209u8 , 200u8 , 2u8 , 53u8 , 141u8 , 193u8 , 245u8 , 103u8 , 254u8 , 167u8 , 145u8 , 125u8 , 163u8 , 156u8 , 221u8 , 129u8 , 188u8 ,] { let pallet = self . client . metadata () . pallet ("ElectionProviderMultiPhase") ? ; let constant = pallet . constant ("SignedMaxRefunds") ? ; let value = :: subxt :: codec :: Decode :: decode (& mut & constant . value [..]) ? ; Ok (value) } else { Err (:: subxt :: MetadataError :: IncompatibleMetadata . into ()) } } # [doc = " Base reward for a signed solution"] pub fn signed_reward_base (& self) -> :: core :: result :: Result < :: core :: primitive :: u128 , :: subxt :: BasicError > { if self . client . metadata () . constant_hash ("ElectionProviderMultiPhase" , "SignedRewardBase") ? == [75u8 , 6u8 , 220u8 , 82u8 , 254u8 , 68u8 , 121u8 , 240u8 , 254u8 , 11u8 , 94u8 , 125u8 , 209u8 , 65u8 , 179u8 , 73u8 , 144u8 , 153u8 , 20u8 , 114u8 , 77u8 , 254u8 , 191u8 , 165u8 , 207u8 , 97u8 , 79u8 , 55u8 , 170u8 , 200u8 , 52u8 , 117u8 ,] { let pallet = self . client . metadata () . pallet ("ElectionProviderMultiPhase") ? ; let constant = pallet . constant ("SignedRewardBase") ? ; let value = :: subxt :: codec :: Decode :: decode (& mut & constant . value [..]) ? ; Ok (value) } else { Err (:: subxt :: MetadataError :: IncompatibleMetadata . into ()) } } # [doc = " Base deposit for a signed solution."] pub fn signed_deposit_base (& self) -> :: core :: result :: Result < :: core :: primitive :: u128 , :: subxt :: BasicError > { if self . client . metadata () . constant_hash ("ElectionProviderMultiPhase" , "SignedDepositBase") ? == [20u8 , 67u8 , 105u8 , 212u8 , 233u8 , 123u8 , 27u8 , 231u8 , 41u8 , 179u8 , 93u8 , 75u8 , 96u8 , 162u8 , 46u8 , 247u8 , 166u8 , 64u8 , 110u8 , 15u8 , 111u8 , 207u8 , 91u8 , 51u8 , 119u8 , 85u8 , 235u8 , 209u8 , 21u8 , 67u8 , 111u8 , 59u8 ,] { let pallet = self . client . metadata () . pallet ("ElectionProviderMultiPhase") ? ; let constant = pallet . constant ("SignedDepositBase") ? ; let value = :: subxt :: codec :: Decode :: decode (& mut & constant . value [..]) ? ; Ok (value) } else { Err (:: subxt :: MetadataError :: IncompatibleMetadata . into ()) } } # [doc = " Per-byte deposit for a signed solution."] pub fn signed_deposit_byte (& self) -> :: core :: result :: Result < :: core :: primitive :: u128 , :: subxt :: BasicError > { if self . client . metadata () . constant_hash ("ElectionProviderMultiPhase" , "SignedDepositByte") ? == [120u8 , 24u8 , 20u8 , 203u8 , 10u8 , 199u8 , 252u8 , 85u8 , 25u8 , 113u8 , 107u8 , 165u8 , 207u8 , 220u8 , 255u8 , 176u8 , 53u8 , 197u8 , 150u8 , 251u8 , 191u8 , 250u8 , 154u8 , 103u8 , 39u8 , 6u8 , 62u8 , 129u8 , 188u8 , 188u8 , 110u8 , 35u8 ,] { let pallet = self . client . metadata () . pallet ("ElectionProviderMultiPhase") ? ; let constant = pallet . constant ("SignedDepositByte") ? ; let value = :: subxt :: codec :: Decode :: decode (& mut & constant . value [..]) ? ; Ok (value) } else { Err (:: subxt :: MetadataError :: IncompatibleMetadata . into ()) } } # [doc = " Per-weight deposit for a signed solution."] pub fn signed_deposit_weight (& self) -> :: core :: result :: Result < :: core :: primitive :: u128 , :: subxt :: BasicError > { if self . client . metadata () . constant_hash ("ElectionProviderMultiPhase" , "SignedDepositWeight") ? == [229u8 , 168u8 , 140u8 , 127u8 , 138u8 , 107u8 , 171u8 , 116u8 , 171u8 , 63u8 , 205u8 , 84u8 , 202u8 , 17u8 , 134u8 , 171u8 , 204u8 , 31u8 , 54u8 , 43u8 , 138u8 , 50u8 , 55u8 , 112u8 , 27u8 , 103u8 , 183u8 , 209u8 , 167u8 , 214u8 , 19u8 , 95u8 ,] { let pallet = self . client . metadata () . pallet ("ElectionProviderMultiPhase") ? ; let constant = pallet . constant ("SignedDepositWeight") ? ; let value = :: subxt :: codec :: Decode :: decode (& mut & constant . value [..]) ? ; Ok (value) } else { Err (:: subxt :: MetadataError :: IncompatibleMetadata . into ()) } } # [doc = " The maximum number of electing voters to put in the snapshot. At the moment, snapshots"] # [doc = " are only over a single block, but once multi-block elections are introduced they will"] # [doc = " take place over multiple blocks."] pub fn max_electing_voters (& self) -> :: core :: result :: Result < :: core :: primitive :: u32 , :: subxt :: BasicError > { if self . client . metadata () . constant_hash ("ElectionProviderMultiPhase" , "MaxElectingVoters") ? == [227u8 , 41u8 , 243u8 , 127u8 , 233u8 , 219u8 , 66u8 , 95u8 , 237u8 , 28u8 , 1u8 , 45u8 , 249u8 , 33u8 , 208u8 , 194u8 , 63u8 , 165u8 , 162u8 , 100u8 , 129u8 , 111u8 , 236u8 , 229u8 , 72u8 , 166u8 , 39u8 , 173u8 , 86u8 , 81u8 , 39u8 , 160u8 ,] { let pallet = self . client . metadata () . pallet ("ElectionProviderMultiPhase") ? ; let constant = pallet . constant ("MaxElectingVoters") ? ; let value = :: subxt :: codec :: Decode :: decode (& mut & constant . value [..]) ? ; Ok (value) } else { Err (:: subxt :: MetadataError :: IncompatibleMetadata . into ()) } } # [doc = " The maximum number of electable targets to put in the snapshot."] pub fn max_electable_targets (& self) -> :: core :: result :: Result < :: core :: primitive :: u16 , :: subxt :: BasicError > { if self . client . metadata () . constant_hash ("ElectionProviderMultiPhase" , "MaxElectableTargets") ? == [71u8 , 15u8 , 36u8 , 77u8 , 111u8 , 52u8 , 73u8 , 94u8 , 27u8 , 213u8 , 122u8 , 58u8 , 126u8 , 157u8 , 17u8 , 238u8 , 168u8 , 174u8 , 0u8 , 94u8 , 15u8 , 86u8 , 206u8 , 115u8 , 222u8 , 234u8 , 25u8 , 195u8 , 107u8 , 138u8 , 213u8 , 39u8 ,] { let pallet = self . client . metadata () . pallet ("ElectionProviderMultiPhase") ? ; let constant = pallet . constant ("MaxElectableTargets") ? ; let value = :: subxt :: codec :: Decode :: decode (& mut & constant . value [..]) ? ; Ok (value) } else { Err (:: subxt :: MetadataError :: IncompatibleMetadata . into ()) } } } } } pub mod staking { use super :: root_mod ; use super :: runtime_types ; pub mod calls { use super :: root_mod ; use super :: runtime_types ; type DispatchError = runtime_types :: sp_runtime :: DispatchError ; # [derive (:: subxt :: codec :: Decode , :: subxt :: codec :: Encode , Clone , Debug , Eq , PartialEq)] pub struct Bond { pub controller : :: subxt :: sp_runtime :: MultiAddress < :: subxt :: sp_core :: crypto :: AccountId32 , :: core :: primitive :: u32 > , # [codec (compact)] pub value : :: core :: primitive :: u128 , pub payee : runtime_types :: pallet_staking :: RewardDestination < :: subxt :: sp_core :: crypto :: AccountId32 > , } impl :: subxt :: Call for Bond { const PALLET : & 'static str = "Staking" ; const FUNCTION : & 'static str = "bond" ; } # [derive (:: subxt :: codec :: Decode , :: subxt :: codec :: Encode , Clone , Debug , Eq , PartialEq)] pub struct BondExtra { # [codec (compact)] pub max_additional : :: core :: primitive :: u128 , } impl :: subxt :: Call for BondExtra { const PALLET : & 'static str = "Staking" ; const FUNCTION : & 'static str = "bond_extra" ; } # [derive (:: subxt :: codec :: Decode , :: subxt :: codec :: Encode , Clone , Debug , Eq , PartialEq)] pub struct Unbond { # [codec (compact)] pub value : :: core :: primitive :: u128 , } impl :: subxt :: Call for Unbond { const PALLET : & 'static str = "Staking" ; const FUNCTION : & 'static str = "unbond" ; } # [derive (:: subxt :: codec :: CompactAs , :: subxt :: codec :: Decode , :: subxt :: codec :: Encode , Clone , Debug , Eq , PartialEq)] pub struct WithdrawUnbonded { pub num_slashing_spans : :: core :: primitive :: u32 , } impl :: subxt :: Call for WithdrawUnbonded { const PALLET : & 'static str = "Staking" ; const FUNCTION : & 'static str = "withdraw_unbonded" ; } # [derive (:: subxt :: codec :: Decode , :: subxt :: codec :: Encode , Clone , Debug , Eq , PartialEq)] pub struct Validate { pub prefs : runtime_types :: pallet_staking :: ValidatorPrefs , } impl :: subxt :: Call for Validate { const PALLET : & 'static str = "Staking" ; const FUNCTION : & 'static str = "validate" ; } # [derive (:: subxt :: codec :: Decode , :: subxt :: codec :: Encode , Clone , Debug , Eq , PartialEq)] pub struct Nominate { pub targets : :: std :: vec :: Vec < :: subxt :: sp_runtime :: MultiAddress < :: subxt :: sp_core :: crypto :: AccountId32 , :: core :: primitive :: u32 > > , } impl :: subxt :: Call for Nominate { const PALLET : & 'static str = "Staking" ; const FUNCTION : & 'static str = "nominate" ; } # [derive (:: subxt :: codec :: Decode , :: subxt :: codec :: Encode , Clone , Debug , Eq , PartialEq)] pub struct Chill ; impl :: subxt :: Call for Chill { const PALLET : & 'static str = "Staking" ; const FUNCTION : & 'static str = "chill" ; } # [derive (:: subxt :: codec :: Decode , :: subxt :: codec :: Encode , Clone , Debug , Eq , PartialEq)] pub struct SetPayee { pub payee : runtime_types :: pallet_staking :: RewardDestination < :: subxt :: sp_core :: crypto :: AccountId32 > , } impl :: subxt :: Call for SetPayee { const PALLET : & 'static str = "Staking" ; const FUNCTION : & 'static str = "set_payee" ; } # [derive (:: subxt :: codec :: Decode , :: subxt :: codec :: Encode , Clone , Debug , Eq , PartialEq)] pub struct SetController { pub controller : :: subxt :: sp_runtime :: MultiAddress < :: subxt :: sp_core :: crypto :: AccountId32 , :: core :: primitive :: u32 > , } impl :: subxt :: Call for SetController { const PALLET : & 'static str = "Staking" ; const FUNCTION : & 'static str = "set_controller" ; } # [derive (:: subxt :: codec :: Decode , :: subxt :: codec :: Encode , Clone , Debug , Eq , PartialEq)] pub struct SetValidatorCount { # [codec (compact)] pub new : :: core :: primitive :: u32 , } impl :: subxt :: Call for SetValidatorCount { const PALLET : & 'static str = "Staking" ; const FUNCTION : & 'static str = "set_validator_count" ; } # [derive (:: subxt :: codec :: Decode , :: subxt :: codec :: Encode , Clone , Debug , Eq , PartialEq)] pub struct IncreaseValidatorCount { # [codec (compact)] pub additional : :: core :: primitive :: u32 , } impl :: subxt :: Call for IncreaseValidatorCount { const PALLET : & 'static str = "Staking" ; const FUNCTION : & 'static str = "increase_validator_count" ; } # [derive (:: subxt :: codec :: Decode , :: subxt :: codec :: Encode , Clone , Debug , Eq , PartialEq)] pub struct ScaleValidatorCount { pub factor : runtime_types :: sp_arithmetic :: per_things :: Percent , } impl :: subxt :: Call for ScaleValidatorCount { const PALLET : & 'static str = "Staking" ; const FUNCTION : & 'static str = "scale_validator_count" ; } # [derive (:: subxt :: codec :: Decode , :: subxt :: codec :: Encode , Clone , Debug , Eq , PartialEq)] pub struct ForceNoEras ; impl :: subxt :: Call for ForceNoEras { const PALLET : & 'static str = "Staking" ; const FUNCTION : & 'static str = "force_no_eras" ; } # [derive (:: subxt :: codec :: Decode , :: subxt :: codec :: Encode , Clone , Debug , Eq , PartialEq)] pub struct ForceNewEra ; impl :: subxt :: Call for ForceNewEra { const PALLET : & 'static str = "Staking" ; const FUNCTION : & 'static str = "force_new_era" ; } # [derive (:: subxt :: codec :: Decode , :: subxt :: codec :: Encode , Clone , Debug , Eq , PartialEq)] pub struct SetInvulnerables { pub invulnerables : :: std :: vec :: Vec < :: subxt :: sp_core :: crypto :: AccountId32 > , } impl :: subxt :: Call for SetInvulnerables { const PALLET : & 'static str = "Staking" ; const FUNCTION : & 'static str = "set_invulnerables" ; } # [derive (:: subxt :: codec :: Decode , :: subxt :: codec :: Encode , Clone , Debug , Eq , PartialEq)] pub struct ForceUnstake { pub stash : :: subxt :: sp_core :: crypto :: AccountId32 , pub num_slashing_spans : :: core :: primitive :: u32 , } impl :: subxt :: Call for ForceUnstake { const PALLET : & 'static str = "Staking" ; const FUNCTION : & 'static str = "force_unstake" ; } # [derive (:: subxt :: codec :: Decode , :: subxt :: codec :: Encode , Clone , Debug , Eq , PartialEq)] pub struct ForceNewEraAlways ; impl :: subxt :: Call for ForceNewEraAlways { const PALLET : & 'static str = "Staking" ; const FUNCTION : & 'static str = "force_new_era_always" ; } # [derive (:: subxt :: codec :: Decode , :: subxt :: codec :: Encode , Clone , Debug , Eq , PartialEq)] pub struct CancelDeferredSlash { pub era : :: core :: primitive :: u32 , pub slash_indices : :: std :: vec :: Vec < :: core :: primitive :: u32 > , } impl :: subxt :: Call for CancelDeferredSlash { const PALLET : & 'static str = "Staking" ; const FUNCTION : & 'static str = "cancel_deferred_slash" ; } # [derive (:: subxt :: codec :: Decode , :: subxt :: codec :: Encode , Clone , Debug , Eq , PartialEq)] pub struct PayoutStakers { pub validator_stash : :: subxt :: sp_core :: crypto :: AccountId32 , pub era : :: core :: primitive :: u32 , } impl :: subxt :: Call for PayoutStakers { const PALLET : & 'static str = "Staking" ; const FUNCTION : & 'static str = "payout_stakers" ; } # [derive (:: subxt :: codec :: Decode , :: subxt :: codec :: Encode , Clone , Debug , Eq , PartialEq)] pub struct Rebond { # [codec (compact)] pub value : :: core :: primitive :: u128 , } impl :: subxt :: Call for Rebond { const PALLET : & 'static str = "Staking" ; const FUNCTION : & 'static str = "rebond" ; } # [derive (:: subxt :: codec :: Decode , :: subxt :: codec :: Encode , Clone , Debug , Eq , PartialEq)] pub struct SetHistoryDepth { # [codec (compact)] pub new_history_depth : :: core :: primitive :: u32 , # [codec (compact)] pub era_items_deleted : :: core :: primitive :: u32 , } impl :: subxt :: Call for SetHistoryDepth { const PALLET : & 'static str = "Staking" ; const FUNCTION : & 'static str = "set_history_depth" ; } # [derive (:: subxt :: codec :: Decode , :: subxt :: codec :: Encode , Clone , Debug , Eq , PartialEq)] pub struct ReapStash { pub stash : :: subxt :: sp_core :: crypto :: AccountId32 , pub num_slashing_spans : :: core :: primitive :: u32 , } impl :: subxt :: Call for ReapStash { const PALLET : & 'static str = "Staking" ; const FUNCTION : & 'static str = "reap_stash" ; } # [derive (:: subxt :: codec :: Decode , :: subxt :: codec :: Encode , Clone , Debug , Eq , PartialEq)] pub struct Kick { pub who : :: std :: vec :: Vec < :: subxt :: sp_runtime :: MultiAddress < :: subxt :: sp_core :: crypto :: AccountId32 , :: core :: primitive :: u32 > > , } impl :: subxt :: Call for Kick { const PALLET : & 'static str = "Staking" ; const FUNCTION : & 'static str = "kick" ; } # [derive (:: subxt :: codec :: Decode , :: subxt :: codec :: Encode , Clone , Debug , Eq , PartialEq)] pub struct SetStakingConfigs { pub min_nominator_bond : runtime_types :: pallet_staking :: pallet :: pallet :: ConfigOp < :: core :: primitive :: u128 > , pub min_validator_bond : runtime_types :: pallet_staking :: pallet :: pallet :: ConfigOp < :: core :: primitive :: u128 > , pub max_nominator_count : runtime_types :: pallet_staking :: pallet :: pallet :: ConfigOp < :: core :: primitive :: u32 > , pub max_validator_count : runtime_types :: pallet_staking :: pallet :: pallet :: ConfigOp < :: core :: primitive :: u32 > , pub chill_threshold : runtime_types :: pallet_staking :: pallet :: pallet :: ConfigOp < runtime_types :: sp_arithmetic :: per_things :: Percent > , pub min_commission : runtime_types :: pallet_staking :: pallet :: pallet :: ConfigOp < runtime_types :: sp_arithmetic :: per_things :: Perbill > , } impl :: subxt :: Call for SetStakingConfigs { const PALLET : & 'static str = "Staking" ; const FUNCTION : & 'static str = "set_staking_configs" ; } # [derive (:: subxt :: codec :: Decode , :: subxt :: codec :: Encode , Clone , Debug , Eq , PartialEq)] pub struct ChillOther { pub controller : :: subxt :: sp_core :: crypto :: AccountId32 , } impl :: subxt :: Call for ChillOther { const PALLET : & 'static str = "Staking" ; const FUNCTION : & 'static str = "chill_other" ; } # [derive (:: subxt :: codec :: Decode , :: subxt :: codec :: Encode , Clone , Debug , Eq , PartialEq)] pub struct ForceApplyMinCommission { pub validator_stash : :: subxt :: sp_core :: crypto :: AccountId32 , } impl :: subxt :: Call for ForceApplyMinCommission { const PALLET : & 'static str = "Staking" ; const FUNCTION : & 'static str = "force_apply_min_commission" ; } pub struct TransactionApi < 'a , T : :: subxt :: Config , X > { client : & 'a :: subxt :: Client < T > , marker : :: core :: marker :: PhantomData < X > , } impl < 'a , T , X > TransactionApi < 'a , T , X > where T : :: subxt :: Config , X : :: subxt :: extrinsic :: ExtrinsicParams < T > , { pub fn new (client : & 'a :: subxt :: Client < T >) -> Self { Self { client , marker : :: core :: marker :: PhantomData } } # [doc = "Take the origin account as a stash and lock up `value` of its balance. `controller` will"] # [doc = "be the account that controls it."] # [doc = ""] # [doc = "`value` must be more than the `minimum_balance` specified by `T::Currency`."] # [doc = ""] # [doc = "The dispatch origin for this call must be _Signed_ by the stash account."] # [doc = ""] # [doc = "Emits `Bonded`."] # [doc = "# <weight>"] # [doc = "- Independent of the arguments. Moderate complexity."] # [doc = "- O(1)."] # [doc = "- Three extra DB entries."] # [doc = ""] # [doc = "NOTE: Two of the storage writes (`Self::bonded`, `Self::payee`) are _never_ cleaned"] # [doc = "unless the `origin` falls below _existential deposit_ and gets removed as dust."] # [doc = "------------------"] # [doc = "# </weight>"] pub fn bond (& self , controller : :: subxt :: sp_runtime :: MultiAddress < :: subxt :: sp_core :: crypto :: AccountId32 , :: core :: primitive :: u32 > , value : :: core :: primitive :: u128 , payee : runtime_types :: pallet_staking :: RewardDestination < :: subxt :: sp_core :: crypto :: AccountId32 > ,) -> Result < :: subxt :: SubmittableExtrinsic < 'a , T , X , Bond , DispatchError , root_mod :: Event > , :: subxt :: BasicError > { if self . client . metadata () . call_hash :: < Bond > () ? == [128u8 , 109u8 , 219u8 , 32u8 , 105u8 , 191u8 , 244u8 , 153u8 , 228u8 , 154u8 , 89u8 , 52u8 , 237u8 , 82u8 , 0u8 , 132u8 , 27u8 , 71u8 , 57u8 , 96u8 , 172u8 , 50u8 , 192u8 , 163u8 , 229u8 , 106u8 , 139u8 , 28u8 , 118u8 , 187u8 , 83u8 , 150u8 ,] { let call = Bond { controller , value , payee , } ; Ok (:: subxt :: SubmittableExtrinsic :: new (self . client , call)) } else { Err (:: subxt :: MetadataError :: IncompatibleMetadata . into ()) } } # [doc = "Add some extra amount that have appeared in the stash `free_balance` into the balance up"] # [doc = "for staking."] # [doc = ""] # [doc = "The dispatch origin for this call must be _Signed_ by the stash, not the controller."] # [doc = ""] # [doc = "Use this if there are additional funds in your stash account that you wish to bond."] # [doc = "Unlike [`bond`](Self::bond) or [`unbond`](Self::unbond) this function does not impose"] # [doc = "any limitation on the amount that can be added."] # [doc = ""] # [doc = "Emits `Bonded`."] # [doc = ""] # [doc = "# <weight>"] # [doc = "- Independent of the arguments. Insignificant complexity."] # [doc = "- O(1)."] # [doc = "# </weight>"] pub fn bond_extra (& self , max_additional : :: core :: primitive :: u128 ,) -> Result < :: subxt :: SubmittableExtrinsic < 'a , T , X , BondExtra , DispatchError , root_mod :: Event > , :: subxt :: BasicError > { if self . client . metadata () . call_hash :: < BondExtra > () ? == [170u8 , 38u8 , 37u8 , 71u8 , 243u8 , 41u8 , 24u8 , 59u8 , 17u8 , 229u8 , 61u8 , 20u8 , 130u8 , 167u8 , 1u8 , 1u8 , 158u8 , 180u8 , 234u8 , 65u8 , 196u8 , 181u8 , 232u8 , 146u8 , 62u8 , 90u8 , 194u8 , 183u8 , 253u8 , 142u8 , 251u8 , 200u8 ,] { let call = BondExtra { max_additional , } ; Ok (:: subxt :: SubmittableExtrinsic :: new (self . client , call)) } else { Err (:: subxt :: MetadataError :: IncompatibleMetadata . into ()) } } # [doc = "Schedule a portion of the stash to be unlocked ready for transfer out after the bond"] # [doc = "period ends. If this leaves an amount actively bonded less than"] # [doc = "T::Currency::minimum_balance(), then it is increased to the full amount."] # [doc = ""] # [doc = "The dispatch origin for this call must be _Signed_ by the controller, not the stash."] # [doc = ""] # [doc = "Once the unlock period is done, you can call `withdraw_unbonded` to actually move"] # [doc = "the funds out of management ready for transfer."] # [doc = ""] # [doc = "No more than a limited number of unlocking chunks (see `MaxUnlockingChunks`)"] # [doc = "can co-exists at the same time. In that case, [`Call::withdraw_unbonded`] need"] # [doc = "to be called first to remove some of the chunks (if possible)."] # [doc = ""] # [doc = "If a user encounters the `InsufficientBond` error when calling this extrinsic,"] # [doc = "they should call `chill` first in order to free up their bonded funds."] # [doc = ""] # [doc = "Emits `Unbonded`."] # [doc = ""] # [doc = "See also [`Call::withdraw_unbonded`]."] pub fn unbond (& self , value : :: core :: primitive :: u128 ,) -> Result < :: subxt :: SubmittableExtrinsic < 'a , T , X , Unbond , DispatchError , root_mod :: Event > , :: subxt :: BasicError > { if self . client . metadata () . call_hash :: < Unbond > () ? == [85u8 , 188u8 , 141u8 , 62u8 , 242u8 , 15u8 , 6u8 , 20u8 , 96u8 , 220u8 , 201u8 , 163u8 , 29u8 , 136u8 , 24u8 , 4u8 , 143u8 , 13u8 , 22u8 , 118u8 , 22u8 , 212u8 , 164u8 , 125u8 , 200u8 , 219u8 , 6u8 , 25u8 , 174u8 , 92u8 , 108u8 , 89u8 ,] { let call = Unbond { value , } ; Ok (:: subxt :: SubmittableExtrinsic :: new (self . client , call)) } else { Err (:: subxt :: MetadataError :: IncompatibleMetadata . into ()) } } # [doc = "Remove any unlocked chunks from the `unlocking` queue from our management."] # [doc = ""] # [doc = "This essentially frees up that balance to be used by the stash account to do"] # [doc = "whatever it wants."] # [doc = ""] # [doc = "The dispatch origin for this call must be _Signed_ by the controller."] # [doc = ""] # [doc = "Emits `Withdrawn`."] # [doc = ""] # [doc = "See also [`Call::unbond`]."] # [doc = ""] # [doc = "# <weight>"] # [doc = "Complexity O(S) where S is the number of slashing spans to remove"] # [doc = "NOTE: Weight annotation is the kill scenario, we refund otherwise."] # [doc = "# </weight>"] pub fn withdraw_unbonded (& self , num_slashing_spans : :: core :: primitive :: u32 ,) -> Result < :: subxt :: SubmittableExtrinsic < 'a , T , X , WithdrawUnbonded , DispatchError , root_mod :: Event > , :: subxt :: BasicError > { if self . client . metadata () . call_hash :: < WithdrawUnbonded > () ? == [252u8 , 47u8 , 185u8 , 86u8 , 179u8 , 203u8 , 20u8 , 5u8 , 88u8 , 252u8 , 212u8 , 173u8 , 20u8 , 202u8 , 206u8 , 56u8 , 10u8 , 186u8 , 124u8 , 221u8 , 42u8 , 61u8 , 202u8 , 110u8 , 233u8 , 40u8 , 210u8 , 135u8 , 204u8 , 110u8 , 133u8 , 123u8 ,] { let call = WithdrawUnbonded { num_slashing_spans , } ; Ok (:: subxt :: SubmittableExtrinsic :: new (self . client , call)) } else { Err (:: subxt :: MetadataError :: IncompatibleMetadata . into ()) } } # [doc = "Declare the desire to validate for the origin controller."] # [doc = ""] # [doc = "Effects will be felt at the beginning of the next era."] # [doc = ""] # [doc = "The dispatch origin for this call must be _Signed_ by the controller, not the stash."] pub fn validate (& self , prefs : runtime_types :: pallet_staking :: ValidatorPrefs ,) -> Result < :: subxt :: SubmittableExtrinsic < 'a , T , X , Validate , DispatchError , root_mod :: Event > , :: subxt :: BasicError > { if self . client . metadata () . call_hash :: < Validate > () ? == [138u8 , 13u8 , 146u8 , 216u8 , 4u8 , 27u8 , 20u8 , 159u8 , 148u8 , 25u8 , 169u8 , 229u8 , 145u8 , 2u8 , 251u8 , 58u8 , 13u8 , 128u8 , 20u8 , 22u8 , 194u8 , 11u8 , 13u8 , 65u8 , 50u8 , 51u8 , 158u8 , 239u8 , 45u8 , 90u8 , 6u8 , 37u8 ,] { let call = Validate { prefs , } ; Ok (:: subxt :: SubmittableExtrinsic :: new (self . client , call)) } else { Err (:: subxt :: MetadataError :: IncompatibleMetadata . into ()) } } # [doc = "Declare the desire to nominate `targets` for the origin controller."] # [doc = ""] # [doc = "Effects will be felt at the beginning of the next era."] # [doc = ""] # [doc = "The dispatch origin for this call must be _Signed_ by the controller, not the stash."] # [doc = ""] # [doc = "# <weight>"] # [doc = "- The transaction's complexity is proportional to the size of `targets` (N)"] # [doc = "which is capped at CompactAssignments::LIMIT (T::MaxNominations)."] # [doc = "- Both the reads and writes follow a similar pattern."] # [doc = "# </weight>"] pub fn nominate (& self , targets : :: std :: vec :: Vec < :: subxt :: sp_runtime :: MultiAddress < :: subxt :: sp_core :: crypto :: AccountId32 , :: core :: primitive :: u32 > > ,) -> Result < :: subxt :: SubmittableExtrinsic < 'a , T , X , Nominate , DispatchError , root_mod :: Event > , :: subxt :: BasicError > { if self . client . metadata () . call_hash :: < Nominate > () ? == [253u8 , 19u8 , 234u8 , 31u8 , 124u8 , 216u8 , 107u8 , 102u8 , 143u8 , 144u8 , 73u8 , 45u8 , 207u8 , 169u8 , 48u8 , 144u8 , 169u8 , 97u8 , 81u8 , 110u8 , 216u8 , 107u8 , 198u8 , 93u8 , 180u8 , 189u8 , 44u8 , 222u8 , 219u8 , 15u8 , 210u8 , 84u8 ,] { let call = Nominate { targets , } ; Ok (:: subxt :: SubmittableExtrinsic :: new (self . client , call)) } else { Err (:: subxt :: MetadataError :: IncompatibleMetadata . into ()) } } # [doc = "Declare no desire to either validate or nominate."] # [doc = ""] # [doc = "Effects will be felt at the beginning of the next era."] # [doc = ""] # [doc = "The dispatch origin for this call must be _Signed_ by the controller, not the stash."] # [doc = ""] # [doc = "# <weight>"] # [doc = "- Independent of the arguments. Insignificant complexity."] # [doc = "- Contains one read."] # [doc = "- Writes are limited to the `origin` account key."] # [doc = "# </weight>"] pub fn chill (& self ,) -> Result < :: subxt :: SubmittableExtrinsic < 'a , T , X , Chill , DispatchError , root_mod :: Event > , :: subxt :: BasicError > { if self . client . metadata () . call_hash :: < Chill > () ? == [94u8 , 20u8 , 196u8 , 31u8 , 220u8 , 125u8 , 115u8 , 167u8 , 140u8 , 3u8 , 20u8 , 132u8 , 81u8 , 120u8 , 215u8 , 166u8 , 230u8 , 56u8 , 16u8 , 222u8 , 31u8 , 153u8 , 120u8 , 62u8 , 153u8 , 67u8 , 220u8 , 239u8 , 11u8 , 234u8 , 127u8 , 122u8 ,] { let call = Chill { } ; Ok (:: subxt :: SubmittableExtrinsic :: new (self . client , call)) } else { Err (:: subxt :: MetadataError :: IncompatibleMetadata . into ()) } } # [doc = "(Re-)set the payment target for a controller."] # [doc = ""] # [doc = "Effects will be felt instantly (as soon as this function is completed successfully)."] # [doc = ""] # [doc = "The dispatch origin for this call must be _Signed_ by the controller, not the stash."] # [doc = ""] # [doc = "# <weight>"] # [doc = "- Independent of the arguments. Insignificant complexity."] # [doc = "- Contains a limited number of reads."] # [doc = "- Writes are limited to the `origin` account key."] # [doc = "---------"] # [doc = "- Weight: O(1)"] # [doc = "- DB Weight:"] # [doc = "    - Read: Ledger"] # [doc = "    - Write: Payee"] # [doc = "# </weight>"] pub fn set_payee (& self , payee : runtime_types :: pallet_staking :: RewardDestination < :: subxt :: sp_core :: crypto :: AccountId32 > ,) -> Result < :: subxt :: SubmittableExtrinsic < 'a , T , X , SetPayee , DispatchError , root_mod :: Event > , :: subxt :: BasicError > { if self . client . metadata () . call_hash :: < SetPayee > () ? == [185u8 , 62u8 , 154u8 , 65u8 , 135u8 , 104u8 , 38u8 , 171u8 , 237u8 , 16u8 , 169u8 , 38u8 , 53u8 , 161u8 , 170u8 , 232u8 , 249u8 , 185u8 , 24u8 , 155u8 , 54u8 , 88u8 , 96u8 , 147u8 , 171u8 , 85u8 , 216u8 , 240u8 , 52u8 , 158u8 , 134u8 , 72u8 ,] { let call = SetPayee { payee , } ; Ok (:: subxt :: SubmittableExtrinsic :: new (self . client , call)) } else { Err (:: subxt :: MetadataError :: IncompatibleMetadata . into ()) } } # [doc = "(Re-)set the controller of a stash."] # [doc = ""] # [doc = "Effects will be felt instantly (as soon as this function is completed successfully)."] # [doc = ""] # [doc = "The dispatch origin for this call must be _Signed_ by the stash, not the controller."] # [doc = ""] # [doc = "# <weight>"] # [doc = "- Independent of the arguments. Insignificant complexity."] # [doc = "- Contains a limited number of reads."] # [doc = "- Writes are limited to the `origin` account key."] # [doc = "----------"] # [doc = "Weight: O(1)"] # [doc = "DB Weight:"] # [doc = "- Read: Bonded, Ledger New Controller, Ledger Old Controller"] # [doc = "- Write: Bonded, Ledger New Controller, Ledger Old Controller"] # [doc = "# </weight>"] pub fn set_controller (& self , controller : :: subxt :: sp_runtime :: MultiAddress < :: subxt :: sp_core :: crypto :: AccountId32 , :: core :: primitive :: u32 > ,) -> Result < :: subxt :: SubmittableExtrinsic < 'a , T , X , SetController , DispatchError , root_mod :: Event > , :: subxt :: BasicError > { if self . client . metadata () . call_hash :: < SetController > () ? == [174u8 , 112u8 , 40u8 , 87u8 , 122u8 , 45u8 , 254u8 , 162u8 , 27u8 , 128u8 , 104u8 , 204u8 , 5u8 , 51u8 , 52u8 , 195u8 , 40u8 , 124u8 , 45u8 , 63u8 , 252u8 , 101u8 , 56u8 , 100u8 , 122u8 , 231u8 , 128u8 , 31u8 , 146u8 , 111u8 , 94u8 , 3u8 ,] { let call = SetController { controller , } ; Ok (:: subxt :: SubmittableExtrinsic :: new (self . client , call)) } else { Err (:: subxt :: MetadataError :: IncompatibleMetadata . into ()) } } # [doc = "Sets the ideal number of validators."] # [doc = ""] # [doc = "The dispatch origin must be Root."] # [doc = ""] # [doc = "# <weight>"] # [doc = "Weight: O(1)"] # [doc = "Write: Validator Count"] # [doc = "# </weight>"] pub fn set_validator_count (& self , new : :: core :: primitive :: u32 ,) -> Result < :: subxt :: SubmittableExtrinsic < 'a , T , X , SetValidatorCount , DispatchError , root_mod :: Event > , :: subxt :: BasicError > { if self . client . metadata () . call_hash :: < SetValidatorCount > () ? == [181u8 , 82u8 , 21u8 , 239u8 , 81u8 , 194u8 , 166u8 , 66u8 , 55u8 , 156u8 , 68u8 , 22u8 , 76u8 , 251u8 , 241u8 , 113u8 , 168u8 , 8u8 , 193u8 , 125u8 , 112u8 , 82u8 , 200u8 , 139u8 , 55u8 , 139u8 , 22u8 , 35u8 , 171u8 , 124u8 , 112u8 , 52u8 ,] { let call = SetValidatorCount { new , } ; Ok (:: subxt :: SubmittableExtrinsic :: new (self . client , call)) } else { Err (:: subxt :: MetadataError :: IncompatibleMetadata . into ()) } } # [doc = "Increments the ideal number of validators."] # [doc = ""] # [doc = "The dispatch origin must be Root."] # [doc = ""] # [doc = "# <weight>"] # [doc = "Same as [`Self::set_validator_count`]."] # [doc = "# </weight>"] pub fn increase_validator_count (& self , additional : :: core :: primitive :: u32 ,) -> Result < :: subxt :: SubmittableExtrinsic < 'a , T , X , IncreaseValidatorCount , DispatchError , root_mod :: Event > , :: subxt :: BasicError > { if self . client . metadata () . call_hash :: < IncreaseValidatorCount > () ? == [219u8 , 143u8 , 69u8 , 205u8 , 182u8 , 155u8 , 101u8 , 39u8 , 59u8 , 214u8 , 81u8 , 47u8 , 247u8 , 54u8 , 106u8 , 92u8 , 183u8 , 42u8 , 30u8 , 57u8 , 28u8 , 136u8 , 13u8 , 13u8 , 170u8 , 101u8 , 216u8 , 234u8 , 194u8 , 90u8 , 248u8 , 234u8 ,] { let call = IncreaseValidatorCount { additional , } ; Ok (:: subxt :: SubmittableExtrinsic :: new (self . client , call)) } else { Err (:: subxt :: MetadataError :: IncompatibleMetadata . into ()) } } # [doc = "Scale up the ideal number of validators by a factor."] # [doc = ""] # [doc = "The dispatch origin must be Root."] # [doc = ""] # [doc = "# <weight>"] # [doc = "Same as [`Self::set_validator_count`]."] # [doc = "# </weight>"] pub fn scale_validator_count (& self , factor : runtime_types :: sp_arithmetic :: per_things :: Percent ,) -> Result < :: subxt :: SubmittableExtrinsic < 'a , T , X , ScaleValidatorCount , DispatchError , root_mod :: Event > , :: subxt :: BasicError > { if self . client . metadata () . call_hash :: < ScaleValidatorCount > () ? == [170u8 , 156u8 , 101u8 , 109u8 , 117u8 , 199u8 , 38u8 , 157u8 , 132u8 , 210u8 , 54u8 , 66u8 , 251u8 , 10u8 , 123u8 , 120u8 , 237u8 , 31u8 , 206u8 , 176u8 , 224u8 , 112u8 , 82u8 , 70u8 , 152u8 , 6u8 , 166u8 , 118u8 , 10u8 , 172u8 , 254u8 , 148u8 ,] { let call = ScaleValidatorCount { factor , } ; Ok (:: subxt :: SubmittableExtrinsic :: new (self . client , call)) } else { Err (:: subxt :: MetadataError :: IncompatibleMetadata . into ()) } } # [doc = "Force there to be no new eras indefinitely."] # [doc = ""] # [doc = "The dispatch origin must be Root."] # [doc = ""] # [doc = "# Warning"] # [doc = ""] # [doc = "The election process starts multiple blocks before the end of the era."] # [doc = "Thus the election process may be ongoing when this is called. In this case the"] # [doc = "election will continue until the next era is triggered."] # [doc = ""] # [doc = "# <weight>"] # [doc = "- No arguments."] # [doc = "- Weight: O(1)"] # [doc = "- Write: ForceEra"] # [doc = "# </weight>"] pub fn force_no_eras (& self ,) -> Result < :: subxt :: SubmittableExtrinsic < 'a , T , X , ForceNoEras , DispatchError , root_mod :: Event > , :: subxt :: BasicError > { if self . client . metadata () . call_hash :: < ForceNoEras > () ? == [16u8 , 81u8 , 207u8 , 168u8 , 23u8 , 236u8 , 11u8 , 75u8 , 141u8 , 107u8 , 92u8 , 2u8 , 53u8 , 111u8 , 252u8 , 116u8 , 91u8 , 120u8 , 75u8 , 24u8 , 125u8 , 53u8 , 9u8 , 28u8 , 242u8 , 87u8 , 245u8 , 55u8 , 40u8 , 103u8 , 151u8 , 178u8 ,] { let call = ForceNoEras { } ; Ok (:: subxt :: SubmittableExtrinsic :: new (self . client , call)) } else { Err (:: subxt :: MetadataError :: IncompatibleMetadata . into ()) } } # [doc = "Force there to be a new era at the end of the next session. After this, it will be"] # [doc = "reset to normal (non-forced) behaviour."] # [doc = ""] # [doc = "The dispatch origin must be Root."] # [doc = ""] # [doc = "# Warning"] # [doc = ""] # [doc = "The election process starts multiple blocks before the end of the era."] # [doc = "If this is called just before a new era is triggered, the election process may not"] # [doc = "have enough blocks to get a result."] # [doc = ""] # [doc = "# <weight>"] # [doc = "- No arguments."] # [doc = "- Weight: O(1)"] # [doc = "- Write ForceEra"] # [doc = "# </weight>"] pub fn force_new_era (& self ,) -> Result < :: subxt :: SubmittableExtrinsic < 'a , T , X , ForceNewEra , DispatchError , root_mod :: Event > , :: subxt :: BasicError > { if self . client . metadata () . call_hash :: < ForceNewEra > () ? == [230u8 , 242u8 , 169u8 , 196u8 , 78u8 , 145u8 , 24u8 , 191u8 , 113u8 , 68u8 , 5u8 , 138u8 , 48u8 , 51u8 , 109u8 , 126u8 , 73u8 , 136u8 , 162u8 , 158u8 , 174u8 , 201u8 , 213u8 , 230u8 , 215u8 , 44u8 , 200u8 , 32u8 , 75u8 , 27u8 , 23u8 , 254u8 ,] { let call = ForceNewEra { } ; Ok (:: subxt :: SubmittableExtrinsic :: new (self . client , call)) } else { Err (:: subxt :: MetadataError :: IncompatibleMetadata . into ()) } } # [doc = "Set the validators who cannot be slashed (if any)."] # [doc = ""] # [doc = "The dispatch origin must be Root."] pub fn set_invulnerables (& self , invulnerables : :: std :: vec :: Vec < :: subxt :: sp_core :: crypto :: AccountId32 > ,) -> Result < :: subxt :: SubmittableExtrinsic < 'a , T , X , SetInvulnerables , DispatchError , root_mod :: Event > , :: subxt :: BasicError > { if self . client . metadata () . call_hash :: < SetInvulnerables > () ? == [0u8 , 119u8 , 27u8 , 243u8 , 238u8 , 65u8 , 133u8 , 89u8 , 210u8 , 202u8 , 154u8 , 243u8 , 168u8 , 158u8 , 9u8 , 147u8 , 146u8 , 215u8 , 172u8 , 28u8 , 171u8 , 183u8 , 112u8 , 42u8 , 245u8 , 232u8 , 238u8 , 94u8 , 205u8 , 46u8 , 0u8 , 20u8 ,] { let call = SetInvulnerables { invulnerables , } ; Ok (:: subxt :: SubmittableExtrinsic :: new (self . client , call)) } else { Err (:: subxt :: MetadataError :: IncompatibleMetadata . into ()) } } # [doc = "Force a current staker to become completely unstaked, immediately."] # [doc = ""] # [doc = "The dispatch origin must be Root."] pub fn force_unstake (& self , stash : :: subxt :: sp_core :: crypto :: AccountId32 , num_slashing_spans : :: core :: primitive :: u32 ,) -> Result < :: subxt :: SubmittableExtrinsic < 'a , T , X , ForceUnstake , DispatchError , root_mod :: Event > , :: subxt :: BasicError > { if self . client . metadata () . call_hash :: < ForceUnstake > () ? == [254u8 , 115u8 , 250u8 , 15u8 , 235u8 , 119u8 , 2u8 , 131u8 , 237u8 , 144u8 , 247u8 , 66u8 , 150u8 , 92u8 , 12u8 , 112u8 , 137u8 , 195u8 , 246u8 , 178u8 , 129u8 , 64u8 , 214u8 , 4u8 , 183u8 , 18u8 , 94u8 , 104u8 , 157u8 , 174u8 , 231u8 , 1u8 ,] { let call = ForceUnstake { stash , num_slashing_spans , } ; Ok (:: subxt :: SubmittableExtrinsic :: new (self . client , call)) } else { Err (:: subxt :: MetadataError :: IncompatibleMetadata . into ()) } } # [doc = "Force there to be a new era at the end of sessions indefinitely."] # [doc = ""] # [doc = "The dispatch origin must be Root."] # [doc = ""] # [doc = "# Warning"] # [doc = ""] # [doc = "The election process starts multiple blocks before the end of the era."] # [doc = "If this is called just before a new era is triggered, the election process may not"] # [doc = "have enough blocks to get a result."] pub fn force_new_era_always (& self ,) -> Result < :: subxt :: SubmittableExtrinsic < 'a , T , X , ForceNewEraAlways , DispatchError , root_mod :: Event > , :: subxt :: BasicError > { if self . client . metadata () . call_hash :: < ForceNewEraAlways > () ? == [179u8 , 118u8 , 189u8 , 54u8 , 248u8 , 141u8 , 207u8 , 142u8 , 80u8 , 37u8 , 241u8 , 185u8 , 138u8 , 254u8 , 117u8 , 147u8 , 225u8 , 118u8 , 34u8 , 177u8 , 197u8 , 158u8 , 8u8 , 82u8 , 202u8 , 108u8 , 208u8 , 26u8 , 64u8 , 33u8 , 74u8 , 43u8 ,] { let call = ForceNewEraAlways { } ; Ok (:: subxt :: SubmittableExtrinsic :: new (self . client , call)) } else { Err (:: subxt :: MetadataError :: IncompatibleMetadata . into ()) } } # [doc = "Cancel enactment of a deferred slash."] # [doc = ""] # [doc = "Can be called by the `T::SlashCancelOrigin`."] # [doc = ""] # [doc = "Parameters: era and indices of the slashes for that era to kill."] pub fn cancel_deferred_slash (& self , era : :: core :: primitive :: u32 , slash_indices : :: std :: vec :: Vec < :: core :: primitive :: u32 > ,) -> Result < :: subxt :: SubmittableExtrinsic < 'a , T , X , CancelDeferredSlash , DispatchError , root_mod :: Event > , :: subxt :: BasicError > { if self . client . metadata () . call_hash :: < CancelDeferredSlash > () ? == [217u8 , 175u8 , 246u8 , 108u8 , 78u8 , 134u8 , 98u8 , 49u8 , 178u8 , 209u8 , 98u8 , 178u8 , 52u8 , 242u8 , 173u8 , 135u8 , 171u8 , 70u8 , 129u8 , 239u8 , 62u8 , 150u8 , 84u8 , 142u8 , 243u8 , 193u8 , 179u8 , 249u8 , 114u8 , 231u8 , 8u8 , 252u8 ,] { let call = CancelDeferredSlash { era , slash_indices , } ; Ok (:: subxt :: SubmittableExtrinsic :: new (self . client , call)) } else { Err (:: subxt :: MetadataError :: IncompatibleMetadata . into ()) } } # [doc = "Pay out all the stakers behind a single validator for a single era."] # [doc = ""] # [doc = "- `validator_stash` is the stash account of the validator. Their nominators, up to"] # [doc = "  `T::MaxNominatorRewardedPerValidator`, will also receive their rewards."] # [doc = "- `era` may be any era between `[current_era - history_depth; current_era]`."] # [doc = ""] # [doc = "The origin of this call must be _Signed_. Any account can call this function, even if"] # [doc = "it is not one of the stakers."] # [doc = ""] # [doc = "# <weight>"] # [doc = "- Time complexity: at most O(MaxNominatorRewardedPerValidator)."] # [doc = "- Contains a limited number of reads and writes."] # [doc = "-----------"] # [doc = "N is the Number of payouts for the validator (including the validator)"] # [doc = "Weight:"] # [doc = "- Reward Destination Staked: O(N)"] # [doc = "- Reward Destination Controller (Creating): O(N)"] # [doc = ""] # [doc = "  NOTE: weights are assuming that payouts are made to alive stash account (Staked)."] # [doc = "  Paying even a dead controller is cheaper weight-wise. We don't do any refunds here."] # [doc = "# </weight>"] pub fn payout_stakers (& self , validator_stash : :: subxt :: sp_core :: crypto :: AccountId32 , era : :: core :: primitive :: u32 ,) -> Result < :: subxt :: SubmittableExtrinsic < 'a , T , X , PayoutStakers , DispatchError , root_mod :: Event > , :: subxt :: BasicError > { if self . client . metadata () . call_hash :: < PayoutStakers > () ? == [235u8 , 65u8 , 65u8 , 249u8 , 162u8 , 235u8 , 127u8 , 48u8 , 216u8 , 51u8 , 252u8 , 111u8 , 186u8 , 191u8 , 174u8 , 245u8 , 144u8 , 77u8 , 135u8 , 124u8 , 205u8 , 160u8 , 148u8 , 130u8 , 81u8 , 213u8 , 195u8 , 105u8 , 21u8 , 65u8 , 186u8 , 157u8 ,] { let call = PayoutStakers { validator_stash , era , } ; Ok (:: subxt :: SubmittableExtrinsic :: new (self . client , call)) } else { Err (:: subxt :: MetadataError :: IncompatibleMetadata . into ()) } } # [doc = "Rebond a portion of the stash scheduled to be unlocked."] # [doc = ""] # [doc = "The dispatch origin must be signed by the controller."] # [doc = ""] # [doc = "# <weight>"] # [doc = "- Time complexity: O(L), where L is unlocking chunks"] # [doc = "- Bounded by `MaxUnlockingChunks`."] # [doc = "- Storage changes: Can't increase storage, only decrease it."] # [doc = "# </weight>"] pub fn rebond (& self , value : :: core :: primitive :: u128 ,) -> Result < :: subxt :: SubmittableExtrinsic < 'a , T , X , Rebond , DispatchError , root_mod :: Event > , :: subxt :: BasicError > { if self . client . metadata () . call_hash :: < Rebond > () ? == [138u8 , 156u8 , 164u8 , 170u8 , 178u8 , 236u8 , 221u8 , 242u8 , 157u8 , 176u8 , 173u8 , 145u8 , 254u8 , 94u8 , 158u8 , 27u8 , 138u8 , 103u8 , 116u8 , 31u8 , 41u8 , 106u8 , 199u8 , 180u8 , 233u8 , 172u8 , 38u8 , 7u8 , 76u8 , 29u8 , 5u8 , 225u8 ,] { let call = Rebond { value , } ; Ok (:: subxt :: SubmittableExtrinsic :: new (self . client , call)) } else { Err (:: subxt :: MetadataError :: IncompatibleMetadata . into ()) } } # [doc = "Set `HistoryDepth` value. This function will delete any history information"] # [doc = "when `HistoryDepth` is reduced."] # [doc = ""] # [doc = "Parameters:"] # [doc = "- `new_history_depth`: The new history depth you would like to set."] # [doc = "- `era_items_deleted`: The number of items that will be deleted by this dispatch. This"] # [doc = "  should report all the storage items that will be deleted by clearing old era history."] # [doc = "  Needed to report an accurate weight for the dispatch. Trusted by `Root` to report an"] # [doc = "  accurate number."] # [doc = ""] # [doc = "Origin must be root."] # [doc = ""] # [doc = "# <weight>"] # [doc = "- E: Number of history depths removed, i.e. 10 -> 7 = 3"] # [doc = "- Weight: O(E)"] # [doc = "- DB Weight:"] # [doc = "    - Reads: Current Era, History Depth"] # [doc = "    - Writes: History Depth"] # [doc = "    - Clear Prefix Each: Era Stakers, EraStakersClipped, ErasValidatorPrefs"] # [doc = "    - Writes Each: ErasValidatorReward, ErasRewardPoints, ErasTotalStake,"] # [doc = "      ErasStartSessionIndex"] # [doc = "# </weight>"] pub fn set_history_depth (& self , new_history_depth : :: core :: primitive :: u32 , era_items_deleted : :: core :: primitive :: u32 ,) -> Result < :: subxt :: SubmittableExtrinsic < 'a , T , X , SetHistoryDepth , DispatchError , root_mod :: Event > , :: subxt :: BasicError > { if self . client . metadata () . call_hash :: < SetHistoryDepth > () ? == [128u8 , 149u8 , 139u8 , 192u8 , 213u8 , 239u8 , 248u8 , 215u8 , 57u8 , 145u8 , 177u8 , 225u8 , 43u8 , 214u8 , 228u8 , 14u8 , 213u8 , 181u8 , 18u8 , 40u8 , 242u8 , 1u8 , 210u8 , 87u8 , 143u8 , 78u8 , 0u8 , 23u8 , 145u8 , 46u8 , 210u8 , 168u8 ,] { let call = SetHistoryDepth { new_history_depth , era_items_deleted , } ; Ok (:: subxt :: SubmittableExtrinsic :: new (self . client , call)) } else { Err (:: subxt :: MetadataError :: IncompatibleMetadata . into ()) } } # [doc = "Remove all data structures concerning a staker/stash once it is at a state where it can"] # [doc = "be considered `dust` in the staking system. The requirements are:"] # [doc = ""] # [doc = "1. the `total_balance` of the stash is below existential deposit."] # [doc = "2. or, the `ledger.total` of the stash is below existential deposit."] # [doc = ""] # [doc = "The former can happen in cases like a slash; the latter when a fully unbonded account"] # [doc = "is still receiving staking rewards in `RewardDestination::Staked`."] # [doc = ""] # [doc = "It can be called by anyone, as long as `stash` meets the above requirements."] # [doc = ""] # [doc = "Refunds the transaction fees upon successful execution."] pub fn reap_stash (& self , stash : :: subxt :: sp_core :: crypto :: AccountId32 , num_slashing_spans : :: core :: primitive :: u32 ,) -> Result < :: subxt :: SubmittableExtrinsic < 'a , T , X , ReapStash , DispatchError , root_mod :: Event > , :: subxt :: BasicError > { if self . client . metadata () . call_hash :: < ReapStash > () ? == [84u8 , 192u8 , 207u8 , 193u8 , 133u8 , 53u8 , 93u8 , 148u8 , 153u8 , 112u8 , 54u8 , 145u8 , 68u8 , 195u8 , 42u8 , 158u8 , 17u8 , 230u8 , 197u8 , 218u8 , 179u8 , 101u8 , 237u8 , 105u8 , 17u8 , 232u8 , 125u8 , 163u8 , 209u8 , 134u8 , 3u8 , 248u8 ,] { let call = ReapStash { stash , num_slashing_spans , } ; Ok (:: subxt :: SubmittableExtrinsic :: new (self . client , call)) } else { Err (:: subxt :: MetadataError :: IncompatibleMetadata . into ()) } } # [doc = "Remove the given nominations from the calling validator."] # [doc = ""] # [doc = "Effects will be felt at the beginning of the next era."] # [doc = ""] # [doc = "The dispatch origin for this call must be _Signed_ by the controller, not the stash."] # [doc = ""] # [doc = "- `who`: A list of nominator stash accounts who are nominating this validator which"] # [doc = "  should no longer be nominating this validator."] # [doc = ""] # [doc = "Note: Making this call only makes sense if you first set the validator preferences to"] # [doc = "block any further nominations."] pub fn kick (& self , who : :: std :: vec :: Vec < :: subxt :: sp_runtime :: MultiAddress < :: subxt :: sp_core :: crypto :: AccountId32 , :: core :: primitive :: u32 > > ,) -> Result < :: subxt :: SubmittableExtrinsic < 'a , T , X , Kick , DispatchError , root_mod :: Event > , :: subxt :: BasicError > { if self . client . metadata () . call_hash :: < Kick > () ? == [61u8 , 203u8 , 76u8 , 57u8 , 31u8 , 73u8 , 253u8 , 126u8 , 233u8 , 206u8 , 87u8 , 168u8 , 144u8 , 207u8 , 47u8 , 108u8 , 147u8 , 227u8 , 50u8 , 217u8 , 58u8 , 195u8 , 245u8 , 193u8 , 207u8 , 227u8 , 26u8 , 227u8 , 181u8 , 214u8 , 166u8 , 101u8 ,] { let call = Kick { who , } ; Ok (:: subxt :: SubmittableExtrinsic :: new (self . client , call)) } else { Err (:: subxt :: MetadataError :: IncompatibleMetadata . into ()) } } # [doc = "Update the various staking configurations ."] # [doc = ""] # [doc = "* `min_nominator_bond`: The minimum active bond needed to be a nominator."] # [doc = "* `min_validator_bond`: The minimum active bond needed to be a validator."] # [doc = "* `max_nominator_count`: The max number of users who can be a nominator at once. When"] # [doc = "  set to `None`, no limit is enforced."] # [doc = "* `max_validator_count`: The max number of users who can be a validator at once. When"] # [doc = "  set to `None`, no limit is enforced."] # [doc = "* `chill_threshold`: The ratio of `max_nominator_count` or `max_validator_count` which"] # [doc = "  should be filled in order for the `chill_other` transaction to work."] # [doc = "* `min_commission`: The minimum amount of commission that each validators must maintain."] # [doc = "  This is checked only upon calling `validate`. Existing validators are not affected."] # [doc = ""] # [doc = "Origin must be Root to call this function."] # [doc = ""] # [doc = "NOTE: Existing nominators and validators will not be affected by this update."] # [doc = "to kick people under the new limits, `chill_other` should be called."] pub fn set_staking_configs (& self , min_nominator_bond : runtime_types :: pallet_staking :: pallet :: pallet :: ConfigOp < :: core :: primitive :: u128 > , min_validator_bond : runtime_types :: pallet_staking :: pallet :: pallet :: ConfigOp < :: core :: primitive :: u128 > , max_nominator_count : runtime_types :: pallet_staking :: pallet :: pallet :: ConfigOp < :: core :: primitive :: u32 > , max_validator_count : runtime_types :: pallet_staking :: pallet :: pallet :: ConfigOp < :: core :: primitive :: u32 > , chill_threshold : runtime_types :: pallet_staking :: pallet :: pallet :: ConfigOp < runtime_types :: sp_arithmetic :: per_things :: Percent > , min_commission : runtime_types :: pallet_staking :: pallet :: pallet :: ConfigOp < runtime_types :: sp_arithmetic :: per_things :: Perbill > ,) -> Result < :: subxt :: SubmittableExtrinsic < 'a , T , X , SetStakingConfigs , DispatchError , root_mod :: Event > , :: subxt :: BasicError > { if self . client . metadata () . call_hash :: < SetStakingConfigs > () ? == [249u8 , 192u8 , 107u8 , 126u8 , 200u8 , 50u8 , 63u8 , 120u8 , 116u8 , 53u8 , 183u8 , 80u8 , 134u8 , 135u8 , 49u8 , 112u8 , 232u8 , 140u8 , 177u8 , 175u8 , 136u8 , 220u8 , 209u8 , 179u8 , 219u8 , 110u8 , 19u8 , 165u8 , 191u8 , 173u8 , 65u8 , 13u8 ,] { let call = SetStakingConfigs { min_nominator_bond , min_validator_bond , max_nominator_count , max_validator_count , chill_threshold , min_commission , } ; Ok (:: subxt :: SubmittableExtrinsic :: new (self . client , call)) } else { Err (:: subxt :: MetadataError :: IncompatibleMetadata . into ()) } } # [doc = "Declare a `controller` to stop participating as either a validator or nominator."] # [doc = ""] # [doc = "Effects will be felt at the beginning of the next era."] # [doc = ""] # [doc = "The dispatch origin for this call must be _Signed_, but can be called by anyone."] # [doc = ""] # [doc = "If the caller is the same as the controller being targeted, then no further checks are"] # [doc = "enforced, and this function behaves just like `chill`."] # [doc = ""] # [doc = "If the caller is different than the controller being targeted, the following conditions"] # [doc = "must be met:"] # [doc = ""] # [doc = "* `controller` must belong to a nominator who has become non-decodable,"] # [doc = ""] # [doc = "Or:"] # [doc = ""] # [doc = "* A `ChillThreshold` must be set and checked which defines how close to the max"] # [doc = "  nominators or validators we must reach before users can start chilling one-another."] # [doc = "* A `MaxNominatorCount` and `MaxValidatorCount` must be set which is used to determine"] # [doc = "  how close we are to the threshold."] # [doc = "* A `MinNominatorBond` and `MinValidatorBond` must be set and checked, which determines"] # [doc = "  if this is a person that should be chilled because they have not met the threshold"] # [doc = "  bond required."] # [doc = ""] # [doc = "This can be helpful if bond requirements are updated, and we need to remove old users"] # [doc = "who do not satisfy these requirements."] pub fn chill_other (& self , controller : :: subxt :: sp_core :: crypto :: AccountId32 ,) -> Result < :: subxt :: SubmittableExtrinsic < 'a , T , X , ChillOther , DispatchError , root_mod :: Event > , :: subxt :: BasicError > { if self . client . metadata () . call_hash :: < ChillOther > () ? == [219u8 , 114u8 , 146u8 , 43u8 , 175u8 , 216u8 , 70u8 , 148u8 , 137u8 , 192u8 , 77u8 , 247u8 , 134u8 , 80u8 , 188u8 , 100u8 , 79u8 , 141u8 , 32u8 , 94u8 , 15u8 , 178u8 , 159u8 , 233u8 , 235u8 , 6u8 , 243u8 , 253u8 , 22u8 , 145u8 , 146u8 , 219u8 ,] { let call = ChillOther { controller , } ; Ok (:: subxt :: SubmittableExtrinsic :: new (self . client , call)) } else { Err (:: subxt :: MetadataError :: IncompatibleMetadata . into ()) } } # [doc = "Force a validator to have at least the minimum commission. This will not affect a"] # [doc = "validator who already has a commission greater than or equal to the minimum. Any account"] # [doc = "can call this."] pub fn force_apply_min_commission (& self , validator_stash : :: subxt :: sp_core :: crypto :: AccountId32 ,) -> Result < :: subxt :: SubmittableExtrinsic < 'a , T , X , ForceApplyMinCommission , DispatchError , root_mod :: Event > , :: subxt :: BasicError > { if self . client . metadata () . call_hash :: < ForceApplyMinCommission > () ? == [8u8 , 57u8 , 61u8 , 141u8 , 175u8 , 100u8 , 174u8 , 161u8 , 236u8 , 2u8 , 133u8 , 169u8 , 249u8 , 168u8 , 236u8 , 188u8 , 168u8 , 221u8 , 88u8 , 148u8 , 95u8 , 24u8 , 214u8 , 206u8 , 165u8 , 170u8 , 200u8 , 134u8 , 38u8 , 174u8 , 187u8 , 119u8 ,] { let call = ForceApplyMinCommission { validator_stash , } ; Ok (:: subxt :: SubmittableExtrinsic :: new (self . client , call)) } else { Err (:: subxt :: MetadataError :: IncompatibleMetadata . into ()) } } } } pub type Event = runtime_types :: pallet_staking :: pallet :: pallet :: Event ; pub mod events { use super :: runtime_types ; # [derive (:: subxt :: codec :: Decode , :: subxt :: codec :: Encode , Clone , Debug , Eq , PartialEq)] # [doc = "The era payout has been set; the first balance is the validator-payout; the second is"] # [doc = "the remainder from the maximum amount of reward."] # [doc = "\\[era_index, validator_payout, remainder\\]"] pub struct EraPaid (pub :: core :: primitive :: u32 , pub :: core :: primitive :: u128 , pub :: core :: primitive :: u128 ,) ; impl :: subxt :: Event for EraPaid { const PALLET : & 'static str = "Staking" ; const EVENT : & 'static str = "EraPaid" ; } # [derive (:: subxt :: codec :: Decode , :: subxt :: codec :: Encode , Clone , Debug , Eq , PartialEq)] # [doc = "The nominator has been rewarded by this amount. \\[stash, amount\\]"] pub struct Rewarded (pub :: subxt :: sp_core :: crypto :: AccountId32 , pub :: core :: primitive :: u128 ,) ; impl :: subxt :: Event for Rewarded { const PALLET : & 'static str = "Staking" ; const EVENT : & 'static str = "Rewarded" ; } # [derive (:: subxt :: codec :: Decode , :: subxt :: codec :: Encode , Clone , Debug , Eq , PartialEq)] # [doc = "One validator (and its nominators) has been slashed by the given amount."] # [doc = "\\[validator, amount\\]"] pub struct Slashed (pub :: subxt :: sp_core :: crypto :: AccountId32 , pub :: core :: primitive :: u128 ,) ; impl :: subxt :: Event for Slashed { const PALLET : & 'static str = "Staking" ; const EVENT : & 'static str = "Slashed" ; } # [derive (:: subxt :: codec :: CompactAs , :: subxt :: codec :: Decode , :: subxt :: codec :: Encode , Clone , Debug , Eq , PartialEq)] # [doc = "An old slashing report from a prior era was discarded because it could"] # [doc = "not be processed. \\[session_index\\]"] pub struct OldSlashingReportDiscarded (pub :: core :: primitive :: u32 ,) ; impl :: subxt :: Event for OldSlashingReportDiscarded { const PALLET : & 'static str = "Staking" ; const EVENT : & 'static str = "OldSlashingReportDiscarded" ; } # [derive (:: subxt :: codec :: Decode , :: subxt :: codec :: Encode , Clone , Debug , Eq , PartialEq)] # [doc = "A new set of stakers was elected."] pub struct StakersElected ; impl :: subxt :: Event for StakersElected { const PALLET : & 'static str = "Staking" ; const EVENT : & 'static str = "StakersElected" ; } # [derive (:: subxt :: codec :: Decode , :: subxt :: codec :: Encode , Clone , Debug , Eq , PartialEq)] # [doc = "An account has bonded this amount. \\[stash, amount\\]"] # [doc = ""] # [doc = "NOTE: This event is only emitted when funds are bonded via a dispatchable. Notably,"] # [doc = "it will not be emitted for staking rewards when they are added to stake."] pub struct Bonded (pub :: subxt :: sp_core :: crypto :: AccountId32 , pub :: core :: primitive :: u128 ,) ; impl :: subxt :: Event for Bonded { const PALLET : & 'static str = "Staking" ; const EVENT : & 'static str = "Bonded" ; } # [derive (:: subxt :: codec :: Decode , :: subxt :: codec :: Encode , Clone , Debug , Eq , PartialEq)] # [doc = "An account has unbonded this amount. \\[stash, amount\\]"] pub struct Unbonded (pub :: subxt :: sp_core :: crypto :: AccountId32 , pub :: core :: primitive :: u128 ,) ; impl :: subxt :: Event for Unbonded { const PALLET : & 'static str = "Staking" ; const EVENT : & 'static str = "Unbonded" ; } # [derive (:: subxt :: codec :: Decode , :: subxt :: codec :: Encode , Clone , Debug , Eq , PartialEq)] # [doc = "An account has called `withdraw_unbonded` and removed unbonding chunks worth `Balance`"] # [doc = "from the unlocking queue. \\[stash, amount\\]"] pub struct Withdrawn (pub :: subxt :: sp_core :: crypto :: AccountId32 , pub :: core :: primitive :: u128 ,) ; impl :: subxt :: Event for Withdrawn { const PALLET : & 'static str = "Staking" ; const EVENT : & 'static str = "Withdrawn" ; } # [derive (:: subxt :: codec :: Decode , :: subxt :: codec :: Encode , Clone , Debug , Eq , PartialEq)] # [doc = "A nominator has been kicked from a validator. \\[nominator, stash\\]"] pub struct Kicked (pub :: subxt :: sp_core :: crypto :: AccountId32 , pub :: subxt :: sp_core :: crypto :: AccountId32 ,) ; impl :: subxt :: Event for Kicked { const PALLET : & 'static str = "Staking" ; const EVENT : & 'static str = "Kicked" ; } # [derive (:: subxt :: codec :: Decode , :: subxt :: codec :: Encode , Clone , Debug , Eq , PartialEq)] # [doc = "The election failed. No new era is planned."] pub struct StakingElectionFailed ; impl :: subxt :: Event for StakingElectionFailed { const PALLET : & 'static str = "Staking" ; const EVENT : & 'static str = "StakingElectionFailed" ; } # [derive (:: subxt :: codec :: Decode , :: subxt :: codec :: Encode , Clone , Debug , Eq , PartialEq)] # [doc = "An account has stopped participating as either a validator or nominator."] # [doc = "\\[stash\\]"] pub struct Chilled (pub :: subxt :: sp_core :: crypto :: AccountId32 ,) ; impl :: subxt :: Event for Chilled { const PALLET : & 'static str = "Staking" ; const EVENT : & 'static str = "Chilled" ; } # [derive (:: subxt :: codec :: Decode , :: subxt :: codec :: Encode , Clone , Debug , Eq , PartialEq)] # [doc = "The stakers' rewards are getting paid. \\[era_index, validator_stash\\]"] pub struct PayoutStarted (pub :: core :: primitive :: u32 , pub :: subxt :: sp_core :: crypto :: AccountId32 ,) ; impl :: subxt :: Event for PayoutStarted { const PALLET : & 'static str = "Staking" ; const EVENT : & 'static str = "PayoutStarted" ; } # [derive (:: subxt :: codec :: Decode , :: subxt :: codec :: Encode , Clone , Debug , Eq , PartialEq)] # [doc = "A validator has set their preferences."] pub struct ValidatorPrefsSet (pub :: subxt :: sp_core :: crypto :: AccountId32 , pub runtime_types :: pallet_staking :: ValidatorPrefs ,) ; impl :: subxt :: Event for ValidatorPrefsSet { const PALLET : & 'static str = "Staking" ; const EVENT : & 'static str = "ValidatorPrefsSet" ; } } pub mod storage { use super :: runtime_types ; pub struct HistoryDepth ; impl :: subxt :: StorageEntry for HistoryDepth { const PALLET : & 'static str = "Staking" ; const STORAGE : & 'static str = "HistoryDepth" ; type Value = :: core :: primitive :: u32 ; fn key (& self) -> :: subxt :: StorageEntryKey { :: subxt :: StorageEntryKey :: Plain } } pub struct ValidatorCount ; impl :: subxt :: StorageEntry for ValidatorCount { const PALLET : & 'static str = "Staking" ; const STORAGE : & 'static str = "ValidatorCount" ; type Value = :: core :: primitive :: u32 ; fn key (& self) -> :: subxt :: StorageEntryKey { :: subxt :: StorageEntryKey :: Plain } } pub struct MinimumValidatorCount ; impl :: subxt :: StorageEntry for MinimumValidatorCount { const PALLET : & 'static str = "Staking" ; const STORAGE : & 'static str = "MinimumValidatorCount" ; type Value = :: core :: primitive :: u32 ; fn key (& self) -> :: subxt :: StorageEntryKey { :: subxt :: StorageEntryKey :: Plain } } pub struct Invulnerables ; impl :: subxt :: StorageEntry for Invulnerables { const PALLET : & 'static str = "Staking" ; const STORAGE : & 'static str = "Invulnerables" ; type Value = :: std :: vec :: Vec < :: subxt :: sp_core :: crypto :: AccountId32 > ; fn key (& self) -> :: subxt :: StorageEntryKey { :: subxt :: StorageEntryKey :: Plain } } pub struct Bonded < 'a > (pub & 'a :: subxt :: sp_core :: crypto :: AccountId32) ; impl :: subxt :: StorageEntry for Bonded < '_ > { const PALLET : & 'static str = "Staking" ; const STORAGE : & 'static str = "Bonded" ; type Value = :: subxt :: sp_core :: crypto :: AccountId32 ; fn key (& self) -> :: subxt :: StorageEntryKey { :: subxt :: StorageEntryKey :: Map (vec ! [:: subxt :: StorageMapKey :: new (& self . 0 , :: subxt :: StorageHasher :: Twox64Concat)]) } } pub struct MinNominatorBond ; impl :: subxt :: StorageEntry for MinNominatorBond { const PALLET : & 'static str = "Staking" ; const STORAGE : & 'static str = "MinNominatorBond" ; type Value = :: core :: primitive :: u128 ; fn key (& self) -> :: subxt :: StorageEntryKey { :: subxt :: StorageEntryKey :: Plain } } pub struct MinValidatorBond ; impl :: subxt :: StorageEntry for MinValidatorBond { const PALLET : & 'static str = "Staking" ; const STORAGE : & 'static str = "MinValidatorBond" ; type Value = :: core :: primitive :: u128 ; fn key (& self) -> :: subxt :: StorageEntryKey { :: subxt :: StorageEntryKey :: Plain } } pub struct MinCommission ; impl :: subxt :: StorageEntry for MinCommission { const PALLET : & 'static str = "Staking" ; const STORAGE : & 'static str = "MinCommission" ; type Value = runtime_types :: sp_arithmetic :: per_things :: Perbill ; fn key (& self) -> :: subxt :: StorageEntryKey { :: subxt :: StorageEntryKey :: Plain } } pub struct Ledger < 'a > (pub & 'a :: subxt :: sp_core :: crypto :: AccountId32) ; impl :: subxt :: StorageEntry for Ledger < '_ > { const PALLET : & 'static str = "Staking" ; const STORAGE : & 'static str = "Ledger" ; type Value = runtime_types :: pallet_staking :: StakingLedger ; fn key (& self) -> :: subxt :: StorageEntryKey { :: subxt :: StorageEntryKey :: Map (vec ! [:: subxt :: StorageMapKey :: new (& self . 0 , :: subxt :: StorageHasher :: Blake2_128Concat)]) } } pub struct Payee < 'a > (pub & 'a :: subxt :: sp_core :: crypto :: AccountId32) ; impl :: subxt :: StorageEntry for Payee < '_ > { const PALLET : & 'static str = "Staking" ; const STORAGE : & 'static str = "Payee" ; type Value = runtime_types :: pallet_staking :: RewardDestination < :: subxt :: sp_core :: crypto :: AccountId32 > ; fn key (& self) -> :: subxt :: StorageEntryKey { :: subxt :: StorageEntryKey :: Map (vec ! [:: subxt :: StorageMapKey :: new (& self . 0 , :: subxt :: StorageHasher :: Twox64Concat)]) } } pub struct Validators < 'a > (pub & 'a :: subxt :: sp_core :: crypto :: AccountId32) ; impl :: subxt :: StorageEntry for Validators < '_ > { const PALLET : & 'static str = "Staking" ; const STORAGE : & 'static str = "Validators" ; type Value = runtime_types :: pallet_staking :: ValidatorPrefs ; fn key (& self) -> :: subxt :: StorageEntryKey { :: subxt :: StorageEntryKey :: Map (vec ! [:: subxt :: StorageMapKey :: new (& self . 0 , :: subxt :: StorageHasher :: Twox64Concat)]) } } pub struct CounterForValidators ; impl :: subxt :: StorageEntry for CounterForValidators { const PALLET : & 'static str = "Staking" ; const STORAGE : & 'static str = "CounterForValidators" ; type Value = :: core :: primitive :: u32 ; fn key (& self) -> :: subxt :: StorageEntryKey { :: subxt :: StorageEntryKey :: Plain } } pub struct MaxValidatorsCount ; impl :: subxt :: StorageEntry for MaxValidatorsCount { const PALLET : & 'static str = "Staking" ; const STORAGE : & 'static str = "MaxValidatorsCount" ; type Value = :: core :: primitive :: u32 ; fn key (& self) -> :: subxt :: StorageEntryKey { :: subxt :: StorageEntryKey :: Plain } } pub struct Nominators < 'a > (pub & 'a :: subxt :: sp_core :: crypto :: AccountId32) ; impl :: subxt :: StorageEntry for Nominators < '_ > { const PALLET : & 'static str = "Staking" ; const STORAGE : & 'static str = "Nominators" ; type Value = runtime_types :: pallet_staking :: Nominations ; fn key (& self) -> :: subxt :: StorageEntryKey { :: subxt :: StorageEntryKey :: Map (vec ! [:: subxt :: StorageMapKey :: new (& self . 0 , :: subxt :: StorageHasher :: Twox64Concat)]) } } pub struct CounterForNominators ; impl :: subxt :: StorageEntry for CounterForNominators { const PALLET : & 'static str = "Staking" ; const STORAGE : & 'static str = "CounterForNominators" ; type Value = :: core :: primitive :: u32 ; fn key (& self) -> :: subxt :: StorageEntryKey { :: subxt :: StorageEntryKey :: Plain } } pub struct MaxNominatorsCount ; impl :: subxt :: StorageEntry for MaxNominatorsCount { const PALLET : & 'static str = "Staking" ; const STORAGE : & 'static str = "MaxNominatorsCount" ; type Value = :: core :: primitive :: u32 ; fn key (& self) -> :: subxt :: StorageEntryKey { :: subxt :: StorageEntryKey :: Plain } } pub struct CurrentEra ; impl :: subxt :: StorageEntry for CurrentEra { const PALLET : & 'static str = "Staking" ; const STORAGE : & 'static str = "CurrentEra" ; type Value = :: core :: primitive :: u32 ; fn key (& self) -> :: subxt :: StorageEntryKey { :: subxt :: StorageEntryKey :: Plain } } pub struct ActiveEra ; impl :: subxt :: StorageEntry for ActiveEra { const PALLET : & 'static str = "Staking" ; const STORAGE : & 'static str = "ActiveEra" ; type Value = runtime_types :: pallet_staking :: ActiveEraInfo ; fn key (& self) -> :: subxt :: StorageEntryKey { :: subxt :: StorageEntryKey :: Plain } } pub struct ErasStartSessionIndex < 'a > (pub & 'a :: core :: primitive :: u32) ; impl :: subxt :: StorageEntry for ErasStartSessionIndex < '_ > { const PALLET : & 'static str = "Staking" ; const STORAGE : & 'static str = "ErasStartSessionIndex" ; type Value = :: core :: primitive :: u32 ; fn key (& self) -> :: subxt :: StorageEntryKey { :: subxt :: StorageEntryKey :: Map (vec ! [:: subxt :: StorageMapKey :: new (& self . 0 , :: subxt :: StorageHasher :: Twox64Concat)]) } } pub struct ErasStakers < 'a > (pub & 'a :: core :: primitive :: u32 , pub & 'a :: subxt :: sp_core :: crypto :: AccountId32) ; impl :: subxt :: StorageEntry for ErasStakers < '_ > { const PALLET : & 'static str = "Staking" ; const STORAGE : & 'static str = "ErasStakers" ; type Value = runtime_types :: pallet_staking :: Exposure < :: subxt :: sp_core :: crypto :: AccountId32 , :: core :: primitive :: u128 > ; fn key (& self) -> :: subxt :: StorageEntryKey { :: subxt :: StorageEntryKey :: Map (vec ! [:: subxt :: StorageMapKey :: new (& self . 0 , :: subxt :: StorageHasher :: Twox64Concat) , :: subxt :: StorageMapKey :: new (& self . 1 , :: subxt :: StorageHasher :: Twox64Concat)]) } } pub struct ErasStakersClipped < 'a > (pub & 'a :: core :: primitive :: u32 , pub & 'a :: subxt :: sp_core :: crypto :: AccountId32) ; impl :: subxt :: StorageEntry for ErasStakersClipped < '_ > { const PALLET : & 'static str = "Staking" ; const STORAGE : & 'static str = "ErasStakersClipped" ; type Value = runtime_types :: pallet_staking :: Exposure < :: subxt :: sp_core :: crypto :: AccountId32 , :: core :: primitive :: u128 > ; fn key (& self) -> :: subxt :: StorageEntryKey { :: subxt :: StorageEntryKey :: Map (vec ! [:: subxt :: StorageMapKey :: new (& self . 0 , :: subxt :: StorageHasher :: Twox64Concat) , :: subxt :: StorageMapKey :: new (& self . 1 , :: subxt :: StorageHasher :: Twox64Concat)]) } } pub struct ErasValidatorPrefs < 'a > (pub & 'a :: core :: primitive :: u32 , pub & 'a :: subxt :: sp_core :: crypto :: AccountId32) ; impl :: subxt :: StorageEntry for ErasValidatorPrefs < '_ > { const PALLET : & 'static str = "Staking" ; const STORAGE : & 'static str = "ErasValidatorPrefs" ; type Value = runtime_types :: pallet_staking :: ValidatorPrefs ; fn key (& self) -> :: subxt :: StorageEntryKey { :: subxt :: StorageEntryKey :: Map (vec ! [:: subxt :: StorageMapKey :: new (& self . 0 , :: subxt :: StorageHasher :: Twox64Concat) , :: subxt :: StorageMapKey :: new (& self . 1 , :: subxt :: StorageHasher :: Twox64Concat)]) } } pub struct ErasValidatorReward < 'a > (pub & 'a :: core :: primitive :: u32) ; impl :: subxt :: StorageEntry for ErasValidatorReward < '_ > { const PALLET : & 'static str = "Staking" ; const STORAGE : & 'static str = "ErasValidatorReward" ; type Value = :: core :: primitive :: u128 ; fn key (& self) -> :: subxt :: StorageEntryKey { :: subxt :: StorageEntryKey :: Map (vec ! [:: subxt :: StorageMapKey :: new (& self . 0 , :: subxt :: StorageHasher :: Twox64Concat)]) } } pub struct ErasRewardPoints < 'a > (pub & 'a :: core :: primitive :: u32) ; impl :: subxt :: StorageEntry for ErasRewardPoints < '_ > { const PALLET : & 'static str = "Staking" ; const STORAGE : & 'static str = "ErasRewardPoints" ; type Value = runtime_types :: pallet_staking :: EraRewardPoints < :: subxt :: sp_core :: crypto :: AccountId32 > ; fn key (& self) -> :: subxt :: StorageEntryKey { :: subxt :: StorageEntryKey :: Map (vec ! [:: subxt :: StorageMapKey :: new (& self . 0 , :: subxt :: StorageHasher :: Twox64Concat)]) } } pub struct ErasTotalStake < 'a > (pub & 'a :: core :: primitive :: u32) ; impl :: subxt :: StorageEntry for ErasTotalStake < '_ > { const PALLET : & 'static str = "Staking" ; const STORAGE : & 'static str = "ErasTotalStake" ; type Value = :: core :: primitive :: u128 ; fn key (& self) -> :: subxt :: StorageEntryKey { :: subxt :: StorageEntryKey :: Map (vec ! [:: subxt :: StorageMapKey :: new (& self . 0 , :: subxt :: StorageHasher :: Twox64Concat)]) } } pub struct ForceEra ; impl :: subxt :: StorageEntry for ForceEra { const PALLET : & 'static str = "Staking" ; const STORAGE : & 'static str = "ForceEra" ; type Value = runtime_types :: pallet_staking :: Forcing ; fn key (& self) -> :: subxt :: StorageEntryKey { :: subxt :: StorageEntryKey :: Plain } } pub struct SlashRewardFraction ; impl :: subxt :: StorageEntry for SlashRewardFraction { const PALLET : & 'static str = "Staking" ; const STORAGE : & 'static str = "SlashRewardFraction" ; type Value = runtime_types :: sp_arithmetic :: per_things :: Perbill ; fn key (& self) -> :: subxt :: StorageEntryKey { :: subxt :: StorageEntryKey :: Plain } } pub struct CanceledSlashPayout ; impl :: subxt :: StorageEntry for CanceledSlashPayout { const PALLET : & 'static str = "Staking" ; const STORAGE : & 'static str = "CanceledSlashPayout" ; type Value = :: core :: primitive :: u128 ; fn key (& self) -> :: subxt :: StorageEntryKey { :: subxt :: StorageEntryKey :: Plain } } pub struct UnappliedSlashes < 'a > (pub & 'a :: core :: primitive :: u32) ; impl :: subxt :: StorageEntry for UnappliedSlashes < '_ > { const PALLET : & 'static str = "Staking" ; const STORAGE : & 'static str = "UnappliedSlashes" ; type Value = :: std :: vec :: Vec < runtime_types :: pallet_staking :: UnappliedSlash < :: subxt :: sp_core :: crypto :: AccountId32 , :: core :: primitive :: u128 > > ; fn key (& self) -> :: subxt :: StorageEntryKey { :: subxt :: StorageEntryKey :: Map (vec ! [:: subxt :: StorageMapKey :: new (& self . 0 , :: subxt :: StorageHasher :: Twox64Concat)]) } } pub struct BondedEras ; impl :: subxt :: StorageEntry for BondedEras { const PALLET : & 'static str = "Staking" ; const STORAGE : & 'static str = "BondedEras" ; type Value = :: std :: vec :: Vec < (:: core :: primitive :: u32 , :: core :: primitive :: u32 ,) > ; fn key (& self) -> :: subxt :: StorageEntryKey { :: subxt :: StorageEntryKey :: Plain } } pub struct ValidatorSlashInEra < 'a > (pub & 'a :: core :: primitive :: u32 , pub & 'a :: subxt :: sp_core :: crypto :: AccountId32) ; impl :: subxt :: StorageEntry for ValidatorSlashInEra < '_ > { const PALLET : & 'static str = "Staking" ; const STORAGE : & 'static str = "ValidatorSlashInEra" ; type Value = (runtime_types :: sp_arithmetic :: per_things :: Perbill , :: core :: primitive :: u128 ,) ; fn key (& self) -> :: subxt :: StorageEntryKey { :: subxt :: StorageEntryKey :: Map (vec ! [:: subxt :: StorageMapKey :: new (& self . 0 , :: subxt :: StorageHasher :: Twox64Concat) , :: subxt :: StorageMapKey :: new (& self . 1 , :: subxt :: StorageHasher :: Twox64Concat)]) } } pub struct NominatorSlashInEra < 'a > (pub & 'a :: core :: primitive :: u32 , pub & 'a :: subxt :: sp_core :: crypto :: AccountId32) ; impl :: subxt :: StorageEntry for NominatorSlashInEra < '_ > { const PALLET : & 'static str = "Staking" ; const STORAGE : & 'static str = "NominatorSlashInEra" ; type Value = :: core :: primitive :: u128 ; fn key (& self) -> :: subxt :: StorageEntryKey { :: subxt :: StorageEntryKey :: Map (vec ! [:: subxt :: StorageMapKey :: new (& self . 0 , :: subxt :: StorageHasher :: Twox64Concat) , :: subxt :: StorageMapKey :: new (& self . 1 , :: subxt :: StorageHasher :: Twox64Concat)]) } } pub struct SlashingSpans < 'a > (pub & 'a :: subxt :: sp_core :: crypto :: AccountId32) ; impl :: subxt :: StorageEntry for SlashingSpans < '_ > { const PALLET : & 'static str = "Staking" ; const STORAGE : & 'static str = "SlashingSpans" ; type Value = runtime_types :: pallet_staking :: slashing :: SlashingSpans ; fn key (& self) -> :: subxt :: StorageEntryKey { :: subxt :: StorageEntryKey :: Map (vec ! [:: subxt :: StorageMapKey :: new (& self . 0 , :: subxt :: StorageHasher :: Twox64Concat)]) } } pub struct SpanSlash < 'a > (pub & 'a :: subxt :: sp_core :: crypto :: AccountId32 , pub & 'a :: core :: primitive :: u32) ; impl :: subxt :: StorageEntry for SpanSlash < '_ > { const PALLET : & 'static str = "Staking" ; const STORAGE : & 'static str = "SpanSlash" ; type Value = runtime_types :: pallet_staking :: slashing :: SpanRecord < :: core :: primitive :: u128 > ; fn key (& self) -> :: subxt :: StorageEntryKey { :: subxt :: StorageEntryKey :: Map (vec ! [:: subxt :: StorageMapKey :: new (& (& self . 0 , & self . 1) , :: subxt :: StorageHasher :: Twox64Concat)]) } } pub struct EarliestUnappliedSlash ; impl :: subxt :: StorageEntry for EarliestUnappliedSlash { const PALLET : & 'static str = "Staking" ; const STORAGE : & 'static str = "EarliestUnappliedSlash" ; type Value = :: core :: primitive :: u32 ; fn key (& self) -> :: subxt :: StorageEntryKey { :: subxt :: StorageEntryKey :: Plain } } pub struct CurrentPlannedSession ; impl :: subxt :: StorageEntry for CurrentPlannedSession { const PALLET : & 'static str = "Staking" ; const STORAGE : & 'static str = "CurrentPlannedSession" ; type Value = :: core :: primitive :: u32 ; fn key (& self) -> :: subxt :: StorageEntryKey { :: subxt :: StorageEntryKey :: Plain } } pub struct OffendingValidators ; impl :: subxt :: StorageEntry for OffendingValidators { const PALLET : & 'static str = "Staking" ; const STORAGE : & 'static str = "OffendingValidators" ; type Value = :: std :: vec :: Vec < (:: core :: primitive :: u32 , :: core :: primitive :: bool ,) > ; fn key (& self) -> :: subxt :: StorageEntryKey { :: subxt :: StorageEntryKey :: Plain } } pub struct StorageVersion ; impl :: subxt :: StorageEntry for StorageVersion { const PALLET : & 'static str = "Staking" ; const STORAGE : & 'static str = "StorageVersion" ; type Value = runtime_types :: pallet_staking :: Releases ; fn key (& self) -> :: subxt :: StorageEntryKey { :: subxt :: StorageEntryKey :: Plain } } pub struct ChillThreshold ; impl :: subxt :: StorageEntry for ChillThreshold { const PALLET : & 'static str = "Staking" ; const STORAGE : & 'static str = "ChillThreshold" ; type Value = runtime_types :: sp_arithmetic :: per_things :: Percent ; fn key (& self) -> :: subxt :: StorageEntryKey { :: subxt :: StorageEntryKey :: Plain } } pub struct StorageApi < 'a , T : :: subxt :: Config > { client : & 'a :: subxt :: Client < T > , } impl < 'a , T : :: subxt :: Config > StorageApi < 'a , T > { pub fn new (client : & 'a :: subxt :: Client < T >) -> Self { Self { client } } # [doc = " Number of eras to keep in history."] # [doc = ""] # [doc = " Information is kept for eras in `[current_era - history_depth; current_era]`."] # [doc = ""] # [doc = " Must be more than the number of eras delayed by session otherwise. I.e. active era must"] # [doc = " always be in history. I.e. `active_era > current_era - history_depth` must be"] # [doc = " guaranteed."] pub async fn history_depth (& self , block_hash : :: core :: option :: Option < T :: Hash > ,) -> :: core :: result :: Result < :: core :: primitive :: u32 , :: subxt :: BasicError > { if self . client . metadata () . storage_hash :: < HistoryDepth > () ? == [41u8 , 54u8 , 118u8 , 245u8 , 75u8 , 136u8 , 220u8 , 25u8 , 55u8 , 255u8 , 149u8 , 177u8 , 49u8 , 155u8 , 167u8 , 188u8 , 170u8 , 29u8 , 251u8 , 44u8 , 240u8 , 250u8 , 225u8 , 205u8 , 102u8 , 74u8 , 25u8 , 47u8 , 52u8 , 235u8 , 204u8 , 167u8 ,] { let entry = HistoryDepth ; self . client . storage () . fetch_or_default (& entry , block_hash) . await } else { Err (:: subxt :: MetadataError :: IncompatibleMetadata . into ()) } } # [doc = " The ideal number of staking participants."] pub async fn validator_count (& self , block_hash : :: core :: option :: Option < T :: Hash > ,) -> :: core :: result :: Result < :: core :: primitive :: u32 , :: subxt :: BasicError > { if self . client . metadata () . storage_hash :: < ValidatorCount > () ? == [245u8 , 75u8 , 214u8 , 110u8 , 66u8 , 164u8 , 86u8 , 206u8 , 69u8 , 89u8 , 12u8 , 111u8 , 117u8 , 16u8 , 228u8 , 184u8 , 207u8 , 6u8 , 0u8 , 126u8 , 221u8 , 67u8 , 125u8 , 218u8 , 188u8 , 245u8 , 156u8 , 188u8 , 34u8 , 85u8 , 208u8 , 197u8 ,] { let entry = ValidatorCount ; self . client . storage () . fetch_or_default (& entry , block_hash) . await } else { Err (:: subxt :: MetadataError :: IncompatibleMetadata . into ()) } } # [doc = " Minimum number of staking participants before emergency conditions are imposed."] pub async fn minimum_validator_count (& self , block_hash : :: core :: option :: Option < T :: Hash > ,) -> :: core :: result :: Result < :: core :: primitive :: u32 , :: subxt :: BasicError > { if self . client . metadata () . storage_hash :: < MinimumValidatorCount > () ? == [82u8 , 95u8 , 128u8 , 55u8 , 136u8 , 134u8 , 71u8 , 117u8 , 135u8 , 76u8 , 44u8 , 46u8 , 174u8 , 34u8 , 170u8 , 228u8 , 175u8 , 1u8 , 234u8 , 162u8 , 91u8 , 252u8 , 127u8 , 68u8 , 243u8 , 241u8 , 13u8 , 107u8 , 214u8 , 70u8 , 87u8 , 249u8 ,] { let entry = MinimumValidatorCount ; self . client . storage () . fetch_or_default (& entry , block_hash) . await } else { Err (:: subxt :: MetadataError :: IncompatibleMetadata . into ()) } } # [doc = " Any validators that may never be slashed or forcibly kicked. It's a Vec since they're"] # [doc = " easy to initialize and the performance hit is minimal (we expect no more than four"] # [doc = " invulnerables) and restricted to testnets."] pub async fn invulnerables (& self , block_hash : :: core :: option :: Option < T :: Hash > ,) -> :: core :: result :: Result < :: std :: vec :: Vec < :: subxt :: sp_core :: crypto :: AccountId32 > , :: subxt :: BasicError > { if self . client . metadata () . storage_hash :: < Invulnerables > () ? == [103u8 , 93u8 , 29u8 , 166u8 , 244u8 , 19u8 , 78u8 , 182u8 , 235u8 , 37u8 , 199u8 , 127u8 , 211u8 , 124u8 , 168u8 , 145u8 , 111u8 , 251u8 , 33u8 , 36u8 , 167u8 , 119u8 , 124u8 , 206u8 , 205u8 , 14u8 , 186u8 , 68u8 , 16u8 , 150u8 , 45u8 , 158u8 ,] { let entry = Invulnerables ; self . client . storage () . fetch_or_default (& entry , block_hash) . await } else { Err (:: subxt :: MetadataError :: IncompatibleMetadata . into ()) } } # [doc = " Map from all locked \"stash\" accounts to the controller account."] pub async fn bonded (& self , _0 : & :: subxt :: sp_core :: crypto :: AccountId32 , block_hash : :: core :: option :: Option < T :: Hash > ,) -> :: core :: result :: Result < :: core :: option :: Option < :: subxt :: sp_core :: crypto :: AccountId32 > , :: subxt :: BasicError > { if self . client . metadata () . storage_hash :: < Bonded > () ? == [9u8 , 214u8 , 190u8 , 93u8 , 116u8 , 143u8 , 174u8 , 103u8 , 102u8 , 25u8 , 123u8 , 201u8 , 12u8 , 44u8 , 188u8 , 241u8 , 74u8 , 33u8 , 35u8 , 79u8 , 210u8 , 243u8 , 174u8 , 190u8 , 46u8 , 48u8 , 21u8 , 10u8 , 243u8 , 16u8 , 99u8 , 48u8 ,] { let entry = Bonded (_0) ; self . client . storage () . fetch (& entry , block_hash) . await } else { Err (:: subxt :: MetadataError :: IncompatibleMetadata . into ()) } } # [doc = " Map from all locked \"stash\" accounts to the controller account."] pub async fn bonded_iter (& self , block_hash : :: core :: option :: Option < T :: Hash > ,) -> :: core :: result :: Result < :: subxt :: KeyIter < 'a , T , Bonded < 'a > > , :: subxt :: BasicError > { if self . client . metadata () . storage_hash :: < Bonded > () ? == [9u8 , 214u8 , 190u8 , 93u8 , 116u8 , 143u8 , 174u8 , 103u8 , 102u8 , 25u8 , 123u8 , 201u8 , 12u8 , 44u8 , 188u8 , 241u8 , 74u8 , 33u8 , 35u8 , 79u8 , 210u8 , 243u8 , 174u8 , 190u8 , 46u8 , 48u8 , 21u8 , 10u8 , 243u8 , 16u8 , 99u8 , 48u8 ,] { self . client . storage () . iter (block_hash) . await } else { Err (:: subxt :: MetadataError :: IncompatibleMetadata . into ()) } } # [doc = " The minimum active bond to become and maintain the role of a nominator."] pub async fn min_nominator_bond (& self , block_hash : :: core :: option :: Option < T :: Hash > ,) -> :: core :: result :: Result < :: core :: primitive :: u128 , :: subxt :: BasicError > { if self . client . metadata () . storage_hash :: < MinNominatorBond > () ? == [187u8 , 66u8 , 149u8 , 226u8 , 72u8 , 219u8 , 57u8 , 246u8 , 102u8 , 47u8 , 71u8 , 12u8 , 219u8 , 204u8 , 127u8 , 223u8 , 58u8 , 134u8 , 81u8 , 165u8 , 200u8 , 142u8 , 196u8 , 158u8 , 26u8 , 38u8 , 165u8 , 19u8 , 91u8 , 251u8 , 119u8 , 84u8 ,] { let entry = MinNominatorBond ; self . client . storage () . fetch_or_default (& entry , block_hash) . await } else { Err (:: subxt :: MetadataError :: IncompatibleMetadata . into ()) } } # [doc = " The minimum active bond to become and maintain the role of a validator."] pub async fn min_validator_bond (& self , block_hash : :: core :: option :: Option < T :: Hash > ,) -> :: core :: result :: Result < :: core :: primitive :: u128 , :: subxt :: BasicError > { if self . client . metadata () . storage_hash :: < MinValidatorBond > () ? == [48u8 , 105u8 , 85u8 , 178u8 , 142u8 , 208u8 , 208u8 , 19u8 , 236u8 , 130u8 , 129u8 , 169u8 , 35u8 , 245u8 , 66u8 , 182u8 , 92u8 , 20u8 , 22u8 , 109u8 , 155u8 , 174u8 , 87u8 , 118u8 , 242u8 , 216u8 , 193u8 , 154u8 , 4u8 , 5u8 , 66u8 , 56u8 ,] { let entry = MinValidatorBond ; self . client . storage () . fetch_or_default (& entry , block_hash) . await } else { Err (:: subxt :: MetadataError :: IncompatibleMetadata . into ()) } } # [doc = " The minimum amount of commission that validators can set."] # [doc = ""] # [doc = " If set to `0`, no limit exists."] pub async fn min_commission (& self , block_hash : :: core :: option :: Option < T :: Hash > ,) -> :: core :: result :: Result < runtime_types :: sp_arithmetic :: per_things :: Perbill , :: subxt :: BasicError > { if self . client . metadata () . storage_hash :: < MinCommission > () ? == [198u8 , 29u8 , 53u8 , 56u8 , 181u8 , 170u8 , 164u8 , 240u8 , 27u8 , 171u8 , 69u8 , 57u8 , 151u8 , 40u8 , 23u8 , 166u8 , 157u8 , 68u8 , 208u8 , 20u8 , 2u8 , 78u8 , 63u8 , 235u8 , 166u8 , 50u8 , 3u8 , 246u8 , 237u8 , 146u8 , 170u8 , 91u8 ,] { let entry = MinCommission ; self . client . storage () . fetch_or_default (& entry , block_hash) . await } else { Err (:: subxt :: MetadataError :: IncompatibleMetadata . into ()) } } # [doc = " Map from all (unlocked) \"controller\" accounts to the info regarding the staking."] pub async fn ledger (& self , _0 : & :: subxt :: sp_core :: crypto :: AccountId32 , block_hash : :: core :: option :: Option < T :: Hash > ,) -> :: core :: result :: Result < :: core :: option :: Option < runtime_types :: pallet_staking :: StakingLedger > , :: subxt :: BasicError > { if self . client . metadata () . storage_hash :: < Ledger > () ? == [54u8 , 158u8 , 148u8 , 211u8 , 91u8 , 48u8 , 159u8 , 56u8 , 149u8 , 116u8 , 43u8 , 31u8 , 45u8 , 102u8 , 252u8 , 12u8 , 1u8 , 176u8 , 189u8 , 68u8 , 97u8 , 88u8 , 13u8 , 204u8 , 148u8 , 12u8 , 34u8 , 0u8 , 180u8 , 162u8 , 202u8 , 8u8 ,] { let entry = Ledger (_0) ; self . client . storage () . fetch (& entry , block_hash) . await } else { Err (:: subxt :: MetadataError :: IncompatibleMetadata . into ()) } } # [doc = " Map from all (unlocked) \"controller\" accounts to the info regarding the staking."] pub async fn ledger_iter (& self , block_hash : :: core :: option :: Option < T :: Hash > ,) -> :: core :: result :: Result < :: subxt :: KeyIter < 'a , T , Ledger < 'a > > , :: subxt :: BasicError > { if self . client . metadata () . storage_hash :: < Ledger > () ? == [54u8 , 158u8 , 148u8 , 211u8 , 91u8 , 48u8 , 159u8 , 56u8 , 149u8 , 116u8 , 43u8 , 31u8 , 45u8 , 102u8 , 252u8 , 12u8 , 1u8 , 176u8 , 189u8 , 68u8 , 97u8 , 88u8 , 13u8 , 204u8 , 148u8 , 12u8 , 34u8 , 0u8 , 180u8 , 162u8 , 202u8 , 8u8 ,] { self . client . storage () . iter (block_hash) . await } else { Err (:: subxt :: MetadataError :: IncompatibleMetadata . into ()) } } # [doc = " Where the reward payment should be made. Keyed by stash."] pub async fn payee (& self , _0 : & :: subxt :: sp_core :: crypto :: AccountId32 , block_hash : :: core :: option :: Option < T :: Hash > ,) -> :: core :: result :: Result < runtime_types :: pallet_staking :: RewardDestination < :: subxt :: sp_core :: crypto :: AccountId32 > , :: subxt :: BasicError > { if self . client . metadata () . storage_hash :: < Payee > () ? == [108u8 , 35u8 , 28u8 , 189u8 , 146u8 , 103u8 , 200u8 , 73u8 , 220u8 , 230u8 , 193u8 , 7u8 , 66u8 , 147u8 , 55u8 , 34u8 , 1u8 , 21u8 , 255u8 , 100u8 , 64u8 , 175u8 , 16u8 , 106u8 , 130u8 , 202u8 , 103u8 , 62u8 , 79u8 , 143u8 , 115u8 , 222u8 ,] { let entry = Payee (_0) ; self . client . storage () . fetch_or_default (& entry , block_hash) . await } else { Err (:: subxt :: MetadataError :: IncompatibleMetadata . into ()) } } # [doc = " Where the reward payment should be made. Keyed by stash."] pub async fn payee_iter (& self , block_hash : :: core :: option :: Option < T :: Hash > ,) -> :: core :: result :: Result < :: subxt :: KeyIter < 'a , T , Payee < 'a > > , :: subxt :: BasicError > { if self . client . metadata () . storage_hash :: < Payee > () ? == [108u8 , 35u8 , 28u8 , 189u8 , 146u8 , 103u8 , 200u8 , 73u8 , 220u8 , 230u8 , 193u8 , 7u8 , 66u8 , 147u8 , 55u8 , 34u8 , 1u8 , 21u8 , 255u8 , 100u8 , 64u8 , 175u8 , 16u8 , 106u8 , 130u8 , 202u8 , 103u8 , 62u8 , 79u8 , 143u8 , 115u8 , 222u8 ,] { self . client . storage () . iter (block_hash) . await } else { Err (:: subxt :: MetadataError :: IncompatibleMetadata . into ()) } } # [doc = " The map from (wannabe) validator stash key to the preferences of that validator."] pub async fn validators (& self , _0 : & :: subxt :: sp_core :: crypto :: AccountId32 , block_hash : :: core :: option :: Option < T :: Hash > ,) -> :: core :: result :: Result < runtime_types :: pallet_staking :: ValidatorPrefs , :: subxt :: BasicError > { if self . client . metadata () . storage_hash :: < Validators > () ? == [45u8 , 57u8 , 106u8 , 30u8 , 123u8 , 251u8 , 148u8 , 37u8 , 52u8 , 129u8 , 103u8 , 88u8 , 54u8 , 216u8 , 174u8 , 181u8 , 51u8 , 181u8 , 70u8 , 6u8 , 136u8 , 7u8 , 239u8 , 44u8 , 83u8 , 153u8 , 124u8 , 187u8 , 225u8 , 112u8 , 23u8 , 76u8 ,] { let entry = Validators (_0) ; self . client . storage () . fetch_or_default (& entry , block_hash) . await } else { Err (:: subxt :: MetadataError :: IncompatibleMetadata . into ()) } } # [doc = " The map from (wannabe) validator stash key to the preferences of that validator."] pub async fn validators_iter (& self , block_hash : :: core :: option :: Option < T :: Hash > ,) -> :: core :: result :: Result < :: subxt :: KeyIter < 'a , T , Validators < 'a > > , :: subxt :: BasicError > { if self . client . metadata () . storage_hash :: < Validators > () ? == [45u8 , 57u8 , 106u8 , 30u8 , 123u8 , 251u8 , 148u8 , 37u8 , 52u8 , 129u8 , 103u8 , 88u8 , 54u8 , 216u8 , 174u8 , 181u8 , 51u8 , 181u8 , 70u8 , 6u8 , 136u8 , 7u8 , 239u8 , 44u8 , 83u8 , 153u8 , 124u8 , 187u8 , 225u8 , 112u8 , 23u8 , 76u8 ,] { self . client . storage () . iter (block_hash) . await } else { Err (:: subxt :: MetadataError :: IncompatibleMetadata . into ()) } } # [doc = "Counter for the related counted storage map"] pub async fn counter_for_validators (& self , block_hash : :: core :: option :: Option < T :: Hash > ,) -> :: core :: result :: Result < :: core :: primitive :: u32 , :: subxt :: BasicError > { if self . client . metadata () . storage_hash :: < CounterForValidators > () ? == [139u8 , 25u8 , 223u8 , 6u8 , 160u8 , 239u8 , 212u8 , 85u8 , 36u8 , 185u8 , 69u8 , 63u8 , 21u8 , 156u8 , 144u8 , 241u8 , 112u8 , 85u8 , 49u8 , 78u8 , 88u8 , 11u8 , 8u8 , 48u8 , 118u8 , 34u8 , 62u8 , 159u8 , 239u8 , 122u8 , 90u8 , 45u8 ,] { let entry = CounterForValidators ; self . client . storage () . fetch_or_default (& entry , block_hash) . await } else { Err (:: subxt :: MetadataError :: IncompatibleMetadata . into ()) } } # [doc = " The maximum validator count before we stop allowing new validators to join."] # [doc = ""] # [doc = " When this value is not set, no limits are enforced."] pub async fn max_validators_count (& self , block_hash : :: core :: option :: Option < T :: Hash > ,) -> :: core :: result :: Result < :: core :: option :: Option < :: core :: primitive :: u32 > , :: subxt :: BasicError > { if self . client . metadata () . storage_hash :: < MaxValidatorsCount > () ? == [250u8 , 62u8 , 16u8 , 68u8 , 192u8 , 216u8 , 236u8 , 211u8 , 217u8 , 9u8 , 213u8 , 49u8 , 41u8 , 37u8 , 58u8 , 62u8 , 131u8 , 112u8 , 64u8 , 26u8 , 133u8 , 7u8 , 130u8 , 1u8 , 71u8 , 158u8 , 14u8 , 55u8 , 169u8 , 239u8 , 223u8 , 245u8 ,] { let entry = MaxValidatorsCount ; self . client . storage () . fetch (& entry , block_hash) . await } else { Err (:: subxt :: MetadataError :: IncompatibleMetadata . into ()) } } # [doc = " The map from nominator stash key to their nomination preferences, namely the validators that"] # [doc = " they wish to support."] # [doc = ""] # [doc = " Note that the keys of this storage map might become non-decodable in case the"] # [doc = " [`Config::MaxNominations`] configuration is decreased. In this rare case, these nominators"] # [doc = " are still existent in storage, their key is correct and retrievable (i.e. `contains_key`"] # [doc = " indicates that they exist), but their value cannot be decoded. Therefore, the non-decodable"] # [doc = " nominators will effectively not-exist, until they re-submit their preferences such that it"] # [doc = " is within the bounds of the newly set `Config::MaxNominations`."] # [doc = ""] # [doc = " This implies that `::iter_keys().count()` and `::iter().count()` might return different"] # [doc = " values for this map. Moreover, the main `::count()` is aligned with the former, namely the"] # [doc = " number of keys that exist."] # [doc = ""] # [doc = " Lastly, if any of the nominators become non-decodable, they can be chilled immediately via"] # [doc = " [`Call::chill_other`] dispatchable by anyone."] pub async fn nominators (& self , _0 : & :: subxt :: sp_core :: crypto :: AccountId32 , block_hash : :: core :: option :: Option < T :: Hash > ,) -> :: core :: result :: Result < :: core :: option :: Option < runtime_types :: pallet_staking :: Nominations > , :: subxt :: BasicError > { if self . client . metadata () . storage_hash :: < Nominators > () ? == [176u8 , 26u8 , 169u8 , 68u8 , 99u8 , 216u8 , 95u8 , 198u8 , 5u8 , 123u8 , 21u8 , 83u8 , 220u8 , 140u8 , 122u8 , 111u8 , 22u8 , 133u8 , 9u8 , 155u8 , 35u8 , 58u8 , 232u8 , 143u8 , 62u8 , 229u8 , 228u8 , 98u8 , 175u8 , 114u8 , 152u8 , 253u8 ,] { let entry = Nominators (_0) ; self . client . storage () . fetch (& entry , block_hash) . await } else { Err (:: subxt :: MetadataError :: IncompatibleMetadata . into ()) } } # [doc = " The map from nominator stash key to their nomination preferences, namely the validators that"] # [doc = " they wish to support."] # [doc = ""] # [doc = " Note that the keys of this storage map might become non-decodable in case the"] # [doc = " [`Config::MaxNominations`] configuration is decreased. In this rare case, these nominators"] # [doc = " are still existent in storage, their key is correct and retrievable (i.e. `contains_key`"] # [doc = " indicates that they exist), but their value cannot be decoded. Therefore, the non-decodable"] # [doc = " nominators will effectively not-exist, until they re-submit their preferences such that it"] # [doc = " is within the bounds of the newly set `Config::MaxNominations`."] # [doc = ""] # [doc = " This implies that `::iter_keys().count()` and `::iter().count()` might return different"] # [doc = " values for this map. Moreover, the main `::count()` is aligned with the former, namely the"] # [doc = " number of keys that exist."] # [doc = ""] # [doc = " Lastly, if any of the nominators become non-decodable, they can be chilled immediately via"] # [doc = " [`Call::chill_other`] dispatchable by anyone."] pub async fn nominators_iter (& self , block_hash : :: core :: option :: Option < T :: Hash > ,) -> :: core :: result :: Result < :: subxt :: KeyIter < 'a , T , Nominators < 'a > > , :: subxt :: BasicError > { if self . client . metadata () . storage_hash :: < Nominators > () ? == [176u8 , 26u8 , 169u8 , 68u8 , 99u8 , 216u8 , 95u8 , 198u8 , 5u8 , 123u8 , 21u8 , 83u8 , 220u8 , 140u8 , 122u8 , 111u8 , 22u8 , 133u8 , 9u8 , 155u8 , 35u8 , 58u8 , 232u8 , 143u8 , 62u8 , 229u8 , 228u8 , 98u8 , 175u8 , 114u8 , 152u8 , 253u8 ,] { self . client . storage () . iter (block_hash) . await } else { Err (:: subxt :: MetadataError :: IncompatibleMetadata . into ()) } } # [doc = "Counter for the related counted storage map"] pub async fn counter_for_nominators (& self , block_hash : :: core :: option :: Option < T :: Hash > ,) -> :: core :: result :: Result < :: core :: primitive :: u32 , :: subxt :: BasicError > { if self . client . metadata () . storage_hash :: < CounterForNominators > () ? == [31u8 , 94u8 , 130u8 , 138u8 , 75u8 , 8u8 , 38u8 , 162u8 , 181u8 , 5u8 , 125u8 , 116u8 , 9u8 , 51u8 , 22u8 , 234u8 , 40u8 , 117u8 , 215u8 , 46u8 , 82u8 , 117u8 , 225u8 , 1u8 , 9u8 , 208u8 , 83u8 , 63u8 , 39u8 , 187u8 , 207u8 , 191u8 ,] { let entry = CounterForNominators ; self . client . storage () . fetch_or_default (& entry , block_hash) . await } else { Err (:: subxt :: MetadataError :: IncompatibleMetadata . into ()) } } # [doc = " The maximum nominator count before we stop allowing new validators to join."] # [doc = ""] # [doc = " When this value is not set, no limits are enforced."] pub async fn max_nominators_count (& self , block_hash : :: core :: option :: Option < T :: Hash > ,) -> :: core :: result :: Result < :: core :: option :: Option < :: core :: primitive :: u32 > , :: subxt :: BasicError > { if self . client . metadata () . storage_hash :: < MaxNominatorsCount > () ? == [180u8 , 190u8 , 180u8 , 66u8 , 235u8 , 173u8 , 76u8 , 160u8 , 197u8 , 92u8 , 96u8 , 165u8 , 220u8 , 188u8 , 32u8 , 119u8 , 3u8 , 73u8 , 86u8 , 49u8 , 104u8 , 17u8 , 186u8 , 98u8 , 221u8 , 175u8 , 109u8 , 254u8 , 207u8 , 245u8 , 125u8 , 179u8 ,] { let entry = MaxNominatorsCount ; self . client . storage () . fetch (& entry , block_hash) . await } else { Err (:: subxt :: MetadataError :: IncompatibleMetadata . into ()) } } # [doc = " The current era index."] # [doc = ""] # [doc = " This is the latest planned era, depending on how the Session pallet queues the validator"] # [doc = " set, it might be active or not."] pub async fn current_era (& self , block_hash : :: core :: option :: Option < T :: Hash > ,) -> :: core :: result :: Result < :: core :: option :: Option < :: core :: primitive :: u32 > , :: subxt :: BasicError > { if self . client . metadata () . storage_hash :: < CurrentEra > () ? == [105u8 , 150u8 , 49u8 , 122u8 , 4u8 , 78u8 , 8u8 , 121u8 , 34u8 , 136u8 , 157u8 , 227u8 , 59u8 , 139u8 , 7u8 , 253u8 , 7u8 , 10u8 , 117u8 , 71u8 , 240u8 , 74u8 , 86u8 , 36u8 , 198u8 , 37u8 , 153u8 , 93u8 , 196u8 , 22u8 , 192u8 , 243u8 ,] { let entry = CurrentEra ; self . client . storage () . fetch (& entry , block_hash) . await } else { Err (:: subxt :: MetadataError :: IncompatibleMetadata . into ()) } } # [doc = " The active era information, it holds index and start."] # [doc = ""] # [doc = " The active era is the era being currently rewarded. Validator set of this era must be"] # [doc = " equal to [`SessionInterface::validators`]."] pub async fn active_era (& self , block_hash : :: core :: option :: Option < T :: Hash > ,) -> :: core :: result :: Result < :: core :: option :: Option < runtime_types :: pallet_staking :: ActiveEraInfo > , :: subxt :: BasicError > { if self . client . metadata () . storage_hash :: < ActiveEra > () ? == [230u8 , 144u8 , 49u8 , 201u8 , 36u8 , 253u8 , 97u8 , 135u8 , 57u8 , 169u8 , 157u8 , 138u8 , 21u8 , 35u8 , 14u8 , 2u8 , 151u8 , 214u8 , 176u8 , 211u8 , 48u8 , 105u8 , 38u8 , 123u8 , 98u8 , 255u8 , 14u8 , 35u8 , 177u8 , 247u8 , 31u8 , 28u8 ,] { let entry = ActiveEra ; self . client . storage () . fetch (& entry , block_hash) . await } else { Err (:: subxt :: MetadataError :: IncompatibleMetadata . into ()) } } # [doc = " The session index at which the era start for the last `HISTORY_DEPTH` eras."] # [doc = ""] # [doc = " Note: This tracks the starting session (i.e. session index when era start being active)"] # [doc = " for the eras in `[CurrentEra - HISTORY_DEPTH, CurrentEra]`."] pub async fn eras_start_session_index (& self , _0 : & :: core :: primitive :: u32 , block_hash : :: core :: option :: Option < T :: Hash > ,) -> :: core :: result :: Result < :: core :: option :: Option < :: core :: primitive :: u32 > , :: subxt :: BasicError > { if self . client . metadata () . storage_hash :: < ErasStartSessionIndex > () ? == [92u8 , 157u8 , 168u8 , 144u8 , 132u8 , 3u8 , 212u8 , 80u8 , 230u8 , 229u8 , 251u8 , 218u8 , 97u8 , 55u8 , 79u8 , 100u8 , 163u8 , 91u8 , 32u8 , 246u8 , 122u8 , 78u8 , 149u8 , 214u8 , 103u8 , 249u8 , 119u8 , 20u8 , 101u8 , 116u8 , 110u8 , 185u8 ,] { let entry = ErasStartSessionIndex (_0) ; self . client . storage () . fetch (& entry , block_hash) . await } else { Err (:: subxt :: MetadataError :: IncompatibleMetadata . into ()) } } # [doc = " The session index at which the era start for the last `HISTORY_DEPTH` eras."] # [doc = ""] # [doc = " Note: This tracks the starting session (i.e. session index when era start being active)"] # [doc = " for the eras in `[CurrentEra - HISTORY_DEPTH, CurrentEra]`."] pub async fn eras_start_session_index_iter (& self , block_hash : :: core :: option :: Option < T :: Hash > ,) -> :: core :: result :: Result < :: subxt :: KeyIter < 'a , T , ErasStartSessionIndex < 'a > > , :: subxt :: BasicError > { if self . client . metadata () . storage_hash :: < ErasStartSessionIndex > () ? == [92u8 , 157u8 , 168u8 , 144u8 , 132u8 , 3u8 , 212u8 , 80u8 , 230u8 , 229u8 , 251u8 , 218u8 , 97u8 , 55u8 , 79u8 , 100u8 , 163u8 , 91u8 , 32u8 , 246u8 , 122u8 , 78u8 , 149u8 , 214u8 , 103u8 , 249u8 , 119u8 , 20u8 , 101u8 , 116u8 , 110u8 , 185u8 ,] { self . client . storage () . iter (block_hash) . await } else { Err (:: subxt :: MetadataError :: IncompatibleMetadata . into ()) } } # [doc = " Exposure of validator at era."] # [doc = ""] # [doc = " This is keyed first by the era index to allow bulk deletion and then the stash account."] # [doc = ""] # [doc = " Is it removed after `HISTORY_DEPTH` eras."] # [doc = " If stakers hasn't been set or has been removed then empty exposure is returned."] pub async fn eras_stakers (& self , _0 : & :: core :: primitive :: u32 , _1 : & :: subxt :: sp_core :: crypto :: AccountId32 , block_hash : :: core :: option :: Option < T :: Hash > ,) -> :: core :: result :: Result < runtime_types :: pallet_staking :: Exposure < :: subxt :: sp_core :: crypto :: AccountId32 , :: core :: primitive :: u128 > , :: subxt :: BasicError > { if self . client . metadata () . storage_hash :: < ErasStakers > () ? == [176u8 , 250u8 , 76u8 , 183u8 , 219u8 , 180u8 , 156u8 , 138u8 , 111u8 , 153u8 , 154u8 , 90u8 , 14u8 , 194u8 , 56u8 , 133u8 , 197u8 , 199u8 , 35u8 , 20u8 , 188u8 , 129u8 , 169u8 , 38u8 , 10u8 , 219u8 , 186u8 , 107u8 , 179u8 , 160u8 , 244u8 , 210u8 ,] { let entry = ErasStakers (_0 , _1) ; self . client . storage () . fetch_or_default (& entry , block_hash) . await } else { Err (:: subxt :: MetadataError :: IncompatibleMetadata . into ()) } } # [doc = " Exposure of validator at era."] # [doc = ""] # [doc = " This is keyed first by the era index to allow bulk deletion and then the stash account."] # [doc = ""] # [doc = " Is it removed after `HISTORY_DEPTH` eras."] # [doc = " If stakers hasn't been set or has been removed then empty exposure is returned."] pub async fn eras_stakers_iter (& self , block_hash : :: core :: option :: Option < T :: Hash > ,) -> :: core :: result :: Result < :: subxt :: KeyIter < 'a , T , ErasStakers < 'a > > , :: subxt :: BasicError > { if self . client . metadata () . storage_hash :: < ErasStakers > () ? == [176u8 , 250u8 , 76u8 , 183u8 , 219u8 , 180u8 , 156u8 , 138u8 , 111u8 , 153u8 , 154u8 , 90u8 , 14u8 , 194u8 , 56u8 , 133u8 , 197u8 , 199u8 , 35u8 , 20u8 , 188u8 , 129u8 , 169u8 , 38u8 , 10u8 , 219u8 , 186u8 , 107u8 , 179u8 , 160u8 , 244u8 , 210u8 ,] { self . client . storage () . iter (block_hash) . await } else { Err (:: subxt :: MetadataError :: IncompatibleMetadata . into ()) } } # [doc = " Clipped Exposure of validator at era."] # [doc = ""] # [doc = " This is similar to [`ErasStakers`] but number of nominators exposed is reduced to the"] # [doc = " `T::MaxNominatorRewardedPerValidator` biggest stakers."] # [doc = " (Note: the field `total` and `own` of the exposure remains unchanged)."] # [doc = " This is used to limit the i/o cost for the nominator payout."] # [doc = ""] # [doc = " This is keyed fist by the era index to allow bulk deletion and then the stash account."] # [doc = ""] # [doc = " Is it removed after `HISTORY_DEPTH` eras."] # [doc = " If stakers hasn't been set or has been removed then empty exposure is returned."] pub async fn eras_stakers_clipped (& self , _0 : & :: core :: primitive :: u32 , _1 : & :: subxt :: sp_core :: crypto :: AccountId32 , block_hash : :: core :: option :: Option < T :: Hash > ,) -> :: core :: result :: Result < runtime_types :: pallet_staking :: Exposure < :: subxt :: sp_core :: crypto :: AccountId32 , :: core :: primitive :: u128 > , :: subxt :: BasicError > { if self . client . metadata () . storage_hash :: < ErasStakersClipped > () ? == [91u8 , 87u8 , 165u8 , 255u8 , 253u8 , 169u8 , 48u8 , 28u8 , 254u8 , 124u8 , 93u8 , 108u8 , 252u8 , 15u8 , 141u8 , 139u8 , 152u8 , 118u8 , 226u8 , 122u8 , 178u8 , 110u8 , 4u8 , 242u8 , 62u8 , 77u8 , 157u8 , 122u8 , 149u8 , 225u8 , 201u8 , 231u8 ,] { let entry = ErasStakersClipped (_0 , _1) ; self . client . storage () . fetch_or_default (& entry , block_hash) . await } else { Err (:: subxt :: MetadataError :: IncompatibleMetadata . into ()) } } # [doc = " Clipped Exposure of validator at era."] # [doc = ""] # [doc = " This is similar to [`ErasStakers`] but number of nominators exposed is reduced to the"] # [doc = " `T::MaxNominatorRewardedPerValidator` biggest stakers."] # [doc = " (Note: the field `total` and `own` of the exposure remains unchanged)."] # [doc = " This is used to limit the i/o cost for the nominator payout."] # [doc = ""] # [doc = " This is keyed fist by the era index to allow bulk deletion and then the stash account."] # [doc = ""] # [doc = " Is it removed after `HISTORY_DEPTH` eras."] # [doc = " If stakers hasn't been set or has been removed then empty exposure is returned."] pub async fn eras_stakers_clipped_iter (& self , block_hash : :: core :: option :: Option < T :: Hash > ,) -> :: core :: result :: Result < :: subxt :: KeyIter < 'a , T , ErasStakersClipped < 'a > > , :: subxt :: BasicError > { if self . client . metadata () . storage_hash :: < ErasStakersClipped > () ? == [91u8 , 87u8 , 165u8 , 255u8 , 253u8 , 169u8 , 48u8 , 28u8 , 254u8 , 124u8 , 93u8 , 108u8 , 252u8 , 15u8 , 141u8 , 139u8 , 152u8 , 118u8 , 226u8 , 122u8 , 178u8 , 110u8 , 4u8 , 242u8 , 62u8 , 77u8 , 157u8 , 122u8 , 149u8 , 225u8 , 201u8 , 231u8 ,] { self . client . storage () . iter (block_hash) . await } else { Err (:: subxt :: MetadataError :: IncompatibleMetadata . into ()) } } # [doc = " Similar to `ErasStakers`, this holds the preferences of validators."] # [doc = ""] # [doc = " This is keyed first by the era index to allow bulk deletion and then the stash account."] # [doc = ""] # [doc = " Is it removed after `HISTORY_DEPTH` eras."] pub async fn eras_validator_prefs (& self , _0 : & :: core :: primitive :: u32 , _1 : & :: subxt :: sp_core :: crypto :: AccountId32 , block_hash : :: core :: option :: Option < T :: Hash > ,) -> :: core :: result :: Result < runtime_types :: pallet_staking :: ValidatorPrefs , :: subxt :: BasicError > { if self . client . metadata () . storage_hash :: < ErasValidatorPrefs > () ? == [8u8 , 55u8 , 222u8 , 216u8 , 126u8 , 126u8 , 131u8 , 18u8 , 145u8 , 58u8 , 91u8 , 123u8 , 92u8 , 19u8 , 178u8 , 200u8 , 133u8 , 140u8 , 3u8 , 207u8 , 101u8 , 70u8 , 204u8 , 172u8 , 98u8 , 137u8 , 149u8 , 74u8 , 99u8 , 141u8 , 150u8 , 228u8 ,] { let entry = ErasValidatorPrefs (_0 , _1) ; self . client . storage () . fetch_or_default (& entry , block_hash) . await } else { Err (:: subxt :: MetadataError :: IncompatibleMetadata . into ()) } } # [doc = " Similar to `ErasStakers`, this holds the preferences of validators."] # [doc = ""] # [doc = " This is keyed first by the era index to allow bulk deletion and then the stash account."] # [doc = ""] # [doc = " Is it removed after `HISTORY_DEPTH` eras."] pub async fn eras_validator_prefs_iter (& self , block_hash : :: core :: option :: Option < T :: Hash > ,) -> :: core :: result :: Result < :: subxt :: KeyIter < 'a , T , ErasValidatorPrefs < 'a > > , :: subxt :: BasicError > { if self . client . metadata () . storage_hash :: < ErasValidatorPrefs > () ? == [8u8 , 55u8 , 222u8 , 216u8 , 126u8 , 126u8 , 131u8 , 18u8 , 145u8 , 58u8 , 91u8 , 123u8 , 92u8 , 19u8 , 178u8 , 200u8 , 133u8 , 140u8 , 3u8 , 207u8 , 101u8 , 70u8 , 204u8 , 172u8 , 98u8 , 137u8 , 149u8 , 74u8 , 99u8 , 141u8 , 150u8 , 228u8 ,] { self . client . storage () . iter (block_hash) . await } else { Err (:: subxt :: MetadataError :: IncompatibleMetadata . into ()) } } # [doc = " The total validator era payout for the last `HISTORY_DEPTH` eras."] # [doc = ""] # [doc = " Eras that haven't finished yet or has been removed doesn't have reward."] pub async fn eras_validator_reward (& self , _0 : & :: core :: primitive :: u32 , block_hash : :: core :: option :: Option < T :: Hash > ,) -> :: core :: result :: Result < :: core :: option :: Option < :: core :: primitive :: u128 > , :: subxt :: BasicError > { if self . client . metadata () . storage_hash :: < ErasValidatorReward > () ? == [87u8 , 80u8 , 156u8 , 123u8 , 107u8 , 77u8 , 203u8 , 37u8 , 231u8 , 84u8 , 124u8 , 155u8 , 227u8 , 212u8 , 212u8 , 179u8 , 84u8 , 161u8 , 223u8 , 255u8 , 254u8 , 107u8 , 52u8 , 89u8 , 98u8 , 169u8 , 136u8 , 241u8 , 104u8 , 3u8 , 244u8 , 161u8 ,] { let entry = ErasValidatorReward (_0) ; self . client . storage () . fetch (& entry , block_hash) . await } else { Err (:: subxt :: MetadataError :: IncompatibleMetadata . into ()) } } # [doc = " The total validator era payout for the last `HISTORY_DEPTH` eras."] # [doc = ""] # [doc = " Eras that haven't finished yet or has been removed doesn't have reward."] pub async fn eras_validator_reward_iter (& self , block_hash : :: core :: option :: Option < T :: Hash > ,) -> :: core :: result :: Result < :: subxt :: KeyIter < 'a , T , ErasValidatorReward < 'a > > , :: subxt :: BasicError > { if self . client . metadata () . storage_hash :: < ErasValidatorReward > () ? == [87u8 , 80u8 , 156u8 , 123u8 , 107u8 , 77u8 , 203u8 , 37u8 , 231u8 , 84u8 , 124u8 , 155u8 , 227u8 , 212u8 , 212u8 , 179u8 , 84u8 , 161u8 , 223u8 , 255u8 , 254u8 , 107u8 , 52u8 , 89u8 , 98u8 , 169u8 , 136u8 , 241u8 , 104u8 , 3u8 , 244u8 , 161u8 ,] { self . client . storage () . iter (block_hash) . await } else { Err (:: subxt :: MetadataError :: IncompatibleMetadata . into ()) } } # [doc = " Rewards for the last `HISTORY_DEPTH` eras."] # [doc = " If reward hasn't been set or has been removed then 0 reward is returned."] pub async fn eras_reward_points (& self , _0 : & :: core :: primitive :: u32 , block_hash : :: core :: option :: Option < T :: Hash > ,) -> :: core :: result :: Result < runtime_types :: pallet_staking :: EraRewardPoints < :: subxt :: sp_core :: crypto :: AccountId32 > , :: subxt :: BasicError > { if self . client . metadata () . storage_hash :: < ErasRewardPoints > () ? == [76u8 , 221u8 , 158u8 , 62u8 , 3u8 , 254u8 , 139u8 , 170u8 , 103u8 , 218u8 , 191u8 , 103u8 , 57u8 , 212u8 , 208u8 , 7u8 , 105u8 , 52u8 , 117u8 , 173u8 , 8u8 , 34u8 , 82u8 , 141u8 , 51u8 , 72u8 , 243u8 , 56u8 , 206u8 , 206u8 , 48u8 , 140u8 ,] { let entry = ErasRewardPoints (_0) ; self . client . storage () . fetch_or_default (& entry , block_hash) . await } else { Err (:: subxt :: MetadataError :: IncompatibleMetadata . into ()) } } # [doc = " Rewards for the last `HISTORY_DEPTH` eras."] # [doc = " If reward hasn't been set or has been removed then 0 reward is returned."] pub async fn eras_reward_points_iter (& self , block_hash : :: core :: option :: Option < T :: Hash > ,) -> :: core :: result :: Result < :: subxt :: KeyIter < 'a , T , ErasRewardPoints < 'a > > , :: subxt :: BasicError > { if self . client . metadata () . storage_hash :: < ErasRewardPoints > () ? == [76u8 , 221u8 , 158u8 , 62u8 , 3u8 , 254u8 , 139u8 , 170u8 , 103u8 , 218u8 , 191u8 , 103u8 , 57u8 , 212u8 , 208u8 , 7u8 , 105u8 , 52u8 , 117u8 , 173u8 , 8u8 , 34u8 , 82u8 , 141u8 , 51u8 , 72u8 , 243u8 , 56u8 , 206u8 , 206u8 , 48u8 , 140u8 ,] { self . client . storage () . iter (block_hash) . await } else { Err (:: subxt :: MetadataError :: IncompatibleMetadata . into ()) } } # [doc = " The total amount staked for the last `HISTORY_DEPTH` eras."] # [doc = " If total hasn't been set or has been removed then 0 stake is returned."] pub async fn eras_total_stake (& self , _0 : & :: core :: primitive :: u32 , block_hash : :: core :: option :: Option < T :: Hash > ,) -> :: core :: result :: Result < :: core :: primitive :: u128 , :: subxt :: BasicError > { if self . client . metadata () . storage_hash :: < ErasTotalStake > () ? == [224u8 , 240u8 , 168u8 , 69u8 , 148u8 , 140u8 , 249u8 , 240u8 , 4u8 , 46u8 , 77u8 , 11u8 , 224u8 , 65u8 , 26u8 , 239u8 , 1u8 , 110u8 , 53u8 , 11u8 , 247u8 , 235u8 , 142u8 , 234u8 , 22u8 , 43u8 , 24u8 , 36u8 , 37u8 , 43u8 , 170u8 , 40u8 ,] { let entry = ErasTotalStake (_0) ; self . client . storage () . fetch_or_default (& entry , block_hash) . await } else { Err (:: subxt :: MetadataError :: IncompatibleMetadata . into ()) } } # [doc = " The total amount staked for the last `HISTORY_DEPTH` eras."] # [doc = " If total hasn't been set or has been removed then 0 stake is returned."] pub async fn eras_total_stake_iter (& self , block_hash : :: core :: option :: Option < T :: Hash > ,) -> :: core :: result :: Result < :: subxt :: KeyIter < 'a , T , ErasTotalStake < 'a > > , :: subxt :: BasicError > { if self . client . metadata () . storage_hash :: < ErasTotalStake > () ? == [224u8 , 240u8 , 168u8 , 69u8 , 148u8 , 140u8 , 249u8 , 240u8 , 4u8 , 46u8 , 77u8 , 11u8 , 224u8 , 65u8 , 26u8 , 239u8 , 1u8 , 110u8 , 53u8 , 11u8 , 247u8 , 235u8 , 142u8 , 234u8 , 22u8 , 43u8 , 24u8 , 36u8 , 37u8 , 43u8 , 170u8 , 40u8 ,] { self . client . storage () . iter (block_hash) . await } else { Err (:: subxt :: MetadataError :: IncompatibleMetadata . into ()) } } # [doc = " Mode of era forcing."] pub async fn force_era (& self , block_hash : :: core :: option :: Option < T :: Hash > ,) -> :: core :: result :: Result < runtime_types :: pallet_staking :: Forcing , :: subxt :: BasicError > { if self . client . metadata () . storage_hash :: < ForceEra > () ? == [221u8 , 41u8 , 71u8 , 21u8 , 28u8 , 193u8 , 65u8 , 97u8 , 103u8 , 37u8 , 145u8 , 146u8 , 183u8 , 194u8 , 57u8 , 131u8 , 214u8 , 136u8 , 68u8 , 156u8 , 140u8 , 194u8 , 69u8 , 151u8 , 115u8 , 177u8 , 92u8 , 147u8 , 29u8 , 40u8 , 41u8 , 31u8 ,] { let entry = ForceEra ; self . client . storage () . fetch_or_default (& entry , block_hash) . await } else { Err (:: subxt :: MetadataError :: IncompatibleMetadata . into ()) } } # [doc = " The percentage of the slash that is distributed to reporters."] # [doc = ""] # [doc = " The rest of the slashed value is handled by the `Slash`."] pub async fn slash_reward_fraction (& self , block_hash : :: core :: option :: Option < T :: Hash > ,) -> :: core :: result :: Result < runtime_types :: sp_arithmetic :: per_things :: Perbill , :: subxt :: BasicError > { if self . client . metadata () . storage_hash :: < SlashRewardFraction > () ? == [92u8 , 55u8 , 255u8 , 233u8 , 174u8 , 125u8 , 32u8 , 21u8 , 78u8 , 237u8 , 123u8 , 241u8 , 113u8 , 243u8 , 48u8 , 101u8 , 190u8 , 165u8 , 216u8 , 134u8 , 35u8 , 128u8 , 7u8 , 207u8 , 48u8 , 92u8 , 116u8 , 179u8 , 253u8 , 14u8 , 87u8 , 176u8 ,] { let entry = SlashRewardFraction ; self . client . storage () . fetch_or_default (& entry , block_hash) . await } else { Err (:: subxt :: MetadataError :: IncompatibleMetadata . into ()) } } # [doc = " The amount of currency given to reporters of a slash event which was"] # [doc = " canceled by extraordinary circumstances (e.g. governance)."] pub async fn canceled_slash_payout (& self , block_hash : :: core :: option :: Option < T :: Hash > ,) -> :: core :: result :: Result < :: core :: primitive :: u128 , :: subxt :: BasicError > { if self . client . metadata () . storage_hash :: < CanceledSlashPayout > () ? == [126u8 , 218u8 , 66u8 , 92u8 , 82u8 , 124u8 , 145u8 , 161u8 , 40u8 , 176u8 , 14u8 , 211u8 , 178u8 , 216u8 , 8u8 , 156u8 , 83u8 , 14u8 , 91u8 , 15u8 , 200u8 , 170u8 , 3u8 , 127u8 , 141u8 , 139u8 , 151u8 , 98u8 , 74u8 , 96u8 , 238u8 , 29u8 ,] { let entry = CanceledSlashPayout ; self . client . storage () . fetch_or_default (& entry , block_hash) . await } else { Err (:: subxt :: MetadataError :: IncompatibleMetadata . into ()) } } # [doc = " All unapplied slashes that are queued for later."] pub async fn unapplied_slashes (& self , _0 : & :: core :: primitive :: u32 , block_hash : :: core :: option :: Option < T :: Hash > ,) -> :: core :: result :: Result < :: std :: vec :: Vec < runtime_types :: pallet_staking :: UnappliedSlash < :: subxt :: sp_core :: crypto :: AccountId32 , :: core :: primitive :: u128 > > , :: subxt :: BasicError > { if self . client . metadata () . storage_hash :: < UnappliedSlashes > () ? == [213u8 , 28u8 , 144u8 , 139u8 , 187u8 , 184u8 , 7u8 , 192u8 , 114u8 , 57u8 , 238u8 , 66u8 , 7u8 , 254u8 , 41u8 , 230u8 , 189u8 , 188u8 , 127u8 , 49u8 , 201u8 , 179u8 , 21u8 , 157u8 , 177u8 , 130u8 , 137u8 , 151u8 , 51u8 , 213u8 , 242u8 , 236u8 ,] { let entry = UnappliedSlashes (_0) ; self . client . storage () . fetch_or_default (& entry , block_hash) . await } else { Err (:: subxt :: MetadataError :: IncompatibleMetadata . into ()) } } # [doc = " All unapplied slashes that are queued for later."] pub async fn unapplied_slashes_iter (& self , block_hash : :: core :: option :: Option < T :: Hash > ,) -> :: core :: result :: Result < :: subxt :: KeyIter < 'a , T , UnappliedSlashes < 'a > > , :: subxt :: BasicError > { if self . client . metadata () . storage_hash :: < UnappliedSlashes > () ? == [213u8 , 28u8 , 144u8 , 139u8 , 187u8 , 184u8 , 7u8 , 192u8 , 114u8 , 57u8 , 238u8 , 66u8 , 7u8 , 254u8 , 41u8 , 230u8 , 189u8 , 188u8 , 127u8 , 49u8 , 201u8 , 179u8 , 21u8 , 157u8 , 177u8 , 130u8 , 137u8 , 151u8 , 51u8 , 213u8 , 242u8 , 236u8 ,] { self . client . storage () . iter (block_hash) . await } else { Err (:: subxt :: MetadataError :: IncompatibleMetadata . into ()) } } # [doc = " A mapping from still-bonded eras to the first session index of that era."] # [doc = ""] # [doc = " Must contains information for eras for the range:"] # [doc = " `[active_era - bounding_duration; active_era]`"] pub async fn bonded_eras (& self , block_hash : :: core :: option :: Option < T :: Hash > ,) -> :: core :: result :: Result < :: std :: vec :: Vec < (:: core :: primitive :: u32 , :: core :: primitive :: u32 ,) > , :: subxt :: BasicError > { if self . client . metadata () . storage_hash :: < BondedEras > () ? == [243u8 , 162u8 , 236u8 , 198u8 , 122u8 , 182u8 , 37u8 , 55u8 , 171u8 , 156u8 , 235u8 , 223u8 , 226u8 , 129u8 , 89u8 , 206u8 , 2u8 , 155u8 , 222u8 , 154u8 , 116u8 , 124u8 , 4u8 , 119u8 , 155u8 , 94u8 , 248u8 , 30u8 , 171u8 , 51u8 , 78u8 , 106u8 ,] { let entry = BondedEras ; self . client . storage () . fetch_or_default (& entry , block_hash) . await } else { Err (:: subxt :: MetadataError :: IncompatibleMetadata . into ()) } } # [doc = " All slashing events on validators, mapped by era to the highest slash proportion"] # [doc = " and slash value of the era."] pub async fn validator_slash_in_era (& self , _0 : & :: core :: primitive :: u32 , _1 : & :: subxt :: sp_core :: crypto :: AccountId32 , block_hash : :: core :: option :: Option < T :: Hash > ,) -> :: core :: result :: Result < :: core :: option :: Option < (runtime_types :: sp_arithmetic :: per_things :: Perbill , :: core :: primitive :: u128 ,) > , :: subxt :: BasicError > { if self . client . metadata () . storage_hash :: < ValidatorSlashInEra > () ? == [241u8 , 177u8 , 227u8 , 239u8 , 150u8 , 186u8 , 50u8 , 97u8 , 144u8 , 224u8 , 24u8 , 149u8 , 189u8 , 166u8 , 71u8 , 232u8 , 221u8 , 129u8 , 122u8 , 248u8 , 235u8 , 100u8 , 130u8 , 230u8 , 11u8 , 96u8 , 214u8 , 59u8 , 79u8 , 40u8 , 236u8 , 136u8 ,] { let entry = ValidatorSlashInEra (_0 , _1) ; self . client . storage () . fetch (& entry , block_hash) . await } else { Err (:: subxt :: MetadataError :: IncompatibleMetadata . into ()) } } # [doc = " All slashing events on validators, mapped by era to the highest slash proportion"] # [doc = " and slash value of the era."] pub async fn validator_slash_in_era_iter (& self , block_hash : :: core :: option :: Option < T :: Hash > ,) -> :: core :: result :: Result < :: subxt :: KeyIter < 'a , T , ValidatorSlashInEra < 'a > > , :: subxt :: BasicError > { if self . client . metadata () . storage_hash :: < ValidatorSlashInEra > () ? == [241u8 , 177u8 , 227u8 , 239u8 , 150u8 , 186u8 , 50u8 , 97u8 , 144u8 , 224u8 , 24u8 , 149u8 , 189u8 , 166u8 , 71u8 , 232u8 , 221u8 , 129u8 , 122u8 , 248u8 , 235u8 , 100u8 , 130u8 , 230u8 , 11u8 , 96u8 , 214u8 , 59u8 , 79u8 , 40u8 , 236u8 , 136u8 ,] { self . client . storage () . iter (block_hash) . await } else { Err (:: subxt :: MetadataError :: IncompatibleMetadata . into ()) } } # [doc = " All slashing events on nominators, mapped by era to the highest slash value of the era."] pub async fn nominator_slash_in_era (& self , _0 : & :: core :: primitive :: u32 , _1 : & :: subxt :: sp_core :: crypto :: AccountId32 , block_hash : :: core :: option :: Option < T :: Hash > ,) -> :: core :: result :: Result < :: core :: option :: Option < :: core :: primitive :: u128 > , :: subxt :: BasicError > { if self . client . metadata () . storage_hash :: < NominatorSlashInEra > () ? == [149u8 , 144u8 , 51u8 , 167u8 , 71u8 , 119u8 , 218u8 , 110u8 , 25u8 , 45u8 , 168u8 , 149u8 , 62u8 , 195u8 , 248u8 , 50u8 , 215u8 , 216u8 , 228u8 , 4u8 , 238u8 , 4u8 , 52u8 , 211u8 , 65u8 , 223u8 , 84u8 , 105u8 , 186u8 , 200u8 , 73u8 , 133u8 ,] { let entry = NominatorSlashInEra (_0 , _1) ; self . client . storage () . fetch (& entry , block_hash) . await } else { Err (:: subxt :: MetadataError :: IncompatibleMetadata . into ()) } } # [doc = " All slashing events on nominators, mapped by era to the highest slash value of the era."] pub async fn nominator_slash_in_era_iter (& self , block_hash : :: core :: option :: Option < T :: Hash > ,) -> :: core :: result :: Result < :: subxt :: KeyIter < 'a , T , NominatorSlashInEra < 'a > > , :: subxt :: BasicError > { if self . client . metadata () . storage_hash :: < NominatorSlashInEra > () ? == [149u8 , 144u8 , 51u8 , 167u8 , 71u8 , 119u8 , 218u8 , 110u8 , 25u8 , 45u8 , 168u8 , 149u8 , 62u8 , 195u8 , 248u8 , 50u8 , 215u8 , 216u8 , 228u8 , 4u8 , 238u8 , 4u8 , 52u8 , 211u8 , 65u8 , 223u8 , 84u8 , 105u8 , 186u8 , 200u8 , 73u8 , 133u8 ,] { self . client . storage () . iter (block_hash) . await } else { Err (:: subxt :: MetadataError :: IncompatibleMetadata . into ()) } } # [doc = " Slashing spans for stash accounts."] pub async fn slashing_spans (& self , _0 : & :: subxt :: sp_core :: crypto :: AccountId32 , block_hash : :: core :: option :: Option < T :: Hash > ,) -> :: core :: result :: Result < :: core :: option :: Option < runtime_types :: pallet_staking :: slashing :: SlashingSpans > , :: subxt :: BasicError > { if self . client . metadata () . storage_hash :: < SlashingSpans > () ? == [22u8 , 73u8 , 200u8 , 194u8 , 106u8 , 157u8 , 84u8 , 5u8 , 119u8 , 5u8 , 73u8 , 247u8 , 125u8 , 213u8 , 80u8 , 37u8 , 154u8 , 192u8 , 16u8 , 2u8 , 135u8 , 124u8 , 139u8 , 26u8 , 84u8 , 223u8 , 254u8 , 229u8 , 148u8 , 45u8 , 194u8 , 183u8 ,] { let entry = SlashingSpans (_0) ; self . client . storage () . fetch (& entry , block_hash) . await } else { Err (:: subxt :: MetadataError :: IncompatibleMetadata . into ()) } } # [doc = " Slashing spans for stash accounts."] pub async fn slashing_spans_iter (& self , block_hash : :: core :: option :: Option < T :: Hash > ,) -> :: core :: result :: Result < :: subxt :: KeyIter < 'a , T , SlashingSpans < 'a > > , :: subxt :: BasicError > { if self . client . metadata () . storage_hash :: < SlashingSpans > () ? == [22u8 , 73u8 , 200u8 , 194u8 , 106u8 , 157u8 , 84u8 , 5u8 , 119u8 , 5u8 , 73u8 , 247u8 , 125u8 , 213u8 , 80u8 , 37u8 , 154u8 , 192u8 , 16u8 , 2u8 , 135u8 , 124u8 , 139u8 , 26u8 , 84u8 , 223u8 , 254u8 , 229u8 , 148u8 , 45u8 , 194u8 , 183u8 ,] { self . client . storage () . iter (block_hash) . await } else { Err (:: subxt :: MetadataError :: IncompatibleMetadata . into ()) } } # [doc = " Records information about the maximum slash of a stash within a slashing span,"] # [doc = " as well as how much reward has been paid out."] pub async fn span_slash (& self , _0 : & :: subxt :: sp_core :: crypto :: AccountId32 , _1 : & :: core :: primitive :: u32 , block_hash : :: core :: option :: Option < T :: Hash > ,) -> :: core :: result :: Result < runtime_types :: pallet_staking :: slashing :: SpanRecord < :: core :: primitive :: u128 > , :: subxt :: BasicError > { if self . client . metadata () . storage_hash :: < SpanSlash > () ? == [95u8 , 42u8 , 40u8 , 167u8 , 201u8 , 140u8 , 142u8 , 55u8 , 69u8 , 238u8 , 248u8 , 118u8 , 209u8 , 11u8 , 117u8 , 132u8 , 179u8 , 33u8 , 17u8 , 156u8 , 137u8 , 220u8 , 170u8 , 144u8 , 235u8 , 99u8 , 248u8 , 47u8 , 99u8 , 42u8 , 247u8 , 189u8 ,] { let entry = SpanSlash (_0 , _1) ; self . client . storage () . fetch_or_default (& entry , block_hash) . await } else { Err (:: subxt :: MetadataError :: IncompatibleMetadata . into ()) } } # [doc = " Records information about the maximum slash of a stash within a slashing span,"] # [doc = " as well as how much reward has been paid out."] pub async fn span_slash_iter (& self , block_hash : :: core :: option :: Option < T :: Hash > ,) -> :: core :: result :: Result < :: subxt :: KeyIter < 'a , T , SpanSlash < 'a > > , :: subxt :: BasicError > { if self . client . metadata () . storage_hash :: < SpanSlash > () ? == [95u8 , 42u8 , 40u8 , 167u8 , 201u8 , 140u8 , 142u8 , 55u8 , 69u8 , 238u8 , 248u8 , 118u8 , 209u8 , 11u8 , 117u8 , 132u8 , 179u8 , 33u8 , 17u8 , 156u8 , 137u8 , 220u8 , 170u8 , 144u8 , 235u8 , 99u8 , 248u8 , 47u8 , 99u8 , 42u8 , 247u8 , 189u8 ,] { self . client . storage () . iter (block_hash) . await } else { Err (:: subxt :: MetadataError :: IncompatibleMetadata . into ()) } } # [doc = " The earliest era for which we have a pending, unapplied slash."] pub async fn earliest_unapplied_slash (& self , block_hash : :: core :: option :: Option < T :: Hash > ,) -> :: core :: result :: Result < :: core :: option :: Option < :: core :: primitive :: u32 > , :: subxt :: BasicError > { if self . client . metadata () . storage_hash :: < EarliestUnappliedSlash > () ? == [2u8 , 167u8 , 88u8 , 76u8 , 113u8 , 225u8 , 232u8 , 80u8 , 183u8 , 162u8 , 104u8 , 28u8 , 162u8 , 13u8 , 120u8 , 45u8 , 200u8 , 130u8 , 147u8 , 124u8 , 210u8 , 111u8 , 30u8 , 222u8 , 70u8 , 79u8 , 125u8 , 157u8 , 56u8 , 252u8 , 237u8 , 216u8 ,] { let entry = EarliestUnappliedSlash ; self . client . storage () . fetch (& entry , block_hash) . await } else { Err (:: subxt :: MetadataError :: IncompatibleMetadata . into ()) } } # [doc = " The last planned session scheduled by the session pallet."] # [doc = ""] # [doc = " This is basically in sync with the call to [`pallet_session::SessionManager::new_session`]."] pub async fn current_planned_session (& self , block_hash : :: core :: option :: Option < T :: Hash > ,) -> :: core :: result :: Result < :: core :: primitive :: u32 , :: subxt :: BasicError > { if self . client . metadata () . storage_hash :: < CurrentPlannedSession > () ? == [38u8 , 22u8 , 56u8 , 250u8 , 17u8 , 154u8 , 99u8 , 37u8 , 155u8 , 253u8 , 100u8 , 117u8 , 5u8 , 239u8 , 31u8 , 190u8 , 53u8 , 241u8 , 11u8 , 185u8 , 163u8 , 227u8 , 10u8 , 77u8 , 210u8 , 64u8 , 156u8 , 218u8 , 105u8 , 16u8 , 1u8 , 57u8 ,] { let entry = CurrentPlannedSession ; self . client . storage () . fetch_or_default (& entry , block_hash) . await } else { Err (:: subxt :: MetadataError :: IncompatibleMetadata . into ()) } } # [doc = " Indices of validators that have offended in the active era and whether they are currently"] # [doc = " disabled."] # [doc = ""] # [doc = " This value should be a superset of disabled validators since not all offences lead to the"] # [doc = " validator being disabled (if there was no slash). This is needed to track the percentage of"] # [doc = " validators that have offended in the current era, ensuring a new era is forced if"] # [doc = " `OffendingValidatorsThreshold` is reached. The vec is always kept sorted so that we can find"] # [doc = " whether a given validator has previously offended using binary search. It gets cleared when"] # [doc = " the era ends."] pub async fn offending_validators (& self , block_hash : :: core :: option :: Option < T :: Hash > ,) -> :: core :: result :: Result < :: std :: vec :: Vec < (:: core :: primitive :: u32 , :: core :: primitive :: bool ,) > , :: subxt :: BasicError > { if self . client . metadata () . storage_hash :: < OffendingValidators > () ? == [94u8 , 254u8 , 0u8 , 50u8 , 76u8 , 232u8 , 51u8 , 153u8 , 118u8 , 14u8 , 70u8 , 101u8 , 112u8 , 215u8 , 173u8 , 82u8 , 182u8 , 104u8 , 167u8 , 103u8 , 187u8 , 168u8 , 86u8 , 16u8 , 51u8 , 235u8 , 51u8 , 119u8 , 38u8 , 154u8 , 42u8 , 113u8 ,] { let entry = OffendingValidators ; self . client . storage () . fetch_or_default (& entry , block_hash) . await } else { Err (:: subxt :: MetadataError :: IncompatibleMetadata . into ()) } } # [doc = " True if network has been upgraded to this version."] # [doc = " Storage version of the pallet."] # [doc = ""] # [doc = " This is set to v7.0.0 for new networks."] pub async fn storage_version (& self , block_hash : :: core :: option :: Option < T :: Hash > ,) -> :: core :: result :: Result < runtime_types :: pallet_staking :: Releases , :: subxt :: BasicError > { if self . client . metadata () . storage_hash :: < StorageVersion > () ? == [156u8 , 107u8 , 113u8 , 89u8 , 107u8 , 89u8 , 171u8 , 229u8 , 13u8 , 96u8 , 203u8 , 67u8 , 119u8 , 153u8 , 199u8 , 158u8 , 63u8 , 114u8 , 229u8 , 113u8 , 81u8 , 70u8 , 200u8 , 9u8 , 147u8 , 233u8 , 6u8 , 7u8 , 210u8 , 109u8 , 149u8 , 14u8 ,] { let entry = StorageVersion ; self . client . storage () . fetch_or_default (& entry , block_hash) . await } else { Err (:: subxt :: MetadataError :: IncompatibleMetadata . into ()) } } # [doc = " The threshold for when users can start calling `chill_other` for other validators /"] # [doc = " nominators. The threshold is compared to the actual number of validators / nominators"] # [doc = " (`CountFor*`) in the system compared to the configured max (`Max*Count`)."] pub async fn chill_threshold (& self , block_hash : :: core :: option :: Option < T :: Hash > ,) -> :: core :: result :: Result < :: core :: option :: Option < runtime_types :: sp_arithmetic :: per_things :: Percent > , :: subxt :: BasicError > { if self . client . metadata () . storage_hash :: < ChillThreshold > () ? == [254u8 , 131u8 , 112u8 , 90u8 , 234u8 , 72u8 , 26u8 , 240u8 , 38u8 , 14u8 , 128u8 , 234u8 , 133u8 , 169u8 , 66u8 , 48u8 , 234u8 , 170u8 , 159u8 , 145u8 , 75u8 , 135u8 , 79u8 , 189u8 , 54u8 , 89u8 , 113u8 , 144u8 , 16u8 , 70u8 , 184u8 , 43u8 ,] { let entry = ChillThreshold ; self . client . storage () . fetch (& entry , block_hash) . await } else { Err (:: subxt :: MetadataError :: IncompatibleMetadata . into ()) } } } } pub mod constants { use super :: runtime_types ; pub struct ConstantsApi < 'a , T : :: subxt :: Config > { client : & 'a :: subxt :: Client < T > , } impl < 'a , T : :: subxt :: Config > ConstantsApi < 'a , T > { pub fn new (client : & 'a :: subxt :: Client < T >) -> Self { Self { client } } # [doc = " Maximum number of nominations per nominator."] pub fn max_nominations (& self) -> :: core :: result :: Result < :: core :: primitive :: u32 , :: subxt :: BasicError > { if self . client . metadata () . constant_hash ("Staking" , "MaxNominations") ? == [155u8 , 58u8 , 120u8 , 225u8 , 19u8 , 30u8 , 64u8 , 6u8 , 16u8 , 72u8 , 160u8 , 120u8 , 99u8 , 8u8 , 170u8 , 47u8 , 217u8 , 196u8 , 184u8 , 183u8 , 199u8 , 156u8 , 76u8 , 154u8 , 143u8 , 172u8 , 67u8 , 133u8 , 95u8 , 36u8 , 60u8 , 50u8 ,] { let pallet = self . client . metadata () . pallet ("Staking") ? ; let constant = pallet . constant ("MaxNominations") ? ; let value = :: subxt :: codec :: Decode :: decode (& mut & constant . value [..]) ? ; Ok (value) } else { Err (:: subxt :: MetadataError :: IncompatibleMetadata . into ()) } } # [doc = " Number of sessions per era."] pub fn sessions_per_era (& self) -> :: core :: result :: Result < :: core :: primitive :: u32 , :: subxt :: BasicError > { if self . client . metadata () . constant_hash ("Staking" , "SessionsPerEra") ? == [73u8 , 207u8 , 178u8 , 212u8 , 159u8 , 9u8 , 41u8 , 31u8 , 205u8 , 221u8 , 166u8 , 159u8 , 104u8 , 218u8 , 113u8 , 160u8 , 174u8 , 66u8 , 95u8 , 0u8 , 237u8 , 42u8 , 120u8 , 171u8 , 68u8 , 78u8 , 136u8 , 162u8 , 163u8 , 225u8 , 199u8 , 138u8 ,] { let pallet = self . client . metadata () . pallet ("Staking") ? ; let constant = pallet . constant ("SessionsPerEra") ? ; let value = :: subxt :: codec :: Decode :: decode (& mut & constant . value [..]) ? ; Ok (value) } else { Err (:: subxt :: MetadataError :: IncompatibleMetadata . into ()) } } # [doc = " Number of eras that staked funds must remain bonded for."] pub fn bonding_duration (& self) -> :: core :: result :: Result < :: core :: primitive :: u32 , :: subxt :: BasicError > { if self . client . metadata () . constant_hash ("Staking" , "BondingDuration") ? == [117u8 , 2u8 , 56u8 , 16u8 , 159u8 , 102u8 , 149u8 , 196u8 , 2u8 , 213u8 , 25u8 , 224u8 , 92u8 , 126u8 , 224u8 , 29u8 , 59u8 , 121u8 , 215u8 , 129u8 , 144u8 , 144u8 , 128u8 , 154u8 , 133u8 , 111u8 , 55u8 , 39u8 , 28u8 , 45u8 , 198u8 , 55u8 ,] { let pallet = self . client . metadata () . pallet ("Staking") ? ; let constant = pallet . constant ("BondingDuration") ? ; let value = :: subxt :: codec :: Decode :: decode (& mut & constant . value [..]) ? ; Ok (value) } else { Err (:: subxt :: MetadataError :: IncompatibleMetadata . into ()) } } # [doc = " Number of eras that slashes are deferred by, after computation."] # [doc = ""] # [doc = " This should be less than the bonding duration. Set to 0 if slashes"] # [doc = " should be applied immediately, without opportunity for intervention."] pub fn slash_defer_duration (& self) -> :: core :: result :: Result < :: core :: primitive :: u32 , :: subxt :: BasicError > { if self . client . metadata () . constant_hash ("Staking" , "SlashDeferDuration") ? == [220u8 , 161u8 , 133u8 , 191u8 , 255u8 , 153u8 , 120u8 , 221u8 , 22u8 , 83u8 , 197u8 , 36u8 , 152u8 , 22u8 , 94u8 , 201u8 , 77u8 , 101u8 , 224u8 , 65u8 , 21u8 , 128u8 , 142u8 , 89u8 , 236u8 , 244u8 , 35u8 , 96u8 , 27u8 , 90u8 , 61u8 , 102u8 ,] { let pallet = self . client . metadata () . pallet ("Staking") ? ; let constant = pallet . constant ("SlashDeferDuration") ? ; let value = :: subxt :: codec :: Decode :: decode (& mut & constant . value [..]) ? ; Ok (value) } else { Err (:: subxt :: MetadataError :: IncompatibleMetadata . into ()) } } # [doc = " The maximum number of nominators rewarded for each validator."] # [doc = ""] # [doc = " For each validator only the `$MaxNominatorRewardedPerValidator` biggest stakers can"] # [doc = " claim their reward. This used to limit the i/o cost for the nominator payout."] pub fn max_nominator_rewarded_per_validator (& self) -> :: core :: result :: Result < :: core :: primitive :: u32 , :: subxt :: BasicError > { if self . client . metadata () . constant_hash ("Staking" , "MaxNominatorRewardedPerValidator") ? == [203u8 , 67u8 , 240u8 , 15u8 , 205u8 , 129u8 , 216u8 , 42u8 , 197u8 , 166u8 , 179u8 , 175u8 , 9u8 , 179u8 , 182u8 , 19u8 , 57u8 , 206u8 , 237u8 , 79u8 , 204u8 , 135u8 , 76u8 , 243u8 , 108u8 , 191u8 , 151u8 , 127u8 , 38u8 , 154u8 , 193u8 , 142u8 ,] { let pallet = self . client . metadata () . pallet ("Staking") ? ; let constant = pallet . constant ("MaxNominatorRewardedPerValidator") ? ; let value = :: subxt :: codec :: Decode :: decode (& mut & constant . value [..]) ? ; Ok (value) } else { Err (:: subxt :: MetadataError :: IncompatibleMetadata . into ()) } } # [doc = " The maximum number of `unlocking` chunks a [`StakingLedger`] can have. Effectively"] # [doc = " determines how many unique eras a staker may be unbonding in."] pub fn max_unlocking_chunks (& self) -> :: core :: result :: Result < :: core :: primitive :: u32 , :: subxt :: BasicError > { if self . client . metadata () . constant_hash ("Staking" , "MaxUnlockingChunks") ? == [60u8 , 255u8 , 33u8 , 12u8 , 50u8 , 253u8 , 93u8 , 203u8 , 3u8 , 245u8 , 156u8 , 201u8 , 121u8 , 119u8 , 72u8 , 58u8 , 38u8 , 133u8 , 127u8 , 51u8 , 21u8 , 223u8 , 40u8 , 23u8 , 116u8 , 158u8 , 77u8 , 24u8 , 139u8 , 219u8 , 197u8 , 150u8 ,] { let pallet = self . client . metadata () . pallet ("Staking") ? ; let constant = pallet . constant ("MaxUnlockingChunks") ? ; let value = :: subxt :: codec :: Decode :: decode (& mut & constant . value [..]) ? ; Ok (value) } else { Err (:: subxt :: MetadataError :: IncompatibleMetadata . into ()) } } } } } pub mod session { use super :: root_mod ; use super :: runtime_types ; pub mod calls { use super :: root_mod ; use super :: runtime_types ; type DispatchError = runtime_types :: sp_runtime :: DispatchError ; # [derive (:: subxt :: codec :: Decode , :: subxt :: codec :: Encode , Clone , Debug , Eq , PartialEq)] pub struct SetKeys { pub keys : runtime_types :: egg_standalone_runtime :: opaque :: SessionKeys , pub proof : :: std :: vec :: Vec < :: core :: primitive :: u8 > , } impl :: subxt :: Call for SetKeys { const PALLET : & 'static str = "Session" ; const FUNCTION : & 'static str = "set_keys" ; } # [derive (:: subxt :: codec :: Decode , :: subxt :: codec :: Encode , Clone , Debug , Eq , PartialEq)] pub struct PurgeKeys ; impl :: subxt :: Call for PurgeKeys { const PALLET : & 'static str = "Session" ; const FUNCTION : & 'static str = "purge_keys" ; } pub struct TransactionApi < 'a , T : :: subxt :: Config , X > { client : & 'a :: subxt :: Client < T > , marker : :: core :: marker :: PhantomData < X > , } impl < 'a , T , X > TransactionApi < 'a , T , X > where T : :: subxt :: Config , X : :: subxt :: extrinsic :: ExtrinsicParams < T > , { pub fn new (client : & 'a :: subxt :: Client < T >) -> Self { Self { client , marker : :: core :: marker :: PhantomData } } # [doc = "Sets the session key(s) of the function caller to `keys`."] # [doc = "Allows an account to set its session key prior to becoming a validator."] # [doc = "This doesn't take effect until the next session."] # [doc = ""] # [doc = "The dispatch origin of this function must be signed."] # [doc = ""] # [doc = "# <weight>"] # [doc = "- Complexity: `O(1)`. Actual cost depends on the number of length of"] # [doc = "  `T::Keys::key_ids()` which is fixed."] # [doc = "- DbReads: `origin account`, `T::ValidatorIdOf`, `NextKeys`"] # [doc = "- DbWrites: `origin account`, `NextKeys`"] # [doc = "- DbReads per key id: `KeyOwner`"] # [doc = "- DbWrites per key id: `KeyOwner`"] # [doc = "# </weight>"] pub fn set_keys (& self , keys : runtime_types :: egg_standalone_runtime :: opaque :: SessionKeys , proof : :: std :: vec :: Vec < :: core :: primitive :: u8 > ,) -> Result < :: subxt :: SubmittableExtrinsic < 'a , T , X , SetKeys , DispatchError , root_mod :: Event > , :: subxt :: BasicError > { if self . client . metadata () . call_hash :: < SetKeys > () ? == [200u8 , 83u8 , 161u8 , 111u8 , 254u8 , 4u8 , 240u8 , 117u8 , 252u8 , 120u8 , 177u8 , 187u8 , 38u8 , 150u8 , 99u8 , 152u8 , 1u8 , 132u8 , 21u8 , 80u8 , 92u8 , 243u8 , 208u8 , 183u8 , 223u8 , 141u8 , 166u8 , 101u8 , 223u8 , 74u8 , 133u8 , 132u8 ,] { let call = SetKeys { keys , proof , } ; Ok (:: subxt :: SubmittableExtrinsic :: new (self . client , call)) } else { Err (:: subxt :: MetadataError :: IncompatibleMetadata . into ()) } } # [doc = "Removes any session key(s) of the function caller."] # [doc = ""] # [doc = "This doesn't take effect until the next session."] # [doc = ""] # [doc = "The dispatch origin of this function must be Signed and the account must be either be"] # [doc = "convertible to a validator ID using the chain's typical addressing system (this usually"] # [doc = "means being a controller account) or directly convertible into a validator ID (which"] # [doc = "usually means being a stash account)."] # [doc = ""] # [doc = "# <weight>"] # [doc = "- Complexity: `O(1)` in number of key types. Actual cost depends on the number of length"] # [doc = "  of `T::Keys::key_ids()` which is fixed."] # [doc = "- DbReads: `T::ValidatorIdOf`, `NextKeys`, `origin account`"] # [doc = "- DbWrites: `NextKeys`, `origin account`"] # [doc = "- DbWrites per key id: `KeyOwner`"] # [doc = "# </weight>"] pub fn purge_keys (& self ,) -> Result < :: subxt :: SubmittableExtrinsic < 'a , T , X , PurgeKeys , DispatchError , root_mod :: Event > , :: subxt :: BasicError > { if self . client . metadata () . call_hash :: < PurgeKeys > () ? == [200u8 , 255u8 , 4u8 , 213u8 , 188u8 , 92u8 , 99u8 , 116u8 , 163u8 , 152u8 , 29u8 , 35u8 , 133u8 , 119u8 , 246u8 , 44u8 , 91u8 , 31u8 , 145u8 , 23u8 , 213u8 , 64u8 , 71u8 , 242u8 , 207u8 , 239u8 , 231u8 , 37u8 , 61u8 , 63u8 , 190u8 , 35u8 ,] { let call = PurgeKeys { } ; Ok (:: subxt :: SubmittableExtrinsic :: new (self . client , call)) } else { Err (:: subxt :: MetadataError :: IncompatibleMetadata . into ()) } } } } pub type Event = runtime_types :: pallet_session :: pallet :: Event ; pub mod events { use super :: runtime_types ; # [derive (:: subxt :: codec :: CompactAs , :: subxt :: codec :: Decode , :: subxt :: codec :: Encode , Clone , Debug , Eq , PartialEq)] # [doc = "New session has happened. Note that the argument is the session index, not the"] # [doc = "block number as the type might suggest."] pub struct NewSession { pub session_index : :: core :: primitive :: u32 , } impl :: subxt :: Event for NewSession { const PALLET : & 'static str = "Session" ; const EVENT : & 'static str = "NewSession" ; } } pub mod storage { use super :: runtime_types ; pub struct Validators ; impl :: subxt :: StorageEntry for Validators { const PALLET : & 'static str = "Session" ; const STORAGE : & 'static str = "Validators" ; type Value = :: std :: vec :: Vec < :: subxt :: sp_core :: crypto :: AccountId32 > ; fn key (& self) -> :: subxt :: StorageEntryKey { :: subxt :: StorageEntryKey :: Plain } } pub struct CurrentIndex ; impl :: subxt :: StorageEntry for CurrentIndex { const PALLET : & 'static str = "Session" ; const STORAGE : & 'static str = "CurrentIndex" ; type Value = :: core :: primitive :: u32 ; fn key (& self) -> :: subxt :: StorageEntryKey { :: subxt :: StorageEntryKey :: Plain } } pub struct QueuedChanged ; impl :: subxt :: StorageEntry for QueuedChanged { const PALLET : & 'static str = "Session" ; const STORAGE : & 'static str = "QueuedChanged" ; type Value = :: core :: primitive :: bool ; fn key (& self) -> :: subxt :: StorageEntryKey { :: subxt :: StorageEntryKey :: Plain } } pub struct QueuedKeys ; impl :: subxt :: StorageEntry for QueuedKeys { const PALLET : & 'static str = "Session" ; const STORAGE : & 'static str = "QueuedKeys" ; type Value = :: std :: vec :: Vec < (:: subxt :: sp_core :: crypto :: AccountId32 , runtime_types :: egg_standalone_runtime :: opaque :: SessionKeys ,) > ; fn key (& self) -> :: subxt :: StorageEntryKey { :: subxt :: StorageEntryKey :: Plain } } pub struct DisabledValidators ; impl :: subxt :: StorageEntry for DisabledValidators { const PALLET : & 'static str = "Session" ; const STORAGE : & 'static str = "DisabledValidators" ; type Value = :: std :: vec :: Vec < :: core :: primitive :: u32 > ; fn key (& self) -> :: subxt :: StorageEntryKey { :: subxt :: StorageEntryKey :: Plain } } pub struct NextKeys < 'a > (pub & 'a :: subxt :: sp_core :: crypto :: AccountId32) ; impl :: subxt :: StorageEntry for NextKeys < '_ > { const PALLET : & 'static str = "Session" ; const STORAGE : & 'static str = "NextKeys" ; type Value = runtime_types :: egg_standalone_runtime :: opaque :: SessionKeys ; fn key (& self) -> :: subxt :: StorageEntryKey { :: subxt :: StorageEntryKey :: Map (vec ! [:: subxt :: StorageMapKey :: new (& self . 0 , :: subxt :: StorageHasher :: Twox64Concat)]) } } pub struct KeyOwner < 'a > (pub & 'a runtime_types :: sp_core :: crypto :: KeyTypeId , pub & 'a [:: core :: primitive :: u8]) ; impl :: subxt :: StorageEntry for KeyOwner < '_ > { const PALLET : & 'static str = "Session" ; const STORAGE : & 'static str = "KeyOwner" ; type Value = :: subxt :: sp_core :: crypto :: AccountId32 ; fn key (& self) -> :: subxt :: StorageEntryKey { :: subxt :: StorageEntryKey :: Map (vec ! [:: subxt :: StorageMapKey :: new (& (& self . 0 , & self . 1) , :: subxt :: StorageHasher :: Twox64Concat)]) } } pub struct StorageApi < 'a , T : :: subxt :: Config > { client : & 'a :: subxt :: Client < T > , } impl < 'a , T : :: subxt :: Config > StorageApi < 'a , T > { pub fn new (client : & 'a :: subxt :: Client < T >) -> Self { Self { client } } # [doc = " The current set of validators."] pub async fn validators (& self , block_hash : :: core :: option :: Option < T :: Hash > ,) -> :: core :: result :: Result < :: std :: vec :: Vec < :: subxt :: sp_core :: crypto :: AccountId32 > , :: subxt :: BasicError > { if self . client . metadata () . storage_hash :: < Validators > () ? == [186u8 , 248u8 , 234u8 , 74u8 , 245u8 , 141u8 , 90u8 , 152u8 , 226u8 , 220u8 , 255u8 , 104u8 , 174u8 , 1u8 , 37u8 , 152u8 , 23u8 , 208u8 , 25u8 , 49u8 , 33u8 , 253u8 , 254u8 , 251u8 , 141u8 , 16u8 , 18u8 , 175u8 , 196u8 , 188u8 , 163u8 , 209u8 ,] { let entry = Validators ; self . client . storage () . fetch_or_default (& entry , block_hash) . await } else { Err (:: subxt :: MetadataError :: IncompatibleMetadata . into ()) } } # [doc = " Current index of the session."] pub async fn current_index (& self , block_hash : :: core :: option :: Option < T :: Hash > ,) -> :: core :: result :: Result < :: core :: primitive :: u32 , :: subxt :: BasicError > { if self . client . metadata () . storage_hash :: < CurrentIndex > () ? == [148u8 , 179u8 , 159u8 , 15u8 , 197u8 , 95u8 , 214u8 , 30u8 , 209u8 , 251u8 , 183u8 , 231u8 , 91u8 , 25u8 , 181u8 , 191u8 , 143u8 , 252u8 , 227u8 , 80u8 , 159u8 , 66u8 , 194u8 , 67u8 , 113u8 , 74u8 , 111u8 , 91u8 , 218u8 , 187u8 , 130u8 , 40u8 ,] { let entry = CurrentIndex ; self . client . storage () . fetch_or_default (& entry , block_hash) . await } else { Err (:: subxt :: MetadataError :: IncompatibleMetadata . into ()) } } # [doc = " True if the underlying economic identities or weighting behind the validators"] # [doc = " has changed in the queued validator set."] pub async fn queued_changed (& self , block_hash : :: core :: option :: Option < T :: Hash > ,) -> :: core :: result :: Result < :: core :: primitive :: bool , :: subxt :: BasicError > { if self . client . metadata () . storage_hash :: < QueuedChanged > () ? == [105u8 , 140u8 , 235u8 , 218u8 , 96u8 , 100u8 , 252u8 , 10u8 , 58u8 , 221u8 , 244u8 , 251u8 , 67u8 , 91u8 , 80u8 , 202u8 , 152u8 , 42u8 , 50u8 , 113u8 , 200u8 , 247u8 , 59u8 , 213u8 , 77u8 , 195u8 , 1u8 , 150u8 , 220u8 , 18u8 , 245u8 , 46u8 ,] { let entry = QueuedChanged ; self . client . storage () . fetch_or_default (& entry , block_hash) . await } else { Err (:: subxt :: MetadataError :: IncompatibleMetadata . into ()) } } # [doc = " The queued keys for the next session. When the next session begins, these keys"] # [doc = " will be used to determine the validator's session keys."] pub async fn queued_keys (& self , block_hash : :: core :: option :: Option < T :: Hash > ,) -> :: core :: result :: Result < :: std :: vec :: Vec < (:: subxt :: sp_core :: crypto :: AccountId32 , runtime_types :: egg_standalone_runtime :: opaque :: SessionKeys ,) > , :: subxt :: BasicError > { if self . client . metadata () . storage_hash :: < QueuedKeys > () ? == [137u8 , 213u8 , 218u8 , 75u8 , 61u8 , 119u8 , 38u8 , 220u8 , 254u8 , 204u8 , 0u8 , 76u8 , 181u8 , 159u8 , 46u8 , 167u8 , 181u8 , 227u8 , 229u8 , 95u8 , 115u8 , 31u8 , 169u8 , 194u8 , 12u8 , 183u8 , 100u8 , 53u8 , 166u8 , 177u8 , 221u8 , 127u8 ,] { let entry = QueuedKeys ; self . client . storage () . fetch_or_default (& entry , block_hash) . await } else { Err (:: subxt :: MetadataError :: IncompatibleMetadata . into ()) } } # [doc = " Indices of disabled validators."] # [doc = ""] # [doc = " The vec is always kept sorted so that we can find whether a given validator is"] # [doc = " disabled using binary search. It gets cleared when `on_session_ending` returns"] # [doc = " a new set of identities."] pub async fn disabled_validators (& self , block_hash : :: core :: option :: Option < T :: Hash > ,) -> :: core :: result :: Result < :: std :: vec :: Vec < :: core :: primitive :: u32 > , :: subxt :: BasicError > { if self . client . metadata () . storage_hash :: < DisabledValidators > () ? == [135u8 , 22u8 , 22u8 , 97u8 , 82u8 , 217u8 , 144u8 , 141u8 , 121u8 , 240u8 , 189u8 , 16u8 , 176u8 , 88u8 , 177u8 , 31u8 , 20u8 , 242u8 , 73u8 , 104u8 , 11u8 , 110u8 , 214u8 , 34u8 , 52u8 , 217u8 , 106u8 , 33u8 , 174u8 , 174u8 , 198u8 , 84u8 ,] { let entry = DisabledValidators ; self . client . storage () . fetch_or_default (& entry , block_hash) . await } else { Err (:: subxt :: MetadataError :: IncompatibleMetadata . into ()) } } # [doc = " The next session keys for a validator."] pub async fn next_keys (& self , _0 : & :: subxt :: sp_core :: crypto :: AccountId32 , block_hash : :: core :: option :: Option < T :: Hash > ,) -> :: core :: result :: Result < :: core :: option :: Option < runtime_types :: egg_standalone_runtime :: opaque :: SessionKeys > , :: subxt :: BasicError > { if self . client . metadata () . storage_hash :: < NextKeys > () ? == [24u8 , 176u8 , 51u8 , 156u8 , 199u8 , 189u8 , 133u8 , 108u8 , 121u8 , 157u8 , 5u8 , 226u8 , 215u8 , 0u8 , 178u8 , 33u8 , 236u8 , 110u8 , 26u8 , 79u8 , 180u8 , 83u8 , 17u8 , 130u8 , 163u8 , 197u8 , 8u8 , 12u8 , 241u8 , 75u8 , 122u8 , 113u8 ,] { let entry = NextKeys (_0) ; self . client . storage () . fetch (& entry , block_hash) . await } else { Err (:: subxt :: MetadataError :: IncompatibleMetadata . into ()) } } # [doc = " The next session keys for a validator."] pub async fn next_keys_iter (& self , block_hash : :: core :: option :: Option < T :: Hash > ,) -> :: core :: result :: Result < :: subxt :: KeyIter < 'a , T , NextKeys < 'a > > , :: subxt :: BasicError > { if self . client . metadata () . storage_hash :: < NextKeys > () ? == [24u8 , 176u8 , 51u8 , 156u8 , 199u8 , 189u8 , 133u8 , 108u8 , 121u8 , 157u8 , 5u8 , 226u8 , 215u8 , 0u8 , 178u8 , 33u8 , 236u8 , 110u8 , 26u8 , 79u8 , 180u8 , 83u8 , 17u8 , 130u8 , 163u8 , 197u8 , 8u8 , 12u8 , 241u8 , 75u8 , 122u8 , 113u8 ,] { self . client . storage () . iter (block_hash) . await } else { Err (:: subxt :: MetadataError :: IncompatibleMetadata . into ()) } } # [doc = " The owner of a key. The key is the `KeyTypeId` + the encoded key."] pub async fn key_owner (& self , _0 : & runtime_types :: sp_core :: crypto :: KeyTypeId , _1 : & [:: core :: primitive :: u8] , block_hash : :: core :: option :: Option < T :: Hash > ,) -> :: core :: result :: Result < :: core :: option :: Option < :: subxt :: sp_core :: crypto :: AccountId32 > , :: subxt :: BasicError > { if self . client . metadata () . storage_hash :: < KeyOwner > () ? == [49u8 , 245u8 , 212u8 , 141u8 , 211u8 , 208u8 , 109u8 , 102u8 , 249u8 , 161u8 , 41u8 , 93u8 , 220u8 , 230u8 , 14u8 , 59u8 , 251u8 , 176u8 , 33u8 , 127u8 , 93u8 , 149u8 , 205u8 , 229u8 , 113u8 , 129u8 , 162u8 , 177u8 , 155u8 , 216u8 , 151u8 , 57u8 ,] { let entry = KeyOwner (_0 , _1) ; self . client . storage () . fetch (& entry , block_hash) . await } else { Err (:: subxt :: MetadataError :: IncompatibleMetadata . into ()) } } # [doc = " The owner of a key. The key is the `KeyTypeId` + the encoded key."] pub async fn key_owner_iter (& self , block_hash : :: core :: option :: Option < T :: Hash > ,) -> :: core :: result :: Result < :: subxt :: KeyIter < 'a , T , KeyOwner < 'a > > , :: subxt :: BasicError > { if self . client . metadata () . storage_hash :: < KeyOwner > () ? == [49u8 , 245u8 , 212u8 , 141u8 , 211u8 , 208u8 , 109u8 , 102u8 , 249u8 , 161u8 , 41u8 , 93u8 , 220u8 , 230u8 , 14u8 , 59u8 , 251u8 , 176u8 , 33u8 , 127u8 , 93u8 , 149u8 , 205u8 , 229u8 , 113u8 , 129u8 , 162u8 , 177u8 , 155u8 , 216u8 , 151u8 , 57u8 ,] { self . client . storage () . iter (block_hash) . await } else { Err (:: subxt :: MetadataError :: IncompatibleMetadata . into ()) } } } } } pub mod historical { use super :: root_mod ; use super :: runtime_types ; } pub mod treasury { use super :: root_mod ; use super :: runtime_types ; pub mod calls { use super :: root_mod ; use super :: runtime_types ; type DispatchError = runtime_types :: sp_runtime :: DispatchError ; # [derive (:: subxt :: codec :: Decode , :: subxt :: codec :: Encode , Clone , Debug , Eq , PartialEq)] pub struct ProposeSpend { # [codec (compact)] pub value : :: core :: primitive :: u128 , pub beneficiary : :: subxt :: sp_runtime :: MultiAddress < :: subxt :: sp_core :: crypto :: AccountId32 , :: core :: primitive :: u32 > , } impl :: subxt :: Call for ProposeSpend { const PALLET : & 'static str = "Treasury" ; const FUNCTION : & 'static str = "propose_spend" ; } # [derive (:: subxt :: codec :: Decode , :: subxt :: codec :: Encode , Clone , Debug , Eq , PartialEq)] pub struct RejectProposal { # [codec (compact)] pub proposal_id : :: core :: primitive :: u32 , } impl :: subxt :: Call for RejectProposal { const PALLET : & 'static str = "Treasury" ; const FUNCTION : & 'static str = "reject_proposal" ; } # [derive (:: subxt :: codec :: Decode , :: subxt :: codec :: Encode , Clone , Debug , Eq , PartialEq)] pub struct ApproveProposal { # [codec (compact)] pub proposal_id : :: core :: primitive :: u32 , } impl :: subxt :: Call for ApproveProposal { const PALLET : & 'static str = "Treasury" ; const FUNCTION : & 'static str = "approve_proposal" ; } # [derive (:: subxt :: codec :: Decode , :: subxt :: codec :: Encode , Clone , Debug , Eq , PartialEq)] pub struct Spend { # [codec (compact)] pub amount : :: core :: primitive :: u128 , pub beneficiary : :: subxt :: sp_runtime :: MultiAddress < :: subxt :: sp_core :: crypto :: AccountId32 , :: core :: primitive :: u32 > , } impl :: subxt :: Call for Spend { const PALLET : & 'static str = "Treasury" ; const FUNCTION : & 'static str = "spend" ; } # [derive (:: subxt :: codec :: Decode , :: subxt :: codec :: Encode , Clone , Debug , Eq , PartialEq)] pub struct RemoveApproval { # [codec (compact)] pub proposal_id : :: core :: primitive :: u32 , } impl :: subxt :: Call for RemoveApproval { const PALLET : & 'static str = "Treasury" ; const FUNCTION : & 'static str = "remove_approval" ; } pub struct TransactionApi < 'a , T : :: subxt :: Config , X > { client : & 'a :: subxt :: Client < T > , marker : :: core :: marker :: PhantomData < X > , } impl < 'a , T , X > TransactionApi < 'a , T , X > where T : :: subxt :: Config , X : :: subxt :: extrinsic :: ExtrinsicParams < T > , { pub fn new (client : & 'a :: subxt :: Client < T >) -> Self { Self { client , marker : :: core :: marker :: PhantomData } } # [doc = "Put forward a suggestion for spending. A deposit proportional to the value"] # [doc = "is reserved and slashed if the proposal is rejected. It is returned once the"] # [doc = "proposal is awarded."] # [doc = ""] # [doc = "# <weight>"] # [doc = "- Complexity: O(1)"] # [doc = "- DbReads: `ProposalCount`, `origin account`"] # [doc = "- DbWrites: `ProposalCount`, `Proposals`, `origin account`"] # [doc = "# </weight>"] pub fn propose_spend (& self , value : :: core :: primitive :: u128 , beneficiary : :: subxt :: sp_runtime :: MultiAddress < :: subxt :: sp_core :: crypto :: AccountId32 , :: core :: primitive :: u32 > ,) -> Result < :: subxt :: SubmittableExtrinsic < 'a , T , X , ProposeSpend , DispatchError , root_mod :: Event > , :: subxt :: BasicError > { if self . client . metadata () . call_hash :: < ProposeSpend > () ? == [28u8 , 133u8 , 252u8 , 219u8 , 50u8 , 86u8 , 29u8 , 221u8 , 188u8 , 4u8 , 33u8 , 236u8 , 171u8 , 116u8 , 77u8 , 164u8 , 7u8 , 55u8 , 138u8 , 37u8 , 51u8 , 213u8 , 224u8 , 6u8 , 25u8 , 245u8 , 137u8 , 136u8 , 196u8 , 86u8 , 28u8 , 154u8 ,] { let call = ProposeSpend { value , beneficiary , } ; Ok (:: subxt :: SubmittableExtrinsic :: new (self . client , call)) } else { Err (:: subxt :: MetadataError :: IncompatibleMetadata . into ()) } } # [doc = "Reject a proposed spend. The original deposit will be slashed."] # [doc = ""] # [doc = "May only be called from `T::RejectOrigin`."] # [doc = ""] # [doc = "# <weight>"] # [doc = "- Complexity: O(1)"] # [doc = "- DbReads: `Proposals`, `rejected proposer account`"] # [doc = "- DbWrites: `Proposals`, `rejected proposer account`"] # [doc = "# </weight>"] pub fn reject_proposal (& self , proposal_id : :: core :: primitive :: u32 ,) -> Result < :: subxt :: SubmittableExtrinsic < 'a , T , X , RejectProposal , DispatchError , root_mod :: Event > , :: subxt :: BasicError > { if self . client . metadata () . call_hash :: < RejectProposal > () ? == [153u8 , 238u8 , 223u8 , 212u8 , 86u8 , 178u8 , 184u8 , 150u8 , 117u8 , 91u8 , 69u8 , 30u8 , 196u8 , 134u8 , 56u8 , 54u8 , 236u8 , 145u8 , 202u8 , 139u8 , 135u8 , 254u8 , 80u8 , 189u8 , 40u8 , 56u8 , 148u8 , 108u8 , 42u8 , 118u8 , 74u8 , 242u8 ,] { let call = RejectProposal { proposal_id , } ; Ok (:: subxt :: SubmittableExtrinsic :: new (self . client , call)) } else { Err (:: subxt :: MetadataError :: IncompatibleMetadata . into ()) } } # [doc = "Approve a proposal. At a later time, the proposal will be allocated to the beneficiary"] # [doc = "and the original deposit will be returned."] # [doc = ""] # [doc = "May only be called from `T::ApproveOrigin`."] # [doc = ""] # [doc = "# <weight>"] # [doc = "- Complexity: O(1)."] # [doc = "- DbReads: `Proposals`, `Approvals`"] # [doc = "- DbWrite: `Approvals`"] # [doc = "# </weight>"] pub fn approve_proposal (& self , proposal_id : :: core :: primitive :: u32 ,) -> Result < :: subxt :: SubmittableExtrinsic < 'a , T , X , ApproveProposal , DispatchError , root_mod :: Event > , :: subxt :: BasicError > { if self . client . metadata () . call_hash :: < ApproveProposal > () ? == [191u8 , 81u8 , 78u8 , 230u8 , 230u8 , 192u8 , 144u8 , 232u8 , 81u8 , 70u8 , 227u8 , 212u8 , 194u8 , 228u8 , 231u8 , 147u8 , 57u8 , 222u8 , 156u8 , 77u8 , 173u8 , 60u8 , 92u8 , 84u8 , 255u8 , 64u8 , 240u8 , 45u8 , 131u8 , 200u8 , 206u8 , 231u8 ,] { let call = ApproveProposal { proposal_id , } ; Ok (:: subxt :: SubmittableExtrinsic :: new (self . client , call)) } else { Err (:: subxt :: MetadataError :: IncompatibleMetadata . into ()) } } # [doc = "Propose and approve a spend of treasury funds."] # [doc = ""] # [doc = "- `origin`: Must be `SpendOrigin` with the `Success` value being at least `amount`."] # [doc = "- `amount`: The amount to be transferred from the treasury to the `beneficiary`."] # [doc = "- `beneficiary`: The destination account for the transfer."] # [doc = ""] # [doc = "NOTE: For record-keeping purposes, the proposer is deemed to be equivalent to the"] # [doc = "beneficiary."] pub fn spend (& self , amount : :: core :: primitive :: u128 , beneficiary : :: subxt :: sp_runtime :: MultiAddress < :: subxt :: sp_core :: crypto :: AccountId32 , :: core :: primitive :: u32 > ,) -> Result < :: subxt :: SubmittableExtrinsic < 'a , T , X , Spend , DispatchError , root_mod :: Event > , :: subxt :: BasicError > { if self . client . metadata () . call_hash :: < Spend > () ? == [33u8 , 165u8 , 91u8 , 184u8 , 205u8 , 162u8 , 10u8 , 142u8 , 182u8 , 60u8 , 250u8 , 247u8 , 181u8 , 1u8 , 173u8 , 103u8 , 61u8 , 23u8 , 183u8 , 1u8 , 142u8 , 206u8 , 149u8 , 41u8 , 131u8 , 219u8 , 137u8 , 120u8 , 157u8 , 114u8 , 102u8 , 143u8 ,] { let call = Spend { amount , beneficiary , } ; Ok (:: subxt :: SubmittableExtrinsic :: new (self . client , call)) } else { Err (:: subxt :: MetadataError :: IncompatibleMetadata . into ()) } } # [doc = "Force a previously approved proposal to be removed from the approval queue."] # [doc = "The original deposit will no longer be returned."] # [doc = ""] # [doc = "May only be called from `T::RejectOrigin`."] # [doc = "- `proposal_id`: The index of a proposal"] # [doc = ""] # [doc = "# <weight>"] # [doc = "- Complexity: O(A) where `A` is the number of approvals"] # [doc = "- Db reads and writes: `Approvals`"] # [doc = "# </weight>"] # [doc = ""] # [doc = "Errors:"] # [doc = "- `ProposalNotApproved`: The `proposal_id` supplied was not found in the approval queue,"] # [doc = "i.e., the proposal has not been approved. This could also mean the proposal does not"] # [doc = "exist altogether, thus there is no way it would have been approved in the first place."] pub fn remove_approval (& self , proposal_id : :: core :: primitive :: u32 ,) -> Result < :: subxt :: SubmittableExtrinsic < 'a , T , X , RemoveApproval , DispatchError , root_mod :: Event > , :: subxt :: BasicError > { if self . client . metadata () . call_hash :: < RemoveApproval > () ? == [235u8 , 199u8 , 214u8 , 142u8 , 168u8 , 99u8 , 226u8 , 70u8 , 161u8 , 36u8 , 122u8 , 95u8 , 242u8 , 2u8 , 191u8 , 163u8 , 192u8 , 26u8 , 185u8 , 75u8 , 47u8 , 155u8 , 80u8 , 175u8 , 88u8 , 85u8 , 83u8 , 8u8 , 138u8 , 130u8 , 12u8 , 228u8 ,] { let call = RemoveApproval { proposal_id , } ; Ok (:: subxt :: SubmittableExtrinsic :: new (self . client , call)) } else { Err (:: subxt :: MetadataError :: IncompatibleMetadata . into ()) } } } } pub type Event = runtime_types :: pallet_treasury :: pallet :: Event ; pub mod events { use super :: runtime_types ; # [derive (:: subxt :: codec :: CompactAs , :: subxt :: codec :: Decode , :: subxt :: codec :: Encode , Clone , Debug , Eq , PartialEq)] # [doc = "New proposal."] pub struct Proposed { pub proposal_index : :: core :: primitive :: u32 , } impl :: subxt :: Event for Proposed { const PALLET : & 'static str = "Treasury" ; const EVENT : & 'static str = "Proposed" ; } # [derive (:: subxt :: codec :: CompactAs , :: subxt :: codec :: Decode , :: subxt :: codec :: Encode , Clone , Debug , Eq , PartialEq)] # [doc = "We have ended a spend period and will now allocate funds."] pub struct Spending { pub budget_remaining : :: core :: primitive :: u128 , } impl :: subxt :: Event for Spending { const PALLET : & 'static str = "Treasury" ; const EVENT : & 'static str = "Spending" ; } # [derive (:: subxt :: codec :: Decode , :: subxt :: codec :: Encode , Clone , Debug , Eq , PartialEq)] # [doc = "Some funds have been allocated."] pub struct Awarded { pub proposal_index : :: core :: primitive :: u32 , pub award : :: core :: primitive :: u128 , pub account : :: subxt :: sp_core :: crypto :: AccountId32 , } impl :: subxt :: Event for Awarded { const PALLET : & 'static str = "Treasury" ; const EVENT : & 'static str = "Awarded" ; } # [derive (:: subxt :: codec :: Decode , :: subxt :: codec :: Encode , Clone , Debug , Eq , PartialEq)] # [doc = "A proposal was rejected; funds were slashed."] pub struct Rejected { pub proposal_index : :: core :: primitive :: u32 , pub slashed : :: core :: primitive :: u128 , } impl :: subxt :: Event for Rejected { const PALLET : & 'static str = "Treasury" ; const EVENT : & 'static str = "Rejected" ; } # [derive (:: subxt :: codec :: CompactAs , :: subxt :: codec :: Decode , :: subxt :: codec :: Encode , Clone , Debug , Eq , PartialEq)] # [doc = "Some of our funds have been burnt."] pub struct Burnt { pub burnt_funds : :: core :: primitive :: u128 , } impl :: subxt :: Event for Burnt { const PALLET : & 'static str = "Treasury" ; const EVENT : & 'static str = "Burnt" ; } # [derive (:: subxt :: codec :: CompactAs , :: subxt :: codec :: Decode , :: subxt :: codec :: Encode , Clone , Debug , Eq , PartialEq)] # [doc = "Spending has finished; this is the amount that rolls over until next spend."] pub struct Rollover { pub rollover_balance : :: core :: primitive :: u128 , } impl :: subxt :: Event for Rollover { const PALLET : & 'static str = "Treasury" ; const EVENT : & 'static str = "Rollover" ; } # [derive (:: subxt :: codec :: CompactAs , :: subxt :: codec :: Decode , :: subxt :: codec :: Encode , Clone , Debug , Eq , PartialEq)] # [doc = "Some funds have been deposited."] pub struct Deposit { pub value : :: core :: primitive :: u128 , } impl :: subxt :: Event for Deposit { const PALLET : & 'static str = "Treasury" ; const EVENT : & 'static str = "Deposit" ; } # [derive (:: subxt :: codec :: Decode , :: subxt :: codec :: Encode , Clone , Debug , Eq , PartialEq)] # [doc = "A new spend proposal has been approved."] pub struct SpendApproved { pub proposal_index : :: core :: primitive :: u32 , pub amount : :: core :: primitive :: u128 , pub beneficiary : :: subxt :: sp_core :: crypto :: AccountId32 , } impl :: subxt :: Event for SpendApproved { const PALLET : & 'static str = "Treasury" ; const EVENT : & 'static str = "SpendApproved" ; } } pub mod storage { use super :: runtime_types ; pub struct ProposalCount ; impl :: subxt :: StorageEntry for ProposalCount { const PALLET : & 'static str = "Treasury" ; const STORAGE : & 'static str = "ProposalCount" ; type Value = :: core :: primitive :: u32 ; fn key (& self) -> :: subxt :: StorageEntryKey { :: subxt :: StorageEntryKey :: Plain } } pub struct Proposals < 'a > (pub & 'a :: core :: primitive :: u32) ; impl :: subxt :: StorageEntry for Proposals < '_ > { const PALLET : & 'static str = "Treasury" ; const STORAGE : & 'static str = "Proposals" ; type Value = runtime_types :: pallet_treasury :: Proposal < :: subxt :: sp_core :: crypto :: AccountId32 , :: core :: primitive :: u128 > ; fn key (& self) -> :: subxt :: StorageEntryKey { :: subxt :: StorageEntryKey :: Map (vec ! [:: subxt :: StorageMapKey :: new (& self . 0 , :: subxt :: StorageHasher :: Twox64Concat)]) } } pub struct Approvals ; impl :: subxt :: StorageEntry for Approvals { const PALLET : & 'static str = "Treasury" ; const STORAGE : & 'static str = "Approvals" ; type Value = runtime_types :: sp_runtime :: bounded :: bounded_vec :: BoundedVec < :: core :: primitive :: u32 > ; fn key (& self) -> :: subxt :: StorageEntryKey { :: subxt :: StorageEntryKey :: Plain } } pub struct StorageApi < 'a , T : :: subxt :: Config > { client : & 'a :: subxt :: Client < T > , } impl < 'a , T : :: subxt :: Config > StorageApi < 'a , T > { pub fn new (client : & 'a :: subxt :: Client < T >) -> Self { Self { client } } # [doc = " Number of proposals that have been made."] pub async fn proposal_count (& self , block_hash : :: core :: option :: Option < T :: Hash > ,) -> :: core :: result :: Result < :: core :: primitive :: u32 , :: subxt :: BasicError > { if self . client . metadata () . storage_hash :: < ProposalCount > () ? == [132u8 , 145u8 , 78u8 , 218u8 , 51u8 , 189u8 , 55u8 , 172u8 , 143u8 , 33u8 , 140u8 , 99u8 , 124u8 , 208u8 , 57u8 , 232u8 , 154u8 , 110u8 , 32u8 , 142u8 , 24u8 , 149u8 , 109u8 , 105u8 , 30u8 , 83u8 , 39u8 , 177u8 , 127u8 , 160u8 , 34u8 , 70u8 ,] { let entry = ProposalCount ; self . client . storage () . fetch_or_default (& entry , block_hash) . await } else { Err (:: subxt :: MetadataError :: IncompatibleMetadata . into ()) } } # [doc = " Proposals that have been made."] pub async fn proposals (& self , _0 : & :: core :: primitive :: u32 , block_hash : :: core :: option :: Option < T :: Hash > ,) -> :: core :: result :: Result < :: core :: option :: Option < runtime_types :: pallet_treasury :: Proposal < :: subxt :: sp_core :: crypto :: AccountId32 , :: core :: primitive :: u128 > > , :: subxt :: BasicError > { if self . client . metadata () . storage_hash :: < Proposals > () ? == [46u8 , 242u8 , 203u8 , 56u8 , 166u8 , 200u8 , 95u8 , 110u8 , 47u8 , 71u8 , 71u8 , 45u8 , 12u8 , 93u8 , 222u8 , 120u8 , 40u8 , 130u8 , 29u8 , 236u8 , 189u8 , 49u8 , 115u8 , 238u8 , 135u8 , 64u8 , 252u8 , 171u8 , 29u8 , 229u8 , 63u8 , 31u8 ,] { let entry = Proposals (_0) ; self . client . storage () . fetch (& entry , block_hash) . await } else { Err (:: subxt :: MetadataError :: IncompatibleMetadata . into ()) } } # [doc = " Proposals that have been made."] pub async fn proposals_iter (& self , block_hash : :: core :: option :: Option < T :: Hash > ,) -> :: core :: result :: Result < :: subxt :: KeyIter < 'a , T , Proposals < 'a > > , :: subxt :: BasicError > { if self . client . metadata () . storage_hash :: < Proposals > () ? == [46u8 , 242u8 , 203u8 , 56u8 , 166u8 , 200u8 , 95u8 , 110u8 , 47u8 , 71u8 , 71u8 , 45u8 , 12u8 , 93u8 , 222u8 , 120u8 , 40u8 , 130u8 , 29u8 , 236u8 , 189u8 , 49u8 , 115u8 , 238u8 , 135u8 , 64u8 , 252u8 , 171u8 , 29u8 , 229u8 , 63u8 , 31u8 ,] { self . client . storage () . iter (block_hash) . await } else { Err (:: subxt :: MetadataError :: IncompatibleMetadata . into ()) } } # [doc = " Proposal indices that have been approved but not yet awarded."] pub async fn approvals (& self , block_hash : :: core :: option :: Option < T :: Hash > ,) -> :: core :: result :: Result < runtime_types :: sp_runtime :: bounded :: bounded_vec :: BoundedVec < :: core :: primitive :: u32 > , :: subxt :: BasicError > { if self . client . metadata () . storage_hash :: < Approvals > () ? == [152u8 , 185u8 , 127u8 , 54u8 , 169u8 , 155u8 , 124u8 , 22u8 , 142u8 , 132u8 , 254u8 , 197u8 , 162u8 , 152u8 , 15u8 , 18u8 , 192u8 , 138u8 , 196u8 , 231u8 , 234u8 , 178u8 , 111u8 , 181u8 , 20u8 , 131u8 , 149u8 , 36u8 , 222u8 , 4u8 , 119u8 , 135u8 ,] { let entry = Approvals ; self . client . storage () . fetch_or_default (& entry , block_hash) . await } else { Err (:: subxt :: MetadataError :: IncompatibleMetadata . into ()) } } } } pub mod constants { use super :: runtime_types ; pub struct ConstantsApi < 'a , T : :: subxt :: Config > { client : & 'a :: subxt :: Client < T > , } impl < 'a , T : :: subxt :: Config > ConstantsApi < 'a , T > { pub fn new (client : & 'a :: subxt :: Client < T >) -> Self { Self { client } } # [doc = " Fraction of a proposal's value that should be bonded in order to place the proposal."] # [doc = " An accepted proposal gets these back. A rejected proposal does not."] pub fn proposal_bond (& self) -> :: core :: result :: Result < runtime_types :: sp_arithmetic :: per_things :: Permill , :: subxt :: BasicError > { if self . client . metadata () . constant_hash ("Treasury" , "ProposalBond") ? == [254u8 , 112u8 , 56u8 , 108u8 , 71u8 , 90u8 , 128u8 , 114u8 , 54u8 , 239u8 , 87u8 , 235u8 , 71u8 , 56u8 , 11u8 , 132u8 , 179u8 , 134u8 , 115u8 , 139u8 , 109u8 , 136u8 , 59u8 , 69u8 , 108u8 , 160u8 , 18u8 , 120u8 , 34u8 , 213u8 , 166u8 , 13u8 ,] { let pallet = self . client . metadata () . pallet ("Treasury") ? ; let constant = pallet . constant ("ProposalBond") ? ; let value = :: subxt :: codec :: Decode :: decode (& mut & constant . value [..]) ? ; Ok (value) } else { Err (:: subxt :: MetadataError :: IncompatibleMetadata . into ()) } } # [doc = " Minimum amount of funds that should be placed in a deposit for making a proposal."] pub fn proposal_bond_minimum (& self) -> :: core :: result :: Result < :: core :: primitive :: u128 , :: subxt :: BasicError > { if self . client . metadata () . constant_hash ("Treasury" , "ProposalBondMinimum") ? == [233u8 , 16u8 , 162u8 , 158u8 , 32u8 , 30u8 , 243u8 , 215u8 , 145u8 , 211u8 , 68u8 , 173u8 , 77u8 , 212u8 , 78u8 , 195u8 , 144u8 , 4u8 , 72u8 , 249u8 , 90u8 , 11u8 , 26u8 , 64u8 , 65u8 , 90u8 , 193u8 , 69u8 , 145u8 , 33u8 , 163u8 , 122u8 ,] { let pallet = self . client . metadata () . pallet ("Treasury") ? ; let constant = pallet . constant ("ProposalBondMinimum") ? ; let value = :: subxt :: codec :: Decode :: decode (& mut & constant . value [..]) ? ; Ok (value) } else { Err (:: subxt :: MetadataError :: IncompatibleMetadata . into ()) } } # [doc = " Maximum amount of funds that should be placed in a deposit for making a proposal."] pub fn proposal_bond_maximum (& self) -> :: core :: result :: Result < :: core :: option :: Option < :: core :: primitive :: u128 > , :: subxt :: BasicError > { if self . client . metadata () . constant_hash ("Treasury" , "ProposalBondMaximum") ? == [79u8 , 134u8 , 147u8 , 214u8 , 110u8 , 132u8 , 189u8 , 187u8 , 0u8 , 91u8 , 197u8 , 118u8 , 151u8 , 131u8 , 196u8 , 215u8 , 19u8 , 78u8 , 42u8 , 44u8 , 54u8 , 254u8 , 191u8 , 209u8 , 21u8 , 157u8 , 22u8 , 42u8 , 74u8 , 29u8 , 105u8 , 141u8 ,] { let pallet = self . client . metadata () . pallet ("Treasury") ? ; let constant = pallet . constant ("ProposalBondMaximum") ? ; let value = :: subxt :: codec :: Decode :: decode (& mut & constant . value [..]) ? ; Ok (value) } else { Err (:: subxt :: MetadataError :: IncompatibleMetadata . into ()) } } # [doc = " Period between successive spends."] pub fn spend_period (& self) -> :: core :: result :: Result < :: core :: primitive :: u32 , :: subxt :: BasicError > { if self . client . metadata () . constant_hash ("Treasury" , "SpendPeriod") ? == [115u8 , 221u8 , 84u8 , 219u8 , 142u8 , 238u8 , 6u8 , 207u8 , 71u8 , 87u8 , 240u8 , 69u8 , 79u8 , 23u8 , 51u8 , 10u8 , 0u8 , 181u8 , 107u8 , 195u8 , 62u8 , 157u8 , 168u8 , 4u8 , 186u8 , 106u8 , 130u8 , 8u8 , 183u8 , 234u8 , 154u8 , 37u8 ,] { let pallet = self . client . metadata () . pallet ("Treasury") ? ; let constant = pallet . constant ("SpendPeriod") ? ; let value = :: subxt :: codec :: Decode :: decode (& mut & constant . value [..]) ? ; Ok (value) } else { Err (:: subxt :: MetadataError :: IncompatibleMetadata . into ()) } } # [doc = " Percentage of spare funds (if any) that are burnt per spend period."] pub fn burn (& self) -> :: core :: result :: Result < runtime_types :: sp_arithmetic :: per_things :: Permill , :: subxt :: BasicError > { if self . client . metadata () . constant_hash ("Treasury" , "Burn") ? == [23u8 , 135u8 , 10u8 , 8u8 , 254u8 , 98u8 , 29u8 , 19u8 , 250u8 , 126u8 , 55u8 , 163u8 , 214u8 , 9u8 , 137u8 , 147u8 , 184u8 , 116u8 , 178u8 , 88u8 , 118u8 , 94u8 , 19u8 , 239u8 , 105u8 , 224u8 , 169u8 , 50u8 , 141u8 , 137u8 , 182u8 , 202u8 ,] { let pallet = self . client . metadata () . pallet ("Treasury") ? ; let constant = pallet . constant ("Burn") ? ; let value = :: subxt :: codec :: Decode :: decode (& mut & constant . value [..]) ? ; Ok (value) } else { Err (:: subxt :: MetadataError :: IncompatibleMetadata . into ()) } } # [doc = " The treasury's pallet id, used for deriving its sovereign account ID."] pub fn pallet_id (& self) -> :: core :: result :: Result < runtime_types :: frame_support :: PalletId , :: subxt :: BasicError > { if self . client . metadata () . constant_hash ("Treasury" , "PalletId") ? == [65u8 , 140u8 , 92u8 , 164u8 , 174u8 , 209u8 , 169u8 , 31u8 , 29u8 , 55u8 , 10u8 , 151u8 , 10u8 , 165u8 , 68u8 , 7u8 , 110u8 , 108u8 , 233u8 , 42u8 , 19u8 , 211u8 , 98u8 , 108u8 , 73u8 , 14u8 , 235u8 , 97u8 , 23u8 , 118u8 , 211u8 , 21u8 ,] { let pallet = self . client . metadata () . pallet ("Treasury") ? ; let constant = pallet . constant ("PalletId") ? ; let value = :: subxt :: codec :: Decode :: decode (& mut & constant . value [..]) ? ; Ok (value) } else { Err (:: subxt :: MetadataError :: IncompatibleMetadata . into ()) } } # [doc = " The maximum number of approvals that can wait in the spending queue."] # [doc = ""] # [doc = " NOTE: This parameter is also used within the Bounties Pallet extension if enabled."] pub fn max_approvals (& self) -> :: core :: result :: Result < :: core :: primitive :: u32 , :: subxt :: BasicError > { if self . client . metadata () . constant_hash ("Treasury" , "MaxApprovals") ? == [90u8 , 101u8 , 189u8 , 20u8 , 137u8 , 178u8 , 7u8 , 81u8 , 148u8 , 6u8 , 59u8 , 229u8 , 228u8 , 66u8 , 13u8 , 179u8 , 199u8 , 159u8 , 168u8 , 227u8 , 3u8 , 76u8 , 124u8 , 35u8 , 199u8 , 142u8 , 79u8 , 78u8 , 254u8 , 63u8 , 2u8 , 175u8 ,] { let pallet = self . client . metadata () . pallet ("Treasury") ? ; let constant = pallet . constant ("MaxApprovals") ? ; let value = :: subxt :: codec :: Decode :: decode (& mut & constant . value [..]) ? ; Ok (value) } else { Err (:: subxt :: MetadataError :: IncompatibleMetadata . into ()) } } } } } pub mod bounties { use super :: root_mod ; use super :: runtime_types ; pub mod calls { use super :: root_mod ; use super :: runtime_types ; type DispatchError = runtime_types :: sp_runtime :: DispatchError ; # [derive (:: subxt :: codec :: Decode , :: subxt :: codec :: Encode , Clone , Debug , Eq , PartialEq)] pub struct ProposeBounty { # [codec (compact)] pub value : :: core :: primitive :: u128 , pub description : :: std :: vec :: Vec < :: core :: primitive :: u8 > , } impl :: subxt :: Call for ProposeBounty { const PALLET : & 'static str = "Bounties" ; const FUNCTION : & 'static str = "propose_bounty" ; } # [derive (:: subxt :: codec :: Decode , :: subxt :: codec :: Encode , Clone , Debug , Eq , PartialEq)] pub struct ApproveBounty { # [codec (compact)] pub bounty_id : :: core :: primitive :: u32 , } impl :: subxt :: Call for ApproveBounty { const PALLET : & 'static str = "Bounties" ; const FUNCTION : & 'static str = "approve_bounty" ; } # [derive (:: subxt :: codec :: Decode , :: subxt :: codec :: Encode , Clone , Debug , Eq , PartialEq)] pub struct ProposeCurator { # [codec (compact)] pub bounty_id : :: core :: primitive :: u32 , pub curator : :: subxt :: sp_runtime :: MultiAddress < :: subxt :: sp_core :: crypto :: AccountId32 , :: core :: primitive :: u32 > , # [codec (compact)] pub fee : :: core :: primitive :: u128 , } impl :: subxt :: Call for ProposeCurator { const PALLET : & 'static str = "Bounties" ; const FUNCTION : & 'static str = "propose_curator" ; } # [derive (:: subxt :: codec :: Decode , :: subxt :: codec :: Encode , Clone , Debug , Eq , PartialEq)] pub struct UnassignCurator { # [codec (compact)] pub bounty_id : :: core :: primitive :: u32 , } impl :: subxt :: Call for UnassignCurator { const PALLET : & 'static str = "Bounties" ; const FUNCTION : & 'static str = "unassign_curator" ; } # [derive (:: subxt :: codec :: Decode , :: subxt :: codec :: Encode , Clone , Debug , Eq , PartialEq)] pub struct AcceptCurator { # [codec (compact)] pub bounty_id : :: core :: primitive :: u32 , } impl :: subxt :: Call for AcceptCurator { const PALLET : & 'static str = "Bounties" ; const FUNCTION : & 'static str = "accept_curator" ; } # [derive (:: subxt :: codec :: Decode , :: subxt :: codec :: Encode , Clone , Debug , Eq , PartialEq)] pub struct AwardBounty { # [codec (compact)] pub bounty_id : :: core :: primitive :: u32 , pub beneficiary : :: subxt :: sp_runtime :: MultiAddress < :: subxt :: sp_core :: crypto :: AccountId32 , :: core :: primitive :: u32 > , } impl :: subxt :: Call for AwardBounty { const PALLET : & 'static str = "Bounties" ; const FUNCTION : & 'static str = "award_bounty" ; } # [derive (:: subxt :: codec :: Decode , :: subxt :: codec :: Encode , Clone , Debug , Eq , PartialEq)] pub struct ClaimBounty { # [codec (compact)] pub bounty_id : :: core :: primitive :: u32 , } impl :: subxt :: Call for ClaimBounty { const PALLET : & 'static str = "Bounties" ; const FUNCTION : & 'static str = "claim_bounty" ; } # [derive (:: subxt :: codec :: Decode , :: subxt :: codec :: Encode , Clone , Debug , Eq , PartialEq)] pub struct CloseBounty { # [codec (compact)] pub bounty_id : :: core :: primitive :: u32 , } impl :: subxt :: Call for CloseBounty { const PALLET : & 'static str = "Bounties" ; const FUNCTION : & 'static str = "close_bounty" ; } # [derive (:: subxt :: codec :: Decode , :: subxt :: codec :: Encode , Clone , Debug , Eq , PartialEq)] pub struct ExtendBountyExpiry { # [codec (compact)] pub bounty_id : :: core :: primitive :: u32 , pub remark : :: std :: vec :: Vec < :: core :: primitive :: u8 > , } impl :: subxt :: Call for ExtendBountyExpiry { const PALLET : & 'static str = "Bounties" ; const FUNCTION : & 'static str = "extend_bounty_expiry" ; } pub struct TransactionApi < 'a , T : :: subxt :: Config , X > { client : & 'a :: subxt :: Client < T > , marker : :: core :: marker :: PhantomData < X > , } impl < 'a , T , X > TransactionApi < 'a , T , X > where T : :: subxt :: Config , X : :: subxt :: extrinsic :: ExtrinsicParams < T > , { pub fn new (client : & 'a :: subxt :: Client < T >) -> Self { Self { client , marker : :: core :: marker :: PhantomData } } # [doc = "Propose a new bounty."] # [doc = ""] # [doc = "The dispatch origin for this call must be _Signed_."] # [doc = ""] # [doc = "Payment: `TipReportDepositBase` will be reserved from the origin account, as well as"] # [doc = "`DataDepositPerByte` for each byte in `reason`. It will be unreserved upon approval,"] # [doc = "or slashed when rejected."] # [doc = ""] # [doc = "- `curator`: The curator account whom will manage this bounty."] # [doc = "- `fee`: The curator fee."] # [doc = "- `value`: The total payment amount of this bounty, curator fee included."] # [doc = "- `description`: The description of this bounty."] pub fn propose_bounty (& self , value : :: core :: primitive :: u128 , description : :: std :: vec :: Vec < :: core :: primitive :: u8 > ,) -> Result < :: subxt :: SubmittableExtrinsic < 'a , T , X , ProposeBounty , DispatchError , root_mod :: Event > , :: subxt :: BasicError > { if self . client . metadata () . call_hash :: < ProposeBounty > () ? == [253u8 , 42u8 , 134u8 , 229u8 , 115u8 , 98u8 , 40u8 , 39u8 , 180u8 , 206u8 , 12u8 , 1u8 , 35u8 , 196u8 , 71u8 , 167u8 , 210u8 , 16u8 , 215u8 , 84u8 , 56u8 , 193u8 , 19u8 , 147u8 , 96u8 , 5u8 , 4u8 , 223u8 , 106u8 , 30u8 , 21u8 , 89u8 ,] { let call = ProposeBounty { value , description , } ; Ok (:: subxt :: SubmittableExtrinsic :: new (self . client , call)) } else { Err (:: subxt :: MetadataError :: IncompatibleMetadata . into ()) } } # [doc = "Approve a bounty proposal. At a later time, the bounty will be funded and become active"] # [doc = "and the original deposit will be returned."] # [doc = ""] # [doc = "May only be called from `T::ApproveOrigin`."] # [doc = ""] # [doc = "# <weight>"] # [doc = "- O(1)."] # [doc = "# </weight>"] pub fn approve_bounty (& self , bounty_id : :: core :: primitive :: u32 ,) -> Result < :: subxt :: SubmittableExtrinsic < 'a , T , X , ApproveBounty , DispatchError , root_mod :: Event > , :: subxt :: BasicError > { if self . client . metadata () . call_hash :: < ApproveBounty > () ? == [127u8 , 220u8 , 25u8 , 197u8 , 19u8 , 183u8 , 177u8 , 17u8 , 164u8 , 29u8 , 250u8 , 136u8 , 125u8 , 90u8 , 247u8 , 177u8 , 37u8 , 180u8 , 77u8 , 75u8 , 164u8 , 32u8 , 195u8 , 207u8 , 58u8 , 249u8 , 141u8 , 11u8 , 53u8 , 184u8 , 224u8 , 135u8 ,] { let call = ApproveBounty { bounty_id , } ; Ok (:: subxt :: SubmittableExtrinsic :: new (self . client , call)) } else { Err (:: subxt :: MetadataError :: IncompatibleMetadata . into ()) } } # [doc = "Assign a curator to a funded bounty."] # [doc = ""] # [doc = "May only be called from `T::ApproveOrigin`."] # [doc = ""] # [doc = "# <weight>"] # [doc = "- O(1)."] # [doc = "# </weight>"] pub fn propose_curator (& self , bounty_id : :: core :: primitive :: u32 , curator : :: subxt :: sp_runtime :: MultiAddress < :: subxt :: sp_core :: crypto :: AccountId32 , :: core :: primitive :: u32 > , fee : :: core :: primitive :: u128 ,) -> Result < :: subxt :: SubmittableExtrinsic < 'a , T , X , ProposeCurator , DispatchError , root_mod :: Event > , :: subxt :: BasicError > { if self . client . metadata () . call_hash :: < ProposeCurator > () ? == [252u8 , 38u8 , 214u8 , 162u8 , 194u8 , 249u8 , 16u8 , 54u8 , 77u8 , 181u8 , 121u8 , 16u8 , 242u8 , 109u8 , 13u8 , 28u8 , 111u8 , 194u8 , 174u8 , 234u8 , 254u8 , 80u8 , 26u8 , 19u8 , 58u8 , 149u8 , 2u8 , 50u8 , 10u8 , 70u8 , 154u8 , 101u8 ,] { let call = ProposeCurator { bounty_id , curator , fee , } ; Ok (:: subxt :: SubmittableExtrinsic :: new (self . client , call)) } else { Err (:: subxt :: MetadataError :: IncompatibleMetadata . into ()) } } # [doc = "Unassign curator from a bounty."] # [doc = ""] # [doc = "This function can only be called by the `RejectOrigin` a signed origin."] # [doc = ""] # [doc = "If this function is called by the `RejectOrigin`, we assume that the curator is"] # [doc = "malicious or inactive. As a result, we will slash the curator when possible."] # [doc = ""] # [doc = "If the origin is the curator, we take this as a sign they are unable to do their job and"] # [doc = "they willingly give up. We could slash them, but for now we allow them to recover their"] # [doc = "deposit and exit without issue. (We may want to change this if it is abused.)"] # [doc = ""] # [doc = "Finally, the origin can be anyone if and only if the curator is \"inactive\". This allows"] # [doc = "anyone in the community to call out that a curator is not doing their due diligence, and"] # [doc = "we should pick a new curator. In this case the curator should also be slashed."] # [doc = ""] # [doc = "# <weight>"] # [doc = "- O(1)."] # [doc = "# </weight>"] pub fn unassign_curator (& self , bounty_id : :: core :: primitive :: u32 ,) -> Result < :: subxt :: SubmittableExtrinsic < 'a , T , X , UnassignCurator , DispatchError , root_mod :: Event > , :: subxt :: BasicError > { if self . client . metadata () . call_hash :: < UnassignCurator > () ? == [156u8 , 163u8 , 248u8 , 148u8 , 22u8 , 231u8 , 232u8 , 182u8 , 48u8 , 87u8 , 85u8 , 118u8 , 169u8 , 249u8 , 123u8 , 199u8 , 248u8 , 206u8 , 221u8 , 196u8 , 69u8 , 69u8 , 52u8 , 116u8 , 65u8 , 165u8 , 172u8 , 242u8 , 61u8 , 109u8 , 143u8 , 69u8 ,] { let call = UnassignCurator { bounty_id , } ; Ok (:: subxt :: SubmittableExtrinsic :: new (self . client , call)) } else { Err (:: subxt :: MetadataError :: IncompatibleMetadata . into ()) } } # [doc = "Accept the curator role for a bounty."] # [doc = "A deposit will be reserved from curator and refund upon successful payout."] # [doc = ""] # [doc = "May only be called from the curator."] # [doc = ""] # [doc = "# <weight>"] # [doc = "- O(1)."] # [doc = "# </weight>"] pub fn accept_curator (& self , bounty_id : :: core :: primitive :: u32 ,) -> Result < :: subxt :: SubmittableExtrinsic < 'a , T , X , AcceptCurator , DispatchError , root_mod :: Event > , :: subxt :: BasicError > { if self . client . metadata () . call_hash :: < AcceptCurator > () ? == [50u8 , 149u8 , 252u8 , 40u8 , 169u8 , 113u8 , 60u8 , 153u8 , 123u8 , 146u8 , 40u8 , 196u8 , 176u8 , 195u8 , 95u8 , 94u8 , 14u8 , 81u8 , 136u8 , 225u8 , 24u8 , 59u8 , 87u8 , 118u8 , 77u8 , 60u8 , 150u8 , 102u8 , 206u8 , 219u8 , 241u8 , 99u8 ,] { let call = AcceptCurator { bounty_id , } ; Ok (:: subxt :: SubmittableExtrinsic :: new (self . client , call)) } else { Err (:: subxt :: MetadataError :: IncompatibleMetadata . into ()) } } # [doc = "Award bounty to a beneficiary account. The beneficiary will be able to claim the funds"] # [doc = "after a delay."] # [doc = ""] # [doc = "The dispatch origin for this call must be the curator of this bounty."] # [doc = ""] # [doc = "- `bounty_id`: Bounty ID to award."] # [doc = "- `beneficiary`: The beneficiary account whom will receive the payout."] # [doc = ""] # [doc = "# <weight>"] # [doc = "- O(1)."] # [doc = "# </weight>"] pub fn award_bounty (& self , bounty_id : :: core :: primitive :: u32 , beneficiary : :: subxt :: sp_runtime :: MultiAddress < :: subxt :: sp_core :: crypto :: AccountId32 , :: core :: primitive :: u32 > ,) -> Result < :: subxt :: SubmittableExtrinsic < 'a , T , X , AwardBounty , DispatchError , root_mod :: Event > , :: subxt :: BasicError > { if self . client . metadata () . call_hash :: < AwardBounty > () ? == [22u8 , 6u8 , 78u8 , 247u8 , 133u8 , 35u8 , 24u8 , 170u8 , 12u8 , 14u8 , 157u8 , 190u8 , 0u8 , 89u8 , 186u8 , 31u8 , 239u8 , 160u8 , 81u8 , 169u8 , 20u8 , 30u8 , 101u8 , 147u8 , 2u8 , 148u8 , 0u8 , 210u8 , 99u8 , 94u8 , 4u8 , 241u8 ,] { let call = AwardBounty { bounty_id , beneficiary , } ; Ok (:: subxt :: SubmittableExtrinsic :: new (self . client , call)) } else { Err (:: subxt :: MetadataError :: IncompatibleMetadata . into ()) } } # [doc = "Claim the payout from an awarded bounty after payout delay."] # [doc = ""] # [doc = "The dispatch origin for this call must be the beneficiary of this bounty."] # [doc = ""] # [doc = "- `bounty_id`: Bounty ID to claim."] # [doc = ""] # [doc = "# <weight>"] # [doc = "- O(1)."] # [doc = "# </weight>"] pub fn claim_bounty (& self , bounty_id : :: core :: primitive :: u32 ,) -> Result < :: subxt :: SubmittableExtrinsic < 'a , T , X , ClaimBounty , DispatchError , root_mod :: Event > , :: subxt :: BasicError > { if self . client . metadata () . call_hash :: < ClaimBounty > () ? == [119u8 , 9u8 , 122u8 , 55u8 , 224u8 , 139u8 , 26u8 , 186u8 , 3u8 , 178u8 , 78u8 , 41u8 , 91u8 , 183u8 , 222u8 , 197u8 , 189u8 , 172u8 , 154u8 , 47u8 , 2u8 , 164u8 , 141u8 , 163u8 , 211u8 , 117u8 , 186u8 , 121u8 , 130u8 , 91u8 , 13u8 , 241u8 ,] { let call = ClaimBounty { bounty_id , } ; Ok (:: subxt :: SubmittableExtrinsic :: new (self . client , call)) } else { Err (:: subxt :: MetadataError :: IncompatibleMetadata . into ()) } } # [doc = "Cancel a proposed or active bounty. All the funds will be sent to treasury and"] # [doc = "the curator deposit will be unreserved if possible."] # [doc = ""] # [doc = "Only `T::RejectOrigin` is able to cancel a bounty."] # [doc = ""] # [doc = "- `bounty_id`: Bounty ID to cancel."] # [doc = ""] # [doc = "# <weight>"] # [doc = "- O(1)."] # [doc = "# </weight>"] pub fn close_bounty (& self , bounty_id : :: core :: primitive :: u32 ,) -> Result < :: subxt :: SubmittableExtrinsic < 'a , T , X , CloseBounty , DispatchError , root_mod :: Event > , :: subxt :: BasicError > { if self . client . metadata () . call_hash :: < CloseBounty > () ? == [119u8 , 47u8 , 246u8 , 188u8 , 235u8 , 22u8 , 53u8 , 70u8 , 182u8 , 15u8 , 247u8 , 153u8 , 208u8 , 191u8 , 144u8 , 132u8 , 30u8 , 200u8 , 36u8 , 186u8 , 194u8 , 225u8 , 140u8 , 160u8 , 152u8 , 194u8 , 38u8 , 223u8 , 33u8 , 130u8 , 120u8 , 254u8 ,] { let call = CloseBounty { bounty_id , } ; Ok (:: subxt :: SubmittableExtrinsic :: new (self . client , call)) } else { Err (:: subxt :: MetadataError :: IncompatibleMetadata . into ()) } } # [doc = "Extend the expiry time of an active bounty."] # [doc = ""] # [doc = "The dispatch origin for this call must be the curator of this bounty."] # [doc = ""] # [doc = "- `bounty_id`: Bounty ID to extend."] # [doc = "- `remark`: additional information."] # [doc = ""] # [doc = "# <weight>"] # [doc = "- O(1)."] # [doc = "# </weight>"] pub fn extend_bounty_expiry (& self , bounty_id : :: core :: primitive :: u32 , remark : :: std :: vec :: Vec < :: core :: primitive :: u8 > ,) -> Result < :: subxt :: SubmittableExtrinsic < 'a , T , X , ExtendBountyExpiry , DispatchError , root_mod :: Event > , :: subxt :: BasicError > { if self . client . metadata () . call_hash :: < ExtendBountyExpiry > () ? == [127u8 , 142u8 , 138u8 , 230u8 , 147u8 , 187u8 , 201u8 , 210u8 , 216u8 , 61u8 , 62u8 , 125u8 , 168u8 , 188u8 , 16u8 , 73u8 , 157u8 , 53u8 , 165u8 , 236u8 , 181u8 , 26u8 , 28u8 , 67u8 , 59u8 , 234u8 , 189u8 , 167u8 , 92u8 , 242u8 , 138u8 , 35u8 ,] { let call = ExtendBountyExpiry { bounty_id , remark , } ; Ok (:: subxt :: SubmittableExtrinsic :: new (self . client , call)) } else { Err (:: subxt :: MetadataError :: IncompatibleMetadata . into ()) } } } } pub type Event = runtime_types :: pallet_bounties :: pallet :: Event ; pub mod events { use super :: runtime_types ; # [derive (:: subxt :: codec :: CompactAs , :: subxt :: codec :: Decode , :: subxt :: codec :: Encode , Clone , Debug , Eq , PartialEq)] # [doc = "New bounty proposal."] pub struct BountyProposed { pub index : :: core :: primitive :: u32 , } impl :: subxt :: Event for BountyProposed { const PALLET : & 'static str = "Bounties" ; const EVENT : & 'static str = "BountyProposed" ; } # [derive (:: subxt :: codec :: Decode , :: subxt :: codec :: Encode , Clone , Debug , Eq , PartialEq)] # [doc = "A bounty proposal was rejected; funds were slashed."] pub struct BountyRejected { pub index : :: core :: primitive :: u32 , pub bond : :: core :: primitive :: u128 , } impl :: subxt :: Event for BountyRejected { const PALLET : & 'static str = "Bounties" ; const EVENT : & 'static str = "BountyRejected" ; } # [derive (:: subxt :: codec :: CompactAs , :: subxt :: codec :: Decode , :: subxt :: codec :: Encode , Clone , Debug , Eq , PartialEq)] # [doc = "A bounty proposal is funded and became active."] pub struct BountyBecameActive { pub index : :: core :: primitive :: u32 , } impl :: subxt :: Event for BountyBecameActive { const PALLET : & 'static str = "Bounties" ; const EVENT : & 'static str = "BountyBecameActive" ; } # [derive (:: subxt :: codec :: Decode , :: subxt :: codec :: Encode , Clone , Debug , Eq , PartialEq)] # [doc = "A bounty is awarded to a beneficiary."] pub struct BountyAwarded { pub index : :: core :: primitive :: u32 , pub beneficiary : :: subxt :: sp_core :: crypto :: AccountId32 , } impl :: subxt :: Event for BountyAwarded { const PALLET : & 'static str = "Bounties" ; const EVENT : & 'static str = "BountyAwarded" ; } # [derive (:: subxt :: codec :: Decode , :: subxt :: codec :: Encode , Clone , Debug , Eq , PartialEq)] # [doc = "A bounty is claimed by beneficiary."] pub struct BountyClaimed { pub index : :: core :: primitive :: u32 , pub payout : :: core :: primitive :: u128 , pub beneficiary : :: subxt :: sp_core :: crypto :: AccountId32 , } impl :: subxt :: Event for BountyClaimed { const PALLET : & 'static str = "Bounties" ; const EVENT : & 'static str = "BountyClaimed" ; } # [derive (:: subxt :: codec :: CompactAs , :: subxt :: codec :: Decode , :: subxt :: codec :: Encode , Clone , Debug , Eq , PartialEq)] # [doc = "A bounty is cancelled."] pub struct BountyCanceled { pub index : :: core :: primitive :: u32 , } impl :: subxt :: Event for BountyCanceled { const PALLET : & 'static str = "Bounties" ; const EVENT : & 'static str = "BountyCanceled" ; } # [derive (:: subxt :: codec :: CompactAs , :: subxt :: codec :: Decode , :: subxt :: codec :: Encode , Clone , Debug , Eq , PartialEq)] # [doc = "A bounty expiry is extended."] pub struct BountyExtended { pub index : :: core :: primitive :: u32 , } impl :: subxt :: Event for BountyExtended { const PALLET : & 'static str = "Bounties" ; const EVENT : & 'static str = "BountyExtended" ; } } pub mod storage { use super :: runtime_types ; pub struct BountyCount ; impl :: subxt :: StorageEntry for BountyCount { const PALLET : & 'static str = "Bounties" ; const STORAGE : & 'static str = "BountyCount" ; type Value = :: core :: primitive :: u32 ; fn key (& self) -> :: subxt :: StorageEntryKey { :: subxt :: StorageEntryKey :: Plain } } pub struct Bounties < 'a > (pub & 'a :: core :: primitive :: u32) ; impl :: subxt :: StorageEntry for Bounties < '_ > { const PALLET : & 'static str = "Bounties" ; const STORAGE : & 'static str = "Bounties" ; type Value = runtime_types :: pallet_bounties :: Bounty < :: subxt :: sp_core :: crypto :: AccountId32 , :: core :: primitive :: u128 , :: core :: primitive :: u32 > ; fn key (& self) -> :: subxt :: StorageEntryKey { :: subxt :: StorageEntryKey :: Map (vec ! [:: subxt :: StorageMapKey :: new (& self . 0 , :: subxt :: StorageHasher :: Twox64Concat)]) } } pub struct BountyDescriptions < 'a > (pub & 'a :: core :: primitive :: u32) ; impl :: subxt :: StorageEntry for BountyDescriptions < '_ > { const PALLET : & 'static str = "Bounties" ; const STORAGE : & 'static str = "BountyDescriptions" ; type Value = runtime_types :: sp_runtime :: bounded :: bounded_vec :: BoundedVec < :: core :: primitive :: u8 > ; fn key (& self) -> :: subxt :: StorageEntryKey { :: subxt :: StorageEntryKey :: Map (vec ! [:: subxt :: StorageMapKey :: new (& self . 0 , :: subxt :: StorageHasher :: Twox64Concat)]) } } pub struct BountyApprovals ; impl :: subxt :: StorageEntry for BountyApprovals { const PALLET : & 'static str = "Bounties" ; const STORAGE : & 'static str = "BountyApprovals" ; type Value = runtime_types :: sp_runtime :: bounded :: bounded_vec :: BoundedVec < :: core :: primitive :: u32 > ; fn key (& self) -> :: subxt :: StorageEntryKey { :: subxt :: StorageEntryKey :: Plain } } pub struct StorageApi < 'a , T : :: subxt :: Config > { client : & 'a :: subxt :: Client < T > , } impl < 'a , T : :: subxt :: Config > StorageApi < 'a , T > { pub fn new (client : & 'a :: subxt :: Client < T >) -> Self { Self { client } } # [doc = " Number of bounty proposals that have been made."] pub async fn bounty_count (& self , block_hash : :: core :: option :: Option < T :: Hash > ,) -> :: core :: result :: Result < :: core :: primitive :: u32 , :: subxt :: BasicError > { if self . client . metadata () . storage_hash :: < BountyCount > () ? == [5u8 , 188u8 , 134u8 , 220u8 , 64u8 , 49u8 , 188u8 , 98u8 , 185u8 , 186u8 , 230u8 , 65u8 , 247u8 , 199u8 , 28u8 , 178u8 , 202u8 , 193u8 , 41u8 , 83u8 , 115u8 , 253u8 , 182u8 , 123u8 , 92u8 , 138u8 , 12u8 , 31u8 , 31u8 , 213u8 , 23u8 , 118u8 ,] { let entry = BountyCount ; self . client . storage () . fetch_or_default (& entry , block_hash) . await } else { Err (:: subxt :: MetadataError :: IncompatibleMetadata . into ()) } } # [doc = " Bounties that have been made."] pub async fn bounties (& self , _0 : & :: core :: primitive :: u32 , block_hash : :: core :: option :: Option < T :: Hash > ,) -> :: core :: result :: Result < :: core :: option :: Option < runtime_types :: pallet_bounties :: Bounty < :: subxt :: sp_core :: crypto :: AccountId32 , :: core :: primitive :: u128 , :: core :: primitive :: u32 > > , :: subxt :: BasicError > { if self . client . metadata () . storage_hash :: < Bounties > () ? == [27u8 , 154u8 , 97u8 , 199u8 , 230u8 , 195u8 , 155u8 , 198u8 , 4u8 , 28u8 , 5u8 , 202u8 , 175u8 , 11u8 , 243u8 , 166u8 , 67u8 , 231u8 , 125u8 , 203u8 , 141u8 , 168u8 , 106u8 , 218u8 , 129u8 , 25u8 , 231u8 , 253u8 , 126u8 , 144u8 , 46u8 , 255u8 ,] { let entry = Bounties (_0) ; self . client . storage () . fetch (& entry , block_hash) . await } else { Err (:: subxt :: MetadataError :: IncompatibleMetadata . into ()) } } # [doc = " Bounties that have been made."] pub async fn bounties_iter (& self , block_hash : :: core :: option :: Option < T :: Hash > ,) -> :: core :: result :: Result < :: subxt :: KeyIter < 'a , T , Bounties < 'a > > , :: subxt :: BasicError > { if self . client . metadata () . storage_hash :: < Bounties > () ? == [27u8 , 154u8 , 97u8 , 199u8 , 230u8 , 195u8 , 155u8 , 198u8 , 4u8 , 28u8 , 5u8 , 202u8 , 175u8 , 11u8 , 243u8 , 166u8 , 67u8 , 231u8 , 125u8 , 203u8 , 141u8 , 168u8 , 106u8 , 218u8 , 129u8 , 25u8 , 231u8 , 253u8 , 126u8 , 144u8 , 46u8 , 255u8 ,] { self . client . storage () . iter (block_hash) . await } else { Err (:: subxt :: MetadataError :: IncompatibleMetadata . into ()) } } # [doc = " The description of each bounty."] pub async fn bounty_descriptions (& self , _0 : & :: core :: primitive :: u32 , block_hash : :: core :: option :: Option < T :: Hash > ,) -> :: core :: result :: Result < :: core :: option :: Option < runtime_types :: sp_runtime :: bounded :: bounded_vec :: BoundedVec < :: core :: primitive :: u8 > > , :: subxt :: BasicError > { if self . client . metadata () . storage_hash :: < BountyDescriptions > () ? == [41u8 , 78u8 , 19u8 , 48u8 , 241u8 , 95u8 , 175u8 , 69u8 , 236u8 , 54u8 , 84u8 , 58u8 , 69u8 , 28u8 , 20u8 , 20u8 , 214u8 , 138u8 , 163u8 , 252u8 , 239u8 , 116u8 , 171u8 , 136u8 , 0u8 , 159u8 , 192u8 , 51u8 , 191u8 , 160u8 , 131u8 , 123u8 ,] { let entry = BountyDescriptions (_0) ; self . client . storage () . fetch (& entry , block_hash) . await } else { Err (:: subxt :: MetadataError :: IncompatibleMetadata . into ()) } } # [doc = " The description of each bounty."] pub async fn bounty_descriptions_iter (& self , block_hash : :: core :: option :: Option < T :: Hash > ,) -> :: core :: result :: Result < :: subxt :: KeyIter < 'a , T , BountyDescriptions < 'a > > , :: subxt :: BasicError > { if self . client . metadata () . storage_hash :: < BountyDescriptions > () ? == [41u8 , 78u8 , 19u8 , 48u8 , 241u8 , 95u8 , 175u8 , 69u8 , 236u8 , 54u8 , 84u8 , 58u8 , 69u8 , 28u8 , 20u8 , 20u8 , 214u8 , 138u8 , 163u8 , 252u8 , 239u8 , 116u8 , 171u8 , 136u8 , 0u8 , 159u8 , 192u8 , 51u8 , 191u8 , 160u8 , 131u8 , 123u8 ,] { self . client . storage () . iter (block_hash) . await } else { Err (:: subxt :: MetadataError :: IncompatibleMetadata . into ()) } } # [doc = " Bounty indices that have been approved but not yet funded."] pub async fn bounty_approvals (& self , block_hash : :: core :: option :: Option < T :: Hash > ,) -> :: core :: result :: Result < runtime_types :: sp_runtime :: bounded :: bounded_vec :: BoundedVec < :: core :: primitive :: u32 > , :: subxt :: BasicError > { if self . client . metadata () . storage_hash :: < BountyApprovals > () ? == [18u8 , 142u8 , 244u8 , 64u8 , 172u8 , 62u8 , 230u8 , 114u8 , 165u8 , 158u8 , 123u8 , 163u8 , 35u8 , 125u8 , 218u8 , 23u8 , 113u8 , 73u8 , 233u8 , 242u8 , 181u8 , 205u8 , 60u8 , 54u8 , 64u8 , 115u8 , 207u8 , 94u8 , 22u8 , 14u8 , 238u8 , 49u8 ,] { let entry = BountyApprovals ; self . client . storage () . fetch_or_default (& entry , block_hash) . await } else { Err (:: subxt :: MetadataError :: IncompatibleMetadata . into ()) } } } } pub mod constants { use super :: runtime_types ; pub struct ConstantsApi < 'a , T : :: subxt :: Config > { client : & 'a :: subxt :: Client < T > , } impl < 'a , T : :: subxt :: Config > ConstantsApi < 'a , T > { pub fn new (client : & 'a :: subxt :: Client < T >) -> Self { Self { client } } # [doc = " The amount held on deposit for placing a bounty proposal."] pub fn bounty_deposit_base (& self) -> :: core :: result :: Result < :: core :: primitive :: u128 , :: subxt :: BasicError > { if self . client . metadata () . constant_hash ("Bounties" , "BountyDepositBase") ? == [132u8 , 176u8 , 127u8 , 152u8 , 185u8 , 81u8 , 145u8 , 102u8 , 4u8 , 79u8 , 128u8 , 178u8 , 160u8 , 7u8 , 174u8 , 242u8 , 232u8 , 128u8 , 161u8 , 90u8 , 72u8 , 66u8 , 88u8 , 186u8 , 198u8 , 26u8 , 62u8 , 69u8 , 23u8 , 134u8 , 74u8 , 113u8 ,] { let pallet = self . client . metadata () . pallet ("Bounties") ? ; let constant = pallet . constant ("BountyDepositBase") ? ; let value = :: subxt :: codec :: Decode :: decode (& mut & constant . value [..]) ? ; Ok (value) } else { Err (:: subxt :: MetadataError :: IncompatibleMetadata . into ()) } } # [doc = " The delay period for which a bounty beneficiary need to wait before claim the payout."] pub fn bounty_deposit_payout_delay (& self) -> :: core :: result :: Result < :: core :: primitive :: u32 , :: subxt :: BasicError > { if self . client . metadata () . constant_hash ("Bounties" , "BountyDepositPayoutDelay") ? == [247u8 , 44u8 , 166u8 , 71u8 , 243u8 , 101u8 , 122u8 , 12u8 , 164u8 , 64u8 , 26u8 , 120u8 , 227u8 , 239u8 , 38u8 , 37u8 , 47u8 , 104u8 , 169u8 , 39u8 , 191u8 , 214u8 , 245u8 , 228u8 , 55u8 , 198u8 , 209u8 , 213u8 , 52u8 , 20u8 , 146u8 , 14u8 ,] { let pallet = self . client . metadata () . pallet ("Bounties") ? ; let constant = pallet . constant ("BountyDepositPayoutDelay") ? ; let value = :: subxt :: codec :: Decode :: decode (& mut & constant . value [..]) ? ; Ok (value) } else { Err (:: subxt :: MetadataError :: IncompatibleMetadata . into ()) } } # [doc = " Bounty duration in blocks."] pub fn bounty_update_period (& self) -> :: core :: result :: Result < :: core :: primitive :: u32 , :: subxt :: BasicError > { if self . client . metadata () . constant_hash ("Bounties" , "BountyUpdatePeriod") ? == [203u8 , 38u8 , 78u8 , 249u8 , 181u8 , 142u8 , 96u8 , 62u8 , 153u8 , 174u8 , 181u8 , 59u8 , 110u8 , 33u8 , 126u8 , 255u8 , 187u8 , 211u8 , 192u8 , 188u8 , 185u8 , 151u8 , 26u8 , 101u8 , 173u8 , 28u8 , 61u8 , 186u8 , 190u8 , 65u8 , 154u8 , 4u8 ,] { let pallet = self . client . metadata () . pallet ("Bounties") ? ; let constant = pallet . constant ("BountyUpdatePeriod") ? ; let value = :: subxt :: codec :: Decode :: decode (& mut & constant . value [..]) ? ; Ok (value) } else { Err (:: subxt :: MetadataError :: IncompatibleMetadata . into ()) } } # [doc = " The curator deposit is calculated as a percentage of the curator fee."] # [doc = ""] # [doc = " This deposit has optional upper and lower bounds with `CuratorDepositMax` and"] # [doc = " `CuratorDepositMin`."] pub fn curator_deposit_multiplier (& self) -> :: core :: result :: Result < runtime_types :: sp_arithmetic :: per_things :: Permill , :: subxt :: BasicError > { if self . client . metadata () . constant_hash ("Bounties" , "CuratorDepositMultiplier") ? == [119u8 , 126u8 , 117u8 , 41u8 , 6u8 , 165u8 , 141u8 , 28u8 , 50u8 , 24u8 , 197u8 , 238u8 , 10u8 , 25u8 , 186u8 , 143u8 , 77u8 , 212u8 , 156u8 , 98u8 , 147u8 , 70u8 , 188u8 , 56u8 , 23u8 , 176u8 , 175u8 , 248u8 , 158u8 , 34u8 , 97u8 , 39u8 ,] { let pallet = self . client . metadata () . pallet ("Bounties") ? ; let constant = pallet . constant ("CuratorDepositMultiplier") ? ; let value = :: subxt :: codec :: Decode :: decode (& mut & constant . value [..]) ? ; Ok (value) } else { Err (:: subxt :: MetadataError :: IncompatibleMetadata . into ()) } } # [doc = " Maximum amount of funds that should be placed in a deposit for making a proposal."] pub fn curator_deposit_max (& self) -> :: core :: result :: Result < :: core :: option :: Option < :: core :: primitive :: u128 > , :: subxt :: BasicError > { if self . client . metadata () . constant_hash ("Bounties" , "CuratorDepositMax") ? == [250u8 , 96u8 , 182u8 , 112u8 , 66u8 , 3u8 , 147u8 , 220u8 , 204u8 , 187u8 , 221u8 , 246u8 , 140u8 , 240u8 , 61u8 , 42u8 , 86u8 , 97u8 , 251u8 , 170u8 , 218u8 , 82u8 , 144u8 , 203u8 , 126u8 , 109u8 , 144u8 , 219u8 , 110u8 , 51u8 , 242u8 , 4u8 ,] { let pallet = self . client . metadata () . pallet ("Bounties") ? ; let constant = pallet . constant ("CuratorDepositMax") ? ; let value = :: subxt :: codec :: Decode :: decode (& mut & constant . value [..]) ? ; Ok (value) } else { Err (:: subxt :: MetadataError :: IncompatibleMetadata . into ()) } } # [doc = " Minimum amount of funds that should be placed in a deposit for making a proposal."] pub fn curator_deposit_min (& self) -> :: core :: result :: Result < :: core :: option :: Option < :: core :: primitive :: u128 > , :: subxt :: BasicError > { if self . client . metadata () . constant_hash ("Bounties" , "CuratorDepositMin") ? == [63u8 , 20u8 , 230u8 , 145u8 , 178u8 , 91u8 , 53u8 , 150u8 , 74u8 , 158u8 , 29u8 , 243u8 , 254u8 , 235u8 , 225u8 , 69u8 , 196u8 , 27u8 , 208u8 , 36u8 , 224u8 , 107u8 , 221u8 , 151u8 , 219u8 , 144u8 , 126u8 , 154u8 , 178u8 , 130u8 , 83u8 , 120u8 ,] { let pallet = self . client . metadata () . pallet ("Bounties") ? ; let constant = pallet . constant ("CuratorDepositMin") ? ; let value = :: subxt :: codec :: Decode :: decode (& mut & constant . value [..]) ? ; Ok (value) } else { Err (:: subxt :: MetadataError :: IncompatibleMetadata . into ()) } } # [doc = " Minimum value for a bounty."] pub fn bounty_value_minimum (& self) -> :: core :: result :: Result < :: core :: primitive :: u128 , :: subxt :: BasicError > { if self . client . metadata () . constant_hash ("Bounties" , "BountyValueMinimum") ? == [20u8 , 78u8 , 167u8 , 236u8 , 224u8 , 73u8 , 234u8 , 96u8 , 130u8 , 85u8 , 208u8 , 225u8 , 119u8 , 164u8 , 231u8 , 242u8 , 25u8 , 82u8 , 250u8 , 189u8 , 247u8 , 164u8 , 241u8 , 226u8 , 128u8 , 187u8 , 89u8 , 106u8 , 107u8 , 118u8 , 3u8 , 3u8 ,] { let pallet = self . client . metadata () . pallet ("Bounties") ? ; let constant = pallet . constant ("BountyValueMinimum") ? ; let value = :: subxt :: codec :: Decode :: decode (& mut & constant . value [..]) ? ; Ok (value) } else { Err (:: subxt :: MetadataError :: IncompatibleMetadata . into ()) } } # [doc = " The amount held on deposit per byte within the tip report reason or bounty description."] pub fn data_deposit_per_byte (& self) -> :: core :: result :: Result < :: core :: primitive :: u128 , :: subxt :: BasicError > { if self . client . metadata () . constant_hash ("Bounties" , "DataDepositPerByte") ? == [141u8 , 69u8 , 220u8 , 26u8 , 40u8 , 243u8 , 50u8 , 254u8 , 213u8 , 237u8 , 200u8 , 120u8 , 176u8 , 96u8 , 170u8 , 86u8 , 155u8 , 94u8 , 200u8 , 33u8 , 64u8 , 9u8 , 201u8 , 1u8 , 184u8 , 87u8 , 4u8 , 132u8 , 15u8 , 126u8 , 40u8 , 34u8 ,] { let pallet = self . client . metadata () . pallet ("Bounties") ? ; let constant = pallet . constant ("DataDepositPerByte") ? ; let value = :: subxt :: codec :: Decode :: decode (& mut & constant . value [..]) ? ; Ok (value) } else { Err (:: subxt :: MetadataError :: IncompatibleMetadata . into ()) } } # [doc = " Maximum acceptable reason length."] # [doc = ""] # [doc = " Benchmarks depend on this value, be sure to update weights file when changing this value"] pub fn maximum_reason_length (& self) -> :: core :: result :: Result < :: core :: primitive :: u32 , :: subxt :: BasicError > { if self . client . metadata () . constant_hash ("Bounties" , "MaximumReasonLength") ? == [6u8 , 46u8 , 148u8 , 219u8 , 56u8 , 41u8 , 75u8 , 223u8 , 3u8 , 100u8 , 250u8 , 18u8 , 151u8 , 75u8 , 96u8 , 195u8 , 60u8 , 239u8 , 249u8 , 60u8 , 161u8 , 226u8 , 201u8 , 178u8 , 71u8 , 174u8 , 43u8 , 242u8 , 39u8 , 18u8 , 126u8 , 220u8 ,] { let pallet = self . client . metadata () . pallet ("Bounties") ? ; let constant = pallet . constant ("MaximumReasonLength") ? ; let value = :: subxt :: codec :: Decode :: decode (& mut & constant . value [..]) ? ; Ok (value) } else { Err (:: subxt :: MetadataError :: IncompatibleMetadata . into ()) } } } } } pub mod child_bounties { use super :: root_mod ; use super :: runtime_types ; pub mod calls { use super :: root_mod ; use super :: runtime_types ; type DispatchError = runtime_types :: sp_runtime :: DispatchError ; # [derive (:: subxt :: codec :: Decode , :: subxt :: codec :: Encode , Clone , Debug , Eq , PartialEq)] pub struct AddChildBounty { # [codec (compact)] pub parent_bounty_id : :: core :: primitive :: u32 , # [codec (compact)] pub value : :: core :: primitive :: u128 , pub description : :: std :: vec :: Vec < :: core :: primitive :: u8 > , } impl :: subxt :: Call for AddChildBounty { const PALLET : & 'static str = "ChildBounties" ; const FUNCTION : & 'static str = "add_child_bounty" ; } # [derive (:: subxt :: codec :: Decode , :: subxt :: codec :: Encode , Clone , Debug , Eq , PartialEq)] pub struct ProposeCurator { # [codec (compact)] pub parent_bounty_id : :: core :: primitive :: u32 , # [codec (compact)] pub child_bounty_id : :: core :: primitive :: u32 , pub curator : :: subxt :: sp_runtime :: MultiAddress < :: subxt :: sp_core :: crypto :: AccountId32 , :: core :: primitive :: u32 > , # [codec (compact)] pub fee : :: core :: primitive :: u128 , } impl :: subxt :: Call for ProposeCurator { const PALLET : & 'static str = "ChildBounties" ; const FUNCTION : & 'static str = "propose_curator" ; } # [derive (:: subxt :: codec :: Decode , :: subxt :: codec :: Encode , Clone , Debug , Eq , PartialEq)] pub struct AcceptCurator { # [codec (compact)] pub parent_bounty_id : :: core :: primitive :: u32 , # [codec (compact)] pub child_bounty_id : :: core :: primitive :: u32 , } impl :: subxt :: Call for AcceptCurator { const PALLET : & 'static str = "ChildBounties" ; const FUNCTION : & 'static str = "accept_curator" ; } # [derive (:: subxt :: codec :: Decode , :: subxt :: codec :: Encode , Clone , Debug , Eq , PartialEq)] pub struct UnassignCurator { # [codec (compact)] pub parent_bounty_id : :: core :: primitive :: u32 , # [codec (compact)] pub child_bounty_id : :: core :: primitive :: u32 , } impl :: subxt :: Call for UnassignCurator { const PALLET : & 'static str = "ChildBounties" ; const FUNCTION : & 'static str = "unassign_curator" ; } # [derive (:: subxt :: codec :: Decode , :: subxt :: codec :: Encode , Clone , Debug , Eq , PartialEq)] pub struct AwardChildBounty { # [codec (compact)] pub parent_bounty_id : :: core :: primitive :: u32 , # [codec (compact)] pub child_bounty_id : :: core :: primitive :: u32 , pub beneficiary : :: subxt :: sp_runtime :: MultiAddress < :: subxt :: sp_core :: crypto :: AccountId32 , :: core :: primitive :: u32 > , } impl :: subxt :: Call for AwardChildBounty { const PALLET : & 'static str = "ChildBounties" ; const FUNCTION : & 'static str = "award_child_bounty" ; } # [derive (:: subxt :: codec :: Decode , :: subxt :: codec :: Encode , Clone , Debug , Eq , PartialEq)] pub struct ClaimChildBounty { # [codec (compact)] pub parent_bounty_id : :: core :: primitive :: u32 , # [codec (compact)] pub child_bounty_id : :: core :: primitive :: u32 , } impl :: subxt :: Call for ClaimChildBounty { const PALLET : & 'static str = "ChildBounties" ; const FUNCTION : & 'static str = "claim_child_bounty" ; } # [derive (:: subxt :: codec :: Decode , :: subxt :: codec :: Encode , Clone , Debug , Eq , PartialEq)] pub struct CloseChildBounty { # [codec (compact)] pub parent_bounty_id : :: core :: primitive :: u32 , # [codec (compact)] pub child_bounty_id : :: core :: primitive :: u32 , } impl :: subxt :: Call for CloseChildBounty { const PALLET : & 'static str = "ChildBounties" ; const FUNCTION : & 'static str = "close_child_bounty" ; } pub struct TransactionApi < 'a , T : :: subxt :: Config , X > { client : & 'a :: subxt :: Client < T > , marker : :: core :: marker :: PhantomData < X > , } impl < 'a , T , X > TransactionApi < 'a , T , X > where T : :: subxt :: Config , X : :: subxt :: extrinsic :: ExtrinsicParams < T > , { pub fn new (client : & 'a :: subxt :: Client < T >) -> Self { Self { client , marker : :: core :: marker :: PhantomData } } # [doc = "Add a new child-bounty."] # [doc = ""] # [doc = "The dispatch origin for this call must be the curator of parent"] # [doc = "bounty and the parent bounty must be in \"active\" state."] # [doc = ""] # [doc = "Child-bounty gets added successfully & fund gets transferred from"] # [doc = "parent bounty to child-bounty account, if parent bounty has enough"] # [doc = "funds, else the call fails."] # [doc = ""] # [doc = "Upper bound to maximum number of active  child bounties that can be"] # [doc = "added are managed via runtime trait config"] # [doc = "[`Config::MaxActiveChildBountyCount`]."] # [doc = ""] # [doc = "If the call is success, the status of child-bounty is updated to"] # [doc = "\"Added\"."] # [doc = ""] # [doc = "- `parent_bounty_id`: Index of parent bounty for which child-bounty is being added."] # [doc = "- `value`: Value for executing the proposal."] # [doc = "- `description`: Text description for the child-bounty."] pub fn add_child_bounty (& self , parent_bounty_id : :: core :: primitive :: u32 , value : :: core :: primitive :: u128 , description : :: std :: vec :: Vec < :: core :: primitive :: u8 > ,) -> Result < :: subxt :: SubmittableExtrinsic < 'a , T , X , AddChildBounty , DispatchError , root_mod :: Event > , :: subxt :: BasicError > { if self . client . metadata () . call_hash :: < AddChildBounty > () ? == [235u8 , 216u8 , 166u8 , 226u8 , 107u8 , 159u8 , 235u8 , 35u8 , 207u8 , 154u8 , 124u8 , 226u8 , 242u8 , 241u8 , 4u8 , 20u8 , 1u8 , 215u8 , 110u8 , 127u8 , 19u8 , 211u8 , 36u8 , 159u8 , 110u8 , 146u8 , 58u8 , 23u8 , 210u8 , 51u8 , 193u8 , 228u8 ,] { let call = AddChildBounty { parent_bounty_id , value , description , } ; Ok (:: subxt :: SubmittableExtrinsic :: new (self . client , call)) } else { Err (:: subxt :: MetadataError :: IncompatibleMetadata . into ()) } } # [doc = "Propose curator for funded child-bounty."] # [doc = ""] # [doc = "The dispatch origin for this call must be curator of parent bounty."] # [doc = ""] # [doc = "Parent bounty must be in active state, for this child-bounty call to"] # [doc = "work."] # [doc = ""] # [doc = "Child-bounty must be in \"Added\" state, for processing the call. And"] # [doc = "state of child-bounty is moved to \"CuratorProposed\" on successful"] # [doc = "call completion."] # [doc = ""] # [doc = "- `parent_bounty_id`: Index of parent bounty."] # [doc = "- `child_bounty_id`: Index of child bounty."] # [doc = "- `curator`: Address of child-bounty curator."] # [doc = "- `fee`: payment fee to child-bounty curator for execution."] pub fn propose_curator (& self , parent_bounty_id : :: core :: primitive :: u32 , child_bounty_id : :: core :: primitive :: u32 , curator : :: subxt :: sp_runtime :: MultiAddress < :: subxt :: sp_core :: crypto :: AccountId32 , :: core :: primitive :: u32 > , fee : :: core :: primitive :: u128 ,) -> Result < :: subxt :: SubmittableExtrinsic < 'a , T , X , ProposeCurator , DispatchError , root_mod :: Event > , :: subxt :: BasicError > { if self . client . metadata () . call_hash :: < ProposeCurator > () ? == [19u8 , 217u8 , 51u8 , 222u8 , 245u8 , 169u8 , 32u8 , 59u8 , 8u8 , 56u8 , 244u8 , 4u8 , 86u8 , 244u8 , 241u8 , 63u8 , 190u8 , 81u8 , 148u8 , 13u8 , 13u8 , 174u8 , 226u8 , 47u8 , 188u8 , 170u8 , 78u8 , 172u8 , 202u8 , 222u8 , 97u8 , 76u8 ,] { let call = ProposeCurator { parent_bounty_id , child_bounty_id , curator , fee , } ; Ok (:: subxt :: SubmittableExtrinsic :: new (self . client , call)) } else { Err (:: subxt :: MetadataError :: IncompatibleMetadata . into ()) } } # [doc = "Accept the curator role for the child-bounty."] # [doc = ""] # [doc = "The dispatch origin for this call must be the curator of this"] # [doc = "child-bounty."] # [doc = ""] # [doc = "A deposit will be reserved from the curator and refund upon"] # [doc = "successful payout or cancellation."] # [doc = ""] # [doc = "Fee for curator is deducted from curator fee of parent bounty."] # [doc = ""] # [doc = "Parent bounty must be in active state, for this child-bounty call to"] # [doc = "work."] # [doc = ""] # [doc = "Child-bounty must be in \"CuratorProposed\" state, for processing the"] # [doc = "call. And state of child-bounty is moved to \"Active\" on successful"] # [doc = "call completion."] # [doc = ""] # [doc = "- `parent_bounty_id`: Index of parent bounty."] # [doc = "- `child_bounty_id`: Index of child bounty."] pub fn accept_curator (& self , parent_bounty_id : :: core :: primitive :: u32 , child_bounty_id : :: core :: primitive :: u32 ,) -> Result < :: subxt :: SubmittableExtrinsic < 'a , T , X , AcceptCurator , DispatchError , root_mod :: Event > , :: subxt :: BasicError > { if self . client . metadata () . call_hash :: < AcceptCurator > () ? == [115u8 , 24u8 , 36u8 , 188u8 , 30u8 , 11u8 , 184u8 , 102u8 , 151u8 , 96u8 , 41u8 , 162u8 , 104u8 , 54u8 , 76u8 , 251u8 , 189u8 , 50u8 , 190u8 , 50u8 , 15u8 , 171u8 , 231u8 , 218u8 , 45u8 , 129u8 , 137u8 , 69u8 , 130u8 , 39u8 , 190u8 , 223u8 ,] { let call = AcceptCurator { parent_bounty_id , child_bounty_id , } ; Ok (:: subxt :: SubmittableExtrinsic :: new (self . client , call)) } else { Err (:: subxt :: MetadataError :: IncompatibleMetadata . into ()) } } # [doc = "Unassign curator from a child-bounty."] # [doc = ""] # [doc = "The dispatch origin for this call can be either `RejectOrigin`, or"] # [doc = "the curator of the parent bounty, or any signed origin."] # [doc = ""] # [doc = "For the origin other than T::RejectOrigin and the child-bounty"] # [doc = "curator, parent bounty must be in active state, for this call to"] # [doc = "work. We allow child-bounty curator and T::RejectOrigin to execute"] # [doc = "this call irrespective of the parent bounty state."] # [doc = ""] # [doc = "If this function is called by the `RejectOrigin` or the"] # [doc = "parent bounty curator, we assume that the child-bounty curator is"] # [doc = "malicious or inactive. As a result, child-bounty curator deposit is"] # [doc = "slashed."] # [doc = ""] # [doc = "If the origin is the child-bounty curator, we take this as a sign"] # [doc = "that they are unable to do their job, and are willingly giving up."] # [doc = "We could slash the deposit, but for now we allow them to unreserve"] # [doc = "their deposit and exit without issue. (We may want to change this if"] # [doc = "it is abused.)"] # [doc = ""] # [doc = "Finally, the origin can be anyone iff the child-bounty curator is"] # [doc = "\"inactive\". Expiry update due of parent bounty is used to estimate"] # [doc = "inactive state of child-bounty curator."] # [doc = ""] # [doc = "This allows anyone in the community to call out that a child-bounty"] # [doc = "curator is not doing their due diligence, and we should pick a new"] # [doc = "one. In this case the child-bounty curator deposit is slashed."] # [doc = ""] # [doc = "State of child-bounty is moved to Added state on successful call"] # [doc = "completion."] # [doc = ""] # [doc = "- `parent_bounty_id`: Index of parent bounty."] # [doc = "- `child_bounty_id`: Index of child bounty."] pub fn unassign_curator (& self , parent_bounty_id : :: core :: primitive :: u32 , child_bounty_id : :: core :: primitive :: u32 ,) -> Result < :: subxt :: SubmittableExtrinsic < 'a , T , X , UnassignCurator , DispatchError , root_mod :: Event > , :: subxt :: BasicError > { if self . client . metadata () . call_hash :: < UnassignCurator > () ? == [210u8 , 24u8 , 20u8 , 200u8 , 106u8 , 200u8 , 33u8 , 43u8 , 169u8 , 133u8 , 157u8 , 108u8 , 220u8 , 36u8 , 110u8 , 172u8 , 218u8 , 1u8 , 209u8 , 254u8 , 69u8 , 117u8 , 70u8 , 173u8 , 66u8 , 177u8 , 54u8 , 128u8 , 239u8 , 83u8 , 60u8 , 118u8 ,] { let call = UnassignCurator { parent_bounty_id , child_bounty_id , } ; Ok (:: subxt :: SubmittableExtrinsic :: new (self . client , call)) } else { Err (:: subxt :: MetadataError :: IncompatibleMetadata . into ()) } } # [doc = "Award child-bounty to a beneficiary."] # [doc = ""] # [doc = "The beneficiary will be able to claim the funds after a delay."] # [doc = ""] # [doc = "The dispatch origin for this call must be the parent curator or"] # [doc = "curator of this child-bounty."] # [doc = ""] # [doc = "Parent bounty must be in active state, for this child-bounty call to"] # [doc = "work."] # [doc = ""] # [doc = "Child-bounty must be in active state, for processing the call. And"] # [doc = "state of child-bounty is moved to \"PendingPayout\" on successful call"] # [doc = "completion."] # [doc = ""] # [doc = "- `parent_bounty_id`: Index of parent bounty."] # [doc = "- `child_bounty_id`: Index of child bounty."] # [doc = "- `beneficiary`: Beneficiary account."] pub fn award_child_bounty (& self , parent_bounty_id : :: core :: primitive :: u32 , child_bounty_id : :: core :: primitive :: u32 , beneficiary : :: subxt :: sp_runtime :: MultiAddress < :: subxt :: sp_core :: crypto :: AccountId32 , :: core :: primitive :: u32 > ,) -> Result < :: subxt :: SubmittableExtrinsic < 'a , T , X , AwardChildBounty , DispatchError , root_mod :: Event > , :: subxt :: BasicError > { if self . client . metadata () . call_hash :: < AwardChildBounty > () ? == [74u8 , 171u8 , 238u8 , 22u8 , 34u8 , 62u8 , 95u8 , 231u8 , 204u8 , 84u8 , 195u8 , 47u8 , 255u8 , 59u8 , 81u8 , 68u8 , 112u8 , 236u8 , 82u8 , 171u8 , 81u8 , 49u8 , 49u8 , 216u8 , 15u8 , 139u8 , 92u8 , 173u8 , 223u8 , 142u8 , 23u8 , 226u8 ,] { let call = AwardChildBounty { parent_bounty_id , child_bounty_id , beneficiary , } ; Ok (:: subxt :: SubmittableExtrinsic :: new (self . client , call)) } else { Err (:: subxt :: MetadataError :: IncompatibleMetadata . into ()) } } # [doc = "Claim the payout from an awarded child-bounty after payout delay."] # [doc = ""] # [doc = "The dispatch origin for this call may be any signed origin."] # [doc = ""] # [doc = "Call works independent of parent bounty state, No need for parent"] # [doc = "bounty to be in active state."] # [doc = ""] # [doc = "The Beneficiary is paid out with agreed bounty value. Curator fee is"] # [doc = "paid & curator deposit is unreserved."] # [doc = ""] # [doc = "Child-bounty must be in \"PendingPayout\" state, for processing the"] # [doc = "call. And instance of child-bounty is removed from the state on"] # [doc = "successful call completion."] # [doc = ""] # [doc = "- `parent_bounty_id`: Index of parent bounty."] # [doc = "- `child_bounty_id`: Index of child bounty."] pub fn claim_child_bounty (& self , parent_bounty_id : :: core :: primitive :: u32 , child_bounty_id : :: core :: primitive :: u32 ,) -> Result < :: subxt :: SubmittableExtrinsic < 'a , T , X , ClaimChildBounty , DispatchError , root_mod :: Event > , :: subxt :: BasicError > { if self . client . metadata () . call_hash :: < ClaimChildBounty > () ? == [54u8 , 194u8 , 203u8 , 13u8 , 230u8 , 207u8 , 25u8 , 249u8 , 203u8 , 199u8 , 123u8 , 79u8 , 255u8 , 85u8 , 40u8 , 125u8 , 73u8 , 5u8 , 126u8 , 103u8 , 205u8 , 222u8 , 232u8 , 161u8 , 178u8 , 206u8 , 39u8 , 5u8 , 16u8 , 167u8 , 198u8 , 93u8 ,] { let call = ClaimChildBounty { parent_bounty_id , child_bounty_id , } ; Ok (:: subxt :: SubmittableExtrinsic :: new (self . client , call)) } else { Err (:: subxt :: MetadataError :: IncompatibleMetadata . into ()) } } # [doc = "Cancel a proposed or active child-bounty. Child-bounty account funds"] # [doc = "are transferred to parent bounty account. The child-bounty curator"] # [doc = "deposit may be unreserved if possible."] # [doc = ""] # [doc = "The dispatch origin for this call must be either parent curator or"] # [doc = "`T::RejectOrigin`."] # [doc = ""] # [doc = "If the state of child-bounty is `Active`, curator deposit is"] # [doc = "unreserved."] # [doc = ""] # [doc = "If the state of child-bounty is `PendingPayout`, call fails &"] # [doc = "returns `PendingPayout` error."] # [doc = ""] # [doc = "For the origin other than T::RejectOrigin, parent bounty must be in"] # [doc = "active state, for this child-bounty call to work. For origin"] # [doc = "T::RejectOrigin execution is forced."] # [doc = ""] # [doc = "Instance of child-bounty is removed from the state on successful"] # [doc = "call completion."] # [doc = ""] # [doc = "- `parent_bounty_id`: Index of parent bounty."] # [doc = "- `child_bounty_id`: Index of child bounty."] pub fn close_child_bounty (& self , parent_bounty_id : :: core :: primitive :: u32 , child_bounty_id : :: core :: primitive :: u32 ,) -> Result < :: subxt :: SubmittableExtrinsic < 'a , T , X , CloseChildBounty , DispatchError , root_mod :: Event > , :: subxt :: BasicError > { if self . client . metadata () . call_hash :: < CloseChildBounty > () ? == [123u8 , 201u8 , 206u8 , 242u8 , 80u8 , 37u8 , 113u8 , 182u8 , 237u8 , 187u8 , 51u8 , 229u8 , 226u8 , 250u8 , 129u8 , 203u8 , 196u8 , 22u8 , 91u8 , 154u8 , 118u8 , 233u8 , 254u8 , 240u8 , 113u8 , 86u8 , 55u8 , 5u8 , 59u8 , 15u8 , 160u8 , 204u8 ,] { let call = CloseChildBounty { parent_bounty_id , child_bounty_id , } ; Ok (:: subxt :: SubmittableExtrinsic :: new (self . client , call)) } else { Err (:: subxt :: MetadataError :: IncompatibleMetadata . into ()) } } } } pub type Event = runtime_types :: pallet_child_bounties :: pallet :: Event ; pub mod events { use super :: runtime_types ; # [derive (:: subxt :: codec :: Decode , :: subxt :: codec :: Encode , Clone , Debug , Eq , PartialEq)] # [doc = "A child-bounty is added."] pub struct Added { pub index : :: core :: primitive :: u32 , pub child_index : :: core :: primitive :: u32 , } impl :: subxt :: Event for Added { const PALLET : & 'static str = "ChildBounties" ; const EVENT : & 'static str = "Added" ; } # [derive (:: subxt :: codec :: Decode , :: subxt :: codec :: Encode , Clone , Debug , Eq , PartialEq)] # [doc = "A child-bounty is awarded to a beneficiary."] pub struct Awarded { pub index : :: core :: primitive :: u32 , pub child_index : :: core :: primitive :: u32 , pub beneficiary : :: subxt :: sp_core :: crypto :: AccountId32 , } impl :: subxt :: Event for Awarded { const PALLET : & 'static str = "ChildBounties" ; const EVENT : & 'static str = "Awarded" ; } # [derive (:: subxt :: codec :: Decode , :: subxt :: codec :: Encode , Clone , Debug , Eq , PartialEq)] # [doc = "A child-bounty is claimed by beneficiary."] pub struct Claimed { pub index : :: core :: primitive :: u32 , pub child_index : :: core :: primitive :: u32 , pub payout : :: core :: primitive :: u128 , pub beneficiary : :: subxt :: sp_core :: crypto :: AccountId32 , } impl :: subxt :: Event for Claimed { const PALLET : & 'static str = "ChildBounties" ; const EVENT : & 'static str = "Claimed" ; } # [derive (:: subxt :: codec :: Decode , :: subxt :: codec :: Encode , Clone , Debug , Eq , PartialEq)] # [doc = "A child-bounty is cancelled."] pub struct Canceled { pub index : :: core :: primitive :: u32 , pub child_index : :: core :: primitive :: u32 , } impl :: subxt :: Event for Canceled { const PALLET : & 'static str = "ChildBounties" ; const EVENT : & 'static str = "Canceled" ; } } pub mod storage { use super :: runtime_types ; pub struct ChildBountyCount ; impl :: subxt :: StorageEntry for ChildBountyCount { const PALLET : & 'static str = "ChildBounties" ; const STORAGE : & 'static str = "ChildBountyCount" ; type Value = :: core :: primitive :: u32 ; fn key (& self) -> :: subxt :: StorageEntryKey { :: subxt :: StorageEntryKey :: Plain } } pub struct ParentChildBounties < 'a > (pub & 'a :: core :: primitive :: u32) ; impl :: subxt :: StorageEntry for ParentChildBounties < '_ > { const PALLET : & 'static str = "ChildBounties" ; const STORAGE : & 'static str = "ParentChildBounties" ; type Value = :: core :: primitive :: u32 ; fn key (& self) -> :: subxt :: StorageEntryKey { :: subxt :: StorageEntryKey :: Map (vec ! [:: subxt :: StorageMapKey :: new (& self . 0 , :: subxt :: StorageHasher :: Twox64Concat)]) } } pub struct ChildBounties < 'a > (pub & 'a :: core :: primitive :: u32 , pub & 'a :: core :: primitive :: u32) ; impl :: subxt :: StorageEntry for ChildBounties < '_ > { const PALLET : & 'static str = "ChildBounties" ; const STORAGE : & 'static str = "ChildBounties" ; type Value = runtime_types :: pallet_child_bounties :: ChildBounty < :: subxt :: sp_core :: crypto :: AccountId32 , :: core :: primitive :: u128 , :: core :: primitive :: u32 > ; fn key (& self) -> :: subxt :: StorageEntryKey { :: subxt :: StorageEntryKey :: Map (vec ! [:: subxt :: StorageMapKey :: new (& self . 0 , :: subxt :: StorageHasher :: Twox64Concat) , :: subxt :: StorageMapKey :: new (& self . 1 , :: subxt :: StorageHasher :: Twox64Concat)]) } } pub struct ChildBountyDescriptions < 'a > (pub & 'a :: core :: primitive :: u32) ; impl :: subxt :: StorageEntry for ChildBountyDescriptions < '_ > { const PALLET : & 'static str = "ChildBounties" ; const STORAGE : & 'static str = "ChildBountyDescriptions" ; type Value = runtime_types :: sp_runtime :: bounded :: bounded_vec :: BoundedVec < :: core :: primitive :: u8 > ; fn key (& self) -> :: subxt :: StorageEntryKey { :: subxt :: StorageEntryKey :: Map (vec ! [:: subxt :: StorageMapKey :: new (& self . 0 , :: subxt :: StorageHasher :: Twox64Concat)]) } } pub struct ChildrenCuratorFees < 'a > (pub & 'a :: core :: primitive :: u32) ; impl :: subxt :: StorageEntry for ChildrenCuratorFees < '_ > { const PALLET : & 'static str = "ChildBounties" ; const STORAGE : & 'static str = "ChildrenCuratorFees" ; type Value = :: core :: primitive :: u128 ; fn key (& self) -> :: subxt :: StorageEntryKey { :: subxt :: StorageEntryKey :: Map (vec ! [:: subxt :: StorageMapKey :: new (& self . 0 , :: subxt :: StorageHasher :: Twox64Concat)]) } } pub struct StorageApi < 'a , T : :: subxt :: Config > { client : & 'a :: subxt :: Client < T > , } impl < 'a , T : :: subxt :: Config > StorageApi < 'a , T > { pub fn new (client : & 'a :: subxt :: Client < T >) -> Self { Self { client } } # [doc = " Number of total child bounties."] pub async fn child_bounty_count (& self , block_hash : :: core :: option :: Option < T :: Hash > ,) -> :: core :: result :: Result < :: core :: primitive :: u32 , :: subxt :: BasicError > { if self . client . metadata () . storage_hash :: < ChildBountyCount > () ? == [46u8 , 10u8 , 183u8 , 160u8 , 98u8 , 215u8 , 39u8 , 253u8 , 81u8 , 94u8 , 114u8 , 147u8 , 115u8 , 162u8 , 33u8 , 117u8 , 160u8 , 214u8 , 167u8 , 7u8 , 109u8 , 143u8 , 158u8 , 1u8 , 200u8 , 205u8 , 17u8 , 93u8 , 89u8 , 26u8 , 30u8 , 95u8 ,] { let entry = ChildBountyCount ; self . client . storage () . fetch_or_default (& entry , block_hash) . await } else { Err (:: subxt :: MetadataError :: IncompatibleMetadata . into ()) } } # [doc = " Number of child bounties per parent bounty."] # [doc = " Map of parent bounty index to number of child bounties."] pub async fn parent_child_bounties (& self , _0 : & :: core :: primitive :: u32 , block_hash : :: core :: option :: Option < T :: Hash > ,) -> :: core :: result :: Result < :: core :: primitive :: u32 , :: subxt :: BasicError > { if self . client . metadata () . storage_hash :: < ParentChildBounties > () ? == [127u8 , 161u8 , 181u8 , 79u8 , 235u8 , 196u8 , 252u8 , 162u8 , 39u8 , 15u8 , 251u8 , 49u8 , 125u8 , 80u8 , 101u8 , 24u8 , 234u8 , 88u8 , 212u8 , 126u8 , 63u8 , 63u8 , 19u8 , 75u8 , 137u8 , 125u8 , 38u8 , 250u8 , 77u8 , 49u8 , 76u8 , 188u8 ,] { let entry = ParentChildBounties (_0) ; self . client . storage () . fetch_or_default (& entry , block_hash) . await } else { Err (:: subxt :: MetadataError :: IncompatibleMetadata . into ()) } } # [doc = " Number of child bounties per parent bounty."] # [doc = " Map of parent bounty index to number of child bounties."] pub async fn parent_child_bounties_iter (& self , block_hash : :: core :: option :: Option < T :: Hash > ,) -> :: core :: result :: Result < :: subxt :: KeyIter < 'a , T , ParentChildBounties < 'a > > , :: subxt :: BasicError > { if self . client . metadata () . storage_hash :: < ParentChildBounties > () ? == [127u8 , 161u8 , 181u8 , 79u8 , 235u8 , 196u8 , 252u8 , 162u8 , 39u8 , 15u8 , 251u8 , 49u8 , 125u8 , 80u8 , 101u8 , 24u8 , 234u8 , 88u8 , 212u8 , 126u8 , 63u8 , 63u8 , 19u8 , 75u8 , 137u8 , 125u8 , 38u8 , 250u8 , 77u8 , 49u8 , 76u8 , 188u8 ,] { self . client . storage () . iter (block_hash) . await } else { Err (:: subxt :: MetadataError :: IncompatibleMetadata . into ()) } } # [doc = " Child bounties that have been added."] pub async fn child_bounties (& self , _0 : & :: core :: primitive :: u32 , _1 : & :: core :: primitive :: u32 , block_hash : :: core :: option :: Option < T :: Hash > ,) -> :: core :: result :: Result < :: core :: option :: Option < runtime_types :: pallet_child_bounties :: ChildBounty < :: subxt :: sp_core :: crypto :: AccountId32 , :: core :: primitive :: u128 , :: core :: primitive :: u32 > > , :: subxt :: BasicError > { if self . client . metadata () . storage_hash :: < ChildBounties > () ? == [66u8 , 224u8 , 32u8 , 188u8 , 0u8 , 175u8 , 253u8 , 132u8 , 17u8 , 243u8 , 51u8 , 237u8 , 230u8 , 40u8 , 198u8 , 178u8 , 222u8 , 159u8 , 99u8 , 29u8 , 237u8 , 147u8 , 183u8 , 111u8 , 103u8 , 195u8 , 185u8 , 27u8 , 252u8 , 2u8 , 55u8 , 108u8 ,] { let entry = ChildBounties (_0 , _1) ; self . client . storage () . fetch (& entry , block_hash) . await } else { Err (:: subxt :: MetadataError :: IncompatibleMetadata . into ()) } } # [doc = " Child bounties that have been added."] pub async fn child_bounties_iter (& self , block_hash : :: core :: option :: Option < T :: Hash > ,) -> :: core :: result :: Result < :: subxt :: KeyIter < 'a , T , ChildBounties < 'a > > , :: subxt :: BasicError > { if self . client . metadata () . storage_hash :: < ChildBounties > () ? == [66u8 , 224u8 , 32u8 , 188u8 , 0u8 , 175u8 , 253u8 , 132u8 , 17u8 , 243u8 , 51u8 , 237u8 , 230u8 , 40u8 , 198u8 , 178u8 , 222u8 , 159u8 , 99u8 , 29u8 , 237u8 , 147u8 , 183u8 , 111u8 , 103u8 , 195u8 , 185u8 , 27u8 , 252u8 , 2u8 , 55u8 , 108u8 ,] { self . client . storage () . iter (block_hash) . await } else { Err (:: subxt :: MetadataError :: IncompatibleMetadata . into ()) } } # [doc = " The description of each child-bounty."] pub async fn child_bounty_descriptions (& self , _0 : & :: core :: primitive :: u32 , block_hash : :: core :: option :: Option < T :: Hash > ,) -> :: core :: result :: Result < :: core :: option :: Option < runtime_types :: sp_runtime :: bounded :: bounded_vec :: BoundedVec < :: core :: primitive :: u8 > > , :: subxt :: BasicError > { if self . client . metadata () . storage_hash :: < ChildBountyDescriptions > () ? == [20u8 , 134u8 , 50u8 , 207u8 , 242u8 , 159u8 , 242u8 , 22u8 , 76u8 , 80u8 , 193u8 , 247u8 , 73u8 , 51u8 , 113u8 , 241u8 , 186u8 , 26u8 , 227u8 , 44u8 , 122u8 , 189u8 , 171u8 , 137u8 , 31u8 , 103u8 , 184u8 , 129u8 , 31u8 , 98u8 , 19u8 , 60u8 ,] { let entry = ChildBountyDescriptions (_0) ; self . client . storage () . fetch (& entry , block_hash) . await } else { Err (:: subxt :: MetadataError :: IncompatibleMetadata . into ()) } } # [doc = " The description of each child-bounty."] pub async fn child_bounty_descriptions_iter (& self , block_hash : :: core :: option :: Option < T :: Hash > ,) -> :: core :: result :: Result < :: subxt :: KeyIter < 'a , T , ChildBountyDescriptions < 'a > > , :: subxt :: BasicError > { if self . client . metadata () . storage_hash :: < ChildBountyDescriptions > () ? == [20u8 , 134u8 , 50u8 , 207u8 , 242u8 , 159u8 , 242u8 , 22u8 , 76u8 , 80u8 , 193u8 , 247u8 , 73u8 , 51u8 , 113u8 , 241u8 , 186u8 , 26u8 , 227u8 , 44u8 , 122u8 , 189u8 , 171u8 , 137u8 , 31u8 , 103u8 , 184u8 , 129u8 , 31u8 , 98u8 , 19u8 , 60u8 ,] { self . client . storage () . iter (block_hash) . await } else { Err (:: subxt :: MetadataError :: IncompatibleMetadata . into ()) } } # [doc = " The cumulative child-bounty curator fee for each parent bounty."] pub async fn children_curator_fees (& self , _0 : & :: core :: primitive :: u32 , block_hash : :: core :: option :: Option < T :: Hash > ,) -> :: core :: result :: Result < :: core :: primitive :: u128 , :: subxt :: BasicError > { if self . client . metadata () . storage_hash :: < ChildrenCuratorFees > () ? == [174u8 , 128u8 , 86u8 , 179u8 , 133u8 , 76u8 , 98u8 , 169u8 , 234u8 , 166u8 , 249u8 , 214u8 , 172u8 , 171u8 , 8u8 , 161u8 , 105u8 , 69u8 , 148u8 , 151u8 , 35u8 , 174u8 , 118u8 , 139u8 , 101u8 , 56u8 , 85u8 , 211u8 , 121u8 , 168u8 , 0u8 , 216u8 ,] { let entry = ChildrenCuratorFees (_0) ; self . client . storage () . fetch_or_default (& entry , block_hash) . await } else { Err (:: subxt :: MetadataError :: IncompatibleMetadata . into ()) } } # [doc = " The cumulative child-bounty curator fee for each parent bounty."] pub async fn children_curator_fees_iter (& self , block_hash : :: core :: option :: Option < T :: Hash > ,) -> :: core :: result :: Result < :: subxt :: KeyIter < 'a , T , ChildrenCuratorFees < 'a > > , :: subxt :: BasicError > { if self . client . metadata () . storage_hash :: < ChildrenCuratorFees > () ? == [174u8 , 128u8 , 86u8 , 179u8 , 133u8 , 76u8 , 98u8 , 169u8 , 234u8 , 166u8 , 249u8 , 214u8 , 172u8 , 171u8 , 8u8 , 161u8 , 105u8 , 69u8 , 148u8 , 151u8 , 35u8 , 174u8 , 118u8 , 139u8 , 101u8 , 56u8 , 85u8 , 211u8 , 121u8 , 168u8 , 0u8 , 216u8 ,] { self . client . storage () . iter (block_hash) . await } else { Err (:: subxt :: MetadataError :: IncompatibleMetadata . into ()) } } } } pub mod constants { use super :: runtime_types ; pub struct ConstantsApi < 'a , T : :: subxt :: Config > { client : & 'a :: subxt :: Client < T > , } impl < 'a , T : :: subxt :: Config > ConstantsApi < 'a , T > { pub fn new (client : & 'a :: subxt :: Client < T >) -> Self { Self { client } } # [doc = " Maximum number of child bounties that can be added to a parent bounty."] pub fn max_active_child_bounty_count (& self) -> :: core :: result :: Result < :: core :: primitive :: u32 , :: subxt :: BasicError > { if self . client . metadata () . constant_hash ("ChildBounties" , "MaxActiveChildBountyCount") ? == [13u8 , 61u8 , 78u8 , 65u8 , 15u8 , 140u8 , 185u8 , 163u8 , 43u8 , 214u8 , 218u8 , 86u8 , 37u8 , 153u8 , 183u8 , 135u8 , 26u8 , 139u8 , 199u8 , 135u8 , 143u8 , 162u8 , 114u8 , 71u8 , 86u8 , 164u8 , 215u8 , 93u8 , 108u8 , 182u8 , 79u8 , 47u8 ,] { let pallet = self . client . metadata () . pallet ("ChildBounties") ? ; let constant = pallet . constant ("MaxActiveChildBountyCount") ? ; let value = :: subxt :: codec :: Decode :: decode (& mut & constant . value [..]) ? ; Ok (value) } else { Err (:: subxt :: MetadataError :: IncompatibleMetadata . into ()) } } # [doc = " Minimum value for a child-bounty."] pub fn child_bounty_value_minimum (& self) -> :: core :: result :: Result < :: core :: primitive :: u128 , :: subxt :: BasicError > { if self . client . metadata () . constant_hash ("ChildBounties" , "ChildBountyValueMinimum") ? == [65u8 , 139u8 , 157u8 , 25u8 , 67u8 , 162u8 , 99u8 , 197u8 , 146u8 , 154u8 , 145u8 , 251u8 , 75u8 , 143u8 , 9u8 , 26u8 , 120u8 , 167u8 , 80u8 , 13u8 , 11u8 , 7u8 , 123u8 , 254u8 , 187u8 , 99u8 , 78u8 , 31u8 , 81u8 , 238u8 , 190u8 , 107u8 ,] { let pallet = self . client . metadata () . pallet ("ChildBounties") ? ; let constant = pallet . constant ("ChildBountyValueMinimum") ? ; let value = :: subxt :: codec :: Decode :: decode (& mut & constant . value [..]) ? ; Ok (value) } else { Err (:: subxt :: MetadataError :: IncompatibleMetadata . into ()) } } } } } pub mod bags_list { use super :: root_mod ; use super :: runtime_types ; pub mod calls { use super :: root_mod ; use super :: runtime_types ; type DispatchError = runtime_types :: sp_runtime :: DispatchError ; # [derive (:: subxt :: codec :: Decode , :: subxt :: codec :: Encode , Clone , Debug , Eq , PartialEq)] pub struct Rebag { pub dislocated : :: subxt :: sp_core :: crypto :: AccountId32 , } impl :: subxt :: Call for Rebag { const PALLET : & 'static str = "BagsList" ; const FUNCTION : & 'static str = "rebag" ; } # [derive (:: subxt :: codec :: Decode , :: subxt :: codec :: Encode , Clone , Debug , Eq , PartialEq)] pub struct PutInFrontOf { pub lighter : :: subxt :: sp_core :: crypto :: AccountId32 , } impl :: subxt :: Call for PutInFrontOf { const PALLET : & 'static str = "BagsList" ; const FUNCTION : & 'static str = "put_in_front_of" ; } pub struct TransactionApi < 'a , T : :: subxt :: Config , X > { client : & 'a :: subxt :: Client < T > , marker : :: core :: marker :: PhantomData < X > , } impl < 'a , T , X > TransactionApi < 'a , T , X > where T : :: subxt :: Config , X : :: subxt :: extrinsic :: ExtrinsicParams < T > , { pub fn new (client : & 'a :: subxt :: Client < T >) -> Self { Self { client , marker : :: core :: marker :: PhantomData } } # [doc = "Declare that some `dislocated` account has, through rewards or penalties, sufficiently"] # [doc = "changed its score that it should properly fall into a different bag than its current"] # [doc = "one."] # [doc = ""] # [doc = "Anyone can call this function about any potentially dislocated account."] # [doc = ""] # [doc = "Will always update the stored score of `dislocated` to the correct score, based on"] # [doc = "`ScoreProvider`."] # [doc = ""] # [doc = "If `dislocated` does not exists, it returns an error."] pub fn rebag (& self , dislocated : :: subxt :: sp_core :: crypto :: AccountId32 ,) -> Result < :: subxt :: SubmittableExtrinsic < 'a , T , X , Rebag , DispatchError , root_mod :: Event > , :: subxt :: BasicError > { if self . client . metadata () . call_hash :: < Rebag > () ? == [46u8 , 138u8 , 28u8 , 6u8 , 58u8 , 153u8 , 5u8 , 41u8 , 44u8 , 7u8 , 228u8 , 72u8 , 135u8 , 184u8 , 185u8 , 132u8 , 146u8 , 181u8 , 47u8 , 166u8 , 149u8 , 21u8 , 155u8 , 29u8 , 159u8 , 79u8 , 83u8 , 137u8 , 156u8 , 17u8 , 60u8 , 23u8 ,] { let call = Rebag { dislocated , } ; Ok (:: subxt :: SubmittableExtrinsic :: new (self . client , call)) } else { Err (:: subxt :: MetadataError :: IncompatibleMetadata . into ()) } } # [doc = "Move the caller's Id directly in front of `lighter`."] # [doc = ""] # [doc = "The dispatch origin for this call must be _Signed_ and can only be called by the Id of"] # [doc = "the account going in front of `lighter`."] # [doc = ""] # [doc = "Only works if"] # [doc = "- both nodes are within the same bag,"] # [doc = "- and `origin` has a greater `Score` than `lighter`."] pub fn put_in_front_of (& self , lighter : :: subxt :: sp_core :: crypto :: AccountId32 ,) -> Result < :: subxt :: SubmittableExtrinsic < 'a , T , X , PutInFrontOf , DispatchError , root_mod :: Event > , :: subxt :: BasicError > { if self . client . metadata () . call_hash :: < PutInFrontOf > () ? == [79u8 , 254u8 , 222u8 , 19u8 , 17u8 , 80u8 , 7u8 , 68u8 , 54u8 , 9u8 , 23u8 , 133u8 , 108u8 , 29u8 , 166u8 , 177u8 , 230u8 , 247u8 , 226u8 , 189u8 , 3u8 , 241u8 , 100u8 , 178u8 , 234u8 , 204u8 , 118u8 , 215u8 , 84u8 , 28u8 , 21u8 , 136u8 ,] { let call = PutInFrontOf { lighter , } ; Ok (:: subxt :: SubmittableExtrinsic :: new (self . client , call)) } else { Err (:: subxt :: MetadataError :: IncompatibleMetadata . into ()) } } } } pub type Event = runtime_types :: pallet_bags_list :: pallet :: Event ; pub mod events { use super :: runtime_types ; # [derive (:: subxt :: codec :: Decode , :: subxt :: codec :: Encode , Clone , Debug , Eq , PartialEq)] # [doc = "Moved an account from one bag to another."] pub struct Rebagged { pub who : :: subxt :: sp_core :: crypto :: AccountId32 , pub from : :: core :: primitive :: u64 , pub to : :: core :: primitive :: u64 , } impl :: subxt :: Event for Rebagged { const PALLET : & 'static str = "BagsList" ; const EVENT : & 'static str = "Rebagged" ; } # [derive (:: subxt :: codec :: Decode , :: subxt :: codec :: Encode , Clone , Debug , Eq , PartialEq)] # [doc = "Updated the score of some account to the given amount."] pub struct ScoreUpdated { pub who : :: subxt :: sp_core :: crypto :: AccountId32 , pub new_score : :: core :: primitive :: u64 , } impl :: subxt :: Event for ScoreUpdated { const PALLET : & 'static str = "BagsList" ; const EVENT : & 'static str = "ScoreUpdated" ; } } pub mod storage { use super :: runtime_types ; pub struct ListNodes < 'a > (pub & 'a :: subxt :: sp_core :: crypto :: AccountId32) ; impl :: subxt :: StorageEntry for ListNodes < '_ > { const PALLET : & 'static str = "BagsList" ; const STORAGE : & 'static str = "ListNodes" ; type Value = runtime_types :: pallet_bags_list :: list :: Node ; fn key (& self) -> :: subxt :: StorageEntryKey { :: subxt :: StorageEntryKey :: Map (vec ! [:: subxt :: StorageMapKey :: new (& self . 0 , :: subxt :: StorageHasher :: Twox64Concat)]) } } pub struct CounterForListNodes ; impl :: subxt :: StorageEntry for CounterForListNodes { const PALLET : & 'static str = "BagsList" ; const STORAGE : & 'static str = "CounterForListNodes" ; type Value = :: core :: primitive :: u32 ; fn key (& self) -> :: subxt :: StorageEntryKey { :: subxt :: StorageEntryKey :: Plain } } pub struct ListBags < 'a > (pub & 'a :: core :: primitive :: u64) ; impl :: subxt :: StorageEntry for ListBags < '_ > { const PALLET : & 'static str = "BagsList" ; const STORAGE : & 'static str = "ListBags" ; type Value = runtime_types :: pallet_bags_list :: list :: Bag ; fn key (& self) -> :: subxt :: StorageEntryKey { :: subxt :: StorageEntryKey :: Map (vec ! [:: subxt :: StorageMapKey :: new (& self . 0 , :: subxt :: StorageHasher :: Twox64Concat)]) } } pub struct StorageApi < 'a , T : :: subxt :: Config > { client : & 'a :: subxt :: Client < T > , } impl < 'a , T : :: subxt :: Config > StorageApi < 'a , T > { pub fn new (client : & 'a :: subxt :: Client < T >) -> Self { Self { client } } # [doc = " A single node, within some bag."] # [doc = ""] # [doc = " Nodes store links forward and back within their respective bags."] pub async fn list_nodes (& self , _0 : & :: subxt :: sp_core :: crypto :: AccountId32 , block_hash : :: core :: option :: Option < T :: Hash > ,) -> :: core :: result :: Result < :: core :: option :: Option < runtime_types :: pallet_bags_list :: list :: Node > , :: subxt :: BasicError > { if self . client . metadata () . storage_hash :: < ListNodes > () ? == [144u8 , 72u8 , 250u8 , 207u8 , 66u8 , 204u8 , 6u8 , 146u8 , 219u8 , 225u8 , 6u8 , 82u8 , 111u8 , 172u8 , 171u8 , 184u8 , 35u8 , 129u8 , 246u8 , 162u8 , 224u8 , 116u8 , 244u8 , 80u8 , 197u8 , 146u8 , 243u8 , 123u8 , 209u8 , 135u8 , 164u8 , 201u8 ,] { let entry = ListNodes (_0) ; self . client . storage () . fetch (& entry , block_hash) . await } else { Err (:: subxt :: MetadataError :: IncompatibleMetadata . into ()) } } # [doc = " A single node, within some bag."] # [doc = ""] # [doc = " Nodes store links forward and back within their respective bags."] pub async fn list_nodes_iter (& self , block_hash : :: core :: option :: Option < T :: Hash > ,) -> :: core :: result :: Result < :: subxt :: KeyIter < 'a , T , ListNodes < 'a > > , :: subxt :: BasicError > { if self . client . metadata () . storage_hash :: < ListNodes > () ? == [144u8 , 72u8 , 250u8 , 207u8 , 66u8 , 204u8 , 6u8 , 146u8 , 219u8 , 225u8 , 6u8 , 82u8 , 111u8 , 172u8 , 171u8 , 184u8 , 35u8 , 129u8 , 246u8 , 162u8 , 224u8 , 116u8 , 244u8 , 80u8 , 197u8 , 146u8 , 243u8 , 123u8 , 209u8 , 135u8 , 164u8 , 201u8 ,] { self . client . storage () . iter (block_hash) . await } else { Err (:: subxt :: MetadataError :: IncompatibleMetadata . into ()) } } # [doc = "Counter for the related counted storage map"] pub async fn counter_for_list_nodes (& self , block_hash : :: core :: option :: Option < T :: Hash > ,) -> :: core :: result :: Result < :: core :: primitive :: u32 , :: subxt :: BasicError > { if self . client . metadata () . storage_hash :: < CounterForListNodes > () ? == [156u8 , 168u8 , 97u8 , 33u8 , 84u8 , 117u8 , 220u8 , 89u8 , 62u8 , 182u8 , 24u8 , 88u8 , 231u8 , 244u8 , 41u8 , 19u8 , 210u8 , 131u8 , 87u8 , 0u8 , 241u8 , 230u8 , 160u8 , 142u8 , 128u8 , 153u8 , 83u8 , 36u8 , 88u8 , 247u8 , 70u8 , 130u8 ,] { let entry = CounterForListNodes ; self . client . storage () . fetch_or_default (& entry , block_hash) . await } else { Err (:: subxt :: MetadataError :: IncompatibleMetadata . into ()) } } # [doc = " A bag stored in storage."] # [doc = ""] # [doc = " Stores a `Bag` struct, which stores head and tail pointers to itself."] pub async fn list_bags (& self , _0 : & :: core :: primitive :: u64 , block_hash : :: core :: option :: Option < T :: Hash > ,) -> :: core :: result :: Result < :: core :: option :: Option < runtime_types :: pallet_bags_list :: list :: Bag > , :: subxt :: BasicError > { if self . client . metadata () . storage_hash :: < ListBags > () ? == [117u8 , 35u8 , 42u8 , 116u8 , 5u8 , 68u8 , 168u8 , 75u8 , 112u8 , 29u8 , 54u8 , 49u8 , 169u8 , 103u8 , 22u8 , 163u8 , 53u8 , 122u8 , 181u8 , 32u8 , 97u8 , 41u8 , 56u8 , 89u8 , 77u8 , 200u8 , 0u8 , 123u8 , 226u8 , 178u8 , 81u8 , 138u8 ,] { let entry = ListBags (_0) ; self . client . storage () . fetch (& entry , block_hash) . await } else { Err (:: subxt :: MetadataError :: IncompatibleMetadata . into ()) } } # [doc = " A bag stored in storage."] # [doc = ""] # [doc = " Stores a `Bag` struct, which stores head and tail pointers to itself."] pub async fn list_bags_iter (& self , block_hash : :: core :: option :: Option < T :: Hash > ,) -> :: core :: result :: Result < :: subxt :: KeyIter < 'a , T , ListBags < 'a > > , :: subxt :: BasicError > { if self . client . metadata () . storage_hash :: < ListBags > () ? == [117u8 , 35u8 , 42u8 , 116u8 , 5u8 , 68u8 , 168u8 , 75u8 , 112u8 , 29u8 , 54u8 , 49u8 , 169u8 , 103u8 , 22u8 , 163u8 , 53u8 , 122u8 , 181u8 , 32u8 , 97u8 , 41u8 , 56u8 , 89u8 , 77u8 , 200u8 , 0u8 , 123u8 , 226u8 , 178u8 , 81u8 , 138u8 ,] { self . client . storage () . iter (block_hash) . await } else { Err (:: subxt :: MetadataError :: IncompatibleMetadata . into ()) } } } } pub mod constants { use super :: runtime_types ; pub struct ConstantsApi < 'a , T : :: subxt :: Config > { client : & 'a :: subxt :: Client < T > , } impl < 'a , T : :: subxt :: Config > ConstantsApi < 'a , T > { pub fn new (client : & 'a :: subxt :: Client < T >) -> Self { Self { client } } # [doc = " The list of thresholds separating the various bags."] # [doc = ""] # [doc = " Ids are separated into unsorted bags according to their score. This specifies the"] # [doc = " thresholds separating the bags. An id's bag is the largest bag for which the id's score"] # [doc = " is less than or equal to its upper threshold."] # [doc = ""] # [doc = " When ids are iterated, higher bags are iterated completely before lower bags. This means"] # [doc = " that iteration is _semi-sorted_: ids of higher score tend to come before ids of lower"] # [doc = " score, but peer ids within a particular bag are sorted in insertion order."] # [doc = ""] # [doc = " # Expressing the constant"] # [doc = ""] # [doc = " This constant must be sorted in strictly increasing order. Duplicate items are not"] # [doc = " permitted."] # [doc = ""] # [doc = " There is an implied upper limit of `Score::MAX`; that value does not need to be"] # [doc = " specified within the bag. For any two threshold lists, if one ends with"] # [doc = " `Score::MAX`, the other one does not, and they are otherwise equal, the two"] # [doc = " lists will behave identically."] # [doc = ""] # [doc = " # Calculation"] # [doc = ""] # [doc = " It is recommended to generate the set of thresholds in a geometric series, such that"] # [doc = " there exists some constant ratio such that `threshold[k + 1] == (threshold[k] *"] # [doc = " constant_ratio).max(threshold[k] + 1)` for all `k`."] # [doc = ""] # [doc = " The helpers in the `/utils/frame/generate-bags` module can simplify this calculation."] # [doc = ""] # [doc = " # Examples"] # [doc = ""] # [doc = " - If `BagThresholds::get().is_empty()`, then all ids are put into the same bag, and"] # [doc = "   iteration is strictly in insertion order."] # [doc = " - If `BagThresholds::get().len() == 64`, and the thresholds are determined according to"] # [doc = "   the procedure given above, then the constant ratio is equal to 2."] # [doc = " - If `BagThresholds::get().len() == 200`, and the thresholds are determined according to"] # [doc = "   the procedure given above, then the constant ratio is approximately equal to 1.248."] # [doc = " - If the threshold list begins `[1, 2, 3, ...]`, then an id with score 0 or 1 will fall"] # [doc = "   into bag 0, an id with score 2 will fall into bag 1, etc."] # [doc = ""] # [doc = " # Migration"] # [doc = ""] # [doc = " In the event that this list ever changes, a copy of the old bags list must be retained."] # [doc = " With that `List::migrate` can be called, which will perform the appropriate migration."] pub fn bag_thresholds (& self) -> :: core :: result :: Result < :: std :: vec :: Vec < :: core :: primitive :: u64 > , :: subxt :: BasicError > { if self . client . metadata () . constant_hash ("BagsList" , "BagThresholds") ? == [232u8 , 39u8 , 251u8 , 43u8 , 179u8 , 92u8 , 72u8 , 248u8 , 228u8 , 116u8 , 63u8 , 106u8 , 47u8 , 87u8 , 145u8 , 55u8 , 19u8 , 105u8 , 55u8 , 210u8 , 246u8 , 136u8 , 117u8 , 53u8 , 14u8 , 36u8 , 232u8 , 143u8 , 53u8 , 104u8 , 222u8 , 69u8 ,] { let pallet = self . client . metadata () . pallet ("BagsList") ? ; let constant = pallet . constant ("BagThresholds") ? ; let value = :: subxt :: codec :: Decode :: decode (& mut & constant . value [..]) ? ; Ok (value) } else { Err (:: subxt :: MetadataError :: IncompatibleMetadata . into ()) } } } } } pub mod nomination_pools { use super :: root_mod ; use super :: runtime_types ; pub mod calls { use super :: root_mod ; use super :: runtime_types ; type DispatchError = runtime_types :: sp_runtime :: DispatchError ; # [derive (:: subxt :: codec :: Decode , :: subxt :: codec :: Encode , Clone , Debug , Eq , PartialEq)] pub struct Join { # [codec (compact)] pub amount : :: core :: primitive :: u128 , pub pool_id : :: core :: primitive :: u32 , } impl :: subxt :: Call for Join { const PALLET : & 'static str = "NominationPools" ; const FUNCTION : & 'static str = "join" ; } # [derive (:: subxt :: codec :: Decode , :: subxt :: codec :: Encode , Clone , Debug , Eq , PartialEq)] pub struct BondExtra { pub extra : runtime_types :: pallet_nomination_pools :: BondExtra < :: core :: primitive :: u128 > , } impl :: subxt :: Call for BondExtra { const PALLET : & 'static str = "NominationPools" ; const FUNCTION : & 'static str = "bond_extra" ; } # [derive (:: subxt :: codec :: Decode , :: subxt :: codec :: Encode , Clone , Debug , Eq , PartialEq)] pub struct ClaimPayout ; impl :: subxt :: Call for ClaimPayout { const PALLET : & 'static str = "NominationPools" ; const FUNCTION : & 'static str = "claim_payout" ; } # [derive (:: subxt :: codec :: Decode , :: subxt :: codec :: Encode , Clone , Debug , Eq , PartialEq)] pub struct Unbond { pub member_account : :: subxt :: sp_core :: crypto :: AccountId32 , # [codec (compact)] pub unbonding_points : :: core :: primitive :: u128 , } impl :: subxt :: Call for Unbond { const PALLET : & 'static str = "NominationPools" ; const FUNCTION : & 'static str = "unbond" ; } # [derive (:: subxt :: codec :: Decode , :: subxt :: codec :: Encode , Clone , Debug , Eq , PartialEq)] pub struct PoolWithdrawUnbonded { pub pool_id : :: core :: primitive :: u32 , pub num_slashing_spans : :: core :: primitive :: u32 , } impl :: subxt :: Call for PoolWithdrawUnbonded { const PALLET : & 'static str = "NominationPools" ; const FUNCTION : & 'static str = "pool_withdraw_unbonded" ; } # [derive (:: subxt :: codec :: Decode , :: subxt :: codec :: Encode , Clone , Debug , Eq , PartialEq)] pub struct WithdrawUnbonded { pub member_account : :: subxt :: sp_core :: crypto :: AccountId32 , pub num_slashing_spans : :: core :: primitive :: u32 , } impl :: subxt :: Call for WithdrawUnbonded { const PALLET : & 'static str = "NominationPools" ; const FUNCTION : & 'static str = "withdraw_unbonded" ; } # [derive (:: subxt :: codec :: Decode , :: subxt :: codec :: Encode , Clone , Debug , Eq , PartialEq)] pub struct Create { # [codec (compact)] pub amount : :: core :: primitive :: u128 , pub root : :: subxt :: sp_core :: crypto :: AccountId32 , pub nominator : :: subxt :: sp_core :: crypto :: AccountId32 , pub state_toggler : :: subxt :: sp_core :: crypto :: AccountId32 , } impl :: subxt :: Call for Create { const PALLET : & 'static str = "NominationPools" ; const FUNCTION : & 'static str = "create" ; } # [derive (:: subxt :: codec :: Decode , :: subxt :: codec :: Encode , Clone , Debug , Eq , PartialEq)] pub struct Nominate { pub pool_id : :: core :: primitive :: u32 , pub validators : :: std :: vec :: Vec < :: subxt :: sp_core :: crypto :: AccountId32 > , } impl :: subxt :: Call for Nominate { const PALLET : & 'static str = "NominationPools" ; const FUNCTION : & 'static str = "nominate" ; } # [derive (:: subxt :: codec :: Decode , :: subxt :: codec :: Encode , Clone , Debug , Eq , PartialEq)] pub struct SetState { pub pool_id : :: core :: primitive :: u32 , pub state : runtime_types :: pallet_nomination_pools :: PoolState , } impl :: subxt :: Call for SetState { const PALLET : & 'static str = "NominationPools" ; const FUNCTION : & 'static str = "set_state" ; } # [derive (:: subxt :: codec :: Decode , :: subxt :: codec :: Encode , Clone , Debug , Eq , PartialEq)] pub struct SetMetadata { pub pool_id : :: core :: primitive :: u32 , pub metadata : :: std :: vec :: Vec < :: core :: primitive :: u8 > , } impl :: subxt :: Call for SetMetadata { const PALLET : & 'static str = "NominationPools" ; const FUNCTION : & 'static str = "set_metadata" ; } # [derive (:: subxt :: codec :: Decode , :: subxt :: codec :: Encode , Clone , Debug , Eq , PartialEq)] pub struct SetConfigs { pub min_join_bond : runtime_types :: pallet_nomination_pools :: ConfigOp < :: core :: primitive :: u128 > , pub min_create_bond : runtime_types :: pallet_nomination_pools :: ConfigOp < :: core :: primitive :: u128 > , pub max_pools : runtime_types :: pallet_nomination_pools :: ConfigOp < :: core :: primitive :: u32 > , pub max_members : runtime_types :: pallet_nomination_pools :: ConfigOp < :: core :: primitive :: u32 > , pub max_members_per_pool : runtime_types :: pallet_nomination_pools :: ConfigOp < :: core :: primitive :: u32 > , } impl :: subxt :: Call for SetConfigs { const PALLET : & 'static str = "NominationPools" ; const FUNCTION : & 'static str = "set_configs" ; } # [derive (:: subxt :: codec :: Decode , :: subxt :: codec :: Encode , Clone , Debug , Eq , PartialEq)] pub struct UpdateRoles { pub pool_id : :: core :: primitive :: u32 , pub new_root : runtime_types :: pallet_nomination_pools :: ConfigOp < :: subxt :: sp_core :: crypto :: AccountId32 > , pub new_nominator : runtime_types :: pallet_nomination_pools :: ConfigOp < :: subxt :: sp_core :: crypto :: AccountId32 > , pub new_state_toggler : runtime_types :: pallet_nomination_pools :: ConfigOp < :: subxt :: sp_core :: crypto :: AccountId32 > , } impl :: subxt :: Call for UpdateRoles { const PALLET : & 'static str = "NominationPools" ; const FUNCTION : & 'static str = "update_roles" ; } # [derive (:: subxt :: codec :: CompactAs , :: subxt :: codec :: Decode , :: subxt :: codec :: Encode , Clone , Debug , Eq , PartialEq)] pub struct Chill { pub pool_id : :: core :: primitive :: u32 , } impl :: subxt :: Call for Chill { const PALLET : & 'static str = "NominationPools" ; const FUNCTION : & 'static str = "chill" ; } pub struct TransactionApi < 'a , T : :: subxt :: Config , X > { client : & 'a :: subxt :: Client < T > , marker : :: core :: marker :: PhantomData < X > , } impl < 'a , T , X > TransactionApi < 'a , T , X > where T : :: subxt :: Config , X : :: subxt :: extrinsic :: ExtrinsicParams < T > , { pub fn new (client : & 'a :: subxt :: Client < T >) -> Self { Self { client , marker : :: core :: marker :: PhantomData } } # [doc = "Stake funds with a pool. The amount to bond is transferred from the member to the"] # [doc = "pools account and immediately increases the pools bond."] # [doc = ""] # [doc = "# Note"] # [doc = ""] # [doc = "* An account can only be a member of a single pool."] # [doc = "* An account cannot join the same pool multiple times."] # [doc = "* This call will *not* dust the member account, so the member must have at least"] # [doc = "  `existential deposit + amount` in their account."] # [doc = "* Only a pool with [`PoolState::Open`] can be joined"] pub fn join (& self , amount : :: core :: primitive :: u128 , pool_id : :: core :: primitive :: u32 ,) -> Result < :: subxt :: SubmittableExtrinsic < 'a , T , X , Join , DispatchError , root_mod :: Event > , :: subxt :: BasicError > { if self . client . metadata () . call_hash :: < Join > () ? == [158u8 , 139u8 , 232u8 , 64u8 , 124u8 , 17u8 , 14u8 , 255u8 , 234u8 , 228u8 , 240u8 , 196u8 , 252u8 , 198u8 , 255u8 , 21u8 , 18u8 , 3u8 , 119u8 , 200u8 , 37u8 , 73u8 , 121u8 , 122u8 , 152u8 , 134u8 , 159u8 , 166u8 , 147u8 , 96u8 , 245u8 , 121u8 ,] { let call = Join { amount , pool_id , } ; Ok (:: subxt :: SubmittableExtrinsic :: new (self . client , call)) } else { Err (:: subxt :: MetadataError :: IncompatibleMetadata . into ()) } } # [doc = "Bond `extra` more funds from `origin` into the pool to which they already belong."] # [doc = ""] # [doc = "Additional funds can come from either the free balance of the account, of from the"] # [doc = "accumulated rewards, see [`BondExtra`]."] pub fn bond_extra (& self , extra : runtime_types :: pallet_nomination_pools :: BondExtra < :: core :: primitive :: u128 > ,) -> Result < :: subxt :: SubmittableExtrinsic < 'a , T , X , BondExtra , DispatchError , root_mod :: Event > , :: subxt :: BasicError > { if self . client . metadata () . call_hash :: < BondExtra > () ? == [236u8 , 60u8 , 189u8 , 213u8 , 196u8 , 40u8 , 125u8 , 14u8 , 153u8 , 227u8 , 246u8 , 244u8 , 154u8 , 47u8 , 60u8 , 99u8 , 204u8 , 103u8 , 143u8 , 249u8 , 36u8 , 160u8 , 246u8 , 183u8 , 62u8 , 207u8 , 106u8 , 34u8 , 140u8 , 233u8 , 60u8 , 157u8 ,] { let call = BondExtra { extra , } ; Ok (:: subxt :: SubmittableExtrinsic :: new (self . client , call)) } else { Err (:: subxt :: MetadataError :: IncompatibleMetadata . into ()) } } # [doc = "A bonded member can use this to claim their payout based on the rewards that the pool"] # [doc = "has accumulated since their last claimed payout (OR since joining if this is there first"] # [doc = "time claiming rewards). The payout will be transferred to the member's account."] # [doc = ""] # [doc = "The member will earn rewards pro rata based on the members stake vs the sum of the"] # [doc = "members in the pools stake. Rewards do not \"expire\"."] pub fn claim_payout (& self ,) -> Result < :: subxt :: SubmittableExtrinsic < 'a , T , X , ClaimPayout , DispatchError , root_mod :: Event > , :: subxt :: BasicError > { if self . client . metadata () . call_hash :: < ClaimPayout > () ? == [128u8 , 58u8 , 138u8 , 55u8 , 64u8 , 16u8 , 129u8 , 25u8 , 211u8 , 229u8 , 193u8 , 115u8 , 47u8 , 45u8 , 155u8 , 221u8 , 218u8 , 1u8 , 222u8 , 5u8 , 236u8 , 32u8 , 88u8 , 0u8 , 198u8 , 72u8 , 196u8 , 181u8 , 104u8 , 16u8 , 212u8 , 29u8 ,] { let call = ClaimPayout { } ; Ok (:: subxt :: SubmittableExtrinsic :: new (self . client , call)) } else { Err (:: subxt :: MetadataError :: IncompatibleMetadata . into ()) } } # [doc = "Unbond up to `unbonding_points` of the `member_account`'s funds from the pool. It"] # [doc = "implicitly collects the rewards one last time, since not doing so would mean some"] # [doc = "rewards would be forfeited."] # [doc = ""] # [doc = "Under certain conditions, this call can be dispatched permissionlessly (i.e. by any"] # [doc = "account)."] # [doc = ""] # [doc = "# Conditions for a permissionless dispatch."] # [doc = ""] # [doc = "* The pool is blocked and the caller is either the root or state-toggler. This is"] # [doc = "  refereed to as a kick."] # [doc = "* The pool is destroying and the member is not the depositor."] # [doc = "* The pool is destroying, the member is the depositor and no other members are in the"] # [doc = "  pool."] # [doc = ""] # [doc = "## Conditions for permissioned dispatch (i.e. the caller is also the"] # [doc = "`member_account`):"] # [doc = ""] # [doc = "* The caller is not the depositor."] # [doc = "* The caller is the depositor, the pool is destroying and no other members are in the"] # [doc = "  pool."] # [doc = ""] # [doc = "# Note"] # [doc = ""] # [doc = "If there are too many unlocking chunks to unbond with the pool account,"] # [doc = "[`Call::pool_withdraw_unbonded`] can be called to try and minimize unlocking chunks. If"] # [doc = "there are too many unlocking chunks, the result of this call will likely be the"] # [doc = "`NoMoreChunks` error from the staking system."] pub fn unbond (& self , member_account : :: subxt :: sp_core :: crypto :: AccountId32 , unbonding_points : :: core :: primitive :: u128 ,) -> Result < :: subxt :: SubmittableExtrinsic < 'a , T , X , Unbond , DispatchError , root_mod :: Event > , :: subxt :: BasicError > { if self . client . metadata () . call_hash :: < Unbond > () ? == [191u8 , 75u8 , 137u8 , 10u8 , 199u8 , 52u8 , 46u8 , 61u8 , 234u8 , 43u8 , 159u8 , 180u8 , 123u8 , 34u8 , 241u8 , 192u8 , 49u8 , 210u8 , 112u8 , 168u8 , 245u8 , 204u8 , 215u8 , 88u8 , 35u8 , 246u8 , 197u8 , 140u8 , 127u8 , 138u8 , 199u8 , 12u8 ,] { let call = Unbond { member_account , unbonding_points , } ; Ok (:: subxt :: SubmittableExtrinsic :: new (self . client , call)) } else { Err (:: subxt :: MetadataError :: IncompatibleMetadata . into ()) } } # [doc = "Call `withdraw_unbonded` for the pools account. This call can be made by any account."] # [doc = ""] # [doc = "This is useful if their are too many unlocking chunks to call `unbond`, and some"] # [doc = "can be cleared by withdrawing. In the case there are too many unlocking chunks, the user"] # [doc = "would probably see an error like `NoMoreChunks` emitted from the staking system when"] # [doc = "they attempt to unbond."] pub fn pool_withdraw_unbonded (& self , pool_id : :: core :: primitive :: u32 , num_slashing_spans : :: core :: primitive :: u32 ,) -> Result < :: subxt :: SubmittableExtrinsic < 'a , T , X , PoolWithdrawUnbonded , DispatchError , root_mod :: Event > , :: subxt :: BasicError > { if self . client . metadata () . call_hash :: < PoolWithdrawUnbonded > () ? == [187u8 , 34u8 , 33u8 , 92u8 , 187u8 , 11u8 , 10u8 , 57u8 , 187u8 , 94u8 , 145u8 , 250u8 , 200u8 , 244u8 , 123u8 , 14u8 , 246u8 , 30u8 , 242u8 , 20u8 , 8u8 , 8u8 , 183u8 , 86u8 , 18u8 , 249u8 , 72u8 , 91u8 , 145u8 , 74u8 , 226u8 , 201u8 ,] { let call = PoolWithdrawUnbonded { pool_id , num_slashing_spans , } ; Ok (:: subxt :: SubmittableExtrinsic :: new (self . client , call)) } else { Err (:: subxt :: MetadataError :: IncompatibleMetadata . into ()) } } # [doc = "Withdraw unbonded funds from `member_account`. If no bonded funds can be unbonded, an"] # [doc = "error is returned."] # [doc = ""] # [doc = "Under certain conditions, this call can be dispatched permissionlessly (i.e. by any"] # [doc = "account)."] # [doc = ""] # [doc = "# Conditions for a permissionless dispatch"] # [doc = ""] # [doc = "* The pool is in destroy mode and the target is not the depositor."] # [doc = "* The target is the depositor and they are the only member in the sub pools."] # [doc = "* The pool is blocked and the caller is either the root or state-toggler."] # [doc = ""] # [doc = "# Conditions for permissioned dispatch"] # [doc = ""] # [doc = "* The caller is the target and they are not the depositor."] # [doc = ""] # [doc = "# Note"] # [doc = ""] # [doc = "If the target is the depositor, the pool will be destroyed."] pub fn withdraw_unbonded (& self , member_account : :: subxt :: sp_core :: crypto :: AccountId32 , num_slashing_spans : :: core :: primitive :: u32 ,) -> Result < :: subxt :: SubmittableExtrinsic < 'a , T , X , WithdrawUnbonded , DispatchError , root_mod :: Event > , :: subxt :: BasicError > { if self . client . metadata () . call_hash :: < WithdrawUnbonded > () ? == [58u8 , 189u8 , 167u8 , 91u8 , 188u8 , 85u8 , 202u8 , 37u8 , 250u8 , 126u8 , 169u8 , 198u8 , 32u8 , 216u8 , 179u8 , 71u8 , 253u8 , 86u8 , 187u8 , 76u8 , 188u8 , 2u8 , 136u8 , 255u8 , 124u8 , 114u8 , 143u8 , 106u8 , 176u8 , 140u8 , 225u8 , 113u8 ,] { let call = WithdrawUnbonded { member_account , num_slashing_spans , } ; Ok (:: subxt :: SubmittableExtrinsic :: new (self . client , call)) } else { Err (:: subxt :: MetadataError :: IncompatibleMetadata . into ()) } } # [doc = "Create a new delegation pool."] # [doc = ""] # [doc = "# Arguments"] # [doc = ""] # [doc = "* `amount` - The amount of funds to delegate to the pool. This also acts of a sort of"] # [doc = "  deposit since the pools creator cannot fully unbond funds until the pool is being"] # [doc = "  destroyed."] # [doc = "* `index` - A disambiguation index for creating the account. Likely only useful when"] # [doc = "  creating multiple pools in the same extrinsic."] # [doc = "* `root` - The account to set as [`PoolRoles::root`]."] # [doc = "* `nominator` - The account to set as the [`PoolRoles::nominator`]."] # [doc = "* `state_toggler` - The account to set as the [`PoolRoles::state_toggler`]."] # [doc = ""] # [doc = "# Note"] # [doc = ""] # [doc = "In addition to `amount`, the caller will transfer the existential deposit; so the caller"] # [doc = "needs at have at least `amount + existential_deposit` transferrable."] pub fn create (& self , amount : :: core :: primitive :: u128 , root : :: subxt :: sp_core :: crypto :: AccountId32 , nominator : :: subxt :: sp_core :: crypto :: AccountId32 , state_toggler : :: subxt :: sp_core :: crypto :: AccountId32 ,) -> Result < :: subxt :: SubmittableExtrinsic < 'a , T , X , Create , DispatchError , root_mod :: Event > , :: subxt :: BasicError > { if self . client . metadata () . call_hash :: < Create > () ? == [181u8 , 62u8 , 119u8 , 124u8 , 166u8 , 46u8 , 7u8 , 35u8 , 209u8 , 172u8 , 242u8 , 12u8 , 143u8 , 28u8 , 207u8 , 246u8 , 121u8 , 70u8 , 228u8 , 157u8 , 213u8 , 155u8 , 124u8 , 191u8 , 77u8 , 7u8 , 242u8 , 166u8 , 208u8 , 234u8 , 70u8 , 31u8 ,] { let call = Create { amount , root , nominator , state_toggler , } ; Ok (:: subxt :: SubmittableExtrinsic :: new (self . client , call)) } else { Err (:: subxt :: MetadataError :: IncompatibleMetadata . into ()) } } # [doc = "Nominate on behalf of the pool."] # [doc = ""] # [doc = "The dispatch origin of this call must be signed by the pool nominator or the pool"] # [doc = "root role."] # [doc = ""] # [doc = "This directly forward the call to the staking pallet, on behalf of the pool bonded"] # [doc = "account."] pub fn nominate (& self , pool_id : :: core :: primitive :: u32 , validators : :: std :: vec :: Vec < :: subxt :: sp_core :: crypto :: AccountId32 > ,) -> Result < :: subxt :: SubmittableExtrinsic < 'a , T , X , Nominate , DispatchError , root_mod :: Event > , :: subxt :: BasicError > { if self . client . metadata () . call_hash :: < Nominate > () ? == [140u8 , 225u8 , 83u8 , 45u8 , 120u8 , 218u8 , 98u8 , 183u8 , 78u8 , 96u8 , 204u8 , 44u8 , 21u8 , 47u8 , 0u8 , 240u8 , 212u8 , 114u8 , 136u8 , 166u8 , 243u8 , 200u8 , 52u8 , 63u8 , 168u8 , 21u8 , 239u8 , 101u8 , 84u8 , 110u8 , 171u8 , 245u8 ,] { let call = Nominate { pool_id , validators , } ; Ok (:: subxt :: SubmittableExtrinsic :: new (self . client , call)) } else { Err (:: subxt :: MetadataError :: IncompatibleMetadata . into ()) } } # [doc = "Set a new state for the pool."] # [doc = ""] # [doc = "The dispatch origin of this call must be signed by the state toggler, or the root role"] # [doc = "of the pool."] pub fn set_state (& self , pool_id : :: core :: primitive :: u32 , state : runtime_types :: pallet_nomination_pools :: PoolState ,) -> Result < :: subxt :: SubmittableExtrinsic < 'a , T , X , SetState , DispatchError , root_mod :: Event > , :: subxt :: BasicError > { if self . client . metadata () . call_hash :: < SetState > () ? == [97u8 , 15u8 , 52u8 , 211u8 , 32u8 , 128u8 , 101u8 , 126u8 , 247u8 , 153u8 , 126u8 , 135u8 , 161u8 , 91u8 , 79u8 , 84u8 , 85u8 , 62u8 , 191u8 , 218u8 , 196u8 , 48u8 , 104u8 , 141u8 , 85u8 , 81u8 , 176u8 , 140u8 , 13u8 , 233u8 , 127u8 , 121u8 ,] { let call = SetState { pool_id , state , } ; Ok (:: subxt :: SubmittableExtrinsic :: new (self . client , call)) } else { Err (:: subxt :: MetadataError :: IncompatibleMetadata . into ()) } } # [doc = "Set a new metadata for the pool."] # [doc = ""] # [doc = "The dispatch origin of this call must be signed by the state toggler, or the root role"] # [doc = "of the pool."] pub fn set_metadata (& self , pool_id : :: core :: primitive :: u32 , metadata : :: std :: vec :: Vec < :: core :: primitive :: u8 > ,) -> Result < :: subxt :: SubmittableExtrinsic < 'a , T , X , SetMetadata , DispatchError , root_mod :: Event > , :: subxt :: BasicError > { if self . client . metadata () . call_hash :: < SetMetadata > () ? == [152u8 , 245u8 , 179u8 , 62u8 , 95u8 , 163u8 , 103u8 , 159u8 , 2u8 , 114u8 , 128u8 , 82u8 , 168u8 , 226u8 , 26u8 , 148u8 , 101u8 , 30u8 , 42u8 , 125u8 , 2u8 , 14u8 , 26u8 , 27u8 , 58u8 , 248u8 , 240u8 , 120u8 , 171u8 , 88u8 , 93u8 , 129u8 ,] { let call = SetMetadata { pool_id , metadata , } ; Ok (:: subxt :: SubmittableExtrinsic :: new (self . client , call)) } else { Err (:: subxt :: MetadataError :: IncompatibleMetadata . into ()) } } # [doc = "Update configurations for the nomination pools. The origin for this call must be"] # [doc = "Root."] # [doc = ""] # [doc = "# Arguments"] # [doc = ""] # [doc = "* `min_join_bond` - Set [`MinJoinBond`]."] # [doc = "* `min_create_bond` - Set [`MinCreateBond`]."] # [doc = "* `max_pools` - Set [`MaxPools`]."] # [doc = "* `max_members` - Set [`MaxPoolMembers`]."] # [doc = "* `max_members_per_pool` - Set [`MaxPoolMembersPerPool`]."] pub fn set_configs (& self , min_join_bond : runtime_types :: pallet_nomination_pools :: ConfigOp < :: core :: primitive :: u128 > , min_create_bond : runtime_types :: pallet_nomination_pools :: ConfigOp < :: core :: primitive :: u128 > , max_pools : runtime_types :: pallet_nomination_pools :: ConfigOp < :: core :: primitive :: u32 > , max_members : runtime_types :: pallet_nomination_pools :: ConfigOp < :: core :: primitive :: u32 > , max_members_per_pool : runtime_types :: pallet_nomination_pools :: ConfigOp < :: core :: primitive :: u32 > ,) -> Result < :: subxt :: SubmittableExtrinsic < 'a , T , X , SetConfigs , DispatchError , root_mod :: Event > , :: subxt :: BasicError > { if self . client . metadata () . call_hash :: < SetConfigs > () ? == [157u8 , 112u8 , 91u8 , 227u8 , 2u8 , 81u8 , 33u8 , 20u8 , 27u8 , 152u8 , 14u8 , 63u8 , 6u8 , 240u8 , 96u8 , 56u8 , 96u8 , 114u8 , 171u8 , 184u8 , 211u8 , 29u8 , 94u8 , 101u8 , 14u8 , 219u8 , 208u8 , 197u8 , 29u8 , 96u8 , 228u8 , 158u8 ,] { let call = SetConfigs { min_join_bond , min_create_bond , max_pools , max_members , max_members_per_pool , } ; Ok (:: subxt :: SubmittableExtrinsic :: new (self . client , call)) } else { Err (:: subxt :: MetadataError :: IncompatibleMetadata . into ()) } } # [doc = "Update the roles of the pool."] # [doc = ""] # [doc = "The root is the only entity that can change any of the roles, including itself,"] # [doc = "excluding the depositor, who can never change."] # [doc = ""] # [doc = "It emits an event, notifying UIs of the role change. This event is quite relevant to"] # [doc = "most pool members and they should be informed of changes to pool roles."] pub fn update_roles (& self , pool_id : :: core :: primitive :: u32 , new_root : runtime_types :: pallet_nomination_pools :: ConfigOp < :: subxt :: sp_core :: crypto :: AccountId32 > , new_nominator : runtime_types :: pallet_nomination_pools :: ConfigOp < :: subxt :: sp_core :: crypto :: AccountId32 > , new_state_toggler : runtime_types :: pallet_nomination_pools :: ConfigOp < :: subxt :: sp_core :: crypto :: AccountId32 > ,) -> Result < :: subxt :: SubmittableExtrinsic < 'a , T , X , UpdateRoles , DispatchError , root_mod :: Event > , :: subxt :: BasicError > { if self . client . metadata () . call_hash :: < UpdateRoles > () ? == [129u8 , 78u8 , 95u8 , 251u8 , 33u8 , 37u8 , 120u8 , 87u8 , 2u8 , 54u8 , 242u8 , 245u8 , 51u8 , 160u8 , 121u8 , 51u8 , 15u8 , 21u8 , 56u8 , 40u8 , 60u8 , 79u8 , 75u8 , 190u8 , 200u8 , 18u8 , 248u8 , 237u8 , 210u8 , 194u8 , 158u8 , 214u8 ,] { let call = UpdateRoles { pool_id , new_root , new_nominator , new_state_toggler , } ; Ok (:: subxt :: SubmittableExtrinsic :: new (self . client , call)) } else { Err (:: subxt :: MetadataError :: IncompatibleMetadata . into ()) } } # [doc = "Chill on behalf of the pool."] # [doc = ""] # [doc = "The dispatch origin of this call must be signed by the pool nominator or the pool"] # [doc = "root role, same as [`Pallet::nominate`]."] # [doc = ""] # [doc = "This directly forward the call to the staking pallet, on behalf of the pool bonded"] # [doc = "account."] pub fn chill (& self , pool_id : :: core :: primitive :: u32 ,) -> Result < :: subxt :: SubmittableExtrinsic < 'a , T , X , Chill , DispatchError , root_mod :: Event > , :: subxt :: BasicError > { if self . client . metadata () . call_hash :: < Chill > () ? == [12u8 , 36u8 , 224u8 , 17u8 , 59u8 , 5u8 , 198u8 , 193u8 , 237u8 , 29u8 , 227u8 , 171u8 , 238u8 , 81u8 , 35u8 , 90u8 , 73u8 , 68u8 , 168u8 , 129u8 , 248u8 , 103u8 , 30u8 , 10u8 , 88u8 , 241u8 , 164u8 , 91u8 , 116u8 , 48u8 , 129u8 , 157u8 ,] { let call = Chill { pool_id , } ; Ok (:: subxt :: SubmittableExtrinsic :: new (self . client , call)) } else { Err (:: subxt :: MetadataError :: IncompatibleMetadata . into ()) } } } } pub type Event = runtime_types :: pallet_nomination_pools :: pallet :: Event ; pub mod events { use super :: runtime_types ; # [derive (:: subxt :: codec :: Decode , :: subxt :: codec :: Encode , Clone , Debug , Eq , PartialEq)] # [doc = "A pool has been created."] pub struct Created { pub depositor : :: subxt :: sp_core :: crypto :: AccountId32 , pub pool_id : :: core :: primitive :: u32 , } impl :: subxt :: Event for Created { const PALLET : & 'static str = "NominationPools" ; const EVENT : & 'static str = "Created" ; } # [derive (:: subxt :: codec :: Decode , :: subxt :: codec :: Encode , Clone , Debug , Eq , PartialEq)] # [doc = "A member has became bonded in a pool."] pub struct Bonded { pub member : :: subxt :: sp_core :: crypto :: AccountId32 , pub pool_id : :: core :: primitive :: u32 , pub bonded : :: core :: primitive :: u128 , pub joined : :: core :: primitive :: bool , } impl :: subxt :: Event for Bonded { const PALLET : & 'static str = "NominationPools" ; const EVENT : & 'static str = "Bonded" ; } # [derive (:: subxt :: codec :: Decode , :: subxt :: codec :: Encode , Clone , Debug , Eq , PartialEq)] # [doc = "A payout has been made to a member."] pub struct PaidOut { pub member : :: subxt :: sp_core :: crypto :: AccountId32 , pub pool_id : :: core :: primitive :: u32 , pub payout : :: core :: primitive :: u128 , } impl :: subxt :: Event for PaidOut { const PALLET : & 'static str = "NominationPools" ; const EVENT : & 'static str = "PaidOut" ; } # [derive (:: subxt :: codec :: Decode , :: subxt :: codec :: Encode , Clone , Debug , Eq , PartialEq)] # [doc = "A member has unbonded from their pool."] # [doc = ""] # [doc = "- `balance` is the corresponding balance of the number of points that has been"] # [doc = "  requested to be unbonded (the argument of the `unbond` transaction) from the bonded"] # [doc = "  pool."] # [doc = "- `points` is the number of points that are issued as a result of `balance` being"] # [doc = "dissolved into the corresponding unbonding pool."] # [doc = ""] # [doc = "In the absence of slashing, these values will match. In the presence of slashing, the"] # [doc = "number of points that are issued in the unbonding pool will be less than the amount"] # [doc = "requested to be unbonded."] pub struct Unbonded { pub member : :: subxt :: sp_core :: crypto :: AccountId32 , pub pool_id : :: core :: primitive :: u32 , pub balance : :: core :: primitive :: u128 , pub points : :: core :: primitive :: u128 , } impl :: subxt :: Event for Unbonded { const PALLET : & 'static str = "NominationPools" ; const EVENT : & 'static str = "Unbonded" ; } # [derive (:: subxt :: codec :: Decode , :: subxt :: codec :: Encode , Clone , Debug , Eq , PartialEq)] # [doc = "A member has withdrawn from their pool."] # [doc = ""] # [doc = "The given number of `points` have been dissolved in return of `balance`."] # [doc = ""] # [doc = "Similar to `Unbonded` event, in the absence of slashing, the ratio of point to balance"] # [doc = "will be 1."] pub struct Withdrawn { pub member : :: subxt :: sp_core :: crypto :: AccountId32 , pub pool_id : :: core :: primitive :: u32 , pub balance : :: core :: primitive :: u128 , pub points : :: core :: primitive :: u128 , } impl :: subxt :: Event for Withdrawn { const PALLET : & 'static str = "NominationPools" ; const EVENT : & 'static str = "Withdrawn" ; } # [derive (:: subxt :: codec :: CompactAs , :: subxt :: codec :: Decode , :: subxt :: codec :: Encode , Clone , Debug , Eq , PartialEq)] # [doc = "A pool has been destroyed."] pub struct Destroyed { pub pool_id : :: core :: primitive :: u32 , } impl :: subxt :: Event for Destroyed { const PALLET : & 'static str = "NominationPools" ; const EVENT : & 'static str = "Destroyed" ; } # [derive (:: subxt :: codec :: Decode , :: subxt :: codec :: Encode , Clone , Debug , Eq , PartialEq)] # [doc = "The state of a pool has changed"] pub struct StateChanged { pub pool_id : :: core :: primitive :: u32 , pub new_state : runtime_types :: pallet_nomination_pools :: PoolState , } impl :: subxt :: Event for StateChanged { const PALLET : & 'static str = "NominationPools" ; const EVENT : & 'static str = "StateChanged" ; } # [derive (:: subxt :: codec :: Decode , :: subxt :: codec :: Encode , Clone , Debug , Eq , PartialEq)] # [doc = "A member has been removed from a pool."] # [doc = ""] # [doc = "The removal can be voluntary (withdrawn all unbonded funds) or involuntary (kicked)."] pub struct MemberRemoved { pub pool_id : :: core :: primitive :: u32 , pub member : :: subxt :: sp_core :: crypto :: AccountId32 , } impl :: subxt :: Event for MemberRemoved { const PALLET : & 'static str = "NominationPools" ; const EVENT : & 'static str = "MemberRemoved" ; } # [derive (:: subxt :: codec :: Decode , :: subxt :: codec :: Encode , Clone , Debug , Eq , PartialEq)] # [doc = "The roles of a pool have been updated to the given new roles. Note that the depositor"] # [doc = "can never change."] pub struct RolesUpdated { pub root : :: core :: option :: Option < :: subxt :: sp_core :: crypto :: AccountId32 > , pub state_toggler : :: core :: option :: Option < :: subxt :: sp_core :: crypto :: AccountId32 > , pub nominator : :: core :: option :: Option < :: subxt :: sp_core :: crypto :: AccountId32 > , } impl :: subxt :: Event for RolesUpdated { const PALLET : & 'static str = "NominationPools" ; const EVENT : & 'static str = "RolesUpdated" ; } # [derive (:: subxt :: codec :: Decode , :: subxt :: codec :: Encode , Clone , Debug , Eq , PartialEq)] # [doc = "The active balance of pool `pool_id` has been slashed to `balance`."] pub struct PoolSlashed { pub pool_id : :: core :: primitive :: u32 , pub balance : :: core :: primitive :: u128 , } impl :: subxt :: Event for PoolSlashed { const PALLET : & 'static str = "NominationPools" ; const EVENT : & 'static str = "PoolSlashed" ; } # [derive (:: subxt :: codec :: Decode , :: subxt :: codec :: Encode , Clone , Debug , Eq , PartialEq)] # [doc = "The unbond pool at `era` of pool `pool_id` has been slashed to `balance`."] pub struct UnbondingPoolSlashed { pub pool_id : :: core :: primitive :: u32 , pub era : :: core :: primitive :: u32 , pub balance : :: core :: primitive :: u128 , } impl :: subxt :: Event for UnbondingPoolSlashed { const PALLET : & 'static str = "NominationPools" ; const EVENT : & 'static str = "UnbondingPoolSlashed" ; } } pub mod storage { use super :: runtime_types ; pub struct MinJoinBond ; impl :: subxt :: StorageEntry for MinJoinBond { const PALLET : & 'static str = "NominationPools" ; const STORAGE : & 'static str = "MinJoinBond" ; type Value = :: core :: primitive :: u128 ; fn key (& self) -> :: subxt :: StorageEntryKey { :: subxt :: StorageEntryKey :: Plain } } pub struct MinCreateBond ; impl :: subxt :: StorageEntry for MinCreateBond { const PALLET : & 'static str = "NominationPools" ; const STORAGE : & 'static str = "MinCreateBond" ; type Value = :: core :: primitive :: u128 ; fn key (& self) -> :: subxt :: StorageEntryKey { :: subxt :: StorageEntryKey :: Plain } } pub struct MaxPools ; impl :: subxt :: StorageEntry for MaxPools { const PALLET : & 'static str = "NominationPools" ; const STORAGE : & 'static str = "MaxPools" ; type Value = :: core :: primitive :: u32 ; fn key (& self) -> :: subxt :: StorageEntryKey { :: subxt :: StorageEntryKey :: Plain } } pub struct MaxPoolMembers ; impl :: subxt :: StorageEntry for MaxPoolMembers { const PALLET : & 'static str = "NominationPools" ; const STORAGE : & 'static str = "MaxPoolMembers" ; type Value = :: core :: primitive :: u32 ; fn key (& self) -> :: subxt :: StorageEntryKey { :: subxt :: StorageEntryKey :: Plain } } pub struct MaxPoolMembersPerPool ; impl :: subxt :: StorageEntry for MaxPoolMembersPerPool { const PALLET : & 'static str = "NominationPools" ; const STORAGE : & 'static str = "MaxPoolMembersPerPool" ; type Value = :: core :: primitive :: u32 ; fn key (& self) -> :: subxt :: StorageEntryKey { :: subxt :: StorageEntryKey :: Plain } } pub struct PoolMembers < 'a > (pub & 'a :: subxt :: sp_core :: crypto :: AccountId32) ; impl :: subxt :: StorageEntry for PoolMembers < '_ > { const PALLET : & 'static str = "NominationPools" ; const STORAGE : & 'static str = "PoolMembers" ; type Value = runtime_types :: pallet_nomination_pools :: PoolMember ; fn key (& self) -> :: subxt :: StorageEntryKey { :: subxt :: StorageEntryKey :: Map (vec ! [:: subxt :: StorageMapKey :: new (& self . 0 , :: subxt :: StorageHasher :: Twox64Concat)]) } } pub struct CounterForPoolMembers ; impl :: subxt :: StorageEntry for CounterForPoolMembers { const PALLET : & 'static str = "NominationPools" ; const STORAGE : & 'static str = "CounterForPoolMembers" ; type Value = :: core :: primitive :: u32 ; fn key (& self) -> :: subxt :: StorageEntryKey { :: subxt :: StorageEntryKey :: Plain } } pub struct BondedPools < 'a > (pub & 'a :: core :: primitive :: u32) ; impl :: subxt :: StorageEntry for BondedPools < '_ > { const PALLET : & 'static str = "NominationPools" ; const STORAGE : & 'static str = "BondedPools" ; type Value = runtime_types :: pallet_nomination_pools :: BondedPoolInner ; fn key (& self) -> :: subxt :: StorageEntryKey { :: subxt :: StorageEntryKey :: Map (vec ! [:: subxt :: StorageMapKey :: new (& self . 0 , :: subxt :: StorageHasher :: Twox64Concat)]) } } pub struct CounterForBondedPools ; impl :: subxt :: StorageEntry for CounterForBondedPools { const PALLET : & 'static str = "NominationPools" ; const STORAGE : & 'static str = "CounterForBondedPools" ; type Value = :: core :: primitive :: u32 ; fn key (& self) -> :: subxt :: StorageEntryKey { :: subxt :: StorageEntryKey :: Plain } } pub struct RewardPools < 'a > (pub & 'a :: core :: primitive :: u32) ; impl :: subxt :: StorageEntry for RewardPools < '_ > { const PALLET : & 'static str = "NominationPools" ; const STORAGE : & 'static str = "RewardPools" ; type Value = runtime_types :: pallet_nomination_pools :: RewardPool ; fn key (& self) -> :: subxt :: StorageEntryKey { :: subxt :: StorageEntryKey :: Map (vec ! [:: subxt :: StorageMapKey :: new (& self . 0 , :: subxt :: StorageHasher :: Twox64Concat)]) } } pub struct CounterForRewardPools ; impl :: subxt :: StorageEntry for CounterForRewardPools { const PALLET : & 'static str = "NominationPools" ; const STORAGE : & 'static str = "CounterForRewardPools" ; type Value = :: core :: primitive :: u32 ; fn key (& self) -> :: subxt :: StorageEntryKey { :: subxt :: StorageEntryKey :: Plain } } pub struct SubPoolsStorage < 'a > (pub & 'a :: core :: primitive :: u32) ; impl :: subxt :: StorageEntry for SubPoolsStorage < '_ > { const PALLET : & 'static str = "NominationPools" ; const STORAGE : & 'static str = "SubPoolsStorage" ; type Value = runtime_types :: pallet_nomination_pools :: SubPools ; fn key (& self) -> :: subxt :: StorageEntryKey { :: subxt :: StorageEntryKey :: Map (vec ! [:: subxt :: StorageMapKey :: new (& self . 0 , :: subxt :: StorageHasher :: Twox64Concat)]) } } pub struct CounterForSubPoolsStorage ; impl :: subxt :: StorageEntry for CounterForSubPoolsStorage { const PALLET : & 'static str = "NominationPools" ; const STORAGE : & 'static str = "CounterForSubPoolsStorage" ; type Value = :: core :: primitive :: u32 ; fn key (& self) -> :: subxt :: StorageEntryKey { :: subxt :: StorageEntryKey :: Plain } } pub struct Metadata < 'a > (pub & 'a :: core :: primitive :: u32) ; impl :: subxt :: StorageEntry for Metadata < '_ > { const PALLET : & 'static str = "NominationPools" ; const STORAGE : & 'static str = "Metadata" ; type Value = runtime_types :: sp_runtime :: bounded :: bounded_vec :: BoundedVec < :: core :: primitive :: u8 > ; fn key (& self) -> :: subxt :: StorageEntryKey { :: subxt :: StorageEntryKey :: Map (vec ! [:: subxt :: StorageMapKey :: new (& self . 0 , :: subxt :: StorageHasher :: Twox64Concat)]) } } pub struct CounterForMetadata ; impl :: subxt :: StorageEntry for CounterForMetadata { const PALLET : & 'static str = "NominationPools" ; const STORAGE : & 'static str = "CounterForMetadata" ; type Value = :: core :: primitive :: u32 ; fn key (& self) -> :: subxt :: StorageEntryKey { :: subxt :: StorageEntryKey :: Plain } } pub struct LastPoolId ; impl :: subxt :: StorageEntry for LastPoolId { const PALLET : & 'static str = "NominationPools" ; const STORAGE : & 'static str = "LastPoolId" ; type Value = :: core :: primitive :: u32 ; fn key (& self) -> :: subxt :: StorageEntryKey { :: subxt :: StorageEntryKey :: Plain } } pub struct ReversePoolIdLookup < 'a > (pub & 'a :: subxt :: sp_core :: crypto :: AccountId32) ; impl :: subxt :: StorageEntry for ReversePoolIdLookup < '_ > { const PALLET : & 'static str = "NominationPools" ; const STORAGE : & 'static str = "ReversePoolIdLookup" ; type Value = :: core :: primitive :: u32 ; fn key (& self) -> :: subxt :: StorageEntryKey { :: subxt :: StorageEntryKey :: Map (vec ! [:: subxt :: StorageMapKey :: new (& self . 0 , :: subxt :: StorageHasher :: Twox64Concat)]) } } pub struct CounterForReversePoolIdLookup ; impl :: subxt :: StorageEntry for CounterForReversePoolIdLookup { const PALLET : & 'static str = "NominationPools" ; const STORAGE : & 'static str = "CounterForReversePoolIdLookup" ; type Value = :: core :: primitive :: u32 ; fn key (& self) -> :: subxt :: StorageEntryKey { :: subxt :: StorageEntryKey :: Plain } } pub struct StorageApi < 'a , T : :: subxt :: Config > { client : & 'a :: subxt :: Client < T > , } impl < 'a , T : :: subxt :: Config > StorageApi < 'a , T > { pub fn new (client : & 'a :: subxt :: Client < T >) -> Self { Self { client } } # [doc = " Minimum amount to bond to join a pool."] pub async fn min_join_bond (& self , block_hash : :: core :: option :: Option < T :: Hash > ,) -> :: core :: result :: Result < :: core :: primitive :: u128 , :: subxt :: BasicError > { if self . client . metadata () . storage_hash :: < MinJoinBond > () ? == [125u8 , 239u8 , 45u8 , 225u8 , 74u8 , 129u8 , 247u8 , 184u8 , 205u8 , 58u8 , 45u8 , 186u8 , 126u8 , 170u8 , 112u8 , 120u8 , 23u8 , 190u8 , 247u8 , 97u8 , 131u8 , 126u8 , 215u8 , 44u8 , 147u8 , 122u8 , 132u8 , 212u8 , 217u8 , 84u8 , 240u8 , 91u8 ,] { let entry = MinJoinBond ; self . client . storage () . fetch_or_default (& entry , block_hash) . await } else { Err (:: subxt :: MetadataError :: IncompatibleMetadata . into ()) } } # [doc = " Minimum bond required to create a pool."] # [doc = ""] # [doc = " This is the amount that the depositor must put as their initial stake in the pool, as an"] # [doc = " indication of \"skin in the game\"."] # [doc = ""] # [doc = " This is the value that will always exist in the staking ledger of the pool bonded account"] # [doc = " while all other accounts leave."] pub async fn min_create_bond (& self , block_hash : :: core :: option :: Option < T :: Hash > ,) -> :: core :: result :: Result < :: core :: primitive :: u128 , :: subxt :: BasicError > { if self . client . metadata () . storage_hash :: < MinCreateBond > () ? == [31u8 , 208u8 , 240u8 , 158u8 , 23u8 , 218u8 , 212u8 , 138u8 , 92u8 , 210u8 , 207u8 , 170u8 , 32u8 , 60u8 , 5u8 , 21u8 , 84u8 , 162u8 , 1u8 , 111u8 , 181u8 , 243u8 , 24u8 , 148u8 , 193u8 , 253u8 , 248u8 , 190u8 , 16u8 , 222u8 , 219u8 , 67u8 ,] { let entry = MinCreateBond ; self . client . storage () . fetch_or_default (& entry , block_hash) . await } else { Err (:: subxt :: MetadataError :: IncompatibleMetadata . into ()) } } # [doc = " Maximum number of nomination pools that can exist. If `None`, then an unbounded number of"] # [doc = " pools can exist."] pub async fn max_pools (& self , block_hash : :: core :: option :: Option < T :: Hash > ,) -> :: core :: result :: Result < :: core :: option :: Option < :: core :: primitive :: u32 > , :: subxt :: BasicError > { if self . client . metadata () . storage_hash :: < MaxPools > () ? == [216u8 , 111u8 , 68u8 , 103u8 , 33u8 , 50u8 , 109u8 , 3u8 , 176u8 , 195u8 , 23u8 , 73u8 , 112u8 , 138u8 , 9u8 , 194u8 , 233u8 , 73u8 , 68u8 , 215u8 , 162u8 , 255u8 , 217u8 , 173u8 , 141u8 , 27u8 , 72u8 , 199u8 , 7u8 , 240u8 , 25u8 , 34u8 ,] { let entry = MaxPools ; self . client . storage () . fetch (& entry , block_hash) . await } else { Err (:: subxt :: MetadataError :: IncompatibleMetadata . into ()) } } # [doc = " Maximum number of members that can exist in the system. If `None`, then the count"] # [doc = " members are not bound on a system wide basis."] pub async fn max_pool_members (& self , block_hash : :: core :: option :: Option < T :: Hash > ,) -> :: core :: result :: Result < :: core :: option :: Option < :: core :: primitive :: u32 > , :: subxt :: BasicError > { if self . client . metadata () . storage_hash :: < MaxPoolMembers > () ? == [82u8 , 217u8 , 26u8 , 234u8 , 223u8 , 241u8 , 66u8 , 182u8 , 43u8 , 233u8 , 59u8 , 242u8 , 202u8 , 254u8 , 69u8 , 50u8 , 254u8 , 196u8 , 166u8 , 89u8 , 120u8 , 87u8 , 76u8 , 148u8 , 31u8 , 197u8 , 49u8 , 88u8 , 206u8 , 41u8 , 242u8 , 62u8 ,] { let entry = MaxPoolMembers ; self . client . storage () . fetch (& entry , block_hash) . await } else { Err (:: subxt :: MetadataError :: IncompatibleMetadata . into ()) } } # [doc = " Maximum number of members that may belong to pool. If `None`, then the count of"] # [doc = " members is not bound on a per pool basis."] pub async fn max_pool_members_per_pool (& self , block_hash : :: core :: option :: Option < T :: Hash > ,) -> :: core :: result :: Result < :: core :: option :: Option < :: core :: primitive :: u32 > , :: subxt :: BasicError > { if self . client . metadata () . storage_hash :: < MaxPoolMembersPerPool > () ? == [93u8 , 241u8 , 16u8 , 169u8 , 138u8 , 199u8 , 128u8 , 149u8 , 65u8 , 30u8 , 55u8 , 11u8 , 41u8 , 252u8 , 83u8 , 250u8 , 9u8 , 33u8 , 152u8 , 239u8 , 195u8 , 147u8 , 16u8 , 248u8 , 180u8 , 153u8 , 88u8 , 231u8 , 248u8 , 169u8 , 186u8 , 48u8 ,] { let entry = MaxPoolMembersPerPool ; self . client . storage () . fetch (& entry , block_hash) . await } else { Err (:: subxt :: MetadataError :: IncompatibleMetadata . into ()) } } # [doc = " Active members."] pub async fn pool_members (& self , _0 : & :: subxt :: sp_core :: crypto :: AccountId32 , block_hash : :: core :: option :: Option < T :: Hash > ,) -> :: core :: result :: Result < :: core :: option :: Option < runtime_types :: pallet_nomination_pools :: PoolMember > , :: subxt :: BasicError > { if self . client . metadata () . storage_hash :: < PoolMembers > () ? == [220u8 , 248u8 , 215u8 , 227u8 , 153u8 , 107u8 , 217u8 , 67u8 , 2u8 , 63u8 , 0u8 , 27u8 , 44u8 , 247u8 , 246u8 , 188u8 , 134u8 , 241u8 , 93u8 , 241u8 , 110u8 , 202u8 , 59u8 , 249u8 , 42u8 , 0u8 , 165u8 , 151u8 , 112u8 , 225u8 , 54u8 , 3u8 ,] { let entry = PoolMembers (_0) ; self . client . storage () . fetch (& entry , block_hash) . await } else { Err (:: subxt :: MetadataError :: IncompatibleMetadata . into ()) } } # [doc = " Active members."] pub async fn pool_members_iter (& self , block_hash : :: core :: option :: Option < T :: Hash > ,) -> :: core :: result :: Result < :: subxt :: KeyIter < 'a , T , PoolMembers < 'a > > , :: subxt :: BasicError > { if self . client . metadata () . storage_hash :: < PoolMembers > () ? == [220u8 , 248u8 , 215u8 , 227u8 , 153u8 , 107u8 , 217u8 , 67u8 , 2u8 , 63u8 , 0u8 , 27u8 , 44u8 , 247u8 , 246u8 , 188u8 , 134u8 , 241u8 , 93u8 , 241u8 , 110u8 , 202u8 , 59u8 , 249u8 , 42u8 , 0u8 , 165u8 , 151u8 , 112u8 , 225u8 , 54u8 , 3u8 ,] { self . client . storage () . iter (block_hash) . await } else { Err (:: subxt :: MetadataError :: IncompatibleMetadata . into ()) } } # [doc = "Counter for the related counted storage map"] pub async fn counter_for_pool_members (& self , block_hash : :: core :: option :: Option < T :: Hash > ,) -> :: core :: result :: Result < :: core :: primitive :: u32 , :: subxt :: BasicError > { if self . client . metadata () . storage_hash :: < CounterForPoolMembers > () ? == [114u8 , 126u8 , 27u8 , 138u8 , 119u8 , 44u8 , 45u8 , 129u8 , 84u8 , 107u8 , 171u8 , 206u8 , 117u8 , 141u8 , 20u8 , 75u8 , 229u8 , 237u8 , 31u8 , 229u8 , 124u8 , 190u8 , 27u8 , 124u8 , 63u8 , 59u8 , 167u8 , 42u8 , 62u8 , 212u8 , 160u8 , 2u8 ,] { let entry = CounterForPoolMembers ; self . client . storage () . fetch_or_default (& entry , block_hash) . await } else { Err (:: subxt :: MetadataError :: IncompatibleMetadata . into ()) } } # [doc = " Storage for bonded pools."] pub async fn bonded_pools (& self , _0 : & :: core :: primitive :: u32 , block_hash : :: core :: option :: Option < T :: Hash > ,) -> :: core :: result :: Result < :: core :: option :: Option < runtime_types :: pallet_nomination_pools :: BondedPoolInner > , :: subxt :: BasicError > { if self . client . metadata () . storage_hash :: < BondedPools > () ? == [118u8 , 190u8 , 153u8 , 45u8 , 232u8 , 166u8 , 193u8 , 158u8 , 194u8 , 178u8 , 150u8 , 75u8 , 216u8 , 176u8 , 191u8 , 215u8 , 213u8 , 188u8 , 176u8 , 235u8 , 241u8 , 106u8 , 125u8 , 204u8 , 61u8 , 179u8 , 133u8 , 229u8 , 161u8 , 53u8 , 161u8 , 254u8 ,] { let entry = BondedPools (_0) ; self . client . storage () . fetch (& entry , block_hash) . await } else { Err (:: subxt :: MetadataError :: IncompatibleMetadata . into ()) } } # [doc = " Storage for bonded pools."] pub async fn bonded_pools_iter (& self , block_hash : :: core :: option :: Option < T :: Hash > ,) -> :: core :: result :: Result < :: subxt :: KeyIter < 'a , T , BondedPools < 'a > > , :: subxt :: BasicError > { if self . client . metadata () . storage_hash :: < BondedPools > () ? == [118u8 , 190u8 , 153u8 , 45u8 , 232u8 , 166u8 , 193u8 , 158u8 , 194u8 , 178u8 , 150u8 , 75u8 , 216u8 , 176u8 , 191u8 , 215u8 , 213u8 , 188u8 , 176u8 , 235u8 , 241u8 , 106u8 , 125u8 , 204u8 , 61u8 , 179u8 , 133u8 , 229u8 , 161u8 , 53u8 , 161u8 , 254u8 ,] { self . client . storage () . iter (block_hash) . await } else { Err (:: subxt :: MetadataError :: IncompatibleMetadata . into ()) } } # [doc = "Counter for the related counted storage map"] pub async fn counter_for_bonded_pools (& self , block_hash : :: core :: option :: Option < T :: Hash > ,) -> :: core :: result :: Result < :: core :: primitive :: u32 , :: subxt :: BasicError > { if self . client . metadata () . storage_hash :: < CounterForBondedPools > () ? == [134u8 , 94u8 , 199u8 , 73u8 , 174u8 , 253u8 , 66u8 , 242u8 , 233u8 , 244u8 , 140u8 , 170u8 , 242u8 , 40u8 , 41u8 , 185u8 , 183u8 , 151u8 , 58u8 , 111u8 , 221u8 , 225u8 , 81u8 , 71u8 , 169u8 , 219u8 , 223u8 , 135u8 , 8u8 , 171u8 , 180u8 , 236u8 ,] { let entry = CounterForBondedPools ; self . client . storage () . fetch_or_default (& entry , block_hash) . await } else { Err (:: subxt :: MetadataError :: IncompatibleMetadata . into ()) } } # [doc = " Reward pools. This is where there rewards for each pool accumulate. When a members payout"] # [doc = " is claimed, the balance comes out fo the reward pool. Keyed by the bonded pools account."] pub async fn reward_pools (& self , _0 : & :: core :: primitive :: u32 , block_hash : :: core :: option :: Option < T :: Hash > ,) -> :: core :: result :: Result < :: core :: option :: Option < runtime_types :: pallet_nomination_pools :: RewardPool > , :: subxt :: BasicError > { if self . client . metadata () . storage_hash :: < RewardPools > () ? == [175u8 , 64u8 , 211u8 , 116u8 , 169u8 , 15u8 , 197u8 , 146u8 , 200u8 , 148u8 , 55u8 , 127u8 , 95u8 , 120u8 , 204u8 , 85u8 , 236u8 , 12u8 , 132u8 , 170u8 , 112u8 , 169u8 , 62u8 , 96u8 , 42u8 , 66u8 , 124u8 , 68u8 , 224u8 , 6u8 , 31u8 , 141u8 ,] { let entry = RewardPools (_0) ; self . client . storage () . fetch (& entry , block_hash) . await } else { Err (:: subxt :: MetadataError :: IncompatibleMetadata . into ()) } } # [doc = " Reward pools. This is where there rewards for each pool accumulate. When a members payout"] # [doc = " is claimed, the balance comes out fo the reward pool. Keyed by the bonded pools account."] pub async fn reward_pools_iter (& self , block_hash : :: core :: option :: Option < T :: Hash > ,) -> :: core :: result :: Result < :: subxt :: KeyIter < 'a , T , RewardPools < 'a > > , :: subxt :: BasicError > { if self . client . metadata () . storage_hash :: < RewardPools > () ? == [175u8 , 64u8 , 211u8 , 116u8 , 169u8 , 15u8 , 197u8 , 146u8 , 200u8 , 148u8 , 55u8 , 127u8 , 95u8 , 120u8 , 204u8 , 85u8 , 236u8 , 12u8 , 132u8 , 170u8 , 112u8 , 169u8 , 62u8 , 96u8 , 42u8 , 66u8 , 124u8 , 68u8 , 224u8 , 6u8 , 31u8 , 141u8 ,] { self . client . storage () . iter (block_hash) . await } else { Err (:: subxt :: MetadataError :: IncompatibleMetadata . into ()) } } # [doc = "Counter for the related counted storage map"] pub async fn counter_for_reward_pools (& self , block_hash : :: core :: option :: Option < T :: Hash > ,) -> :: core :: result :: Result < :: core :: primitive :: u32 , :: subxt :: BasicError > { if self . client . metadata () . storage_hash :: < CounterForRewardPools > () ? == [209u8 , 139u8 , 212u8 , 116u8 , 210u8 , 178u8 , 213u8 , 38u8 , 75u8 , 23u8 , 188u8 , 57u8 , 253u8 , 213u8 , 95u8 , 118u8 , 182u8 , 250u8 , 45u8 , 205u8 , 17u8 , 175u8 , 17u8 , 201u8 , 234u8 , 14u8 , 98u8 , 49u8 , 143u8 , 135u8 , 201u8 , 81u8 ,] { let entry = CounterForRewardPools ; self . client . storage () . fetch_or_default (& entry , block_hash) . await } else { Err (:: subxt :: MetadataError :: IncompatibleMetadata . into ()) } } # [doc = " Groups of unbonding pools. Each group of unbonding pools belongs to a bonded pool,"] # [doc = " hence the name sub-pools. Keyed by the bonded pools account."] pub async fn sub_pools_storage (& self , _0 : & :: core :: primitive :: u32 , block_hash : :: core :: option :: Option < T :: Hash > ,) -> :: core :: result :: Result < :: core :: option :: Option < runtime_types :: pallet_nomination_pools :: SubPools > , :: subxt :: BasicError > { if self . client . metadata () . storage_hash :: < SubPoolsStorage > () ? == [122u8 , 11u8 , 112u8 , 124u8 , 196u8 , 211u8 , 68u8 , 40u8 , 75u8 , 161u8 , 60u8 , 147u8 , 76u8 , 112u8 , 23u8 , 62u8 , 119u8 , 158u8 , 195u8 , 148u8 , 57u8 , 153u8 , 214u8 , 3u8 , 95u8 , 137u8 , 96u8 , 6u8 , 180u8 , 71u8 , 175u8 , 165u8 ,] { let entry = SubPoolsStorage (_0) ; self . client . storage () . fetch (& entry , block_hash) . await } else { Err (:: subxt :: MetadataError :: IncompatibleMetadata . into ()) } } # [doc = " Groups of unbonding pools. Each group of unbonding pools belongs to a bonded pool,"] # [doc = " hence the name sub-pools. Keyed by the bonded pools account."] pub async fn sub_pools_storage_iter (& self , block_hash : :: core :: option :: Option < T :: Hash > ,) -> :: core :: result :: Result < :: subxt :: KeyIter < 'a , T , SubPoolsStorage < 'a > > , :: subxt :: BasicError > { if self . client . metadata () . storage_hash :: < SubPoolsStorage > () ? == [122u8 , 11u8 , 112u8 , 124u8 , 196u8 , 211u8 , 68u8 , 40u8 , 75u8 , 161u8 , 60u8 , 147u8 , 76u8 , 112u8 , 23u8 , 62u8 , 119u8 , 158u8 , 195u8 , 148u8 , 57u8 , 153u8 , 214u8 , 3u8 , 95u8 , 137u8 , 96u8 , 6u8 , 180u8 , 71u8 , 175u8 , 165u8 ,] { self . client . storage () . iter (block_hash) . await } else { Err (:: subxt :: MetadataError :: IncompatibleMetadata . into ()) } } # [doc = "Counter for the related counted storage map"] pub async fn counter_for_sub_pools_storage (& self , block_hash : :: core :: option :: Option < T :: Hash > ,) -> :: core :: result :: Result < :: core :: primitive :: u32 , :: subxt :: BasicError > { if self . client . metadata () . storage_hash :: < CounterForSubPoolsStorage > () ? == [212u8 , 145u8 , 212u8 , 226u8 , 234u8 , 31u8 , 26u8 , 240u8 , 107u8 , 91u8 , 171u8 , 120u8 , 41u8 , 195u8 , 16u8 , 86u8 , 55u8 , 127u8 , 103u8 , 93u8 , 128u8 , 48u8 , 69u8 , 104u8 , 168u8 , 236u8 , 81u8 , 54u8 , 2u8 , 184u8 , 215u8 , 51u8 ,] { let entry = CounterForSubPoolsStorage ; self . client . storage () . fetch_or_default (& entry , block_hash) . await } else { Err (:: subxt :: MetadataError :: IncompatibleMetadata . into ()) } } # [doc = " Metadata for the pool."] pub async fn metadata (& self , _0 : & :: core :: primitive :: u32 , block_hash : :: core :: option :: Option < T :: Hash > ,) -> :: core :: result :: Result < runtime_types :: sp_runtime :: bounded :: bounded_vec :: BoundedVec < :: core :: primitive :: u8 > , :: subxt :: BasicError > { if self . client . metadata () . storage_hash :: < Metadata > () ? == [185u8 , 180u8 , 185u8 , 231u8 , 60u8 , 87u8 , 71u8 , 2u8 , 23u8 , 14u8 , 129u8 , 190u8 , 78u8 , 216u8 , 109u8 , 13u8 , 187u8 , 66u8 , 212u8 , 75u8 , 249u8 , 58u8 , 224u8 , 238u8 , 151u8 , 123u8 , 124u8 , 196u8 , 108u8 , 175u8 , 109u8 , 141u8 ,] { let entry = Metadata (_0) ; self . client . storage () . fetch_or_default (& entry , block_hash) . await } else { Err (:: subxt :: MetadataError :: IncompatibleMetadata . into ()) } } # [doc = " Metadata for the pool."] pub async fn metadata_iter (& self , block_hash : :: core :: option :: Option < T :: Hash > ,) -> :: core :: result :: Result < :: subxt :: KeyIter < 'a , T , Metadata < 'a > > , :: subxt :: BasicError > { if self . client . metadata () . storage_hash :: < Metadata > () ? == [185u8 , 180u8 , 185u8 , 231u8 , 60u8 , 87u8 , 71u8 , 2u8 , 23u8 , 14u8 , 129u8 , 190u8 , 78u8 , 216u8 , 109u8 , 13u8 , 187u8 , 66u8 , 212u8 , 75u8 , 249u8 , 58u8 , 224u8 , 238u8 , 151u8 , 123u8 , 124u8 , 196u8 , 108u8 , 175u8 , 109u8 , 141u8 ,] { self . client . storage () . iter (block_hash) . await } else { Err (:: subxt :: MetadataError :: IncompatibleMetadata . into ()) } } # [doc = "Counter for the related counted storage map"] pub async fn counter_for_metadata (& self , block_hash : :: core :: option :: Option < T :: Hash > ,) -> :: core :: result :: Result < :: core :: primitive :: u32 , :: subxt :: BasicError > { if self . client . metadata () . storage_hash :: < CounterForMetadata > () ? == [190u8 , 232u8 , 77u8 , 134u8 , 245u8 , 89u8 , 160u8 , 187u8 , 163u8 , 68u8 , 188u8 , 204u8 , 31u8 , 145u8 , 219u8 , 165u8 , 213u8 , 1u8 , 167u8 , 90u8 , 175u8 , 218u8 , 147u8 , 144u8 , 158u8 , 226u8 , 23u8 , 233u8 , 55u8 , 168u8 , 161u8 , 237u8 ,] { let entry = CounterForMetadata ; self . client . storage () . fetch_or_default (& entry , block_hash) . await } else { Err (:: subxt :: MetadataError :: IncompatibleMetadata . into ()) } } # [doc = " Ever increasing number of all pools created so far."] pub async fn last_pool_id (& self , block_hash : :: core :: option :: Option < T :: Hash > ,) -> :: core :: result :: Result < :: core :: primitive :: u32 , :: subxt :: BasicError > { if self . client . metadata () . storage_hash :: < LastPoolId > () ? == [50u8 , 254u8 , 218u8 , 41u8 , 213u8 , 184u8 , 170u8 , 166u8 , 31u8 , 29u8 , 196u8 , 57u8 , 215u8 , 20u8 , 40u8 , 40u8 , 19u8 , 22u8 , 9u8 , 184u8 , 11u8 , 21u8 , 21u8 , 125u8 , 97u8 , 38u8 , 219u8 , 209u8 , 2u8 , 238u8 , 247u8 , 51u8 ,] { let entry = LastPoolId ; self . client . storage () . fetch_or_default (& entry , block_hash) . await } else { Err (:: subxt :: MetadataError :: IncompatibleMetadata . into ()) } } # [doc = " A reverse lookup from the pool's account id to its id."] # [doc = ""] # [doc = " This is only used for slashing. In all other instances, the pool id is used, and the"] # [doc = " accounts are deterministically derived from it."] pub async fn reverse_pool_id_lookup (& self , _0 : & :: subxt :: sp_core :: crypto :: AccountId32 , block_hash : :: core :: option :: Option < T :: Hash > ,) -> :: core :: result :: Result < :: core :: option :: Option < :: core :: primitive :: u32 > , :: subxt :: BasicError > { if self . client . metadata () . storage_hash :: < ReversePoolIdLookup > () ? == [152u8 , 178u8 , 17u8 , 189u8 , 226u8 , 181u8 , 78u8 , 103u8 , 199u8 , 137u8 , 41u8 , 229u8 , 239u8 , 205u8 , 95u8 , 106u8 , 20u8 , 62u8 , 157u8 , 95u8 , 105u8 , 54u8 , 180u8 , 206u8 , 13u8 , 43u8 , 253u8 , 179u8 , 89u8 , 155u8 , 58u8 , 194u8 ,] { let entry = ReversePoolIdLookup (_0) ; self . client . storage () . fetch (& entry , block_hash) . await } else { Err (:: subxt :: MetadataError :: IncompatibleMetadata . into ()) } } # [doc = " A reverse lookup from the pool's account id to its id."] # [doc = ""] # [doc = " This is only used for slashing. In all other instances, the pool id is used, and the"] # [doc = " accounts are deterministically derived from it."] pub async fn reverse_pool_id_lookup_iter (& self , block_hash : :: core :: option :: Option < T :: Hash > ,) -> :: core :: result :: Result < :: subxt :: KeyIter < 'a , T , ReversePoolIdLookup < 'a > > , :: subxt :: BasicError > { if self . client . metadata () . storage_hash :: < ReversePoolIdLookup > () ? == [152u8 , 178u8 , 17u8 , 189u8 , 226u8 , 181u8 , 78u8 , 103u8 , 199u8 , 137u8 , 41u8 , 229u8 , 239u8 , 205u8 , 95u8 , 106u8 , 20u8 , 62u8 , 157u8 , 95u8 , 105u8 , 54u8 , 180u8 , 206u8 , 13u8 , 43u8 , 253u8 , 179u8 , 89u8 , 155u8 , 58u8 , 194u8 ,] { self . client . storage () . iter (block_hash) . await } else { Err (:: subxt :: MetadataError :: IncompatibleMetadata . into ()) } } # [doc = "Counter for the related counted storage map"] pub async fn counter_for_reverse_pool_id_lookup (& self , block_hash : :: core :: option :: Option < T :: Hash > ,) -> :: core :: result :: Result < :: core :: primitive :: u32 , :: subxt :: BasicError > { if self . client . metadata () . storage_hash :: < CounterForReversePoolIdLookup > () ? == [148u8 , 83u8 , 81u8 , 33u8 , 188u8 , 72u8 , 148u8 , 208u8 , 245u8 , 178u8 , 52u8 , 245u8 , 229u8 , 140u8 , 100u8 , 152u8 , 8u8 , 217u8 , 161u8 , 80u8 , 226u8 , 42u8 , 15u8 , 252u8 , 90u8 , 197u8 , 120u8 , 114u8 , 144u8 , 90u8 , 199u8 , 123u8 ,] { let entry = CounterForReversePoolIdLookup ; self . client . storage () . fetch_or_default (& entry , block_hash) . await } else { Err (:: subxt :: MetadataError :: IncompatibleMetadata . into ()) } } } } pub mod constants { use super :: runtime_types ; pub struct ConstantsApi < 'a , T : :: subxt :: Config > { client : & 'a :: subxt :: Client < T > , } impl < 'a , T : :: subxt :: Config > ConstantsApi < 'a , T > { pub fn new (client : & 'a :: subxt :: Client < T >) -> Self { Self { client } } # [doc = " The nomination pool's pallet id."] pub fn pallet_id (& self) -> :: core :: result :: Result < runtime_types :: frame_support :: PalletId , :: subxt :: BasicError > { if self . client . metadata () . constant_hash ("NominationPools" , "PalletId") ? == [219u8 , 176u8 , 157u8 , 8u8 , 208u8 , 62u8 , 56u8 , 46u8 , 71u8 , 155u8 , 111u8 , 85u8 , 190u8 , 22u8 , 96u8 , 55u8 , 94u8 , 254u8 , 120u8 , 223u8 , 77u8 , 199u8 , 109u8 , 152u8 , 249u8 , 144u8 , 47u8 , 91u8 , 59u8 , 92u8 , 0u8 , 65u8 ,] { let pallet = self . client . metadata () . pallet ("NominationPools") ? ; let constant = pallet . constant ("PalletId") ? ; let value = :: subxt :: codec :: Decode :: decode (& mut & constant . value [..]) ? ; Ok (value) } else { Err (:: subxt :: MetadataError :: IncompatibleMetadata . into ()) } } # [doc = " The minimum pool points-to-balance ratio that must be maintained for it to be `open`."] # [doc = " This is important in the event slashing takes place and the pool's points-to-balance"] # [doc = " ratio becomes disproportional."] # [doc = " For a value of 10, the threshold would be a pool points-to-balance ratio of 10:1."] # [doc = " Such a scenario would also be the equivalent of the pool being 90% slashed."] pub fn min_points_to_balance (& self) -> :: core :: result :: Result < :: core :: primitive :: u32 , :: subxt :: BasicError > { if self . client . metadata () . constant_hash ("NominationPools" , "MinPointsToBalance") ? == [137u8 , 170u8 , 155u8 , 98u8 , 250u8 , 181u8 , 167u8 , 57u8 , 199u8 , 204u8 , 60u8 , 159u8 , 39u8 , 207u8 , 21u8 , 173u8 , 138u8 , 109u8 , 104u8 , 115u8 , 237u8 , 191u8 , 111u8 , 108u8 , 152u8 , 192u8 , 30u8 , 202u8 , 183u8 , 233u8 , 161u8 , 40u8 ,] { let pallet = self . client . metadata () . pallet ("NominationPools") ? ; let constant = pallet . constant ("MinPointsToBalance") ? ; let value = :: subxt :: codec :: Decode :: decode (& mut & constant . value [..]) ? ; Ok (value) } else { Err (:: subxt :: MetadataError :: IncompatibleMetadata . into ()) } } } } } pub mod scheduler { use super :: root_mod ; use super :: runtime_types ; pub mod calls { use super :: root_mod ; use super :: runtime_types ; type DispatchError = runtime_types :: sp_runtime :: DispatchError ; # [derive (:: subxt :: codec :: Decode , :: subxt :: codec :: Encode , Clone , Debug , Eq , PartialEq)] pub struct Schedule { pub when : :: core :: primitive :: u32 , pub maybe_periodic : :: core :: option :: Option < (:: core :: primitive :: u32 , :: core :: primitive :: u32 ,) > , pub priority : :: core :: primitive :: u8 , pub call : :: std :: boxed :: Box < runtime_types :: frame_support :: traits :: schedule :: MaybeHashed < runtime_types :: egg_standalone_runtime :: Call , :: subxt :: sp_core :: H256 > > , } impl :: subxt :: Call for Schedule { const PALLET : & 'static str = "Scheduler" ; const FUNCTION : & 'static str = "schedule" ; } # [derive (:: subxt :: codec :: Decode , :: subxt :: codec :: Encode , Clone , Debug , Eq , PartialEq)] pub struct Cancel { pub when : :: core :: primitive :: u32 , pub index : :: core :: primitive :: u32 , } impl :: subxt :: Call for Cancel { const PALLET : & 'static str = "Scheduler" ; const FUNCTION : & 'static str = "cancel" ; } # [derive (:: subxt :: codec :: Decode , :: subxt :: codec :: Encode , Clone , Debug , Eq , PartialEq)] pub struct ScheduleNamed { pub id : :: std :: vec :: Vec < :: core :: primitive :: u8 > , pub when : :: core :: primitive :: u32 , pub maybe_periodic : :: core :: option :: Option < (:: core :: primitive :: u32 , :: core :: primitive :: u32 ,) > , pub priority : :: core :: primitive :: u8 , pub call : :: std :: boxed :: Box < runtime_types :: frame_support :: traits :: schedule :: MaybeHashed < runtime_types :: egg_standalone_runtime :: Call , :: subxt :: sp_core :: H256 > > , } impl :: subxt :: Call for ScheduleNamed { const PALLET : & 'static str = "Scheduler" ; const FUNCTION : & 'static str = "schedule_named" ; } # [derive (:: subxt :: codec :: Decode , :: subxt :: codec :: Encode , Clone , Debug , Eq , PartialEq)] pub struct CancelNamed { pub id : :: std :: vec :: Vec < :: core :: primitive :: u8 > , } impl :: subxt :: Call for CancelNamed { const PALLET : & 'static str = "Scheduler" ; const FUNCTION : & 'static str = "cancel_named" ; } # [derive (:: subxt :: codec :: Decode , :: subxt :: codec :: Encode , Clone , Debug , Eq , PartialEq)] pub struct ScheduleAfter { pub after : :: core :: primitive :: u32 , pub maybe_periodic : :: core :: option :: Option < (:: core :: primitive :: u32 , :: core :: primitive :: u32 ,) > , pub priority : :: core :: primitive :: u8 , pub call : :: std :: boxed :: Box < runtime_types :: frame_support :: traits :: schedule :: MaybeHashed < runtime_types :: egg_standalone_runtime :: Call , :: subxt :: sp_core :: H256 > > , } impl :: subxt :: Call for ScheduleAfter { const PALLET : & 'static str = "Scheduler" ; const FUNCTION : & 'static str = "schedule_after" ; } # [derive (:: subxt :: codec :: Decode , :: subxt :: codec :: Encode , Clone , Debug , Eq , PartialEq)] pub struct ScheduleNamedAfter { pub id : :: std :: vec :: Vec < :: core :: primitive :: u8 > , pub after : :: core :: primitive :: u32 , pub maybe_periodic : :: core :: option :: Option < (:: core :: primitive :: u32 , :: core :: primitive :: u32 ,) > , pub priority : :: core :: primitive :: u8 , pub call : :: std :: boxed :: Box < runtime_types :: frame_support :: traits :: schedule :: MaybeHashed < runtime_types :: egg_standalone_runtime :: Call , :: subxt :: sp_core :: H256 > > , } impl :: subxt :: Call for ScheduleNamedAfter { const PALLET : & 'static str = "Scheduler" ; const FUNCTION : & 'static str = "schedule_named_after" ; } pub struct TransactionApi < 'a , T : :: subxt :: Config , X > { client : & 'a :: subxt :: Client < T > , marker : :: core :: marker :: PhantomData < X > , } impl < 'a , T , X > TransactionApi < 'a , T , X > where T : :: subxt :: Config , X : :: subxt :: extrinsic :: ExtrinsicParams < T > , { pub fn new (client : & 'a :: subxt :: Client < T >) -> Self { Self { client , marker : :: core :: marker :: PhantomData } } # [doc = "Anonymously schedule a task."] pub fn schedule (& self , when : :: core :: primitive :: u32 , maybe_periodic : :: core :: option :: Option < (:: core :: primitive :: u32 , :: core :: primitive :: u32 ,) > , priority : :: core :: primitive :: u8 , call : runtime_types :: frame_support :: traits :: schedule :: MaybeHashed < runtime_types :: egg_standalone_runtime :: Call , :: subxt :: sp_core :: H256 > ,) -> Result < :: subxt :: SubmittableExtrinsic < 'a , T , X , Schedule , DispatchError , root_mod :: Event > , :: subxt :: BasicError > { if self . client . metadata () . call_hash :: < Schedule > () ? == [180u8 , 86u8 , 56u8 , 79u8 , 55u8 , 247u8 , 54u8 , 174u8 , 7u8 , 226u8 , 5u8 , 21u8 , 1u8 , 174u8 , 33u8 , 105u8 , 214u8 , 35u8 , 236u8 , 52u8 , 168u8 , 23u8 , 231u8 , 127u8 , 76u8 , 75u8 , 129u8 , 213u8 , 251u8 , 165u8 , 191u8 , 191u8 ,] { let call = Schedule { when , maybe_periodic , priority , call : :: std :: boxed :: Box :: new (call) , } ; Ok (:: subxt :: SubmittableExtrinsic :: new (self . client , call)) } else { Err (:: subxt :: MetadataError :: IncompatibleMetadata . into ()) } } # [doc = "Cancel an anonymously scheduled task."] pub fn cancel (& self , when : :: core :: primitive :: u32 , index : :: core :: primitive :: u32 ,) -> Result < :: subxt :: SubmittableExtrinsic < 'a , T , X , Cancel , DispatchError , root_mod :: Event > , :: subxt :: BasicError > { if self . client . metadata () . call_hash :: < Cancel > () ? == [118u8 , 0u8 , 188u8 , 218u8 , 148u8 , 86u8 , 139u8 , 15u8 , 3u8 , 161u8 , 6u8 , 150u8 , 46u8 , 32u8 , 85u8 , 179u8 , 106u8 , 113u8 , 240u8 , 115u8 , 167u8 , 114u8 , 243u8 , 69u8 , 103u8 , 60u8 , 99u8 , 135u8 , 21u8 , 8u8 , 19u8 , 225u8 ,] { let call = Cancel { when , index , } ; Ok (:: subxt :: SubmittableExtrinsic :: new (self . client , call)) } else { Err (:: subxt :: MetadataError :: IncompatibleMetadata . into ()) } } # [doc = "Schedule a named task."] pub fn schedule_named (& self , id : :: std :: vec :: Vec < :: core :: primitive :: u8 > , when : :: core :: primitive :: u32 , maybe_periodic : :: core :: option :: Option < (:: core :: primitive :: u32 , :: core :: primitive :: u32 ,) > , priority : :: core :: primitive :: u8 , call : runtime_types :: frame_support :: traits :: schedule :: MaybeHashed < runtime_types :: egg_standalone_runtime :: Call , :: subxt :: sp_core :: H256 > ,) -> Result < :: subxt :: SubmittableExtrinsic < 'a , T , X , ScheduleNamed , DispatchError , root_mod :: Event > , :: subxt :: BasicError > { if self . client . metadata () . call_hash :: < ScheduleNamed > () ? == [136u8 , 107u8 , 131u8 , 94u8 , 29u8 , 142u8 , 96u8 , 183u8 , 194u8 , 48u8 , 147u8 , 233u8 , 35u8 , 207u8 , 15u8 , 5u8 , 133u8 , 95u8 , 184u8 , 187u8 , 46u8 , 42u8 , 29u8 , 115u8 , 126u8 , 230u8 , 196u8 , 214u8 , 74u8 , 195u8 , 240u8 , 5u8 ,] { let call = ScheduleNamed { id , when , maybe_periodic , priority , call : :: std :: boxed :: Box :: new (call) , } ; Ok (:: subxt :: SubmittableExtrinsic :: new (self . client , call)) } else { Err (:: subxt :: MetadataError :: IncompatibleMetadata . into ()) } } # [doc = "Cancel a named scheduled task."] pub fn cancel_named (& self , id : :: std :: vec :: Vec < :: core :: primitive :: u8 > ,) -> Result < :: subxt :: SubmittableExtrinsic < 'a , T , X , CancelNamed , DispatchError , root_mod :: Event > , :: subxt :: BasicError > { if self . client . metadata () . call_hash :: < CancelNamed > () ? == [118u8 , 221u8 , 232u8 , 126u8 , 67u8 , 134u8 , 33u8 , 7u8 , 224u8 , 110u8 , 181u8 , 18u8 , 57u8 , 39u8 , 15u8 , 64u8 , 90u8 , 132u8 , 2u8 , 238u8 , 19u8 , 241u8 , 194u8 , 120u8 , 5u8 , 109u8 , 74u8 , 205u8 , 42u8 , 244u8 , 99u8 , 54u8 ,] { let call = CancelNamed { id , } ; Ok (:: subxt :: SubmittableExtrinsic :: new (self . client , call)) } else { Err (:: subxt :: MetadataError :: IncompatibleMetadata . into ()) } } # [doc = "Anonymously schedule a task after a delay."] # [doc = ""] # [doc = "# <weight>"] # [doc = "Same as [`schedule`]."] # [doc = "# </weight>"] pub fn schedule_after (& self , after : :: core :: primitive :: u32 , maybe_periodic : :: core :: option :: Option < (:: core :: primitive :: u32 , :: core :: primitive :: u32 ,) > , priority : :: core :: primitive :: u8 , call : runtime_types :: frame_support :: traits :: schedule :: MaybeHashed < runtime_types :: egg_standalone_runtime :: Call , :: subxt :: sp_core :: H256 > ,) -> Result < :: subxt :: SubmittableExtrinsic < 'a , T , X , ScheduleAfter , DispatchError , root_mod :: Event > , :: subxt :: BasicError > { if self . client . metadata () . call_hash :: < ScheduleAfter > () ? == [248u8 , 74u8 , 82u8 , 148u8 , 144u8 , 108u8 , 128u8 , 153u8 , 245u8 , 186u8 , 46u8 , 117u8 , 69u8 , 36u8 , 84u8 , 126u8 , 213u8 , 234u8 , 169u8 , 20u8 , 106u8 , 208u8 , 180u8 , 14u8 , 192u8 , 224u8 , 161u8 , 156u8 , 113u8 , 211u8 , 195u8 , 115u8 ,] { let call = ScheduleAfter { after , maybe_periodic , priority , call : :: std :: boxed :: Box :: new (call) , } ; Ok (:: subxt :: SubmittableExtrinsic :: new (self . client , call)) } else { Err (:: subxt :: MetadataError :: IncompatibleMetadata . into ()) } } # [doc = "Schedule a named task after a delay."] # [doc = ""] # [doc = "# <weight>"] # [doc = "Same as [`schedule_named`](Self::schedule_named)."] # [doc = "# </weight>"] pub fn schedule_named_after (& self , id : :: std :: vec :: Vec < :: core :: primitive :: u8 > , after : :: core :: primitive :: u32 , maybe_periodic : :: core :: option :: Option < (:: core :: primitive :: u32 , :: core :: primitive :: u32 ,) > , priority : :: core :: primitive :: u8 , call : runtime_types :: frame_support :: traits :: schedule :: MaybeHashed < runtime_types :: egg_standalone_runtime :: Call , :: subxt :: sp_core :: H256 > ,) -> Result < :: subxt :: SubmittableExtrinsic < 'a , T , X , ScheduleNamedAfter , DispatchError , root_mod :: Event > , :: subxt :: BasicError > { if self . client . metadata () . call_hash :: < ScheduleNamedAfter > () ? == [150u8 , 213u8 , 225u8 , 128u8 , 64u8 , 218u8 , 109u8 , 15u8 , 88u8 , 9u8 , 58u8 , 72u8 , 205u8 , 227u8 , 114u8 , 32u8 , 213u8 , 145u8 , 16u8 , 158u8 , 187u8 , 254u8 , 181u8 , 194u8 , 63u8 , 16u8 , 199u8 , 216u8 , 108u8 , 250u8 , 200u8 , 63u8 ,] { let call = ScheduleNamedAfter { id , after , maybe_periodic , priority , call : :: std :: boxed :: Box :: new (call) , } ; Ok (:: subxt :: SubmittableExtrinsic :: new (self . client , call)) } else { Err (:: subxt :: MetadataError :: IncompatibleMetadata . into ()) } } } } pub type Event = runtime_types :: pallet_scheduler :: pallet :: Event ; pub mod events { use super :: runtime_types ; # [derive (:: subxt :: codec :: Decode , :: subxt :: codec :: Encode , Clone , Debug , Eq , PartialEq)] # [doc = "Scheduled some task."] pub struct Scheduled { pub when : :: core :: primitive :: u32 , pub index : :: core :: primitive :: u32 , } impl :: subxt :: Event for Scheduled { const PALLET : & 'static str = "Scheduler" ; const EVENT : & 'static str = "Scheduled" ; } # [derive (:: subxt :: codec :: Decode , :: subxt :: codec :: Encode , Clone , Debug , Eq , PartialEq)] # [doc = "Canceled some task."] pub struct Canceled { pub when : :: core :: primitive :: u32 , pub index : :: core :: primitive :: u32 , } impl :: subxt :: Event for Canceled { const PALLET : & 'static str = "Scheduler" ; const EVENT : & 'static str = "Canceled" ; } # [derive (:: subxt :: codec :: Decode , :: subxt :: codec :: Encode , Clone , Debug , Eq , PartialEq)] # [doc = "Dispatched some task."] pub struct Dispatched { pub task : (:: core :: primitive :: u32 , :: core :: primitive :: u32 ,) , pub id : :: core :: option :: Option < :: std :: vec :: Vec < :: core :: primitive :: u8 > > , pub result : :: core :: result :: Result < () , runtime_types :: sp_runtime :: DispatchError > , } impl :: subxt :: Event for Dispatched { const PALLET : & 'static str = "Scheduler" ; const EVENT : & 'static str = "Dispatched" ; } # [derive (:: subxt :: codec :: Decode , :: subxt :: codec :: Encode , Clone , Debug , Eq , PartialEq)] # [doc = "The call for the provided hash was not found so the task has been aborted."] pub struct CallLookupFailed { pub task : (:: core :: primitive :: u32 , :: core :: primitive :: u32 ,) , pub id : :: core :: option :: Option < :: std :: vec :: Vec < :: core :: primitive :: u8 > > , pub error : runtime_types :: frame_support :: traits :: schedule :: LookupError , } impl :: subxt :: Event for CallLookupFailed { const PALLET : & 'static str = "Scheduler" ; const EVENT : & 'static str = "CallLookupFailed" ; } } pub mod storage { use super :: runtime_types ; pub struct Agenda < 'a > (pub & 'a :: core :: primitive :: u32) ; impl :: subxt :: StorageEntry for Agenda < '_ > { const PALLET : & 'static str = "Scheduler" ; const STORAGE : & 'static str = "Agenda" ; type Value = :: std :: vec :: Vec < :: core :: option :: Option < runtime_types :: pallet_scheduler :: ScheduledV3 < runtime_types :: frame_support :: traits :: schedule :: MaybeHashed < runtime_types :: egg_standalone_runtime :: Call , :: subxt :: sp_core :: H256 > , :: core :: primitive :: u32 , runtime_types :: egg_standalone_runtime :: OriginCaller , :: subxt :: sp_core :: crypto :: AccountId32 > > > ; fn key (& self) -> :: subxt :: StorageEntryKey { :: subxt :: StorageEntryKey :: Map (vec ! [:: subxt :: StorageMapKey :: new (& self . 0 , :: subxt :: StorageHasher :: Twox64Concat)]) } } pub struct Lookup < 'a > (pub & 'a [:: core :: primitive :: u8]) ; impl :: subxt :: StorageEntry for Lookup < '_ > { const PALLET : & 'static str = "Scheduler" ; const STORAGE : & 'static str = "Lookup" ; type Value = (:: core :: primitive :: u32 , :: core :: primitive :: u32 ,) ; fn key (& self) -> :: subxt :: StorageEntryKey { :: subxt :: StorageEntryKey :: Map (vec ! [:: subxt :: StorageMapKey :: new (& self . 0 , :: subxt :: StorageHasher :: Twox64Concat)]) } } pub struct StorageApi < 'a , T : :: subxt :: Config > { client : & 'a :: subxt :: Client < T > , } impl < 'a , T : :: subxt :: Config > StorageApi < 'a , T > { pub fn new (client : & 'a :: subxt :: Client < T >) -> Self { Self { client } } # [doc = " Items to be executed, indexed by the block number that they should be executed on."] pub async fn agenda (& self , _0 : & :: core :: primitive :: u32 , block_hash : :: core :: option :: Option < T :: Hash > ,) -> :: core :: result :: Result < :: std :: vec :: Vec < :: core :: option :: Option < runtime_types :: pallet_scheduler :: ScheduledV3 < runtime_types :: frame_support :: traits :: schedule :: MaybeHashed < runtime_types :: egg_standalone_runtime :: Call , :: subxt :: sp_core :: H256 > , :: core :: primitive :: u32 , runtime_types :: egg_standalone_runtime :: OriginCaller , :: subxt :: sp_core :: crypto :: AccountId32 > > > , :: subxt :: BasicError > { if self . client . metadata () . storage_hash :: < Agenda > () ? == [56u8 , 115u8 , 71u8 , 26u8 , 227u8 , 119u8 , 237u8 , 140u8 , 232u8 , 216u8 , 222u8 , 59u8 , 146u8 , 55u8 , 233u8 , 214u8 , 183u8 , 148u8 , 37u8 , 198u8 , 170u8 , 56u8 , 188u8 , 70u8 , 80u8 , 168u8 , 117u8 , 44u8 , 214u8 , 83u8 , 160u8 , 177u8 ,] { let entry = Agenda (_0) ; self . client . storage () . fetch_or_default (& entry , block_hash) . await } else { Err (:: subxt :: MetadataError :: IncompatibleMetadata . into ()) } } # [doc = " Items to be executed, indexed by the block number that they should be executed on."] pub async fn agenda_iter (& self , block_hash : :: core :: option :: Option < T :: Hash > ,) -> :: core :: result :: Result < :: subxt :: KeyIter < 'a , T , Agenda < 'a > > , :: subxt :: BasicError > { if self . client . metadata () . storage_hash :: < Agenda > () ? == [56u8 , 115u8 , 71u8 , 26u8 , 227u8 , 119u8 , 237u8 , 140u8 , 232u8 , 216u8 , 222u8 , 59u8 , 146u8 , 55u8 , 233u8 , 214u8 , 183u8 , 148u8 , 37u8 , 198u8 , 170u8 , 56u8 , 188u8 , 70u8 , 80u8 , 168u8 , 117u8 , 44u8 , 214u8 , 83u8 , 160u8 , 177u8 ,] { self . client . storage () . iter (block_hash) . await } else { Err (:: subxt :: MetadataError :: IncompatibleMetadata . into ()) } } # [doc = " Lookup from identity to the block number and index of the task."] pub async fn lookup (& self , _0 : & [:: core :: primitive :: u8] , block_hash : :: core :: option :: Option < T :: Hash > ,) -> :: core :: result :: Result < :: core :: option :: Option < (:: core :: primitive :: u32 , :: core :: primitive :: u32 ,) > , :: subxt :: BasicError > { if self . client . metadata () . storage_hash :: < Lookup > () ? == [56u8 , 105u8 , 156u8 , 110u8 , 251u8 , 141u8 , 219u8 , 56u8 , 131u8 , 57u8 , 180u8 , 33u8 , 48u8 , 30u8 , 193u8 , 194u8 , 169u8 , 182u8 , 168u8 , 43u8 , 36u8 , 202u8 , 222u8 , 182u8 , 41u8 , 216u8 , 222u8 , 1u8 , 72u8 , 165u8 , 62u8 , 166u8 ,] { let entry = Lookup (_0) ; self . client . storage () . fetch (& entry , block_hash) . await } else { Err (:: subxt :: MetadataError :: IncompatibleMetadata . into ()) } } # [doc = " Lookup from identity to the block number and index of the task."] pub async fn lookup_iter (& self , block_hash : :: core :: option :: Option < T :: Hash > ,) -> :: core :: result :: Result < :: subxt :: KeyIter < 'a , T , Lookup < 'a > > , :: subxt :: BasicError > { if self . client . metadata () . storage_hash :: < Lookup > () ? == [56u8 , 105u8 , 156u8 , 110u8 , 251u8 , 141u8 , 219u8 , 56u8 , 131u8 , 57u8 , 180u8 , 33u8 , 48u8 , 30u8 , 193u8 , 194u8 , 169u8 , 182u8 , 168u8 , 43u8 , 36u8 , 202u8 , 222u8 , 182u8 , 41u8 , 216u8 , 222u8 , 1u8 , 72u8 , 165u8 , 62u8 , 166u8 ,] { self . client . storage () . iter (block_hash) . await } else { Err (:: subxt :: MetadataError :: IncompatibleMetadata . into ()) } } } } pub mod constants { use super :: runtime_types ; pub struct ConstantsApi < 'a , T : :: subxt :: Config > { client : & 'a :: subxt :: Client < T > , } impl < 'a , T : :: subxt :: Config > ConstantsApi < 'a , T > { pub fn new (client : & 'a :: subxt :: Client < T >) -> Self { Self { client } } # [doc = " The maximum weight that may be scheduled per block for any dispatchables of less"] # [doc = " priority than `schedule::HARD_DEADLINE`."] pub fn maximum_weight (& self) -> :: core :: result :: Result < :: core :: primitive :: u64 , :: subxt :: BasicError > { if self . client . metadata () . constant_hash ("Scheduler" , "MaximumWeight") ? == [230u8 , 169u8 , 152u8 , 214u8 , 255u8 , 61u8 , 176u8 , 69u8 , 211u8 , 100u8 , 217u8 , 192u8 , 188u8 , 247u8 , 181u8 , 157u8 , 38u8 , 122u8 , 75u8 , 206u8 , 246u8 , 8u8 , 161u8 , 175u8 , 73u8 , 182u8 , 204u8 , 242u8 , 227u8 , 3u8 , 231u8 , 254u8 ,] { let pallet = self . client . metadata () . pallet ("Scheduler") ? ; let constant = pallet . constant ("MaximumWeight") ? ; let value = :: subxt :: codec :: Decode :: decode (& mut & constant . value [..]) ? ; Ok (value) } else { Err (:: subxt :: MetadataError :: IncompatibleMetadata . into ()) } } # [doc = " The maximum number of scheduled calls in the queue for a single block."] # [doc = " Not strictly enforced, but used for weight estimation."] pub fn max_scheduled_per_block (& self) -> :: core :: result :: Result < :: core :: primitive :: u32 , :: subxt :: BasicError > { if self . client . metadata () . constant_hash ("Scheduler" , "MaxScheduledPerBlock") ? == [64u8 , 25u8 , 128u8 , 202u8 , 165u8 , 97u8 , 30u8 , 196u8 , 174u8 , 132u8 , 139u8 , 223u8 , 88u8 , 20u8 , 228u8 , 203u8 , 253u8 , 201u8 , 83u8 , 157u8 , 161u8 , 120u8 , 187u8 , 165u8 , 4u8 , 64u8 , 184u8 , 34u8 , 28u8 , 129u8 , 136u8 , 13u8 ,] { let pallet = self . client . metadata () . pallet ("Scheduler") ? ; let constant = pallet . constant ("MaxScheduledPerBlock") ? ; let value = :: subxt :: codec :: Decode :: decode (& mut & constant . value [..]) ? ; Ok (value) } else { Err (:: subxt :: MetadataError :: IncompatibleMetadata . into ()) } } } } } pub mod preimage { use super :: root_mod ; use super :: runtime_types ; pub mod calls { use super :: root_mod ; use super :: runtime_types ; type DispatchError = runtime_types :: sp_runtime :: DispatchError ; # [derive (:: subxt :: codec :: Decode , :: subxt :: codec :: Encode , Clone , Debug , Eq , PartialEq)] pub struct NotePreimage { pub bytes : :: std :: vec :: Vec < :: core :: primitive :: u8 > , } impl :: subxt :: Call for NotePreimage { const PALLET : & 'static str = "Preimage" ; const FUNCTION : & 'static str = "note_preimage" ; } # [derive (:: subxt :: codec :: Decode , :: subxt :: codec :: Encode , Clone , Debug , Eq , PartialEq)] pub struct UnnotePreimage { pub hash : :: subxt :: sp_core :: H256 , } impl :: subxt :: Call for UnnotePreimage { const PALLET : & 'static str = "Preimage" ; const FUNCTION : & 'static str = "unnote_preimage" ; } # [derive (:: subxt :: codec :: Decode , :: subxt :: codec :: Encode , Clone , Debug , Eq , PartialEq)] pub struct RequestPreimage { pub hash : :: subxt :: sp_core :: H256 , } impl :: subxt :: Call for RequestPreimage { const PALLET : & 'static str = "Preimage" ; const FUNCTION : & 'static str = "request_preimage" ; } # [derive (:: subxt :: codec :: Decode , :: subxt :: codec :: Encode , Clone , Debug , Eq , PartialEq)] pub struct UnrequestPreimage { pub hash : :: subxt :: sp_core :: H256 , } impl :: subxt :: Call for UnrequestPreimage { const PALLET : & 'static str = "Preimage" ; const FUNCTION : & 'static str = "unrequest_preimage" ; } pub struct TransactionApi < 'a , T : :: subxt :: Config , X > { client : & 'a :: subxt :: Client < T > , marker : :: core :: marker :: PhantomData < X > , } impl < 'a , T , X > TransactionApi < 'a , T , X > where T : :: subxt :: Config , X : :: subxt :: extrinsic :: ExtrinsicParams < T > , { pub fn new (client : & 'a :: subxt :: Client < T >) -> Self { Self { client , marker : :: core :: marker :: PhantomData } } # [doc = "Register a preimage on-chain."] # [doc = ""] # [doc = "If the preimage was previously requested, no fees or deposits are taken for providing"] # [doc = "the preimage. Otherwise, a deposit is taken proportional to the size of the preimage."] pub fn note_preimage (& self , bytes : :: std :: vec :: Vec < :: core :: primitive :: u8 > ,) -> Result < :: subxt :: SubmittableExtrinsic < 'a , T , X , NotePreimage , DispatchError , root_mod :: Event > , :: subxt :: BasicError > { if self . client . metadata () . call_hash :: < NotePreimage > () ? == [116u8 , 66u8 , 88u8 , 251u8 , 187u8 , 86u8 , 82u8 , 136u8 , 215u8 , 82u8 , 240u8 , 255u8 , 70u8 , 190u8 , 116u8 , 187u8 , 232u8 , 168u8 , 125u8 , 234u8 , 8u8 , 21u8 , 247u8 , 195u8 , 167u8 , 237u8 , 27u8 , 202u8 , 123u8 , 25u8 , 225u8 , 131u8 ,] { let call = NotePreimage { bytes , } ; Ok (:: subxt :: SubmittableExtrinsic :: new (self . client , call)) } else { Err (:: subxt :: MetadataError :: IncompatibleMetadata . into ()) } } # [doc = "Clear an unrequested preimage from the runtime storage."] pub fn unnote_preimage (& self , hash : :: subxt :: sp_core :: H256 ,) -> Result < :: subxt :: SubmittableExtrinsic < 'a , T , X , UnnotePreimage , DispatchError , root_mod :: Event > , :: subxt :: BasicError > { if self . client . metadata () . call_hash :: < UnnotePreimage > () ? == [162u8 , 195u8 , 220u8 , 134u8 , 147u8 , 150u8 , 145u8 , 130u8 , 231u8 , 104u8 , 83u8 , 70u8 , 42u8 , 90u8 , 248u8 , 61u8 , 223u8 , 63u8 , 162u8 , 219u8 , 92u8 , 248u8 , 179u8 , 99u8 , 158u8 , 252u8 , 89u8 , 59u8 , 115u8 , 130u8 , 73u8 , 21u8 ,] { let call = UnnotePreimage { hash , } ; Ok (:: subxt :: SubmittableExtrinsic :: new (self . client , call)) } else { Err (:: subxt :: MetadataError :: IncompatibleMetadata . into ()) } } # [doc = "Request a preimage be uploaded to the chain without paying any fees or deposits."] # [doc = ""] # [doc = "If the preimage requests has already been provided on-chain, we unreserve any deposit"] # [doc = "a user may have paid, and take the control of the preimage out of their hands."] pub fn request_preimage (& self , hash : :: subxt :: sp_core :: H256 ,) -> Result < :: subxt :: SubmittableExtrinsic < 'a , T , X , RequestPreimage , DispatchError , root_mod :: Event > , :: subxt :: BasicError > { if self . client . metadata () . call_hash :: < RequestPreimage > () ? == [186u8 , 108u8 , 235u8 , 145u8 , 104u8 , 29u8 , 22u8 , 33u8 , 21u8 , 121u8 , 32u8 , 75u8 , 141u8 , 125u8 , 205u8 , 186u8 , 210u8 , 184u8 , 134u8 , 248u8 , 74u8 , 175u8 , 104u8 , 91u8 , 247u8 , 151u8 , 70u8 , 192u8 , 183u8 , 163u8 , 245u8 , 180u8 ,] { let call = RequestPreimage { hash , } ; Ok (:: subxt :: SubmittableExtrinsic :: new (self . client , call)) } else { Err (:: subxt :: MetadataError :: IncompatibleMetadata . into ()) } } # [doc = "Clear a previously made request for a preimage."] # [doc = ""] # [doc = "NOTE: THIS MUST NOT BE CALLED ON `hash` MORE TIMES THAN `request_preimage`."] pub fn unrequest_preimage (& self , hash : :: subxt :: sp_core :: H256 ,) -> Result < :: subxt :: SubmittableExtrinsic < 'a , T , X , UnrequestPreimage , DispatchError , root_mod :: Event > , :: subxt :: BasicError > { if self . client . metadata () . call_hash :: < UnrequestPreimage > () ? == [160u8 , 6u8 , 6u8 , 198u8 , 77u8 , 37u8 , 28u8 , 86u8 , 240u8 , 160u8 , 128u8 , 123u8 , 144u8 , 150u8 , 150u8 , 60u8 , 107u8 , 148u8 , 189u8 , 192u8 , 125u8 , 25u8 , 55u8 , 212u8 , 193u8 , 212u8 , 198u8 , 131u8 , 113u8 , 37u8 , 213u8 , 152u8 ,] { let call = UnrequestPreimage { hash , } ; Ok (:: subxt :: SubmittableExtrinsic :: new (self . client , call)) } else { Err (:: subxt :: MetadataError :: IncompatibleMetadata . into ()) } } } } pub type Event = runtime_types :: pallet_preimage :: pallet :: Event ; pub mod events { use super :: runtime_types ; # [derive (:: subxt :: codec :: Decode , :: subxt :: codec :: Encode , Clone , Debug , Eq , PartialEq)] # [doc = "A preimage has been noted."] pub struct Noted { pub hash : :: subxt :: sp_core :: H256 , } impl :: subxt :: Event for Noted { const PALLET : & 'static str = "Preimage" ; const EVENT : & 'static str = "Noted" ; } # [derive (:: subxt :: codec :: Decode , :: subxt :: codec :: Encode , Clone , Debug , Eq , PartialEq)] # [doc = "A preimage has been requested."] pub struct Requested { pub hash : :: subxt :: sp_core :: H256 , } impl :: subxt :: Event for Requested { const PALLET : & 'static str = "Preimage" ; const EVENT : & 'static str = "Requested" ; } # [derive (:: subxt :: codec :: Decode , :: subxt :: codec :: Encode , Clone , Debug , Eq , PartialEq)] # [doc = "A preimage has ben cleared."] pub struct Cleared { pub hash : :: subxt :: sp_core :: H256 , } impl :: subxt :: Event for Cleared { const PALLET : & 'static str = "Preimage" ; const EVENT : & 'static str = "Cleared" ; } } pub mod storage { use super :: runtime_types ; pub struct StatusFor < 'a > (pub & 'a :: subxt :: sp_core :: H256) ; impl :: subxt :: StorageEntry for StatusFor < '_ > { const PALLET : & 'static str = "Preimage" ; const STORAGE : & 'static str = "StatusFor" ; type Value = runtime_types :: pallet_preimage :: RequestStatus < :: subxt :: sp_core :: crypto :: AccountId32 , :: core :: primitive :: u128 > ; fn key (& self) -> :: subxt :: StorageEntryKey { :: subxt :: StorageEntryKey :: Map (vec ! [:: subxt :: StorageMapKey :: new (& self . 0 , :: subxt :: StorageHasher :: Identity)]) } } pub struct PreimageFor < 'a > (pub & 'a :: subxt :: sp_core :: H256) ; impl :: subxt :: StorageEntry for PreimageFor < '_ > { const PALLET : & 'static str = "Preimage" ; const STORAGE : & 'static str = "PreimageFor" ; type Value = runtime_types :: sp_runtime :: bounded :: bounded_vec :: BoundedVec < :: core :: primitive :: u8 > ; fn key (& self) -> :: subxt :: StorageEntryKey { :: subxt :: StorageEntryKey :: Map (vec ! [:: subxt :: StorageMapKey :: new (& self . 0 , :: subxt :: StorageHasher :: Identity)]) } } pub struct StorageApi < 'a , T : :: subxt :: Config > { client : & 'a :: subxt :: Client < T > , } impl < 'a , T : :: subxt :: Config > StorageApi < 'a , T > { pub fn new (client : & 'a :: subxt :: Client < T >) -> Self { Self { client } } # [doc = " The request status of a given hash."] pub async fn status_for (& self , _0 : & :: subxt :: sp_core :: H256 , block_hash : :: core :: option :: Option < T :: Hash > ,) -> :: core :: result :: Result < :: core :: option :: Option < runtime_types :: pallet_preimage :: RequestStatus < :: subxt :: sp_core :: crypto :: AccountId32 , :: core :: primitive :: u128 > > , :: subxt :: BasicError > { if self . client . metadata () . storage_hash :: < StatusFor > () ? == [239u8 , 53u8 , 52u8 , 248u8 , 196u8 , 74u8 , 99u8 , 113u8 , 135u8 , 186u8 , 100u8 , 46u8 , 246u8 , 245u8 , 160u8 , 102u8 , 81u8 , 96u8 , 85u8 , 11u8 , 27u8 , 53u8 , 139u8 , 8u8 , 18u8 , 208u8 , 241u8 , 139u8 , 162u8 , 239u8 , 113u8 , 28u8 ,] { let entry = StatusFor (_0) ; self . client . storage () . fetch (& entry , block_hash) . await } else { Err (:: subxt :: MetadataError :: IncompatibleMetadata . into ()) } } # [doc = " The request status of a given hash."] pub async fn status_for_iter (& self , block_hash : :: core :: option :: Option < T :: Hash > ,) -> :: core :: result :: Result < :: subxt :: KeyIter < 'a , T , StatusFor < 'a > > , :: subxt :: BasicError > { if self . client . metadata () . storage_hash :: < StatusFor > () ? == [239u8 , 53u8 , 52u8 , 248u8 , 196u8 , 74u8 , 99u8 , 113u8 , 135u8 , 186u8 , 100u8 , 46u8 , 246u8 , 245u8 , 160u8 , 102u8 , 81u8 , 96u8 , 85u8 , 11u8 , 27u8 , 53u8 , 139u8 , 8u8 , 18u8 , 208u8 , 241u8 , 139u8 , 162u8 , 239u8 , 113u8 , 28u8 ,] { self . client . storage () . iter (block_hash) . await } else { Err (:: subxt :: MetadataError :: IncompatibleMetadata . into ()) } } # [doc = " The preimages stored by this pallet."] pub async fn preimage_for (& self , _0 : & :: subxt :: sp_core :: H256 , block_hash : :: core :: option :: Option < T :: Hash > ,) -> :: core :: result :: Result < :: core :: option :: Option < runtime_types :: sp_runtime :: bounded :: bounded_vec :: BoundedVec < :: core :: primitive :: u8 > > , :: subxt :: BasicError > { if self . client . metadata () . storage_hash :: < PreimageFor > () ? == [153u8 , 48u8 , 185u8 , 144u8 , 57u8 , 68u8 , 133u8 , 92u8 , 225u8 , 172u8 , 36u8 , 62u8 , 152u8 , 162u8 , 15u8 , 139u8 , 140u8 , 82u8 , 118u8 , 63u8 , 31u8 , 158u8 , 197u8 , 26u8 , 141u8 , 210u8 , 150u8 , 82u8 , 109u8 , 100u8 , 144u8 , 56u8 ,] { let entry = PreimageFor (_0) ; self . client . storage () . fetch (& entry , block_hash) . await } else { Err (:: subxt :: MetadataError :: IncompatibleMetadata . into ()) } } # [doc = " The preimages stored by this pallet."] pub async fn preimage_for_iter (& self , block_hash : :: core :: option :: Option < T :: Hash > ,) -> :: core :: result :: Result < :: subxt :: KeyIter < 'a , T , PreimageFor < 'a > > , :: subxt :: BasicError > { if self . client . metadata () . storage_hash :: < PreimageFor > () ? == [153u8 , 48u8 , 185u8 , 144u8 , 57u8 , 68u8 , 133u8 , 92u8 , 225u8 , 172u8 , 36u8 , 62u8 , 152u8 , 162u8 , 15u8 , 139u8 , 140u8 , 82u8 , 118u8 , 63u8 , 31u8 , 158u8 , 197u8 , 26u8 , 141u8 , 210u8 , 150u8 , 82u8 , 109u8 , 100u8 , 144u8 , 56u8 ,] { self . client . storage () . iter (block_hash) . await } else { Err (:: subxt :: MetadataError :: IncompatibleMetadata . into ()) } } } } } pub mod offences { use super :: root_mod ; use super :: runtime_types ; pub type Event = runtime_types :: pallet_offences :: pallet :: Event ; pub mod events { use super :: runtime_types ; # [derive (:: subxt :: codec :: Decode , :: subxt :: codec :: Encode , Clone , Debug , Eq , PartialEq)] # [doc = "There is an offence reported of the given `kind` happened at the `session_index` and"] # [doc = "(kind-specific) time slot. This event is not deposited for duplicate slashes."] # [doc = "\\[kind, timeslot\\]."] pub struct Offence { pub kind : [:: core :: primitive :: u8 ; 16usize] , pub timeslot : :: std :: vec :: Vec < :: core :: primitive :: u8 > , } impl :: subxt :: Event for Offence { const PALLET : & 'static str = "Offences" ; const EVENT : & 'static str = "Offence" ; } } pub mod storage { use super :: runtime_types ; pub struct Reports < 'a > (pub & 'a :: subxt :: sp_core :: H256) ; impl :: subxt :: StorageEntry for Reports < '_ > { const PALLET : & 'static str = "Offences" ; const STORAGE : & 'static str = "Reports" ; type Value = runtime_types :: sp_staking :: offence :: OffenceDetails < :: subxt :: sp_core :: crypto :: AccountId32 , (:: subxt :: sp_core :: crypto :: AccountId32 , runtime_types :: pallet_staking :: Exposure < :: subxt :: sp_core :: crypto :: AccountId32 , :: core :: primitive :: u128 > ,) > ; fn key (& self) -> :: subxt :: StorageEntryKey { :: subxt :: StorageEntryKey :: Map (vec ! [:: subxt :: StorageMapKey :: new (& self . 0 , :: subxt :: StorageHasher :: Twox64Concat)]) } } pub struct ConcurrentReportsIndex < 'a > (pub & 'a [:: core :: primitive :: u8 ; 16usize] , pub & 'a [:: core :: primitive :: u8]) ; impl :: subxt :: StorageEntry for ConcurrentReportsIndex < '_ > { const PALLET : & 'static str = "Offences" ; const STORAGE : & 'static str = "ConcurrentReportsIndex" ; type Value = :: std :: vec :: Vec < :: subxt :: sp_core :: H256 > ; fn key (& self) -> :: subxt :: StorageEntryKey { :: subxt :: StorageEntryKey :: Map (vec ! [:: subxt :: StorageMapKey :: new (& self . 0 , :: subxt :: StorageHasher :: Twox64Concat) , :: subxt :: StorageMapKey :: new (& self . 1 , :: subxt :: StorageHasher :: Twox64Concat)]) } } pub struct ReportsByKindIndex < 'a > (pub & 'a [:: core :: primitive :: u8 ; 16usize]) ; impl :: subxt :: StorageEntry for ReportsByKindIndex < '_ > { const PALLET : & 'static str = "Offences" ; const STORAGE : & 'static str = "ReportsByKindIndex" ; type Value = :: std :: vec :: Vec < :: core :: primitive :: u8 > ; fn key (& self) -> :: subxt :: StorageEntryKey { :: subxt :: StorageEntryKey :: Map (vec ! [:: subxt :: StorageMapKey :: new (& self . 0 , :: subxt :: StorageHasher :: Twox64Concat)]) } } pub struct StorageApi < 'a , T : :: subxt :: Config > { client : & 'a :: subxt :: Client < T > , } impl < 'a , T : :: subxt :: Config > StorageApi < 'a , T > { pub fn new (client : & 'a :: subxt :: Client < T >) -> Self { Self { client } } # [doc = " The primary structure that holds all offence records keyed by report identifiers."] pub async fn reports (& self , _0 : & :: subxt :: sp_core :: H256 , block_hash : :: core :: option :: Option < T :: Hash > ,) -> :: core :: result :: Result < :: core :: option :: Option < runtime_types :: sp_staking :: offence :: OffenceDetails < :: subxt :: sp_core :: crypto :: AccountId32 , (:: subxt :: sp_core :: crypto :: AccountId32 , runtime_types :: pallet_staking :: Exposure < :: subxt :: sp_core :: crypto :: AccountId32 , :: core :: primitive :: u128 > ,) > > , :: subxt :: BasicError > { if self . client . metadata () . storage_hash :: < Reports > () ? == [82u8 , 209u8 , 30u8 , 189u8 , 152u8 , 16u8 , 7u8 , 24u8 , 178u8 , 140u8 , 17u8 , 226u8 , 97u8 , 37u8 , 80u8 , 211u8 , 252u8 , 36u8 , 196u8 , 121u8 , 113u8 , 79u8 , 209u8 , 113u8 , 236u8 , 148u8 , 243u8 , 100u8 , 46u8 , 193u8 , 180u8 , 83u8 ,] { let entry = Reports (_0) ; self . client . storage () . fetch (& entry , block_hash) . await } else { Err (:: subxt :: MetadataError :: IncompatibleMetadata . into ()) } } # [doc = " The primary structure that holds all offence records keyed by report identifiers."] pub async fn reports_iter (& self , block_hash : :: core :: option :: Option < T :: Hash > ,) -> :: core :: result :: Result < :: subxt :: KeyIter < 'a , T , Reports < 'a > > , :: subxt :: BasicError > { if self . client . metadata () . storage_hash :: < Reports > () ? == [82u8 , 209u8 , 30u8 , 189u8 , 152u8 , 16u8 , 7u8 , 24u8 , 178u8 , 140u8 , 17u8 , 226u8 , 97u8 , 37u8 , 80u8 , 211u8 , 252u8 , 36u8 , 196u8 , 121u8 , 113u8 , 79u8 , 209u8 , 113u8 , 236u8 , 148u8 , 243u8 , 100u8 , 46u8 , 193u8 , 180u8 , 83u8 ,] { self . client . storage () . iter (block_hash) . await } else { Err (:: subxt :: MetadataError :: IncompatibleMetadata . into ()) } } # [doc = " A vector of reports of the same kind that happened at the same time slot."] pub async fn concurrent_reports_index (& self , _0 : & [:: core :: primitive :: u8 ; 16usize] , _1 : & [:: core :: primitive :: u8] , block_hash : :: core :: option :: Option < T :: Hash > ,) -> :: core :: result :: Result < :: std :: vec :: Vec < :: subxt :: sp_core :: H256 > , :: subxt :: BasicError > { if self . client . metadata () . storage_hash :: < ConcurrentReportsIndex > () ? == [110u8 , 42u8 , 178u8 , 19u8 , 180u8 , 109u8 , 26u8 , 134u8 , 74u8 , 223u8 , 19u8 , 172u8 , 149u8 , 194u8 , 228u8 , 11u8 , 205u8 , 189u8 , 157u8 , 52u8 , 179u8 , 177u8 , 19u8 , 65u8 , 35u8 , 176u8 , 62u8 , 98u8 , 108u8 , 236u8 , 242u8 , 240u8 ,] { let entry = ConcurrentReportsIndex (_0 , _1) ; self . client . storage () . fetch_or_default (& entry , block_hash) . await } else { Err (:: subxt :: MetadataError :: IncompatibleMetadata . into ()) } } # [doc = " A vector of reports of the same kind that happened at the same time slot."] pub async fn concurrent_reports_index_iter (& self , block_hash : :: core :: option :: Option < T :: Hash > ,) -> :: core :: result :: Result < :: subxt :: KeyIter < 'a , T , ConcurrentReportsIndex < 'a > > , :: subxt :: BasicError > { if self . client . metadata () . storage_hash :: < ConcurrentReportsIndex > () ? == [110u8 , 42u8 , 178u8 , 19u8 , 180u8 , 109u8 , 26u8 , 134u8 , 74u8 , 223u8 , 19u8 , 172u8 , 149u8 , 194u8 , 228u8 , 11u8 , 205u8 , 189u8 , 157u8 , 52u8 , 179u8 , 177u8 , 19u8 , 65u8 , 35u8 , 176u8 , 62u8 , 98u8 , 108u8 , 236u8 , 242u8 , 240u8 ,] { self . client . storage () . iter (block_hash) . await } else { Err (:: subxt :: MetadataError :: IncompatibleMetadata . into ()) } } # [doc = " Enumerates all reports of a kind along with the time they happened."] # [doc = ""] # [doc = " All reports are sorted by the time of offence."] # [doc = ""] # [doc = " Note that the actual type of this mapping is `Vec<u8>`, this is because values of"] # [doc = " different types are not supported at the moment so we are doing the manual serialization."] pub async fn reports_by_kind_index (& self , _0 : & [:: core :: primitive :: u8 ; 16usize] , block_hash : :: core :: option :: Option < T :: Hash > ,) -> :: core :: result :: Result < :: std :: vec :: Vec < :: core :: primitive :: u8 > , :: subxt :: BasicError > { if self . client . metadata () . storage_hash :: < ReportsByKindIndex > () ? == [162u8 , 66u8 , 131u8 , 48u8 , 250u8 , 237u8 , 179u8 , 214u8 , 36u8 , 137u8 , 226u8 , 136u8 , 120u8 , 61u8 , 215u8 , 43u8 , 164u8 , 50u8 , 91u8 , 164u8 , 20u8 , 96u8 , 189u8 , 100u8 , 242u8 , 106u8 , 21u8 , 136u8 , 98u8 , 215u8 , 180u8 , 145u8 ,] { let entry = ReportsByKindIndex (_0) ; self . client . storage () . fetch_or_default (& entry , block_hash) . await } else { Err (:: subxt :: MetadataError :: IncompatibleMetadata . into ()) } } # [doc = " Enumerates all reports of a kind along with the time they happened."] # [doc = ""] # [doc = " All reports are sorted by the time of offence."] # [doc = ""] # [doc = " Note that the actual type of this mapping is `Vec<u8>`, this is because values of"] # [doc = " different types are not supported at the moment so we are doing the manual serialization."] pub async fn reports_by_kind_index_iter (& self , block_hash : :: core :: option :: Option < T :: Hash > ,) -> :: core :: result :: Result < :: subxt :: KeyIter < 'a , T , ReportsByKindIndex < 'a > > , :: subxt :: BasicError > { if self . client . metadata () . storage_hash :: < ReportsByKindIndex > () ? == [162u8 , 66u8 , 131u8 , 48u8 , 250u8 , 237u8 , 179u8 , 214u8 , 36u8 , 137u8 , 226u8 , 136u8 , 120u8 , 61u8 , 215u8 , 43u8 , 164u8 , 50u8 , 91u8 , 164u8 , 20u8 , 96u8 , 189u8 , 100u8 , 242u8 , 106u8 , 21u8 , 136u8 , 98u8 , 215u8 , 180u8 , 145u8 ,] { self . client . storage () . iter (block_hash) . await } else { Err (:: subxt :: MetadataError :: IncompatibleMetadata . into ()) } } } } } pub mod dkg { use super :: root_mod ; use super :: runtime_types ; pub mod calls { use super :: root_mod ; use super :: runtime_types ; type DispatchError = runtime_types :: sp_runtime :: DispatchError ; # [derive (:: subxt :: codec :: CompactAs , :: subxt :: codec :: Decode , :: subxt :: codec :: Encode , Clone , Debug , Eq , PartialEq)] pub struct SetSignatureThreshold { pub new_threshold : :: core :: primitive :: u16 , } impl :: subxt :: Call for SetSignatureThreshold { const PALLET : & 'static str = "DKG" ; const FUNCTION : & 'static str = "set_signature_threshold" ; } # [derive (:: subxt :: codec :: CompactAs , :: subxt :: codec :: Decode , :: subxt :: codec :: Encode , Clone , Debug , Eq , PartialEq)] pub struct SetKeygenThreshold { pub new_threshold : :: core :: primitive :: u16 , } impl :: subxt :: Call for SetKeygenThreshold { const PALLET : & 'static str = "DKG" ; const FUNCTION : & 'static str = "set_keygen_threshold" ; } # [derive (:: subxt :: codec :: CompactAs , :: subxt :: codec :: Decode , :: subxt :: codec :: Encode , Clone , Debug , Eq , PartialEq)] pub struct SetRefreshDelay { pub new_delay : :: core :: primitive :: u8 , } impl :: subxt :: Call for SetRefreshDelay { const PALLET : & 'static str = "DKG" ; const FUNCTION : & 'static str = "set_refresh_delay" ; } # [derive (:: subxt :: codec :: Decode , :: subxt :: codec :: Encode , Clone , Debug , Eq , PartialEq)] pub struct SubmitPublicKey { pub keys_and_signatures : runtime_types :: dkg_runtime_primitives :: AggregatedPublicKeys , } impl :: subxt :: Call for SubmitPublicKey { const PALLET : & 'static str = "DKG" ; const FUNCTION : & 'static str = "submit_public_key" ; } # [derive (:: subxt :: codec :: Decode , :: subxt :: codec :: Encode , Clone , Debug , Eq , PartialEq)] pub struct SubmitNextPublicKey { pub keys_and_signatures : runtime_types :: dkg_runtime_primitives :: AggregatedPublicKeys , } impl :: subxt :: Call for SubmitNextPublicKey { const PALLET : & 'static str = "DKG" ; const FUNCTION : & 'static str = "submit_next_public_key" ; } # [derive (:: subxt :: codec :: Decode , :: subxt :: codec :: Encode , Clone , Debug , Eq , PartialEq)] pub struct SubmitPublicKeySignature { pub signature_proposal : runtime_types :: dkg_runtime_primitives :: proposal :: RefreshProposalSigned , } impl :: subxt :: Call for SubmitPublicKeySignature { const PALLET : & 'static str = "DKG" ; const FUNCTION : & 'static str = "submit_public_key_signature" ; } # [derive (:: subxt :: codec :: Decode , :: subxt :: codec :: Encode , Clone , Debug , Eq , PartialEq)] pub struct SubmitMisbehaviourReports { pub reports : runtime_types :: dkg_runtime_primitives :: AggregatedMisbehaviourReports < runtime_types :: dkg_runtime_primitives :: crypto :: Public > , } impl :: subxt :: Call for SubmitMisbehaviourReports { const PALLET : & 'static str = "DKG" ; const FUNCTION : & 'static str = "submit_misbehaviour_reports" ; } # [derive (:: subxt :: codec :: Decode , :: subxt :: codec :: Encode , Clone , Debug , Eq , PartialEq)] pub struct Unjail ; impl :: subxt :: Call for Unjail { const PALLET : & 'static str = "DKG" ; const FUNCTION : & 'static str = "unjail" ; } # [derive (:: subxt :: codec :: Decode , :: subxt :: codec :: Encode , Clone , Debug , Eq , PartialEq)] pub struct ForceUnjailKeygen { pub authority : runtime_types :: dkg_runtime_primitives :: crypto :: Public , } impl :: subxt :: Call for ForceUnjailKeygen { const PALLET : & 'static str = "DKG" ; const FUNCTION : & 'static str = "force_unjail_keygen" ; } # [derive (:: subxt :: codec :: Decode , :: subxt :: codec :: Encode , Clone , Debug , Eq , PartialEq)] pub struct ForceUnjailSigning { pub authority : runtime_types :: dkg_runtime_primitives :: crypto :: Public , } impl :: subxt :: Call for ForceUnjailSigning { const PALLET : & 'static str = "DKG" ; const FUNCTION : & 'static str = "force_unjail_signing" ; } # [derive (:: subxt :: codec :: Decode , :: subxt :: codec :: Encode , Clone , Debug , Eq , PartialEq)] pub struct ManualIncrementNonce ; impl :: subxt :: Call for ManualIncrementNonce { const PALLET : & 'static str = "DKG" ; const FUNCTION : & 'static str = "manual_increment_nonce" ; } # [derive (:: subxt :: codec :: Decode , :: subxt :: codec :: Encode , Clone , Debug , Eq , PartialEq)] pub struct ManualRefresh ; impl :: subxt :: Call for ManualRefresh { const PALLET : & 'static str = "DKG" ; const FUNCTION : & 'static str = "manual_refresh" ; } # [derive (:: subxt :: codec :: Decode , :: subxt :: codec :: Encode , Clone , Debug , Eq , PartialEq)] pub struct ForceChangeAuthorities ; impl :: subxt :: Call for ForceChangeAuthorities { const PALLET : & 'static str = "DKG" ; const FUNCTION : & 'static str = "force_change_authorities" ; } pub struct TransactionApi < 'a , T : :: subxt :: Config , X > { client : & 'a :: subxt :: Client < T > , marker : :: core :: marker :: PhantomData < X > , } impl < 'a , T , X > TransactionApi < 'a , T , X > where T : :: subxt :: Config , X : :: subxt :: extrinsic :: ExtrinsicParams < T > , { pub fn new (client : & 'a :: subxt :: Client < T >) -> Self { Self { client , marker : :: core :: marker :: PhantomData } } # [doc = "Set the pending signature threshold for the session following the next session."] # [doc = ""] # [doc = "We cannot assume that the next DKG has not already completed keygen."] # [doc = "After all, if we are in a new session the next DKG may have already completed."] # [doc = "Therefore, when we update the thresholds we are updating a threshold"] # [doc = "that will become the next threshold after the next session update."] # [doc = ""] # [doc = "* `origin` - The account origin."] # [doc = "* `new_threshold` - The new signature threshold for the DKG."] pub fn set_signature_threshold (& self , new_threshold : :: core :: primitive :: u16 ,) -> Result < :: subxt :: SubmittableExtrinsic < 'a , T , X , SetSignatureThreshold , DispatchError , root_mod :: Event > , :: subxt :: BasicError > { if self . client . metadata () . call_hash :: < SetSignatureThreshold > () ? == [122u8 , 91u8 , 136u8 , 125u8 , 136u8 , 58u8 , 171u8 , 101u8 , 232u8 , 23u8 , 111u8 , 125u8 , 213u8 , 79u8 , 92u8 , 100u8 , 221u8 , 250u8 , 51u8 , 28u8 , 12u8 , 88u8 , 101u8 , 175u8 , 158u8 , 185u8 , 134u8 , 50u8 , 33u8 , 53u8 , 147u8 , 158u8 ,] { let call = SetSignatureThreshold { new_threshold , } ; Ok (:: subxt :: SubmittableExtrinsic :: new (self . client , call)) } else { Err (:: subxt :: MetadataError :: IncompatibleMetadata . into ()) } } # [doc = "Set the pending keygen threshold for the session following the next session."] # [doc = ""] # [doc = "We cannot assume that the next DKG has not already completed keygen."] # [doc = "After all, if we are in a new session the next DKG may have already completed."] # [doc = "Therefore, when we update the thresholds we are updating a threshold"] # [doc = "that will become the next threshold after the next session update."] # [doc = ""] # [doc = "* `origin` - The account origin."] # [doc = "* `new_threshold` - The new keygen threshold for the DKG."] pub fn set_keygen_threshold (& self , new_threshold : :: core :: primitive :: u16 ,) -> Result < :: subxt :: SubmittableExtrinsic < 'a , T , X , SetKeygenThreshold , DispatchError , root_mod :: Event > , :: subxt :: BasicError > { if self . client . metadata () . call_hash :: < SetKeygenThreshold > () ? == [247u8 , 170u8 , 146u8 , 242u8 , 43u8 , 84u8 , 205u8 , 99u8 , 131u8 , 228u8 , 228u8 , 252u8 , 132u8 , 234u8 , 3u8 , 4u8 , 6u8 , 242u8 , 109u8 , 226u8 , 71u8 , 244u8 , 212u8 , 2u8 , 33u8 , 68u8 , 220u8 , 237u8 , 40u8 , 39u8 , 254u8 , 142u8 ,] { let call = SetKeygenThreshold { new_threshold , } ; Ok (:: subxt :: SubmittableExtrinsic :: new (self . client , call)) } else { Err (:: subxt :: MetadataError :: IncompatibleMetadata . into ()) } } # [doc = "Sets the delay when a unsigned `RefreshProposal` will be added to the unsigned"] # [doc = "proposal queue."] # [doc = ""] # [doc = "* `origin` - The account origin."] # [doc = "* `new_delay` - The percentage of elapsed session duration to wait before adding an"] # [doc = "  unsigned refresh proposal to the unsigned proposal queue."] pub fn set_refresh_delay (& self , new_delay : :: core :: primitive :: u8 ,) -> Result < :: subxt :: SubmittableExtrinsic < 'a , T , X , SetRefreshDelay , DispatchError , root_mod :: Event > , :: subxt :: BasicError > { if self . client . metadata () . call_hash :: < SetRefreshDelay > () ? == [153u8 , 213u8 , 152u8 , 100u8 , 176u8 , 155u8 , 11u8 , 107u8 , 152u8 , 61u8 , 137u8 , 56u8 , 184u8 , 130u8 , 234u8 , 108u8 , 213u8 , 62u8 , 166u8 , 1u8 , 204u8 , 160u8 , 33u8 , 28u8 , 54u8 , 27u8 , 223u8 , 23u8 , 45u8 , 234u8 , 242u8 , 161u8 ,] { let call = SetRefreshDelay { new_delay , } ; Ok (:: subxt :: SubmittableExtrinsic :: new (self . client , call)) } else { Err (:: subxt :: MetadataError :: IncompatibleMetadata . into ()) } } # [doc = "Submits and stores the active public key for the genesis session into the on-chain"] # [doc = "storage. This is primarily used to separate the genesis public key submission from"] # [doc = "non-genesis rounds."] # [doc = ""] # [doc = "Can only be submitted by the current authorities. It is also required that a"] # [doc = "`SignatureThreshold` of submissions is reached in order to successfully"] # [doc = "store the public key on-chain."] # [doc = ""] # [doc = "* `origin` - The account origin."] # [doc = "* `keys_and_signatures` - The aggregated public keys and signatures for possible current"] # [doc = "  DKG public keys."] pub fn submit_public_key (& self , keys_and_signatures : runtime_types :: dkg_runtime_primitives :: AggregatedPublicKeys ,) -> Result < :: subxt :: SubmittableExtrinsic < 'a , T , X , SubmitPublicKey , DispatchError , root_mod :: Event > , :: subxt :: BasicError > { if self . client . metadata () . call_hash :: < SubmitPublicKey > () ? == [173u8 , 232u8 , 176u8 , 226u8 , 83u8 , 67u8 , 238u8 , 215u8 , 161u8 , 193u8 , 191u8 , 223u8 , 165u8 , 253u8 , 44u8 , 204u8 , 128u8 , 146u8 , 194u8 , 102u8 , 115u8 , 55u8 , 255u8 , 30u8 , 53u8 , 139u8 , 72u8 , 90u8 , 16u8 , 190u8 , 192u8 , 75u8 ,] { let call = SubmitPublicKey { keys_and_signatures , } ; Ok (:: subxt :: SubmittableExtrinsic :: new (self . client , call)) } else { Err (:: subxt :: MetadataError :: IncompatibleMetadata . into ()) } } # [doc = "Submits and stores the next public key for the next session into the on-chain storage."] # [doc = ""] # [doc = "Can only be submitted by the next authorities. It is also required that a"] # [doc = "`NextSignatureThreshold` of submissions is reached in order to successfully"] # [doc = "store the public key on-chain."] # [doc = ""] # [doc = "* `origin` - The account origin."] # [doc = "* `keys_and_signatures` - The aggregated public keys and signatures for possible next"] # [doc = "  DKG public keys."] pub fn submit_next_public_key (& self , keys_and_signatures : runtime_types :: dkg_runtime_primitives :: AggregatedPublicKeys ,) -> Result < :: subxt :: SubmittableExtrinsic < 'a , T , X , SubmitNextPublicKey , DispatchError , root_mod :: Event > , :: subxt :: BasicError > { if self . client . metadata () . call_hash :: < SubmitNextPublicKey > () ? == [100u8 , 255u8 , 127u8 , 211u8 , 252u8 , 234u8 , 21u8 , 41u8 , 59u8 , 68u8 , 62u8 , 130u8 , 131u8 , 46u8 , 93u8 , 194u8 , 122u8 , 68u8 , 223u8 , 119u8 , 211u8 , 191u8 , 187u8 , 139u8 , 15u8 , 161u8 , 211u8 , 109u8 , 168u8 , 78u8 , 165u8 , 41u8 ,] { let call = SubmitNextPublicKey { keys_and_signatures , } ; Ok (:: subxt :: SubmittableExtrinsic :: new (self . client , call)) } else { Err (:: subxt :: MetadataError :: IncompatibleMetadata . into ()) } } # [doc = "Submits the public key signature for the key refresh/rotation process."] # [doc = ""] # [doc = "The signature is the signature of the next public key `RefreshProposal`, signed by the"] # [doc = "current DKG. It is stored on-chain only if it verifies successfully against the current"] # [doc = "DKG's public key. Successful storage of this public key signature also removes"] # [doc = "the unsigned `RefreshProposal` from the unsigned queue."] # [doc = ""] # [doc = "For manual refreshes, after the signature is submitted and stored on-chain,"] # [doc = "the keys are immediately refreshed and the authority set is immediately rotated"] # [doc = "and incremented."] # [doc = ""] # [doc = "* `origin` - The account origin."] # [doc = "* `signature_proposal` - The signed refresh proposal containing the public key signature"] # [doc = "  and nonce."] pub fn submit_public_key_signature (& self , signature_proposal : runtime_types :: dkg_runtime_primitives :: proposal :: RefreshProposalSigned ,) -> Result < :: subxt :: SubmittableExtrinsic < 'a , T , X , SubmitPublicKeySignature , DispatchError , root_mod :: Event > , :: subxt :: BasicError > { if self . client . metadata () . call_hash :: < SubmitPublicKeySignature > () ? == [64u8 , 121u8 , 205u8 , 174u8 , 235u8 , 120u8 , 49u8 , 71u8 , 91u8 , 199u8 , 18u8 , 52u8 , 161u8 , 61u8 , 232u8 , 90u8 , 246u8 , 207u8 , 79u8 , 19u8 , 173u8 , 156u8 , 150u8 , 52u8 , 127u8 , 218u8 , 165u8 , 181u8 , 221u8 , 121u8 , 216u8 , 65u8 ,] { let call = SubmitPublicKeySignature { signature_proposal , } ; Ok (:: subxt :: SubmittableExtrinsic :: new (self . client , call)) } else { Err (:: subxt :: MetadataError :: IncompatibleMetadata . into ()) } } # [doc = "Submits misbehaviour reports on chain. Signatures of the offending authority are"] # [doc = "verified against the current or next authorities depending on the type of misbehaviour."] # [doc = "- Keygen: Verifies against the next authorities, since they are doing keygen."] # [doc = "- Signing: Verifies against the current authorities, since they are doing signing."] # [doc = ""] # [doc = "Verifies the reports against the respective thresholds and if enough reports are met"] # [doc = "begins to jail and decrease the reputation of the offending authority."] # [doc = ""] # [doc = "The misbehaviour reputation update is:"] # [doc = "\tAUTHORITY_REPUTATION = DECAY_PERCENTAGE * AUTHORITY_REPUTATION"] # [doc = ""] # [doc = "If there are not enough unjailed keygen authorities to perform a keygen after the next"] # [doc = "session, then we deduct the pending keygen threshold (and pending signing threshold)"] # [doc = "accordingly."] # [doc = ""] # [doc = "* `origin` - The account origin."] # [doc = "* `reports` - The aggregated misbehaviour reports containing signatures of an offending"] # [doc = "  authority"] pub fn submit_misbehaviour_reports (& self , reports : runtime_types :: dkg_runtime_primitives :: AggregatedMisbehaviourReports < runtime_types :: dkg_runtime_primitives :: crypto :: Public > ,) -> Result < :: subxt :: SubmittableExtrinsic < 'a , T , X , SubmitMisbehaviourReports , DispatchError , root_mod :: Event > , :: subxt :: BasicError > { if self . client . metadata () . call_hash :: < SubmitMisbehaviourReports > () ? == [179u8 , 201u8 , 171u8 , 224u8 , 9u8 , 158u8 , 65u8 , 95u8 , 226u8 , 168u8 , 136u8 , 197u8 , 129u8 , 197u8 , 49u8 , 197u8 , 235u8 , 0u8 , 254u8 , 39u8 , 111u8 , 240u8 , 117u8 , 123u8 , 163u8 , 177u8 , 9u8 , 211u8 , 223u8 , 104u8 , 131u8 , 237u8 ,] { let call = SubmitMisbehaviourReports { reports , } ; Ok (:: subxt :: SubmittableExtrinsic :: new (self . client , call)) } else { Err (:: subxt :: MetadataError :: IncompatibleMetadata . into ()) } } # [doc = "Attempts to remove an authority from all possible jails (keygen & signing)."] # [doc = "This can only be called by the controller of the authority in jail. The"] # [doc = "origin must map directly to the authority in jail."] # [doc = ""] # [doc = "The authority's jail sentence for either keygen or signing must be elapsed"] # [doc = "for the authority to be removed from the jail."] # [doc = ""] # [doc = "* `origin` - The account origin."] pub fn unjail (& self ,) -> Result < :: subxt :: SubmittableExtrinsic < 'a , T , X , Unjail , DispatchError , root_mod :: Event > , :: subxt :: BasicError > { if self . client . metadata () . call_hash :: < Unjail > () ? == [209u8 , 5u8 , 90u8 , 85u8 , 167u8 , 92u8 , 85u8 , 132u8 , 48u8 , 27u8 , 89u8 , 149u8 , 242u8 , 209u8 , 97u8 , 87u8 , 13u8 , 58u8 , 124u8 , 41u8 , 155u8 , 103u8 , 62u8 , 115u8 , 58u8 , 143u8 , 233u8 , 105u8 , 18u8 , 198u8 , 173u8 , 77u8 ,] { let call = Unjail { } ; Ok (:: subxt :: SubmittableExtrinsic :: new (self . client , call)) } else { Err (:: subxt :: MetadataError :: IncompatibleMetadata . into ()) } } # [doc = "Force removes an authority from keygen jail."] # [doc = ""] # [doc = "Can only be called by the root origin."] # [doc = ""] # [doc = "* `origin` - The account origin."] # [doc = "* `authority` - The authority to be removed from the keygen jail."] pub fn force_unjail_keygen (& self , authority : runtime_types :: dkg_runtime_primitives :: crypto :: Public ,) -> Result < :: subxt :: SubmittableExtrinsic < 'a , T , X , ForceUnjailKeygen , DispatchError , root_mod :: Event > , :: subxt :: BasicError > { if self . client . metadata () . call_hash :: < ForceUnjailKeygen > () ? == [195u8 , 242u8 , 39u8 , 180u8 , 7u8 , 13u8 , 185u8 , 92u8 , 203u8 , 183u8 , 123u8 , 71u8 , 100u8 , 56u8 , 32u8 , 234u8 , 213u8 , 1u8 , 70u8 , 91u8 , 158u8 , 124u8 , 224u8 , 135u8 , 252u8 , 149u8 , 118u8 , 135u8 , 52u8 , 253u8 , 82u8 , 148u8 ,] { let call = ForceUnjailKeygen { authority , } ; Ok (:: subxt :: SubmittableExtrinsic :: new (self . client , call)) } else { Err (:: subxt :: MetadataError :: IncompatibleMetadata . into ()) } } # [doc = "Force removes an authority from signing jail."] # [doc = ""] # [doc = "Can only be called by the root origin."] # [doc = ""] # [doc = "* `origin` - The account origin."] # [doc = "* `authority` - The authority to be removed from the signing jail."] pub fn force_unjail_signing (& self , authority : runtime_types :: dkg_runtime_primitives :: crypto :: Public ,) -> Result < :: subxt :: SubmittableExtrinsic < 'a , T , X , ForceUnjailSigning , DispatchError , root_mod :: Event > , :: subxt :: BasicError > { if self . client . metadata () . call_hash :: < ForceUnjailSigning > () ? == [58u8 , 229u8 , 158u8 , 234u8 , 101u8 , 114u8 , 53u8 , 203u8 , 70u8 , 72u8 , 122u8 , 70u8 , 121u8 , 80u8 , 221u8 , 208u8 , 9u8 , 10u8 , 66u8 , 165u8 , 41u8 , 156u8 , 97u8 , 76u8 , 21u8 , 204u8 , 82u8 , 244u8 , 27u8 , 223u8 , 244u8 , 173u8 ,] { let call = ForceUnjailSigning { authority , } ; Ok (:: subxt :: SubmittableExtrinsic :: new (self . client , call)) } else { Err (:: subxt :: MetadataError :: IncompatibleMetadata . into ()) } } # [doc = "Manually Update the `RefreshNonce` (increment it by one)."] # [doc = ""] # [doc = "Can only be called by the root origin."] # [doc = ""] # [doc = "* `origin` - The account origin."] # [doc = "**Important**: This function is only available for testing purposes."] pub fn manual_increment_nonce (& self ,) -> Result < :: subxt :: SubmittableExtrinsic < 'a , T , X , ManualIncrementNonce , DispatchError , root_mod :: Event > , :: subxt :: BasicError > { if self . client . metadata () . call_hash :: < ManualIncrementNonce > () ? == [22u8 , 159u8 , 183u8 , 158u8 , 52u8 , 204u8 , 244u8 , 244u8 , 25u8 , 35u8 , 106u8 , 37u8 , 142u8 , 136u8 , 162u8 , 142u8 , 8u8 , 184u8 , 168u8 , 216u8 , 224u8 , 54u8 , 160u8 , 201u8 , 147u8 , 181u8 , 178u8 , 49u8 , 132u8 , 194u8 , 244u8 , 121u8 ,] { let call = ManualIncrementNonce { } ; Ok (:: subxt :: SubmittableExtrinsic :: new (self . client , call)) } else { Err (:: subxt :: MetadataError :: IncompatibleMetadata . into ()) } } # [doc = "Manual Trigger DKG Refresh process."] # [doc = ""] # [doc = "Can only be called by the root origin."] # [doc = ""] # [doc = "* `origin` - The account that is initiating the refresh process."] # [doc = "**Important**: This function is only available for testing purposes."] pub fn manual_refresh (& self ,) -> Result < :: subxt :: SubmittableExtrinsic < 'a , T , X , ManualRefresh , DispatchError , root_mod :: Event > , :: subxt :: BasicError > { if self . client . metadata () . call_hash :: < ManualRefresh > () ? == [141u8 , 166u8 , 81u8 , 218u8 , 235u8 , 190u8 , 65u8 , 190u8 , 157u8 , 160u8 , 105u8 , 236u8 , 47u8 , 129u8 , 0u8 , 155u8 , 6u8 , 182u8 , 20u8 , 39u8 , 71u8 , 195u8 , 13u8 , 242u8 , 94u8 , 6u8 , 130u8 , 192u8 , 89u8 , 240u8 , 46u8 , 21u8 ,] { let call = ManualRefresh { } ; Ok (:: subxt :: SubmittableExtrinsic :: new (self . client , call)) } else { Err (:: subxt :: MetadataError :: IncompatibleMetadata . into ()) } } # [doc = "Forcefully rotate the DKG"] # [doc = ""] # [doc = "This forces the next authorities into the current authority spot and"] # [doc = "automatically increments the authority ID. It uses `change_authorities`"] # [doc = "to execute the rotation forcefully."] pub fn force_change_authorities (& self ,) -> Result < :: subxt :: SubmittableExtrinsic < 'a , T , X , ForceChangeAuthorities , DispatchError , root_mod :: Event > , :: subxt :: BasicError > { if self . client . metadata () . call_hash :: < ForceChangeAuthorities > () ? == [98u8 , 226u8 , 238u8 , 39u8 , 98u8 , 79u8 , 85u8 , 160u8 , 82u8 , 3u8 , 34u8 , 195u8 , 220u8 , 178u8 , 25u8 , 110u8 , 12u8 , 72u8 , 165u8 , 126u8 , 207u8 , 173u8 , 210u8 , 74u8 , 54u8 , 106u8 , 255u8 , 243u8 , 240u8 , 22u8 , 161u8 , 255u8 ,] { let call = ForceChangeAuthorities { } ; Ok (:: subxt :: SubmittableExtrinsic :: new (self . client , call)) } else { Err (:: subxt :: MetadataError :: IncompatibleMetadata . into ()) } } } } pub type Event = runtime_types :: pallet_dkg_metadata :: pallet :: Event ; pub mod events { use super :: runtime_types ; # [derive (:: subxt :: codec :: Decode , :: subxt :: codec :: Encode , Clone , Debug , Eq , PartialEq)] # [doc = "Current public key submitted"] pub struct PublicKeySubmitted { pub compressed_pub_key : :: std :: vec :: Vec < :: core :: primitive :: u8 > , pub uncompressed_pub_key : :: std :: vec :: Vec < :: core :: primitive :: u8 > , } impl :: subxt :: Event for PublicKeySubmitted { const PALLET : & 'static str = "DKG" ; const EVENT : & 'static str = "PublicKeySubmitted" ; } # [derive (:: subxt :: codec :: Decode , :: subxt :: codec :: Encode , Clone , Debug , Eq , PartialEq)] # [doc = "Next public key submitted"] pub struct NextPublicKeySubmitted { pub compressed_pub_key : :: std :: vec :: Vec < :: core :: primitive :: u8 > , pub uncompressed_pub_key : :: std :: vec :: Vec < :: core :: primitive :: u8 > , } impl :: subxt :: Event for NextPublicKeySubmitted { const PALLET : & 'static str = "DKG" ; const EVENT : & 'static str = "NextPublicKeySubmitted" ; } # [derive (:: subxt :: codec :: Decode , :: subxt :: codec :: Encode , Clone , Debug , Eq , PartialEq)] # [doc = "Next public key signature submitted"] pub struct NextPublicKeySignatureSubmitted { pub pub_key_sig : :: std :: vec :: Vec < :: core :: primitive :: u8 > , } impl :: subxt :: Event for NextPublicKeySignatureSubmitted { const PALLET : & 'static str = "DKG" ; const EVENT : & 'static str = "NextPublicKeySignatureSubmitted" ; } # [derive (:: subxt :: codec :: Decode , :: subxt :: codec :: Encode , Clone , Debug , Eq , PartialEq)] # [doc = "Current Public Key Changed."] pub struct PublicKeyChanged { pub compressed_pub_key : :: std :: vec :: Vec < :: core :: primitive :: u8 > , pub uncompressed_pub_key : :: std :: vec :: Vec < :: core :: primitive :: u8 > , } impl :: subxt :: Event for PublicKeyChanged { const PALLET : & 'static str = "DKG" ; const EVENT : & 'static str = "PublicKeyChanged" ; } # [derive (:: subxt :: codec :: Decode , :: subxt :: codec :: Encode , Clone , Debug , Eq , PartialEq)] # [doc = "Current Public Key Signature Changed."] pub struct PublicKeySignatureChanged { pub pub_key_sig : :: std :: vec :: Vec < :: core :: primitive :: u8 > , } impl :: subxt :: Event for PublicKeySignatureChanged { const PALLET : & 'static str = "DKG" ; const EVENT : & 'static str = "PublicKeySignatureChanged" ; } # [derive (:: subxt :: codec :: Decode , :: subxt :: codec :: Encode , Clone , Debug , Eq , PartialEq)] # [doc = "Misbehaviour reports submitted"] pub struct MisbehaviourReportsSubmitted { pub misbehaviour_type : runtime_types :: dkg_runtime_primitives :: MisbehaviourType , pub reporters : :: std :: vec :: Vec < runtime_types :: dkg_runtime_primitives :: crypto :: Public > , } impl :: subxt :: Event for MisbehaviourReportsSubmitted { const PALLET : & 'static str = "DKG" ; const EVENT : & 'static str = "MisbehaviourReportsSubmitted" ; } # [derive (:: subxt :: codec :: CompactAs , :: subxt :: codec :: Decode , :: subxt :: codec :: Encode , Clone , Debug , Eq , PartialEq)] # [doc = "Refresh DKG Keys Finished (forcefully)."] pub struct RefreshKeysFinished { pub next_authority_set_id : :: core :: primitive :: u64 , } impl :: subxt :: Event for RefreshKeysFinished { const PALLET : & 'static str = "DKG" ; const EVENT : & 'static str = "RefreshKeysFinished" ; } } pub mod storage { use super :: runtime_types ; pub struct UsedSignatures ; impl :: subxt :: StorageEntry for UsedSignatures { const PALLET : & 'static str = "DKG" ; const STORAGE : & 'static str = "UsedSignatures" ; type Value = :: std :: vec :: Vec < :: std :: vec :: Vec < :: core :: primitive :: u8 > > ; fn key (& self) -> :: subxt :: StorageEntryKey { :: subxt :: StorageEntryKey :: Plain } } pub struct RefreshNonce ; impl :: subxt :: StorageEntry for RefreshNonce { const PALLET : & 'static str = "DKG" ; const STORAGE : & 'static str = "RefreshNonce" ; type Value = :: core :: primitive :: u32 ; fn key (& self) -> :: subxt :: StorageEntryKey { :: subxt :: StorageEntryKey :: Plain } } pub struct RefreshDelay ; impl :: subxt :: StorageEntry for RefreshDelay { const PALLET : & 'static str = "DKG" ; const STORAGE : & 'static str = "RefreshDelay" ; type Value = runtime_types :: sp_arithmetic :: per_things :: Permill ; fn key (& self) -> :: subxt :: StorageEntryKey { :: subxt :: StorageEntryKey :: Plain } } pub struct RefreshInProgress ; impl :: subxt :: StorageEntry for RefreshInProgress { const PALLET : & 'static str = "DKG" ; const STORAGE : & 'static str = "RefreshInProgress" ; type Value = :: core :: primitive :: bool ; fn key (& self) -> :: subxt :: StorageEntryKey { :: subxt :: StorageEntryKey :: Plain } } pub struct ShouldManualRefresh ; impl :: subxt :: StorageEntry for ShouldManualRefresh { const PALLET : & 'static str = "DKG" ; const STORAGE : & 'static str = "ShouldManualRefresh" ; type Value = :: core :: primitive :: bool ; fn key (& self) -> :: subxt :: StorageEntryKey { :: subxt :: StorageEntryKey :: Plain } } pub struct NextDKGPublicKey ; impl :: subxt :: StorageEntry for NextDKGPublicKey { const PALLET : & 'static str = "DKG" ; const STORAGE : & 'static str = "NextDKGPublicKey" ; type Value = (:: core :: primitive :: u64 , :: std :: vec :: Vec < :: core :: primitive :: u8 > ,) ; fn key (& self) -> :: subxt :: StorageEntryKey { :: subxt :: StorageEntryKey :: Plain } } pub struct NextPublicKeySignature ; impl :: subxt :: StorageEntry for NextPublicKeySignature { const PALLET : & 'static str = "DKG" ; const STORAGE : & 'static str = "NextPublicKeySignature" ; type Value = :: std :: vec :: Vec < :: core :: primitive :: u8 > ; fn key (& self) -> :: subxt :: StorageEntryKey { :: subxt :: StorageEntryKey :: Plain } } pub struct DKGPublicKey ; impl :: subxt :: StorageEntry for DKGPublicKey { const PALLET : & 'static str = "DKG" ; const STORAGE : & 'static str = "DKGPublicKey" ; type Value = (:: core :: primitive :: u64 , :: std :: vec :: Vec < :: core :: primitive :: u8 > ,) ; fn key (& self) -> :: subxt :: StorageEntryKey { :: subxt :: StorageEntryKey :: Plain } } pub struct DKGPublicKeySignature ; impl :: subxt :: StorageEntry for DKGPublicKeySignature { const PALLET : & 'static str = "DKG" ; const STORAGE : & 'static str = "DKGPublicKeySignature" ; type Value = :: std :: vec :: Vec < :: core :: primitive :: u8 > ; fn key (& self) -> :: subxt :: StorageEntryKey { :: subxt :: StorageEntryKey :: Plain } } pub struct PreviousPublicKey ; impl :: subxt :: StorageEntry for PreviousPublicKey { const PALLET : & 'static str = "DKG" ; const STORAGE : & 'static str = "PreviousPublicKey" ; type Value = (:: core :: primitive :: u64 , :: std :: vec :: Vec < :: core :: primitive :: u8 > ,) ; fn key (& self) -> :: subxt :: StorageEntryKey { :: subxt :: StorageEntryKey :: Plain } } pub struct HistoricalRounds < 'a > (pub & 'a :: core :: primitive :: u64) ; impl :: subxt :: StorageEntry for HistoricalRounds < '_ > { const PALLET : & 'static str = "DKG" ; const STORAGE : & 'static str = "HistoricalRounds" ; type Value = runtime_types :: pallet_dkg_metadata :: types :: RoundMetadata ; fn key (& self) -> :: subxt :: StorageEntryKey { :: subxt :: StorageEntryKey :: Map (vec ! [:: subxt :: StorageMapKey :: new (& self . 0 , :: subxt :: StorageHasher :: Blake2_256)]) } } pub struct SignatureThreshold ; impl :: subxt :: StorageEntry for SignatureThreshold { const PALLET : & 'static str = "DKG" ; const STORAGE : & 'static str = "SignatureThreshold" ; type Value = :: core :: primitive :: u16 ; fn key (& self) -> :: subxt :: StorageEntryKey { :: subxt :: StorageEntryKey :: Plain } } pub struct KeygenThreshold ; impl :: subxt :: StorageEntry for KeygenThreshold { const PALLET : & 'static str = "DKG" ; const STORAGE : & 'static str = "KeygenThreshold" ; type Value = :: core :: primitive :: u16 ; fn key (& self) -> :: subxt :: StorageEntryKey { :: subxt :: StorageEntryKey :: Plain } } pub struct NextSignatureThreshold ; impl :: subxt :: StorageEntry for NextSignatureThreshold { const PALLET : & 'static str = "DKG" ; const STORAGE : & 'static str = "NextSignatureThreshold" ; type Value = :: core :: primitive :: u16 ; fn key (& self) -> :: subxt :: StorageEntryKey { :: subxt :: StorageEntryKey :: Plain } } pub struct NextKeygenThreshold ; impl :: subxt :: StorageEntry for NextKeygenThreshold { const PALLET : & 'static str = "DKG" ; const STORAGE : & 'static str = "NextKeygenThreshold" ; type Value = :: core :: primitive :: u16 ; fn key (& self) -> :: subxt :: StorageEntryKey { :: subxt :: StorageEntryKey :: Plain } } pub struct PendingSignatureThreshold ; impl :: subxt :: StorageEntry for PendingSignatureThreshold { const PALLET : & 'static str = "DKG" ; const STORAGE : & 'static str = "PendingSignatureThreshold" ; type Value = :: core :: primitive :: u16 ; fn key (& self) -> :: subxt :: StorageEntryKey { :: subxt :: StorageEntryKey :: Plain } } pub struct PendingKeygenThreshold ; impl :: subxt :: StorageEntry for PendingKeygenThreshold { const PALLET : & 'static str = "DKG" ; const STORAGE : & 'static str = "PendingKeygenThreshold" ; type Value = :: core :: primitive :: u16 ; fn key (& self) -> :: subxt :: StorageEntryKey { :: subxt :: StorageEntryKey :: Plain } } pub struct Authorities ; impl :: subxt :: StorageEntry for Authorities { const PALLET : & 'static str = "DKG" ; const STORAGE : & 'static str = "Authorities" ; type Value = :: std :: vec :: Vec < runtime_types :: dkg_runtime_primitives :: crypto :: Public > ; fn key (& self) -> :: subxt :: StorageEntryKey { :: subxt :: StorageEntryKey :: Plain } } pub struct AuthoritySetId ; impl :: subxt :: StorageEntry for AuthoritySetId { const PALLET : & 'static str = "DKG" ; const STORAGE : & 'static str = "AuthoritySetId" ; type Value = :: core :: primitive :: u64 ; fn key (& self) -> :: subxt :: StorageEntryKey { :: subxt :: StorageEntryKey :: Plain } } pub struct NextAuthoritySetId ; impl :: subxt :: StorageEntry for NextAuthoritySetId { const PALLET : & 'static str = "DKG" ; const STORAGE : & 'static str = "NextAuthoritySetId" ; type Value = :: core :: primitive :: u64 ; fn key (& self) -> :: subxt :: StorageEntryKey { :: subxt :: StorageEntryKey :: Plain } } pub struct NextAuthorities ; impl :: subxt :: StorageEntry for NextAuthorities { const PALLET : & 'static str = "DKG" ; const STORAGE : & 'static str = "NextAuthorities" ; type Value = :: std :: vec :: Vec < runtime_types :: dkg_runtime_primitives :: crypto :: Public > ; fn key (& self) -> :: subxt :: StorageEntryKey { :: subxt :: StorageEntryKey :: Plain } } pub struct CurrentAuthoritiesAccounts ; impl :: subxt :: StorageEntry for CurrentAuthoritiesAccounts { const PALLET : & 'static str = "DKG" ; const STORAGE : & 'static str = "CurrentAuthoritiesAccounts" ; type Value = :: std :: vec :: Vec < :: subxt :: sp_core :: crypto :: AccountId32 > ; fn key (& self) -> :: subxt :: StorageEntryKey { :: subxt :: StorageEntryKey :: Plain } } pub struct NextAuthoritiesAccounts ; impl :: subxt :: StorageEntry for NextAuthoritiesAccounts { const PALLET : & 'static str = "DKG" ; const STORAGE : & 'static str = "NextAuthoritiesAccounts" ; type Value = :: std :: vec :: Vec < :: subxt :: sp_core :: crypto :: AccountId32 > ; fn key (& self) -> :: subxt :: StorageEntryKey { :: subxt :: StorageEntryKey :: Plain } } pub struct AccountToAuthority < 'a > (pub & 'a :: subxt :: sp_core :: crypto :: AccountId32) ; impl :: subxt :: StorageEntry for AccountToAuthority < '_ > { const PALLET : & 'static str = "DKG" ; const STORAGE : & 'static str = "AccountToAuthority" ; type Value = runtime_types :: dkg_runtime_primitives :: crypto :: Public ; fn key (& self) -> :: subxt :: StorageEntryKey { :: subxt :: StorageEntryKey :: Map (vec ! [:: subxt :: StorageMapKey :: new (& self . 0 , :: subxt :: StorageHasher :: Blake2_256)]) } } pub struct MisbehaviourReports < 'a > (pub & 'a runtime_types :: dkg_runtime_primitives :: MisbehaviourType , pub & 'a :: core :: primitive :: u64 , pub & 'a runtime_types :: dkg_runtime_primitives :: crypto :: Public) ; impl :: subxt :: StorageEntry for MisbehaviourReports < '_ > { const PALLET : & 'static str = "DKG" ; const STORAGE : & 'static str = "MisbehaviourReports" ; type Value = runtime_types :: dkg_runtime_primitives :: AggregatedMisbehaviourReports < runtime_types :: dkg_runtime_primitives :: crypto :: Public > ; fn key (& self) -> :: subxt :: StorageEntryKey { :: subxt :: StorageEntryKey :: Map (vec ! [:: subxt :: StorageMapKey :: new (& (& self . 0 , & self . 1 , & self . 2) , :: subxt :: StorageHasher :: Blake2_256)]) } } pub struct AuthorityReputations < 'a > (pub & 'a runtime_types :: dkg_runtime_primitives :: crypto :: Public) ; impl :: subxt :: StorageEntry for AuthorityReputations < '_ > { const PALLET : & 'static str = "DKG" ; const STORAGE : & 'static str = "AuthorityReputations" ; type Value = :: core :: primitive :: u128 ; fn key (& self) -> :: subxt :: StorageEntryKey { :: subxt :: StorageEntryKey :: Map (vec ! [:: subxt :: StorageMapKey :: new (& self . 0 , :: subxt :: StorageHasher :: Blake2_256)]) } } pub struct JailedKeygenAuthorities < 'a > (pub & 'a runtime_types :: dkg_runtime_primitives :: crypto :: Public) ; impl :: subxt :: StorageEntry for JailedKeygenAuthorities < '_ > { const PALLET : & 'static str = "DKG" ; const STORAGE : & 'static str = "JailedKeygenAuthorities" ; type Value = :: core :: primitive :: u32 ; fn key (& self) -> :: subxt :: StorageEntryKey { :: subxt :: StorageEntryKey :: Map (vec ! [:: subxt :: StorageMapKey :: new (& self . 0 , :: subxt :: StorageHasher :: Blake2_256)]) } } pub struct JailedSigningAuthorities < 'a > (pub & 'a runtime_types :: dkg_runtime_primitives :: crypto :: Public) ; impl :: subxt :: StorageEntry for JailedSigningAuthorities < '_ > { const PALLET : & 'static str = "DKG" ; const STORAGE : & 'static str = "JailedSigningAuthorities" ; type Value = :: core :: primitive :: u32 ; fn key (& self) -> :: subxt :: StorageEntryKey { :: subxt :: StorageEntryKey :: Map (vec ! [:: subxt :: StorageMapKey :: new (& self . 0 , :: subxt :: StorageHasher :: Blake2_256)]) } } pub struct BestAuthorities ; impl :: subxt :: StorageEntry for BestAuthorities { const PALLET : & 'static str = "DKG" ; const STORAGE : & 'static str = "BestAuthorities" ; type Value = :: std :: vec :: Vec < (:: core :: primitive :: u16 , runtime_types :: dkg_runtime_primitives :: crypto :: Public ,) > ; fn key (& self) -> :: subxt :: StorageEntryKey { :: subxt :: StorageEntryKey :: Plain } } pub struct NextBestAuthorities ; impl :: subxt :: StorageEntry for NextBestAuthorities { const PALLET : & 'static str = "DKG" ; const STORAGE : & 'static str = "NextBestAuthorities" ; type Value = :: std :: vec :: Vec < (:: core :: primitive :: u16 , runtime_types :: dkg_runtime_primitives :: crypto :: Public ,) > ; fn key (& self) -> :: subxt :: StorageEntryKey { :: subxt :: StorageEntryKey :: Plain } } pub struct StorageApi < 'a , T : :: subxt :: Config > { client : & 'a :: subxt :: Client < T > , } impl < 'a , T : :: subxt :: Config > StorageApi < 'a , T > { pub fn new (client : & 'a :: subxt :: Client < T >) -> Self { Self { client } } # [doc = " Public key Signatures for past sessions"] pub async fn used_signatures (& self , block_hash : :: core :: option :: Option < T :: Hash > ,) -> :: core :: result :: Result < :: std :: vec :: Vec < :: std :: vec :: Vec < :: core :: primitive :: u8 > > , :: subxt :: BasicError > { if self . client . metadata () . storage_hash :: < UsedSignatures > () ? == [17u8 , 166u8 , 71u8 , 200u8 , 53u8 , 132u8 , 79u8 , 208u8 , 187u8 , 231u8 , 68u8 , 227u8 , 163u8 , 125u8 , 235u8 , 145u8 , 171u8 , 160u8 , 82u8 , 237u8 , 170u8 , 48u8 , 173u8 , 104u8 , 13u8 , 113u8 , 12u8 , 56u8 , 47u8 , 42u8 , 250u8 , 70u8 ,] { let entry = UsedSignatures ; self . client . storage () . fetch_or_default (& entry , block_hash) . await } else { Err (:: subxt :: MetadataError :: IncompatibleMetadata . into ()) } } # [doc = " Nonce value for next refresh proposal"] pub async fn refresh_nonce (& self , block_hash : :: core :: option :: Option < T :: Hash > ,) -> :: core :: result :: Result < :: core :: primitive :: u32 , :: subxt :: BasicError > { if self . client . metadata () . storage_hash :: < RefreshNonce > () ? == [184u8 , 107u8 , 53u8 , 61u8 , 92u8 , 121u8 , 77u8 , 93u8 , 141u8 , 192u8 , 238u8 , 92u8 , 15u8 , 155u8 , 1u8 , 153u8 , 55u8 , 64u8 , 83u8 , 144u8 , 127u8 , 250u8 , 207u8 , 14u8 , 62u8 , 137u8 , 151u8 , 230u8 , 86u8 , 236u8 , 27u8 , 175u8 ,] { let entry = RefreshNonce ; self . client . storage () . fetch_or_default (& entry , block_hash) . await } else { Err (:: subxt :: MetadataError :: IncompatibleMetadata . into ()) } } # [doc = " Session progress required to kickstart refresh process"] pub async fn refresh_delay (& self , block_hash : :: core :: option :: Option < T :: Hash > ,) -> :: core :: result :: Result < runtime_types :: sp_arithmetic :: per_things :: Permill , :: subxt :: BasicError > { if self . client . metadata () . storage_hash :: < RefreshDelay > () ? == [180u8 , 202u8 , 73u8 , 192u8 , 104u8 , 179u8 , 161u8 , 128u8 , 190u8 , 211u8 , 99u8 , 82u8 , 64u8 , 192u8 , 208u8 , 39u8 , 86u8 , 224u8 , 232u8 , 25u8 , 187u8 , 32u8 , 8u8 , 39u8 , 36u8 , 47u8 , 137u8 , 92u8 , 129u8 , 115u8 , 93u8 , 100u8 ,] { let entry = RefreshDelay ; self . client . storage () . fetch_or_default (& entry , block_hash) . await } else { Err (:: subxt :: MetadataError :: IncompatibleMetadata . into ()) } } # [doc = " Check if there is a refresh in progress."] pub async fn refresh_in_progress (& self , block_hash : :: core :: option :: Option < T :: Hash > ,) -> :: core :: result :: Result < :: core :: primitive :: bool , :: subxt :: BasicError > { if self . client . metadata () . storage_hash :: < RefreshInProgress > () ? == [150u8 , 114u8 , 14u8 , 254u8 , 132u8 , 254u8 , 10u8 , 89u8 , 109u8 , 4u8 , 182u8 , 128u8 , 114u8 , 15u8 , 82u8 , 35u8 , 88u8 , 86u8 , 32u8 , 82u8 , 83u8 , 175u8 , 123u8 , 98u8 , 120u8 , 180u8 , 167u8 , 185u8 , 57u8 , 221u8 , 12u8 , 62u8 ,] { let entry = RefreshInProgress ; self . client . storage () . fetch_or_default (& entry , block_hash) . await } else { Err (:: subxt :: MetadataError :: IncompatibleMetadata . into ()) } } # [doc = " Should we manually trigger a DKG refresh process."] pub async fn should_manual_refresh (& self , block_hash : :: core :: option :: Option < T :: Hash > ,) -> :: core :: result :: Result < :: core :: primitive :: bool , :: subxt :: BasicError > { if self . client . metadata () . storage_hash :: < ShouldManualRefresh > () ? == [8u8 , 62u8 , 186u8 , 74u8 , 165u8 , 5u8 , 229u8 , 30u8 , 130u8 , 245u8 , 0u8 , 67u8 , 160u8 , 166u8 , 39u8 , 193u8 , 18u8 , 152u8 , 51u8 , 30u8 , 228u8 , 176u8 , 167u8 , 200u8 , 114u8 , 106u8 , 125u8 , 65u8 , 176u8 , 234u8 , 192u8 , 95u8 ,] { let entry = ShouldManualRefresh ; self . client . storage () . fetch_or_default (& entry , block_hash) . await } else { Err (:: subxt :: MetadataError :: IncompatibleMetadata . into ()) } } # [doc = " Holds public key for next session"] pub async fn next_dkg_public_key (& self , block_hash : :: core :: option :: Option < T :: Hash > ,) -> :: core :: result :: Result < :: core :: option :: Option < (:: core :: primitive :: u64 , :: std :: vec :: Vec < :: core :: primitive :: u8 > ,) > , :: subxt :: BasicError > { if self . client . metadata () . storage_hash :: < NextDKGPublicKey > () ? == [147u8 , 213u8 , 171u8 , 9u8 , 247u8 , 218u8 , 74u8 , 10u8 , 66u8 , 24u8 , 52u8 , 251u8 , 125u8 , 28u8 , 54u8 , 12u8 , 243u8 , 205u8 , 242u8 , 48u8 , 179u8 , 211u8 , 178u8 , 219u8 , 88u8 , 247u8 , 51u8 , 52u8 , 27u8 , 170u8 , 212u8 , 181u8 ,] { let entry = NextDKGPublicKey ; self . client . storage () . fetch (& entry , block_hash) . await } else { Err (:: subxt :: MetadataError :: IncompatibleMetadata . into ()) } } # [doc = " Signature of the DKG public key for the next session"] pub async fn next_public_key_signature (& self , block_hash : :: core :: option :: Option < T :: Hash > ,) -> :: core :: result :: Result < :: core :: option :: Option < :: std :: vec :: Vec < :: core :: primitive :: u8 > > , :: subxt :: BasicError > { if self . client . metadata () . storage_hash :: < NextPublicKeySignature > () ? == [128u8 , 96u8 , 220u8 , 158u8 , 111u8 , 181u8 , 68u8 , 32u8 , 33u8 , 122u8 , 61u8 , 99u8 , 58u8 , 84u8 , 110u8 , 13u8 , 8u8 , 179u8 , 11u8 , 80u8 , 5u8 , 90u8 , 194u8 , 230u8 , 3u8 , 124u8 , 27u8 , 157u8 , 73u8 , 143u8 , 159u8 , 98u8 ,] { let entry = NextPublicKeySignature ; self . client . storage () . fetch (& entry , block_hash) . await } else { Err (:: subxt :: MetadataError :: IncompatibleMetadata . into ()) } } # [doc = " Holds active public key for ongoing session"] pub async fn dkg_public_key (& self , block_hash : :: core :: option :: Option < T :: Hash > ,) -> :: core :: result :: Result < (:: core :: primitive :: u64 , :: std :: vec :: Vec < :: core :: primitive :: u8 > ,) , :: subxt :: BasicError > { if self . client . metadata () . storage_hash :: < DKGPublicKey > () ? == [134u8 , 73u8 , 251u8 , 94u8 , 50u8 , 143u8 , 130u8 , 71u8 , 180u8 , 91u8 , 29u8 , 20u8 , 105u8 , 138u8 , 225u8 , 205u8 , 180u8 , 94u8 , 203u8 , 106u8 , 109u8 , 101u8 , 114u8 , 3u8 , 182u8 , 236u8 , 231u8 , 124u8 , 198u8 , 106u8 , 102u8 , 242u8 ,] { let entry = DKGPublicKey ; self . client . storage () . fetch_or_default (& entry , block_hash) . await } else { Err (:: subxt :: MetadataError :: IncompatibleMetadata . into ()) } } # [doc = " Signature of the current DKG public key"] pub async fn dkg_public_key_signature (& self , block_hash : :: core :: option :: Option < T :: Hash > ,) -> :: core :: result :: Result < :: std :: vec :: Vec < :: core :: primitive :: u8 > , :: subxt :: BasicError > { if self . client . metadata () . storage_hash :: < DKGPublicKeySignature > () ? == [184u8 , 31u8 , 185u8 , 8u8 , 102u8 , 120u8 , 175u8 , 105u8 , 106u8 , 6u8 , 14u8 , 197u8 , 211u8 , 49u8 , 192u8 , 201u8 , 46u8 , 42u8 , 208u8 , 63u8 , 234u8 , 131u8 , 207u8 , 131u8 , 21u8 , 119u8 , 39u8 , 105u8 , 27u8 , 174u8 , 173u8 , 29u8 ,] { let entry = DKGPublicKeySignature ; self . client . storage () . fetch_or_default (& entry , block_hash) . await } else { Err (:: subxt :: MetadataError :: IncompatibleMetadata . into ()) } } # [doc = " Holds public key for immediate past session"] pub async fn previous_public_key (& self , block_hash : :: core :: option :: Option < T :: Hash > ,) -> :: core :: result :: Result < (:: core :: primitive :: u64 , :: std :: vec :: Vec < :: core :: primitive :: u8 > ,) , :: subxt :: BasicError > { if self . client . metadata () . storage_hash :: < PreviousPublicKey > () ? == [254u8 , 74u8 , 168u8 , 47u8 , 143u8 , 21u8 , 245u8 , 148u8 , 75u8 , 45u8 , 54u8 , 49u8 , 22u8 , 239u8 , 129u8 , 250u8 , 127u8 , 70u8 , 231u8 , 25u8 , 215u8 , 229u8 , 130u8 , 32u8 , 137u8 , 160u8 , 108u8 , 183u8 , 65u8 , 34u8 , 241u8 , 245u8 ,] { let entry = PreviousPublicKey ; self . client . storage () . fetch_or_default (& entry , block_hash) . await } else { Err (:: subxt :: MetadataError :: IncompatibleMetadata . into ()) } } # [doc = " Tracks current proposer set"] pub async fn historical_rounds (& self , _0 : & :: core :: primitive :: u64 , block_hash : :: core :: option :: Option < T :: Hash > ,) -> :: core :: result :: Result < runtime_types :: pallet_dkg_metadata :: types :: RoundMetadata , :: subxt :: BasicError > { if self . client . metadata () . storage_hash :: < HistoricalRounds > () ? == [68u8 , 204u8 , 162u8 , 133u8 , 183u8 , 110u8 , 221u8 , 109u8 , 249u8 , 29u8 , 65u8 , 94u8 , 10u8 , 16u8 , 59u8 , 13u8 , 85u8 , 128u8 , 18u8 , 253u8 , 15u8 , 10u8 , 6u8 , 211u8 , 206u8 , 176u8 , 90u8 , 15u8 , 242u8 , 141u8 , 177u8 , 179u8 ,] { let entry = HistoricalRounds (_0) ; self . client . storage () . fetch_or_default (& entry , block_hash) . await } else { Err (:: subxt :: MetadataError :: IncompatibleMetadata . into ()) } } # [doc = " Tracks current proposer set"] pub async fn historical_rounds_iter (& self , block_hash : :: core :: option :: Option < T :: Hash > ,) -> :: core :: result :: Result < :: subxt :: KeyIter < 'a , T , HistoricalRounds < 'a > > , :: subxt :: BasicError > { if self . client . metadata () . storage_hash :: < HistoricalRounds > () ? == [68u8 , 204u8 , 162u8 , 133u8 , 183u8 , 110u8 , 221u8 , 109u8 , 249u8 , 29u8 , 65u8 , 94u8 , 10u8 , 16u8 , 59u8 , 13u8 , 85u8 , 128u8 , 18u8 , 253u8 , 15u8 , 10u8 , 6u8 , 211u8 , 206u8 , 176u8 , 90u8 , 15u8 , 242u8 , 141u8 , 177u8 , 179u8 ,] { self . client . storage () . iter (block_hash) . await } else { Err (:: subxt :: MetadataError :: IncompatibleMetadata . into ()) } } # [doc = " The current signature threshold (i.e. the `t` in t-of-n)"] pub async fn signature_threshold (& self , block_hash : :: core :: option :: Option < T :: Hash > ,) -> :: core :: result :: Result < :: core :: primitive :: u16 , :: subxt :: BasicError > { if self . client . metadata () . storage_hash :: < SignatureThreshold > () ? == [228u8 , 213u8 , 121u8 , 182u8 , 49u8 , 44u8 , 159u8 , 113u8 , 209u8 , 234u8 , 107u8 , 232u8 , 192u8 , 211u8 , 144u8 , 183u8 , 170u8 , 37u8 , 236u8 , 48u8 , 177u8 , 7u8 , 62u8 , 63u8 , 39u8 , 134u8 , 158u8 , 72u8 , 52u8 , 179u8 , 184u8 , 217u8 ,] { let entry = SignatureThreshold ; self . client . storage () . fetch_or_default (& entry , block_hash) . await } else { Err (:: subxt :: MetadataError :: IncompatibleMetadata . into ()) } } # [doc = " The current signature threshold (i.e. the `n` in t-of-n)"] pub async fn keygen_threshold (& self , block_hash : :: core :: option :: Option < T :: Hash > ,) -> :: core :: result :: Result < :: core :: primitive :: u16 , :: subxt :: BasicError > { if self . client . metadata () . storage_hash :: < KeygenThreshold > () ? == [52u8 , 253u8 , 133u8 , 19u8 , 89u8 , 89u8 , 8u8 , 246u8 , 87u8 , 16u8 , 72u8 , 213u8 , 230u8 , 168u8 , 223u8 , 38u8 , 33u8 , 83u8 , 79u8 , 28u8 , 2u8 , 92u8 , 141u8 , 197u8 , 73u8 , 190u8 , 6u8 , 177u8 , 240u8 , 245u8 , 119u8 , 70u8 ,] { let entry = KeygenThreshold ; self . client . storage () . fetch_or_default (& entry , block_hash) . await } else { Err (:: subxt :: MetadataError :: IncompatibleMetadata . into ()) } } # [doc = " The current signature threshold (i.e. the `t` in t-of-n)"] pub async fn next_signature_threshold (& self , block_hash : :: core :: option :: Option < T :: Hash > ,) -> :: core :: result :: Result < :: core :: primitive :: u16 , :: subxt :: BasicError > { if self . client . metadata () . storage_hash :: < NextSignatureThreshold > () ? == [83u8 , 91u8 , 234u8 , 198u8 , 71u8 , 140u8 , 138u8 , 136u8 , 26u8 , 244u8 , 93u8 , 37u8 , 141u8 , 37u8 , 91u8 , 236u8 , 135u8 , 137u8 , 86u8 , 35u8 , 240u8 , 136u8 , 144u8 , 203u8 , 230u8 , 163u8 , 66u8 , 121u8 , 18u8 , 128u8 , 102u8 , 124u8 ,] { let entry = NextSignatureThreshold ; self . client . storage () . fetch_or_default (& entry , block_hash) . await } else { Err (:: subxt :: MetadataError :: IncompatibleMetadata . into ()) } } # [doc = " The current signature threshold (i.e. the `n` in t-of-n)"] pub async fn next_keygen_threshold (& self , block_hash : :: core :: option :: Option < T :: Hash > ,) -> :: core :: result :: Result < :: core :: primitive :: u16 , :: subxt :: BasicError > { if self . client . metadata () . storage_hash :: < NextKeygenThreshold > () ? == [244u8 , 125u8 , 22u8 , 245u8 , 44u8 , 192u8 , 133u8 , 170u8 , 115u8 , 173u8 , 56u8 , 200u8 , 83u8 , 192u8 , 65u8 , 213u8 , 71u8 , 28u8 , 15u8 , 200u8 , 47u8 , 103u8 , 215u8 , 179u8 , 6u8 , 95u8 , 214u8 , 89u8 , 223u8 , 133u8 , 161u8 , 191u8 ,] { let entry = NextKeygenThreshold ; self . client . storage () . fetch_or_default (& entry , block_hash) . await } else { Err (:: subxt :: MetadataError :: IncompatibleMetadata . into ()) } } # [doc = " The pending signature threshold (i.e. the `t` in t-of-n)"] pub async fn pending_signature_threshold (& self , block_hash : :: core :: option :: Option < T :: Hash > ,) -> :: core :: result :: Result < :: core :: primitive :: u16 , :: subxt :: BasicError > { if self . client . metadata () . storage_hash :: < PendingSignatureThreshold > () ? == [69u8 , 20u8 , 129u8 , 76u8 , 67u8 , 68u8 , 122u8 , 151u8 , 39u8 , 116u8 , 35u8 , 34u8 , 96u8 , 168u8 , 39u8 , 43u8 , 64u8 , 185u8 , 126u8 , 145u8 , 247u8 , 150u8 , 96u8 , 125u8 , 109u8 , 208u8 , 254u8 , 121u8 , 227u8 , 235u8 , 108u8 , 169u8 ,] { let entry = PendingSignatureThreshold ; self . client . storage () . fetch_or_default (& entry , block_hash) . await } else { Err (:: subxt :: MetadataError :: IncompatibleMetadata . into ()) } } # [doc = " The pending signature threshold (i.e. the `n` in t-of-n)"] pub async fn pending_keygen_threshold (& self , block_hash : :: core :: option :: Option < T :: Hash > ,) -> :: core :: result :: Result < :: core :: primitive :: u16 , :: subxt :: BasicError > { if self . client . metadata () . storage_hash :: < PendingKeygenThreshold > () ? == [80u8 , 94u8 , 41u8 , 244u8 , 115u8 , 174u8 , 75u8 , 71u8 , 225u8 , 122u8 , 125u8 , 141u8 , 81u8 , 69u8 , 51u8 , 200u8 , 129u8 , 143u8 , 14u8 , 106u8 , 228u8 , 177u8 , 196u8 , 167u8 , 18u8 , 70u8 , 31u8 , 137u8 , 8u8 , 233u8 , 249u8 , 202u8 ,] { let entry = PendingKeygenThreshold ; self . client . storage () . fetch_or_default (& entry , block_hash) . await } else { Err (:: subxt :: MetadataError :: IncompatibleMetadata . into ()) } } # [doc = " The current authorities set"] pub async fn authorities (& self , block_hash : :: core :: option :: Option < T :: Hash > ,) -> :: core :: result :: Result < :: std :: vec :: Vec < runtime_types :: dkg_runtime_primitives :: crypto :: Public > , :: subxt :: BasicError > { if self . client . metadata () . storage_hash :: < Authorities > () ? == [45u8 , 197u8 , 244u8 , 25u8 , 113u8 , 204u8 , 231u8 , 240u8 , 124u8 , 4u8 , 153u8 , 160u8 , 92u8 , 242u8 , 251u8 , 64u8 , 146u8 , 82u8 , 161u8 , 154u8 , 238u8 , 220u8 , 206u8 , 186u8 , 244u8 , 49u8 , 238u8 , 244u8 , 122u8 , 26u8 , 159u8 , 168u8 ,] { let entry = Authorities ; self . client . storage () . fetch_or_default (& entry , block_hash) . await } else { Err (:: subxt :: MetadataError :: IncompatibleMetadata . into ()) } } # [doc = " The current authority set id"] pub async fn authority_set_id (& self , block_hash : :: core :: option :: Option < T :: Hash > ,) -> :: core :: result :: Result < :: core :: primitive :: u64 , :: subxt :: BasicError > { if self . client . metadata () . storage_hash :: < AuthoritySetId > () ? == [97u8 , 57u8 , 86u8 , 112u8 , 28u8 , 206u8 , 59u8 , 216u8 , 109u8 , 216u8 , 119u8 , 48u8 , 31u8 , 112u8 , 189u8 , 19u8 , 234u8 , 38u8 , 14u8 , 212u8 , 191u8 , 203u8 , 72u8 , 164u8 , 131u8 , 57u8 , 77u8 , 192u8 , 182u8 , 168u8 , 185u8 , 114u8 ,] { let entry = AuthoritySetId ; self . client . storage () . fetch_or_default (& entry , block_hash) . await } else { Err (:: subxt :: MetadataError :: IncompatibleMetadata . into ()) } } # [doc = " The next authority set id"] pub async fn next_authority_set_id (& self , block_hash : :: core :: option :: Option < T :: Hash > ,) -> :: core :: result :: Result < :: core :: primitive :: u64 , :: subxt :: BasicError > { if self . client . metadata () . storage_hash :: < NextAuthoritySetId > () ? == [27u8 , 226u8 , 90u8 , 171u8 , 61u8 , 158u8 , 36u8 , 48u8 , 88u8 , 240u8 , 189u8 , 234u8 , 176u8 , 40u8 , 78u8 , 239u8 , 201u8 , 189u8 , 111u8 , 160u8 , 5u8 , 232u8 , 196u8 , 228u8 , 19u8 , 238u8 , 185u8 , 98u8 , 73u8 , 207u8 , 135u8 , 20u8 ,] { let entry = NextAuthoritySetId ; self . client . storage () . fetch_or_default (& entry , block_hash) . await } else { Err (:: subxt :: MetadataError :: IncompatibleMetadata . into ()) } } # [doc = " Authorities set scheduled to be used with the next session"] pub async fn next_authorities (& self , block_hash : :: core :: option :: Option < T :: Hash > ,) -> :: core :: result :: Result < :: std :: vec :: Vec < runtime_types :: dkg_runtime_primitives :: crypto :: Public > , :: subxt :: BasicError > { if self . client . metadata () . storage_hash :: < NextAuthorities > () ? == [217u8 , 12u8 , 213u8 , 100u8 , 67u8 , 73u8 , 155u8 , 134u8 , 236u8 , 210u8 , 129u8 , 96u8 , 191u8 , 83u8 , 200u8 , 17u8 , 181u8 , 124u8 , 201u8 , 155u8 , 14u8 , 246u8 , 203u8 , 23u8 , 57u8 , 221u8 , 95u8 , 174u8 , 128u8 , 9u8 , 32u8 , 1u8 ,] { let entry = NextAuthorities ; self . client . storage () . fetch_or_default (& entry , block_hash) . await } else { Err (:: subxt :: MetadataError :: IncompatibleMetadata . into ()) } } # [doc = " Accounts for the current authorities"] pub async fn current_authorities_accounts (& self , block_hash : :: core :: option :: Option < T :: Hash > ,) -> :: core :: result :: Result < :: std :: vec :: Vec < :: subxt :: sp_core :: crypto :: AccountId32 > , :: subxt :: BasicError > { if self . client . metadata () . storage_hash :: < CurrentAuthoritiesAccounts > () ? == [143u8 , 155u8 , 186u8 , 132u8 , 219u8 , 16u8 , 177u8 , 244u8 , 116u8 , 144u8 , 165u8 , 191u8 , 14u8 , 56u8 , 62u8 , 63u8 , 18u8 , 33u8 , 41u8 , 252u8 , 56u8 , 98u8 , 40u8 , 14u8 , 249u8 , 170u8 , 6u8 , 101u8 , 31u8 , 90u8 , 101u8 , 35u8 ,] { let entry = CurrentAuthoritiesAccounts ; self . client . storage () . fetch_or_default (& entry , block_hash) . await } else { Err (:: subxt :: MetadataError :: IncompatibleMetadata . into ()) } } # [doc = " Authority account ids scheduled for the next session"] pub async fn next_authorities_accounts (& self , block_hash : :: core :: option :: Option < T :: Hash > ,) -> :: core :: result :: Result < :: std :: vec :: Vec < :: subxt :: sp_core :: crypto :: AccountId32 > , :: subxt :: BasicError > { if self . client . metadata () . storage_hash :: < NextAuthoritiesAccounts > () ? == [13u8 , 29u8 , 34u8 , 81u8 , 8u8 , 237u8 , 117u8 , 154u8 , 204u8 , 126u8 , 180u8 , 185u8 , 26u8 , 3u8 , 214u8 , 240u8 , 106u8 , 66u8 , 205u8 , 195u8 , 182u8 , 72u8 , 210u8 , 240u8 , 88u8 , 85u8 , 97u8 , 154u8 , 176u8 , 72u8 , 128u8 , 72u8 ,] { let entry = NextAuthoritiesAccounts ; self . client . storage () . fetch_or_default (& entry , block_hash) . await } else { Err (:: subxt :: MetadataError :: IncompatibleMetadata . into ()) } } # [doc = " Authority account ids scheduled for the next session"] pub async fn account_to_authority (& self , _0 : & :: subxt :: sp_core :: crypto :: AccountId32 , block_hash : :: core :: option :: Option < T :: Hash > ,) -> :: core :: result :: Result < :: core :: option :: Option < runtime_types :: dkg_runtime_primitives :: crypto :: Public > , :: subxt :: BasicError > { if self . client . metadata () . storage_hash :: < AccountToAuthority > () ? == [9u8 , 173u8 , 43u8 , 145u8 , 55u8 , 81u8 , 127u8 , 90u8 , 228u8 , 13u8 , 32u8 , 72u8 , 33u8 , 13u8 , 193u8 , 171u8 , 247u8 , 159u8 , 147u8 , 15u8 , 119u8 , 213u8 , 108u8 , 148u8 , 130u8 , 10u8 , 80u8 , 141u8 , 207u8 , 109u8 , 19u8 , 190u8 ,] { let entry = AccountToAuthority (_0) ; self . client . storage () . fetch (& entry , block_hash) . await } else { Err (:: subxt :: MetadataError :: IncompatibleMetadata . into ()) } } # [doc = " Authority account ids scheduled for the next session"] pub async fn account_to_authority_iter (& self , block_hash : :: core :: option :: Option < T :: Hash > ,) -> :: core :: result :: Result < :: subxt :: KeyIter < 'a , T , AccountToAuthority < 'a > > , :: subxt :: BasicError > { if self . client . metadata () . storage_hash :: < AccountToAuthority > () ? == [9u8 , 173u8 , 43u8 , 145u8 , 55u8 , 81u8 , 127u8 , 90u8 , 228u8 , 13u8 , 32u8 , 72u8 , 33u8 , 13u8 , 193u8 , 171u8 , 247u8 , 159u8 , 147u8 , 15u8 , 119u8 , 213u8 , 108u8 , 148u8 , 130u8 , 10u8 , 80u8 , 141u8 , 207u8 , 109u8 , 19u8 , 190u8 ,] { self . client . storage () . iter (block_hash) . await } else { Err (:: subxt :: MetadataError :: IncompatibleMetadata . into ()) } } # [doc = " Tracks misbehaviour reports"] pub async fn misbehaviour_reports (& self , _0 : & runtime_types :: dkg_runtime_primitives :: MisbehaviourType , _1 : & :: core :: primitive :: u64 , _2 : & runtime_types :: dkg_runtime_primitives :: crypto :: Public , block_hash : :: core :: option :: Option < T :: Hash > ,) -> :: core :: result :: Result < :: core :: option :: Option < runtime_types :: dkg_runtime_primitives :: AggregatedMisbehaviourReports < runtime_types :: dkg_runtime_primitives :: crypto :: Public > > , :: subxt :: BasicError > { if self . client . metadata () . storage_hash :: < MisbehaviourReports > () ? == [214u8 , 191u8 , 27u8 , 35u8 , 205u8 , 145u8 , 162u8 , 119u8 , 139u8 , 197u8 , 120u8 , 119u8 , 88u8 , 78u8 , 196u8 , 24u8 , 225u8 , 14u8 , 192u8 , 246u8 , 60u8 , 107u8 , 38u8 , 47u8 , 147u8 , 16u8 , 200u8 , 4u8 , 41u8 , 233u8 , 230u8 , 48u8 ,] { let entry = MisbehaviourReports (_0 , _1 , _2) ; self . client . storage () . fetch (& entry , block_hash) . await } else { Err (:: subxt :: MetadataError :: IncompatibleMetadata . into ()) } } # [doc = " Tracks misbehaviour reports"] pub async fn misbehaviour_reports_iter (& self , block_hash : :: core :: option :: Option < T :: Hash > ,) -> :: core :: result :: Result < :: subxt :: KeyIter < 'a , T , MisbehaviourReports < 'a > > , :: subxt :: BasicError > { if self . client . metadata () . storage_hash :: < MisbehaviourReports > () ? == [214u8 , 191u8 , 27u8 , 35u8 , 205u8 , 145u8 , 162u8 , 119u8 , 139u8 , 197u8 , 120u8 , 119u8 , 88u8 , 78u8 , 196u8 , 24u8 , 225u8 , 14u8 , 192u8 , 246u8 , 60u8 , 107u8 , 38u8 , 47u8 , 147u8 , 16u8 , 200u8 , 4u8 , 41u8 , 233u8 , 230u8 , 48u8 ,] { self . client . storage () . iter (block_hash) . await } else { Err (:: subxt :: MetadataError :: IncompatibleMetadata . into ()) } } # [doc = " Tracks authority reputations"] pub async fn authority_reputations (& self , _0 : & runtime_types :: dkg_runtime_primitives :: crypto :: Public , block_hash : :: core :: option :: Option < T :: Hash > ,) -> :: core :: result :: Result < :: core :: primitive :: u128 , :: subxt :: BasicError > { if self . client . metadata () . storage_hash :: < AuthorityReputations > () ? == [28u8 , 53u8 , 70u8 , 152u8 , 69u8 , 174u8 , 255u8 , 70u8 , 170u8 , 125u8 , 51u8 , 63u8 , 180u8 , 13u8 , 223u8 , 163u8 , 241u8 , 137u8 , 156u8 , 105u8 , 144u8 , 178u8 , 255u8 , 226u8 , 203u8 , 188u8 , 171u8 , 30u8 , 62u8 , 254u8 , 123u8 , 103u8 ,] { let entry = AuthorityReputations (_0) ; self . client . storage () . fetch_or_default (& entry , block_hash) . await } else { Err (:: subxt :: MetadataError :: IncompatibleMetadata . into ()) } } # [doc = " Tracks authority reputations"] pub async fn authority_reputations_iter (& self , block_hash : :: core :: option :: Option < T :: Hash > ,) -> :: core :: result :: Result < :: subxt :: KeyIter < 'a , T , AuthorityReputations < 'a > > , :: subxt :: BasicError > { if self . client . metadata () . storage_hash :: < AuthorityReputations > () ? == [28u8 , 53u8 , 70u8 , 152u8 , 69u8 , 174u8 , 255u8 , 70u8 , 170u8 , 125u8 , 51u8 , 63u8 , 180u8 , 13u8 , 223u8 , 163u8 , 241u8 , 137u8 , 156u8 , 105u8 , 144u8 , 178u8 , 255u8 , 226u8 , 203u8 , 188u8 , 171u8 , 30u8 , 62u8 , 254u8 , 123u8 , 103u8 ,] { self . client . storage () . iter (block_hash) . await } else { Err (:: subxt :: MetadataError :: IncompatibleMetadata . into ()) } } # [doc = " Tracks jailed authorities for keygen by mapping"] # [doc = " to the block number when the authority was last jailed"] pub async fn jailed_keygen_authorities (& self , _0 : & runtime_types :: dkg_runtime_primitives :: crypto :: Public , block_hash : :: core :: option :: Option < T :: Hash > ,) -> :: core :: result :: Result < :: core :: primitive :: u32 , :: subxt :: BasicError > { if self . client . metadata () . storage_hash :: < JailedKeygenAuthorities > () ? == [202u8 , 174u8 , 183u8 , 226u8 , 51u8 , 73u8 , 54u8 , 72u8 , 252u8 , 21u8 , 184u8 , 218u8 , 238u8 , 6u8 , 198u8 , 144u8 , 58u8 , 113u8 , 105u8 , 189u8 , 107u8 , 121u8 , 227u8 , 254u8 , 82u8 , 26u8 , 148u8 , 196u8 , 113u8 , 125u8 , 180u8 , 232u8 ,] { let entry = JailedKeygenAuthorities (_0) ; self . client . storage () . fetch_or_default (& entry , block_hash) . await } else { Err (:: subxt :: MetadataError :: IncompatibleMetadata . into ()) } } # [doc = " Tracks jailed authorities for keygen by mapping"] # [doc = " to the block number when the authority was last jailed"] pub async fn jailed_keygen_authorities_iter (& self , block_hash : :: core :: option :: Option < T :: Hash > ,) -> :: core :: result :: Result < :: subxt :: KeyIter < 'a , T , JailedKeygenAuthorities < 'a > > , :: subxt :: BasicError > { if self . client . metadata () . storage_hash :: < JailedKeygenAuthorities > () ? == [202u8 , 174u8 , 183u8 , 226u8 , 51u8 , 73u8 , 54u8 , 72u8 , 252u8 , 21u8 , 184u8 , 218u8 , 238u8 , 6u8 , 198u8 , 144u8 , 58u8 , 113u8 , 105u8 , 189u8 , 107u8 , 121u8 , 227u8 , 254u8 , 82u8 , 26u8 , 148u8 , 196u8 , 113u8 , 125u8 , 180u8 , 232u8 ,] { self . client . storage () . iter (block_hash) . await } else { Err (:: subxt :: MetadataError :: IncompatibleMetadata . into ()) } } # [doc = " Tracks jailed authorities for signing by mapping"] # [doc = " to the block number when the authority was last jailed"] pub async fn jailed_signing_authorities (& self , _0 : & runtime_types :: dkg_runtime_primitives :: crypto :: Public , block_hash : :: core :: option :: Option < T :: Hash > ,) -> :: core :: result :: Result < :: core :: primitive :: u32 , :: subxt :: BasicError > { if self . client . metadata () . storage_hash :: < JailedSigningAuthorities > () ? == [209u8 , 156u8 , 105u8 , 15u8 , 152u8 , 58u8 , 67u8 , 127u8 , 167u8 , 239u8 , 52u8 , 141u8 , 188u8 , 6u8 , 241u8 , 61u8 , 153u8 , 119u8 , 167u8 , 196u8 , 72u8 , 208u8 , 127u8 , 230u8 , 184u8 , 147u8 , 37u8 , 254u8 , 171u8 , 47u8 , 148u8 , 218u8 ,] { let entry = JailedSigningAuthorities (_0) ; self . client . storage () . fetch_or_default (& entry , block_hash) . await } else { Err (:: subxt :: MetadataError :: IncompatibleMetadata . into ()) } } # [doc = " Tracks jailed authorities for signing by mapping"] # [doc = " to the block number when the authority was last jailed"] pub async fn jailed_signing_authorities_iter (& self , block_hash : :: core :: option :: Option < T :: Hash > ,) -> :: core :: result :: Result < :: subxt :: KeyIter < 'a , T , JailedSigningAuthorities < 'a > > , :: subxt :: BasicError > { if self . client . metadata () . storage_hash :: < JailedSigningAuthorities > () ? == [209u8 , 156u8 , 105u8 , 15u8 , 152u8 , 58u8 , 67u8 , 127u8 , 167u8 , 239u8 , 52u8 , 141u8 , 188u8 , 6u8 , 241u8 , 61u8 , 153u8 , 119u8 , 167u8 , 196u8 , 72u8 , 208u8 , 127u8 , 230u8 , 184u8 , 147u8 , 37u8 , 254u8 , 171u8 , 47u8 , 148u8 , 218u8 ,] { self . client . storage () . iter (block_hash) . await } else { Err (:: subxt :: MetadataError :: IncompatibleMetadata . into ()) } } # [doc = " The current best authorities of the active keygen set"] pub async fn best_authorities (& self , block_hash : :: core :: option :: Option < T :: Hash > ,) -> :: core :: result :: Result < :: std :: vec :: Vec < (:: core :: primitive :: u16 , runtime_types :: dkg_runtime_primitives :: crypto :: Public ,) > , :: subxt :: BasicError > { if self . client . metadata () . storage_hash :: < BestAuthorities > () ? == [104u8 , 132u8 , 203u8 , 155u8 , 81u8 , 123u8 , 70u8 , 116u8 , 31u8 , 53u8 , 74u8 , 46u8 , 34u8 , 231u8 , 211u8 , 233u8 , 191u8 , 203u8 , 35u8 , 18u8 , 17u8 , 226u8 , 224u8 , 107u8 , 218u8 , 51u8 , 173u8 , 32u8 , 64u8 , 154u8 , 92u8 , 94u8 ,] { let entry = BestAuthorities ; self . client . storage () . fetch_or_default (& entry , block_hash) . await } else { Err (:: subxt :: MetadataError :: IncompatibleMetadata . into ()) } } # [doc = " The next best authorities of the active keygen set"] pub async fn next_best_authorities (& self , block_hash : :: core :: option :: Option < T :: Hash > ,) -> :: core :: result :: Result < :: std :: vec :: Vec < (:: core :: primitive :: u16 , runtime_types :: dkg_runtime_primitives :: crypto :: Public ,) > , :: subxt :: BasicError > { if self . client . metadata () . storage_hash :: < NextBestAuthorities > () ? == [126u8 , 128u8 , 162u8 , 68u8 , 114u8 , 88u8 , 254u8 , 24u8 , 64u8 , 79u8 , 172u8 , 20u8 , 203u8 , 208u8 , 100u8 , 141u8 , 4u8 , 229u8 , 228u8 , 179u8 , 19u8 , 126u8 , 98u8 , 232u8 , 178u8 , 32u8 , 34u8 , 227u8 , 237u8 , 16u8 , 85u8 , 76u8 ,] { let entry = NextBestAuthorities ; self . client . storage () . fetch_or_default (& entry , block_hash) . await } else { Err (:: subxt :: MetadataError :: IncompatibleMetadata . into ()) } } } } pub mod constants { use super :: runtime_types ; pub struct ConstantsApi < 'a , T : :: subxt :: Config > { client : & 'a :: subxt :: Client < T > , } impl < 'a , T : :: subxt :: Config > ConstantsApi < 'a , T > { pub fn new (client : & 'a :: subxt :: Client < T >) -> Self { Self { client } } # [doc = " Percentage session should have progressed for refresh to begin"] pub fn refresh_delay (& self) -> :: core :: result :: Result < runtime_types :: sp_arithmetic :: per_things :: Permill , :: subxt :: BasicError > { if self . client . metadata () . constant_hash ("DKG" , "RefreshDelay") ? == [34u8 , 177u8 , 141u8 , 188u8 , 147u8 , 221u8 , 100u8 , 94u8 , 234u8 , 115u8 , 144u8 , 160u8 , 97u8 , 109u8 , 223u8 , 56u8 , 161u8 , 104u8 , 71u8 , 57u8 , 206u8 , 163u8 , 185u8 , 43u8 , 14u8 , 126u8 , 111u8 , 88u8 , 184u8 , 192u8 , 19u8 , 207u8 ,] { let pallet = self . client . metadata () . pallet ("DKG") ? ; let constant = pallet . constant ("RefreshDelay") ? ; let value = :: subxt :: codec :: Decode :: decode (& mut & constant . value [..]) ? ; Ok (value) } else { Err (:: subxt :: MetadataError :: IncompatibleMetadata . into ()) } } } } } pub mod dkg_proposals { use super :: root_mod ; use super :: runtime_types ; pub mod calls { use super :: root_mod ; use super :: runtime_types ; type DispatchError = runtime_types :: sp_runtime :: DispatchError ; # [derive (:: subxt :: codec :: CompactAs , :: subxt :: codec :: Decode , :: subxt :: codec :: Encode , Clone , Debug , Eq , PartialEq)] pub struct SetThreshold { pub threshold : :: core :: primitive :: u32 , } impl :: subxt :: Call for SetThreshold { const PALLET : & 'static str = "DKGProposals" ; const FUNCTION : & 'static str = "set_threshold" ; } # [derive (:: subxt :: codec :: Decode , :: subxt :: codec :: Encode , Clone , Debug , Eq , PartialEq)] pub struct SetResource { pub id : runtime_types :: webb_proposals :: header :: ResourceId , pub method : :: std :: vec :: Vec < :: core :: primitive :: u8 > , } impl :: subxt :: Call for SetResource { const PALLET : & 'static str = "DKGProposals" ; const FUNCTION : & 'static str = "set_resource" ; } # [derive (:: subxt :: codec :: Decode , :: subxt :: codec :: Encode , Clone , Debug , Eq , PartialEq)] pub struct RemoveResource { pub id : runtime_types :: webb_proposals :: header :: ResourceId , } impl :: subxt :: Call for RemoveResource { const PALLET : & 'static str = "DKGProposals" ; const FUNCTION : & 'static str = "remove_resource" ; } # [derive (:: subxt :: codec :: Decode , :: subxt :: codec :: Encode , Clone , Debug , Eq , PartialEq)] pub struct WhitelistChain { pub chain_id : runtime_types :: webb_proposals :: header :: TypedChainId , } impl :: subxt :: Call for WhitelistChain { const PALLET : & 'static str = "DKGProposals" ; const FUNCTION : & 'static str = "whitelist_chain" ; } # [derive (:: subxt :: codec :: Decode , :: subxt :: codec :: Encode , Clone , Debug , Eq , PartialEq)] pub struct AddProposer { pub native_account : :: subxt :: sp_core :: crypto :: AccountId32 , pub external_account : :: std :: vec :: Vec < :: core :: primitive :: u8 > , } impl :: subxt :: Call for AddProposer { const PALLET : & 'static str = "DKGProposals" ; const FUNCTION : & 'static str = "add_proposer" ; } # [derive (:: subxt :: codec :: Decode , :: subxt :: codec :: Encode , Clone , Debug , Eq , PartialEq)] pub struct RemoveProposer { pub v : :: subxt :: sp_core :: crypto :: AccountId32 , } impl :: subxt :: Call for RemoveProposer { const PALLET : & 'static str = "DKGProposals" ; const FUNCTION : & 'static str = "remove_proposer" ; } # [derive (:: subxt :: codec :: Decode , :: subxt :: codec :: Encode , Clone , Debug , Eq , PartialEq)] pub struct AcknowledgeProposal { pub nonce : runtime_types :: webb_proposals :: nonce :: Nonce , pub src_chain_id : runtime_types :: webb_proposals :: header :: TypedChainId , pub r_id : runtime_types :: webb_proposals :: header :: ResourceId , pub prop : :: std :: vec :: Vec < :: core :: primitive :: u8 > , } impl :: subxt :: Call for AcknowledgeProposal { const PALLET : & 'static str = "DKGProposals" ; const FUNCTION : & 'static str = "acknowledge_proposal" ; } # [derive (:: subxt :: codec :: Decode , :: subxt :: codec :: Encode , Clone , Debug , Eq , PartialEq)] pub struct RejectProposal { pub nonce : runtime_types :: webb_proposals :: nonce :: Nonce , pub src_chain_id : runtime_types :: webb_proposals :: header :: TypedChainId , pub r_id : runtime_types :: webb_proposals :: header :: ResourceId , pub prop : :: std :: vec :: Vec < :: core :: primitive :: u8 > , } impl :: subxt :: Call for RejectProposal { const PALLET : & 'static str = "DKGProposals" ; const FUNCTION : & 'static str = "reject_proposal" ; } # [derive (:: subxt :: codec :: Decode , :: subxt :: codec :: Encode , Clone , Debug , Eq , PartialEq)] pub struct EvalVoteState { pub nonce : runtime_types :: webb_proposals :: nonce :: Nonce , pub src_chain_id : runtime_types :: webb_proposals :: header :: TypedChainId , pub prop : :: std :: vec :: Vec < :: core :: primitive :: u8 > , } impl :: subxt :: Call for EvalVoteState { const PALLET : & 'static str = "DKGProposals" ; const FUNCTION : & 'static str = "eval_vote_state" ; } pub struct TransactionApi < 'a , T : :: subxt :: Config , X > { client : & 'a :: subxt :: Client < T > , marker : :: core :: marker :: PhantomData < X > , } impl < 'a , T , X > TransactionApi < 'a , T , X > where T : :: subxt :: Config , X : :: subxt :: extrinsic :: ExtrinsicParams < T > , { pub fn new (client : & 'a :: subxt :: Client < T >) -> Self { Self { client , marker : :: core :: marker :: PhantomData } } # [doc = "Sets the vote threshold for proposals."] # [doc = ""] # [doc = "This threshold is used to determine how many votes are required"] # [doc = "before a proposal is executed."] # [doc = ""] # [doc = "# <weight>"] # [doc = "- O(1) lookup and insert"] # [doc = "# </weight>"] pub fn set_threshold (& self , threshold : :: core :: primitive :: u32 ,) -> Result < :: subxt :: SubmittableExtrinsic < 'a , T , X , SetThreshold , DispatchError , root_mod :: Event > , :: subxt :: BasicError > { if self . client . metadata () . call_hash :: < SetThreshold > () ? == [52u8 , 167u8 , 254u8 , 240u8 , 138u8 , 213u8 , 67u8 , 65u8 , 79u8 , 11u8 , 193u8 , 17u8 , 248u8 , 153u8 , 47u8 , 179u8 , 218u8 , 86u8 , 157u8 , 230u8 , 186u8 , 234u8 , 123u8 , 36u8 , 22u8 , 164u8 , 17u8 , 183u8 , 180u8 , 111u8 , 252u8 , 206u8 ,] { let call = SetThreshold { threshold , } ; Ok (:: subxt :: SubmittableExtrinsic :: new (self . client , call)) } else { Err (:: subxt :: MetadataError :: IncompatibleMetadata . into ()) } } # [doc = "Stores a method name on chain under an associated resource ID."] # [doc = ""] # [doc = "# <weight>"] # [doc = "- O(1) write"] # [doc = "# </weight>"] pub fn set_resource (& self , id : runtime_types :: webb_proposals :: header :: ResourceId , method : :: std :: vec :: Vec < :: core :: primitive :: u8 > ,) -> Result < :: subxt :: SubmittableExtrinsic < 'a , T , X , SetResource , DispatchError , root_mod :: Event > , :: subxt :: BasicError > { if self . client . metadata () . call_hash :: < SetResource > () ? == [65u8 , 166u8 , 135u8 , 98u8 , 143u8 , 120u8 , 107u8 , 115u8 , 206u8 , 47u8 , 74u8 , 229u8 , 10u8 , 128u8 , 109u8 , 202u8 , 167u8 , 141u8 , 16u8 , 170u8 , 23u8 , 132u8 , 94u8 , 80u8 , 193u8 , 175u8 , 11u8 , 107u8 , 120u8 , 142u8 , 113u8 , 51u8 ,] { let call = SetResource { id , method , } ; Ok (:: subxt :: SubmittableExtrinsic :: new (self . client , call)) } else { Err (:: subxt :: MetadataError :: IncompatibleMetadata . into ()) } } # [doc = "Removes a resource ID from the resource mapping."] # [doc = ""] # [doc = "After this call, bridge transfers with the associated resource ID"] # [doc = "will be rejected."] # [doc = ""] # [doc = "# <weight>"] # [doc = "- O(1) removal"] # [doc = "# </weight>"] pub fn remove_resource (& self , id : runtime_types :: webb_proposals :: header :: ResourceId ,) -> Result < :: subxt :: SubmittableExtrinsic < 'a , T , X , RemoveResource , DispatchError , root_mod :: Event > , :: subxt :: BasicError > { if self . client . metadata () . call_hash :: < RemoveResource > () ? == [78u8 , 126u8 , 251u8 , 144u8 , 188u8 , 199u8 , 39u8 , 253u8 , 82u8 , 42u8 , 99u8 , 95u8 , 244u8 , 201u8 , 210u8 , 110u8 , 95u8 , 246u8 , 66u8 , 240u8 , 128u8 , 235u8 , 145u8 , 72u8 , 236u8 , 9u8 , 113u8 , 51u8 , 91u8 , 81u8 , 223u8 , 226u8 ,] { let call = RemoveResource { id , } ; Ok (:: subxt :: SubmittableExtrinsic :: new (self . client , call)) } else { Err (:: subxt :: MetadataError :: IncompatibleMetadata . into ()) } } # [doc = "Enables a chain ID as a source or destination for a bridge transfer."] # [doc = ""] # [doc = "# <weight>"] # [doc = "- O(1) lookup and insert"] # [doc = "# </weight>"] pub fn whitelist_chain (& self , chain_id : runtime_types :: webb_proposals :: header :: TypedChainId ,) -> Result < :: subxt :: SubmittableExtrinsic < 'a , T , X , WhitelistChain , DispatchError , root_mod :: Event > , :: subxt :: BasicError > { if self . client . metadata () . call_hash :: < WhitelistChain > () ? == [113u8 , 37u8 , 55u8 , 127u8 , 91u8 , 198u8 , 55u8 , 181u8 , 153u8 , 91u8 , 100u8 , 144u8 , 213u8 , 48u8 , 13u8 , 161u8 , 249u8 , 193u8 , 10u8 , 166u8 , 9u8 , 62u8 , 64u8 , 143u8 , 117u8 , 111u8 , 224u8 , 87u8 , 227u8 , 195u8 , 50u8 , 196u8 ,] { let call = WhitelistChain { chain_id , } ; Ok (:: subxt :: SubmittableExtrinsic :: new (self . client , call)) } else { Err (:: subxt :: MetadataError :: IncompatibleMetadata . into ()) } } # [doc = "Adds a new proposer to the proposer set."] # [doc = ""] # [doc = "# <weight>"] # [doc = "- O(1) lookup and insert"] # [doc = "# </weight>"] pub fn add_proposer (& self , native_account : :: subxt :: sp_core :: crypto :: AccountId32 , external_account : :: std :: vec :: Vec < :: core :: primitive :: u8 > ,) -> Result < :: subxt :: SubmittableExtrinsic < 'a , T , X , AddProposer , DispatchError , root_mod :: Event > , :: subxt :: BasicError > { if self . client . metadata () . call_hash :: < AddProposer > () ? == [242u8 , 216u8 , 225u8 , 176u8 , 155u8 , 212u8 , 134u8 , 196u8 , 170u8 , 136u8 , 230u8 , 164u8 , 145u8 , 82u8 , 90u8 , 204u8 , 235u8 , 92u8 , 14u8 , 136u8 , 177u8 , 123u8 , 178u8 , 218u8 , 154u8 , 130u8 , 125u8 , 222u8 , 24u8 , 206u8 , 121u8 , 20u8 ,] { let call = AddProposer { native_account , external_account , } ; Ok (:: subxt :: SubmittableExtrinsic :: new (self . client , call)) } else { Err (:: subxt :: MetadataError :: IncompatibleMetadata . into ()) } } # [doc = "Removes an existing proposer from the set."] # [doc = ""] # [doc = "# <weight>"] # [doc = "- O(1) lookup and removal"] # [doc = "# </weight>"] pub fn remove_proposer (& self , v : :: subxt :: sp_core :: crypto :: AccountId32 ,) -> Result < :: subxt :: SubmittableExtrinsic < 'a , T , X , RemoveProposer , DispatchError , root_mod :: Event > , :: subxt :: BasicError > { if self . client . metadata () . call_hash :: < RemoveProposer > () ? == [27u8 , 73u8 , 114u8 , 131u8 , 234u8 , 127u8 , 131u8 , 218u8 , 184u8 , 48u8 , 223u8 , 149u8 , 70u8 , 109u8 , 192u8 , 238u8 , 153u8 , 201u8 , 146u8 , 14u8 , 6u8 , 210u8 , 60u8 , 54u8 , 216u8 , 252u8 , 121u8 , 252u8 , 90u8 , 208u8 , 125u8 , 244u8 ,] { let call = RemoveProposer { v , } ; Ok (:: subxt :: SubmittableExtrinsic :: new (self . client , call)) } else { Err (:: subxt :: MetadataError :: IncompatibleMetadata . into ()) } } # [doc = "Commits a vote in favour of the provided proposal."] # [doc = ""] # [doc = "If a proposal with the given nonce and source chain ID does not"] # [doc = "already exist, it will be created with an initial vote in favour"] # [doc = "from the caller."] # [doc = ""] # [doc = "# <weight>"] # [doc = "- weight of proposed call, regardless of whether execution is performed"] # [doc = "# </weight>"] pub fn acknowledge_proposal (& self , nonce : runtime_types :: webb_proposals :: nonce :: Nonce , src_chain_id : runtime_types :: webb_proposals :: header :: TypedChainId , r_id : runtime_types :: webb_proposals :: header :: ResourceId , prop : :: std :: vec :: Vec < :: core :: primitive :: u8 > ,) -> Result < :: subxt :: SubmittableExtrinsic < 'a , T , X , AcknowledgeProposal , DispatchError , root_mod :: Event > , :: subxt :: BasicError > { if self . client . metadata () . call_hash :: < AcknowledgeProposal > () ? == [19u8 , 93u8 , 64u8 , 145u8 , 195u8 , 224u8 , 48u8 , 203u8 , 255u8 , 187u8 , 53u8 , 139u8 , 148u8 , 28u8 , 194u8 , 211u8 , 183u8 , 215u8 , 65u8 , 210u8 , 62u8 , 29u8 , 30u8 , 70u8 , 12u8 , 98u8 , 49u8 , 235u8 , 226u8 , 35u8 , 126u8 , 89u8 ,] { let call = AcknowledgeProposal { nonce , src_chain_id , r_id , prop , } ; Ok (:: subxt :: SubmittableExtrinsic :: new (self . client , call)) } else { Err (:: subxt :: MetadataError :: IncompatibleMetadata . into ()) } } # [doc = "Commits a vote against a provided proposal."] # [doc = ""] # [doc = "# <weight>"] # [doc = "- Fixed, since execution of proposal should not be included"] # [doc = "# </weight>"] pub fn reject_proposal (& self , nonce : runtime_types :: webb_proposals :: nonce :: Nonce , src_chain_id : runtime_types :: webb_proposals :: header :: TypedChainId , r_id : runtime_types :: webb_proposals :: header :: ResourceId , prop : :: std :: vec :: Vec < :: core :: primitive :: u8 > ,) -> Result < :: subxt :: SubmittableExtrinsic < 'a , T , X , RejectProposal , DispatchError , root_mod :: Event > , :: subxt :: BasicError > { if self . client . metadata () . call_hash :: < RejectProposal > () ? == [92u8 , 192u8 , 143u8 , 239u8 , 63u8 , 53u8 , 47u8 , 57u8 , 42u8 , 41u8 , 80u8 , 71u8 , 213u8 , 220u8 , 4u8 , 81u8 , 239u8 , 85u8 , 91u8 , 198u8 , 57u8 , 226u8 , 60u8 , 234u8 , 223u8 , 64u8 , 125u8 , 239u8 , 207u8 , 87u8 , 233u8 , 25u8 ,] { let call = RejectProposal { nonce , src_chain_id , r_id , prop , } ; Ok (:: subxt :: SubmittableExtrinsic :: new (self . client , call)) } else { Err (:: subxt :: MetadataError :: IncompatibleMetadata . into ()) } } # [doc = "Evaluate the state of a proposal given the current vote threshold."] # [doc = ""] # [doc = "A proposal with enough votes will be either executed or cancelled,"] # [doc = "and the status will be updated accordingly."] # [doc = ""] # [doc = "# <weight>"] # [doc = "- weight of proposed call, regardless of whether execution is performed"] # [doc = "# </weight>"] pub fn eval_vote_state (& self , nonce : runtime_types :: webb_proposals :: nonce :: Nonce , src_chain_id : runtime_types :: webb_proposals :: header :: TypedChainId , prop : :: std :: vec :: Vec < :: core :: primitive :: u8 > ,) -> Result < :: subxt :: SubmittableExtrinsic < 'a , T , X , EvalVoteState , DispatchError , root_mod :: Event > , :: subxt :: BasicError > { if self . client . metadata () . call_hash :: < EvalVoteState > () ? == [97u8 , 191u8 , 10u8 , 65u8 , 42u8 , 16u8 , 137u8 , 171u8 , 87u8 , 147u8 , 157u8 , 214u8 , 46u8 , 129u8 , 202u8 , 109u8 , 170u8 , 113u8 , 56u8 , 85u8 , 250u8 , 155u8 , 130u8 , 58u8 , 141u8 , 6u8 , 10u8 , 208u8 , 239u8 , 69u8 , 16u8 , 19u8 ,] { let call = EvalVoteState { nonce , src_chain_id , prop , } ; Ok (:: subxt :: SubmittableExtrinsic :: new (self . client , call)) } else { Err (:: subxt :: MetadataError :: IncompatibleMetadata . into ()) } } } } pub type Event = runtime_types :: pallet_dkg_proposals :: pallet :: Event ; pub mod events { use super :: runtime_types ; # [derive (:: subxt :: codec :: CompactAs , :: subxt :: codec :: Decode , :: subxt :: codec :: Encode , Clone , Debug , Eq , PartialEq)] # [doc = "Vote threshold has changed (new_threshold)"] pub struct ProposerThresholdChanged { pub new_threshold : :: core :: primitive :: u32 , } impl :: subxt :: Event for ProposerThresholdChanged { const PALLET : & 'static str = "DKGProposals" ; const EVENT : & 'static str = "ProposerThresholdChanged" ; } # [derive (:: subxt :: codec :: Decode , :: subxt :: codec :: Encode , Clone , Debug , Eq , PartialEq)] # [doc = "Chain now available for transfers (chain_id)"] pub struct ChainWhitelisted { pub chain_id : runtime_types :: webb_proposals :: header :: TypedChainId , } impl :: subxt :: Event for ChainWhitelisted { const PALLET : & 'static str = "DKGProposals" ; const EVENT : & 'static str = "ChainWhitelisted" ; } # [derive (:: subxt :: codec :: Decode , :: subxt :: codec :: Encode , Clone , Debug , Eq , PartialEq)] # [doc = "Proposer added to set"] pub struct ProposerAdded { pub proposer_id : :: subxt :: sp_core :: crypto :: AccountId32 , } impl :: subxt :: Event for ProposerAdded { const PALLET : & 'static str = "DKGProposals" ; const EVENT : & 'static str = "ProposerAdded" ; } # [derive (:: subxt :: codec :: Decode , :: subxt :: codec :: Encode , Clone , Debug , Eq , PartialEq)] # [doc = "Proposer removed from set"] pub struct ProposerRemoved { pub proposer_id : :: subxt :: sp_core :: crypto :: AccountId32 , } impl :: subxt :: Event for ProposerRemoved { const PALLET : & 'static str = "DKGProposals" ; const EVENT : & 'static str = "ProposerRemoved" ; } # [derive (:: subxt :: codec :: Decode , :: subxt :: codec :: Encode , Clone , Debug , Eq , PartialEq)] # [doc = "Vote submitted in favour of proposal"] pub struct VoteFor { pub chain_id : runtime_types :: webb_proposals :: header :: TypedChainId , pub proposal_nonce : runtime_types :: webb_proposals :: nonce :: Nonce , pub who : :: subxt :: sp_core :: crypto :: AccountId32 , } impl :: subxt :: Event for VoteFor { const PALLET : & 'static str = "DKGProposals" ; const EVENT : & 'static str = "VoteFor" ; } # [derive (:: subxt :: codec :: Decode , :: subxt :: codec :: Encode , Clone , Debug , Eq , PartialEq)] # [doc = "Vot submitted against proposal"] pub struct VoteAgainst { pub chain_id : runtime_types :: webb_proposals :: header :: TypedChainId , pub proposal_nonce : runtime_types :: webb_proposals :: nonce :: Nonce , pub who : :: subxt :: sp_core :: crypto :: AccountId32 , } impl :: subxt :: Event for VoteAgainst { const PALLET : & 'static str = "DKGProposals" ; const EVENT : & 'static str = "VoteAgainst" ; } # [derive (:: subxt :: codec :: Decode , :: subxt :: codec :: Encode , Clone , Debug , Eq , PartialEq)] # [doc = "Voting successful for a proposal"] pub struct ProposalApproved { pub chain_id : runtime_types :: webb_proposals :: header :: TypedChainId , pub proposal_nonce : runtime_types :: webb_proposals :: nonce :: Nonce , } impl :: subxt :: Event for ProposalApproved { const PALLET : & 'static str = "DKGProposals" ; const EVENT : & 'static str = "ProposalApproved" ; } # [derive (:: subxt :: codec :: Decode , :: subxt :: codec :: Encode , Clone , Debug , Eq , PartialEq)] # [doc = "Voting rejected a proposal"] pub struct ProposalRejected { pub chain_id : runtime_types :: webb_proposals :: header :: TypedChainId , pub proposal_nonce : runtime_types :: webb_proposals :: nonce :: Nonce , } impl :: subxt :: Event for ProposalRejected { const PALLET : & 'static str = "DKGProposals" ; const EVENT : & 'static str = "ProposalRejected" ; } # [derive (:: subxt :: codec :: Decode , :: subxt :: codec :: Encode , Clone , Debug , Eq , PartialEq)] # [doc = "Execution of call succeeded"] pub struct ProposalSucceeded { pub chain_id : runtime_types :: webb_proposals :: header :: TypedChainId , pub proposal_nonce : runtime_types :: webb_proposals :: nonce :: Nonce , } impl :: subxt :: Event for ProposalSucceeded { const PALLET : & 'static str = "DKGProposals" ; const EVENT : & 'static str = "ProposalSucceeded" ; } # [derive (:: subxt :: codec :: Decode , :: subxt :: codec :: Encode , Clone , Debug , Eq , PartialEq)] # [doc = "Execution of call failed"] pub struct ProposalFailed { pub chain_id : runtime_types :: webb_proposals :: header :: TypedChainId , pub proposal_nonce : runtime_types :: webb_proposals :: nonce :: Nonce , } impl :: subxt :: Event for ProposalFailed { const PALLET : & 'static str = "DKGProposals" ; const EVENT : & 'static str = "ProposalFailed" ; } # [derive (:: subxt :: codec :: Decode , :: subxt :: codec :: Encode , Clone , Debug , Eq , PartialEq)] # [doc = "Proposers have been reset"] pub struct AuthorityProposersReset { pub proposers : :: std :: vec :: Vec < :: subxt :: sp_core :: crypto :: AccountId32 > , } impl :: subxt :: Event for AuthorityProposersReset { const PALLET : & 'static str = "DKGProposals" ; const EVENT : & 'static str = "AuthorityProposersReset" ; } } pub mod storage { use super :: runtime_types ; pub struct ChainNonces < 'a > (pub & 'a runtime_types :: webb_proposals :: header :: TypedChainId) ; impl :: subxt :: StorageEntry for ChainNonces < '_ > { const PALLET : & 'static str = "DKGProposals" ; const STORAGE : & 'static str = "ChainNonces" ; type Value = runtime_types :: webb_proposals :: nonce :: Nonce ; fn key (& self) -> :: subxt :: StorageEntryKey { :: subxt :: StorageEntryKey :: Map (vec ! [:: subxt :: StorageMapKey :: new (& self . 0 , :: subxt :: StorageHasher :: Blake2_256)]) } } pub struct ProposerThreshold ; impl :: subxt :: StorageEntry for ProposerThreshold { const PALLET : & 'static str = "DKGProposals" ; const STORAGE : & 'static str = "ProposerThreshold" ; type Value = :: core :: primitive :: u32 ; fn key (& self) -> :: subxt :: StorageEntryKey { :: subxt :: StorageEntryKey :: Plain } } pub struct ProposerSetUpdateProposalNonce ; impl :: subxt :: StorageEntry for ProposerSetUpdateProposalNonce { const PALLET : & 'static str = "DKGProposals" ; const STORAGE : & 'static str = "ProposerSetUpdateProposalNonce" ; type Value = :: core :: primitive :: u32 ; fn key (& self) -> :: subxt :: StorageEntryKey { :: subxt :: StorageEntryKey :: Plain } } pub struct Proposers < 'a > (pub & 'a :: subxt :: sp_core :: crypto :: AccountId32) ; impl :: subxt :: StorageEntry for Proposers < '_ > { const PALLET : & 'static str = "DKGProposals" ; const STORAGE : & 'static str = "Proposers" ; type Value = :: core :: primitive :: bool ; fn key (& self) -> :: subxt :: StorageEntryKey { :: subxt :: StorageEntryKey :: Map (vec ! [:: subxt :: StorageMapKey :: new (& self . 0 , :: subxt :: StorageHasher :: Blake2_128Concat)]) } } pub struct ExternalProposerAccounts < 'a > (pub & 'a :: subxt :: sp_core :: crypto :: AccountId32) ; impl :: subxt :: StorageEntry for ExternalProposerAccounts < '_ > { const PALLET : & 'static str = "DKGProposals" ; const STORAGE : & 'static str = "ExternalProposerAccounts" ; type Value = :: std :: vec :: Vec < :: core :: primitive :: u8 > ; fn key (& self) -> :: subxt :: StorageEntryKey { :: subxt :: StorageEntryKey :: Map (vec ! [:: subxt :: StorageMapKey :: new (& self . 0 , :: subxt :: StorageHasher :: Blake2_128Concat)]) } } pub struct AuthorityProposers ; impl :: subxt :: StorageEntry for AuthorityProposers { const PALLET : & 'static str = "DKGProposals" ; const STORAGE : & 'static str = "AuthorityProposers" ; type Value = :: std :: vec :: Vec < :: subxt :: sp_core :: crypto :: AccountId32 > ; fn key (& self) -> :: subxt :: StorageEntryKey { :: subxt :: StorageEntryKey :: Plain } } pub struct ExternalAuthorityProposerAccounts ; impl :: subxt :: StorageEntry for ExternalAuthorityProposerAccounts { const PALLET : & 'static str = "DKGProposals" ; const STORAGE : & 'static str = "ExternalAuthorityProposerAccounts" ; type Value = :: std :: vec :: Vec < :: std :: vec :: Vec < :: core :: primitive :: u8 > > ; fn key (& self) -> :: subxt :: StorageEntryKey { :: subxt :: StorageEntryKey :: Plain } } pub struct ProposerCount ; impl :: subxt :: StorageEntry for ProposerCount { const PALLET : & 'static str = "DKGProposals" ; const STORAGE : & 'static str = "ProposerCount" ; type Value = :: core :: primitive :: u32 ; fn key (& self) -> :: subxt :: StorageEntryKey { :: subxt :: StorageEntryKey :: Plain } } pub struct Votes < 'a > (pub & 'a runtime_types :: webb_proposals :: header :: TypedChainId , pub & 'a (runtime_types :: webb_proposals :: nonce :: Nonce , :: std :: vec :: Vec < :: core :: primitive :: u8 > ,)) ; impl :: subxt :: StorageEntry for Votes < '_ > { const PALLET : & 'static str = "DKGProposals" ; const STORAGE : & 'static str = "Votes" ; type Value = runtime_types :: pallet_dkg_proposals :: types :: ProposalVotes < :: subxt :: sp_core :: crypto :: AccountId32 , :: core :: primitive :: u32 > ; fn key (& self) -> :: subxt :: StorageEntryKey { :: subxt :: StorageEntryKey :: Map (vec ! [:: subxt :: StorageMapKey :: new (& self . 0 , :: subxt :: StorageHasher :: Blake2_256) , :: subxt :: StorageMapKey :: new (& self . 1 , :: subxt :: StorageHasher :: Blake2_256)]) } } pub struct Resources < 'a > (pub & 'a runtime_types :: webb_proposals :: header :: ResourceId) ; impl :: subxt :: StorageEntry for Resources < '_ > { const PALLET : & 'static str = "DKGProposals" ; const STORAGE : & 'static str = "Resources" ; type Value = :: std :: vec :: Vec < :: core :: primitive :: u8 > ; fn key (& self) -> :: subxt :: StorageEntryKey { :: subxt :: StorageEntryKey :: Map (vec ! [:: subxt :: StorageMapKey :: new (& self . 0 , :: subxt :: StorageHasher :: Blake2_256)]) } } pub struct StorageApi < 'a , T : :: subxt :: Config > { client : & 'a :: subxt :: Client < T > , } impl < 'a , T : :: subxt :: Config > StorageApi < 'a , T > { pub fn new (client : & 'a :: subxt :: Client < T >) -> Self { Self { client } } # [doc = " All whitelisted chains and their respective transaction counts"] pub async fn chain_nonces (& self , _0 : & runtime_types :: webb_proposals :: header :: TypedChainId , block_hash : :: core :: option :: Option < T :: Hash > ,) -> :: core :: result :: Result < :: core :: option :: Option < runtime_types :: webb_proposals :: nonce :: Nonce > , :: subxt :: BasicError > { if self . client . metadata () . storage_hash :: < ChainNonces > () ? == [126u8 , 191u8 , 198u8 , 39u8 , 22u8 , 36u8 , 93u8 , 67u8 , 236u8 , 43u8 , 106u8 , 2u8 , 197u8 , 19u8 , 116u8 , 90u8 , 215u8 , 159u8 , 133u8 , 9u8 , 138u8 , 25u8 , 53u8 , 64u8 , 129u8 , 56u8 , 91u8 , 99u8 , 140u8 , 184u8 , 199u8 , 126u8 ,] { let entry = ChainNonces (_0) ; self . client . storage () . fetch (& entry , block_hash) . await } else { Err (:: subxt :: MetadataError :: IncompatibleMetadata . into ()) } } # [doc = " All whitelisted chains and their respective transaction counts"] pub async fn chain_nonces_iter (& self , block_hash : :: core :: option :: Option < T :: Hash > ,) -> :: core :: result :: Result < :: subxt :: KeyIter < 'a , T , ChainNonces < 'a > > , :: subxt :: BasicError > { if self . client . metadata () . storage_hash :: < ChainNonces > () ? == [126u8 , 191u8 , 198u8 , 39u8 , 22u8 , 36u8 , 93u8 , 67u8 , 236u8 , 43u8 , 106u8 , 2u8 , 197u8 , 19u8 , 116u8 , 90u8 , 215u8 , 159u8 , 133u8 , 9u8 , 138u8 , 25u8 , 53u8 , 64u8 , 129u8 , 56u8 , 91u8 , 99u8 , 140u8 , 184u8 , 199u8 , 126u8 ,] { self . client . storage () . iter (block_hash) . await } else { Err (:: subxt :: MetadataError :: IncompatibleMetadata . into ()) } } # [doc = " Number of votes required for a proposal to execute"] pub async fn proposer_threshold (& self , block_hash : :: core :: option :: Option < T :: Hash > ,) -> :: core :: result :: Result < :: core :: primitive :: u32 , :: subxt :: BasicError > { if self . client . metadata () . storage_hash :: < ProposerThreshold > () ? == [129u8 , 174u8 , 171u8 , 36u8 , 172u8 , 108u8 , 139u8 , 176u8 , 152u8 , 127u8 , 52u8 , 68u8 , 109u8 , 238u8 , 50u8 , 176u8 , 49u8 , 78u8 , 240u8 , 36u8 , 94u8 , 247u8 , 215u8 , 82u8 , 109u8 , 10u8 , 81u8 , 156u8 , 14u8 , 247u8 , 39u8 , 154u8 ,] { let entry = ProposerThreshold ; self . client . storage () . fetch_or_default (& entry , block_hash) . await } else { Err (:: subxt :: MetadataError :: IncompatibleMetadata . into ()) } } # [doc = " Proposer Set Update Proposal Nonce"] pub async fn proposer_set_update_proposal_nonce (& self , block_hash : :: core :: option :: Option < T :: Hash > ,) -> :: core :: result :: Result < :: core :: primitive :: u32 , :: subxt :: BasicError > { if self . client . metadata () . storage_hash :: < ProposerSetUpdateProposalNonce > () ? == [118u8 , 52u8 , 184u8 , 159u8 , 206u8 , 28u8 , 122u8 , 219u8 , 168u8 , 206u8 , 143u8 , 16u8 , 128u8 , 31u8 , 254u8 , 40u8 , 45u8 , 92u8 , 183u8 , 46u8 , 80u8 , 19u8 , 131u8 , 6u8 , 26u8 , 105u8 , 81u8 , 174u8 , 10u8 , 154u8 , 186u8 , 157u8 ,] { let entry = ProposerSetUpdateProposalNonce ; self . client . storage () . fetch_or_default (& entry , block_hash) . await } else { Err (:: subxt :: MetadataError :: IncompatibleMetadata . into ()) } } # [doc = " Tracks current proposer set"] pub async fn proposers (& self , _0 : & :: subxt :: sp_core :: crypto :: AccountId32 , block_hash : :: core :: option :: Option < T :: Hash > ,) -> :: core :: result :: Result < :: core :: primitive :: bool , :: subxt :: BasicError > { if self . client . metadata () . storage_hash :: < Proposers > () ? == [137u8 , 239u8 , 193u8 , 226u8 , 156u8 , 178u8 , 137u8 , 139u8 , 181u8 , 99u8 , 72u8 , 129u8 , 47u8 , 24u8 , 41u8 , 41u8 , 180u8 , 191u8 , 219u8 , 186u8 , 240u8 , 143u8 , 127u8 , 146u8 , 93u8 , 164u8 , 181u8 , 112u8 , 197u8 , 207u8 , 149u8 , 218u8 ,] { let entry = Proposers (_0) ; self . client . storage () . fetch_or_default (& entry , block_hash) . await } else { Err (:: subxt :: MetadataError :: IncompatibleMetadata . into ()) } } # [doc = " Tracks current proposer set"] pub async fn proposers_iter (& self , block_hash : :: core :: option :: Option < T :: Hash > ,) -> :: core :: result :: Result < :: subxt :: KeyIter < 'a , T , Proposers < 'a > > , :: subxt :: BasicError > { if self . client . metadata () . storage_hash :: < Proposers > () ? == [137u8 , 239u8 , 193u8 , 226u8 , 156u8 , 178u8 , 137u8 , 139u8 , 181u8 , 99u8 , 72u8 , 129u8 , 47u8 , 24u8 , 41u8 , 41u8 , 180u8 , 191u8 , 219u8 , 186u8 , 240u8 , 143u8 , 127u8 , 146u8 , 93u8 , 164u8 , 181u8 , 112u8 , 197u8 , 207u8 , 149u8 , 218u8 ,] { self . client . storage () . iter (block_hash) . await } else { Err (:: subxt :: MetadataError :: IncompatibleMetadata . into ()) } } # [doc = " Tracks current proposer set external accounts"] # [doc = " Currently meant to store Ethereum compatible 64-bytes ECDSA public keys"] pub async fn external_proposer_accounts (& self , _0 : & :: subxt :: sp_core :: crypto :: AccountId32 , block_hash : :: core :: option :: Option < T :: Hash > ,) -> :: core :: result :: Result < :: std :: vec :: Vec < :: core :: primitive :: u8 > , :: subxt :: BasicError > { if self . client . metadata () . storage_hash :: < ExternalProposerAccounts > () ? == [159u8 , 244u8 , 45u8 , 186u8 , 3u8 , 16u8 , 234u8 , 133u8 , 22u8 , 98u8 , 8u8 , 59u8 , 33u8 , 124u8 , 46u8 , 93u8 , 115u8 , 222u8 , 198u8 , 150u8 , 196u8 , 188u8 , 206u8 , 93u8 , 186u8 , 248u8 , 193u8 , 171u8 , 181u8 , 247u8 , 232u8 , 73u8 ,] { let entry = ExternalProposerAccounts (_0) ; self . client . storage () . fetch_or_default (& entry , block_hash) . await } else { Err (:: subxt :: MetadataError :: IncompatibleMetadata . into ()) } } # [doc = " Tracks current proposer set external accounts"] # [doc = " Currently meant to store Ethereum compatible 64-bytes ECDSA public keys"] pub async fn external_proposer_accounts_iter (& self , block_hash : :: core :: option :: Option < T :: Hash > ,) -> :: core :: result :: Result < :: subxt :: KeyIter < 'a , T , ExternalProposerAccounts < 'a > > , :: subxt :: BasicError > { if self . client . metadata () . storage_hash :: < ExternalProposerAccounts > () ? == [159u8 , 244u8 , 45u8 , 186u8 , 3u8 , 16u8 , 234u8 , 133u8 , 22u8 , 98u8 , 8u8 , 59u8 , 33u8 , 124u8 , 46u8 , 93u8 , 115u8 , 222u8 , 198u8 , 150u8 , 196u8 , 188u8 , 206u8 , 93u8 , 186u8 , 248u8 , 193u8 , 171u8 , 181u8 , 247u8 , 232u8 , 73u8 ,] { self . client . storage () . iter (block_hash) . await } else { Err (:: subxt :: MetadataError :: IncompatibleMetadata . into ()) } } # [doc = " Tracks the authorities that are proposers so we can properly update the proposer set"] # [doc = " across sessions and authority changes."] pub async fn authority_proposers (& self , block_hash : :: core :: option :: Option < T :: Hash > ,) -> :: core :: result :: Result < :: std :: vec :: Vec < :: subxt :: sp_core :: crypto :: AccountId32 > , :: subxt :: BasicError > { if self . client . metadata () . storage_hash :: < AuthorityProposers > () ? == [189u8 , 68u8 , 230u8 , 107u8 , 231u8 , 3u8 , 192u8 , 182u8 , 18u8 , 22u8 , 91u8 , 23u8 , 106u8 , 108u8 , 246u8 , 58u8 , 102u8 , 58u8 , 112u8 , 198u8 , 141u8 , 66u8 , 233u8 , 117u8 , 49u8 , 67u8 , 138u8 , 163u8 , 145u8 , 93u8 , 209u8 , 46u8 ,] { let entry = AuthorityProposers ; self . client . storage () . fetch_or_default (& entry , block_hash) . await } else { Err (:: subxt :: MetadataError :: IncompatibleMetadata . into ()) } } # [doc = " Tracks current proposer set external accounts"] pub async fn external_authority_proposer_accounts (& self , block_hash : :: core :: option :: Option < T :: Hash > ,) -> :: core :: result :: Result < :: std :: vec :: Vec < :: std :: vec :: Vec < :: core :: primitive :: u8 > > , :: subxt :: BasicError > { if self . client . metadata () . storage_hash :: < ExternalAuthorityProposerAccounts > () ? == [180u8 , 223u8 , 172u8 , 35u8 , 236u8 , 128u8 , 207u8 , 140u8 , 38u8 , 75u8 , 40u8 , 243u8 , 244u8 , 122u8 , 7u8 , 25u8 , 120u8 , 152u8 , 240u8 , 169u8 , 165u8 , 208u8 , 190u8 , 127u8 , 189u8 , 117u8 , 160u8 , 34u8 , 243u8 , 253u8 , 223u8 , 18u8 ,] { let entry = ExternalAuthorityProposerAccounts ; self . client . storage () . fetch_or_default (& entry , block_hash) . await } else { Err (:: subxt :: MetadataError :: IncompatibleMetadata . into ()) } } # [doc = " Number of proposers in set"] pub async fn proposer_count (& self , block_hash : :: core :: option :: Option < T :: Hash > ,) -> :: core :: result :: Result < :: core :: primitive :: u32 , :: subxt :: BasicError > { if self . client . metadata () . storage_hash :: < ProposerCount > () ? == [150u8 , 116u8 , 125u8 , 20u8 , 135u8 , 11u8 , 47u8 , 155u8 , 87u8 , 113u8 , 44u8 , 139u8 , 67u8 , 74u8 , 92u8 , 113u8 , 173u8 , 62u8 , 207u8 , 79u8 , 125u8 , 109u8 , 170u8 , 166u8 , 55u8 , 85u8 , 3u8 , 32u8 , 155u8 , 45u8 , 236u8 , 253u8 ,] { let entry = ProposerCount ; self . client . storage () . fetch_or_default (& entry , block_hash) . await } else { Err (:: subxt :: MetadataError :: IncompatibleMetadata . into ()) } } # [doc = " All known proposals."] # [doc = " The key is the hash of the call and the deposit ID, to ensure it's"] # [doc = " unique."] pub async fn votes (& self , _0 : & runtime_types :: webb_proposals :: header :: TypedChainId , _1 : & (runtime_types :: webb_proposals :: nonce :: Nonce , :: std :: vec :: Vec < :: core :: primitive :: u8 > ,) , block_hash : :: core :: option :: Option < T :: Hash > ,) -> :: core :: result :: Result < :: core :: option :: Option < runtime_types :: pallet_dkg_proposals :: types :: ProposalVotes < :: subxt :: sp_core :: crypto :: AccountId32 , :: core :: primitive :: u32 > > , :: subxt :: BasicError > { if self . client . metadata () . storage_hash :: < Votes > () ? == [45u8 , 67u8 , 40u8 , 161u8 , 59u8 , 130u8 , 190u8 , 143u8 , 193u8 , 6u8 , 68u8 , 142u8 , 245u8 , 26u8 , 223u8 , 63u8 , 105u8 , 210u8 , 163u8 , 162u8 , 174u8 , 97u8 , 129u8 , 96u8 , 150u8 , 48u8 , 3u8 , 225u8 , 210u8 , 160u8 , 152u8 , 119u8 ,] { let entry = Votes (_0 , _1) ; self . client . storage () . fetch (& entry , block_hash) . await } else { Err (:: subxt :: MetadataError :: IncompatibleMetadata . into ()) } } # [doc = " All known proposals."] # [doc = " The key is the hash of the call and the deposit ID, to ensure it's"] # [doc = " unique."] pub async fn votes_iter (& self , block_hash : :: core :: option :: Option < T :: Hash > ,) -> :: core :: result :: Result < :: subxt :: KeyIter < 'a , T , Votes < 'a > > , :: subxt :: BasicError > { if self . client . metadata () . storage_hash :: < Votes > () ? == [45u8 , 67u8 , 40u8 , 161u8 , 59u8 , 130u8 , 190u8 , 143u8 , 193u8 , 6u8 , 68u8 , 142u8 , 245u8 , 26u8 , 223u8 , 63u8 , 105u8 , 210u8 , 163u8 , 162u8 , 174u8 , 97u8 , 129u8 , 96u8 , 150u8 , 48u8 , 3u8 , 225u8 , 210u8 , 160u8 , 152u8 , 119u8 ,] { self . client . storage () . iter (block_hash) . await } else { Err (:: subxt :: MetadataError :: IncompatibleMetadata . into ()) } } # [doc = " Utilized by the bridge software to map resource IDs to actual methods"] pub async fn resources (& self , _0 : & runtime_types :: webb_proposals :: header :: ResourceId , block_hash : :: core :: option :: Option < T :: Hash > ,) -> :: core :: result :: Result < :: core :: option :: Option < :: std :: vec :: Vec < :: core :: primitive :: u8 > > , :: subxt :: BasicError > { if self . client . metadata () . storage_hash :: < Resources > () ? == [2u8 , 126u8 , 117u8 , 136u8 , 0u8 , 115u8 , 243u8 , 121u8 , 130u8 , 45u8 , 25u8 , 203u8 , 234u8 , 205u8 , 60u8 , 45u8 , 105u8 , 25u8 , 33u8 , 245u8 , 159u8 , 50u8 , 90u8 , 107u8 , 5u8 , 62u8 , 147u8 , 122u8 , 18u8 , 58u8 , 107u8 , 138u8 ,] { let entry = Resources (_0) ; self . client . storage () . fetch (& entry , block_hash) . await } else { Err (:: subxt :: MetadataError :: IncompatibleMetadata . into ()) } } # [doc = " Utilized by the bridge software to map resource IDs to actual methods"] pub async fn resources_iter (& self , block_hash : :: core :: option :: Option < T :: Hash > ,) -> :: core :: result :: Result < :: subxt :: KeyIter < 'a , T , Resources < 'a > > , :: subxt :: BasicError > { if self . client . metadata () . storage_hash :: < Resources > () ? == [2u8 , 126u8 , 117u8 , 136u8 , 0u8 , 115u8 , 243u8 , 121u8 , 130u8 , 45u8 , 25u8 , 203u8 , 234u8 , 205u8 , 60u8 , 45u8 , 105u8 , 25u8 , 33u8 , 245u8 , 159u8 , 50u8 , 90u8 , 107u8 , 5u8 , 62u8 , 147u8 , 122u8 , 18u8 , 58u8 , 107u8 , 138u8 ,] { self . client . storage () . iter (block_hash) . await } else { Err (:: subxt :: MetadataError :: IncompatibleMetadata . into ()) } } } } pub mod constants { use super :: runtime_types ; pub struct ConstantsApi < 'a , T : :: subxt :: Config > { client : & 'a :: subxt :: Client < T > , } impl < 'a , T : :: subxt :: Config > ConstantsApi < 'a , T > { pub fn new (client : & 'a :: subxt :: Client < T >) -> Self { Self { client } } # [doc = " The identifier for this chain."] # [doc = " This must be unique and must not collide with existing IDs within a"] # [doc = " set of bridged chains."] pub fn chain_identifier (& self) -> :: core :: result :: Result < runtime_types :: webb_proposals :: header :: TypedChainId , :: subxt :: BasicError > { if self . client . metadata () . constant_hash ("DKGProposals" , "ChainIdentifier") ? == [52u8 , 35u8 , 214u8 , 80u8 , 129u8 , 238u8 , 13u8 , 160u8 , 21u8 , 148u8 , 4u8 , 0u8 , 34u8 , 118u8 , 147u8 , 41u8 , 210u8 , 165u8 , 141u8 , 137u8 , 117u8 , 76u8 , 249u8 , 14u8 , 71u8 , 21u8 , 147u8 , 4u8 , 242u8 , 34u8 , 111u8 , 68u8 ,] { let pallet = self . client . metadata () . pallet ("DKGProposals") ? ; let constant = pallet . constant ("ChainIdentifier") ? ; let value = :: subxt :: codec :: Decode :: decode (& mut & constant . value [..]) ? ; Ok (value) } else { Err (:: subxt :: MetadataError :: IncompatibleMetadata . into ()) } } pub fn proposal_lifetime (& self) -> :: core :: result :: Result < :: core :: primitive :: u32 , :: subxt :: BasicError > { if self . client . metadata () . constant_hash ("DKGProposals" , "ProposalLifetime") ? == [35u8 , 86u8 , 18u8 , 170u8 , 148u8 , 201u8 , 144u8 , 246u8 , 23u8 , 203u8 , 119u8 , 251u8 , 230u8 , 72u8 , 38u8 , 95u8 , 70u8 , 10u8 , 227u8 , 153u8 , 138u8 , 96u8 , 186u8 , 123u8 , 39u8 , 28u8 , 64u8 , 12u8 , 31u8 , 16u8 , 120u8 , 206u8 ,] { let pallet = self . client . metadata () . pallet ("DKGProposals") ? ; let constant = pallet . constant ("ProposalLifetime") ? ; let value = :: subxt :: codec :: Decode :: decode (& mut & constant . value [..]) ? ; Ok (value) } else { Err (:: subxt :: MetadataError :: IncompatibleMetadata . into ()) } } # [doc = " The session period"] pub fn period (& self) -> :: core :: result :: Result < :: core :: primitive :: u32 , :: subxt :: BasicError > { if self . client . metadata () . constant_hash ("DKGProposals" , "Period") ? == [187u8 , 184u8 , 238u8 , 110u8 , 174u8 , 34u8 , 204u8 , 156u8 , 122u8 , 102u8 , 237u8 , 5u8 , 34u8 , 85u8 , 34u8 , 171u8 , 156u8 , 53u8 , 40u8 , 237u8 , 39u8 , 63u8 , 227u8 , 57u8 , 34u8 , 61u8 , 33u8 , 186u8 , 232u8 , 68u8 , 197u8 , 30u8 ,] { let pallet = self . client . metadata () . pallet ("DKGProposals") ? ; let constant = pallet . constant ("Period") ? ; let value = :: subxt :: codec :: Decode :: decode (& mut & constant . value [..]) ? ; Ok (value) } else { Err (:: subxt :: MetadataError :: IncompatibleMetadata . into ()) } } } } } pub mod dkg_proposal_handler { use super :: root_mod ; use super :: runtime_types ; pub mod calls { use super :: root_mod ; use super :: runtime_types ; type DispatchError = runtime_types :: sp_runtime :: DispatchError ; # [derive (:: subxt :: codec :: Decode , :: subxt :: codec :: Encode , Clone , Debug , Eq , PartialEq)] pub struct SubmitSignedProposals { pub props : :: std :: vec :: Vec < runtime_types :: dkg_runtime_primitives :: proposal :: Proposal > , } impl :: subxt :: Call for SubmitSignedProposals { const PALLET : & 'static str = "DKGProposalHandler" ; const FUNCTION : & 'static str = "submit_signed_proposals" ; } # [derive (:: subxt :: codec :: Decode , :: subxt :: codec :: Encode , Clone , Debug , Eq , PartialEq)] pub struct ForceSubmitUnsignedProposal { pub prop : runtime_types :: dkg_runtime_primitives :: proposal :: Proposal , } impl :: subxt :: Call for ForceSubmitUnsignedProposal { const PALLET : & 'static str = "DKGProposalHandler" ; const FUNCTION : & 'static str = "force_submit_unsigned_proposal" ; } pub struct TransactionApi < 'a , T : :: subxt :: Config , X > { client : & 'a :: subxt :: Client < T > , marker : :: core :: marker :: PhantomData < X > , } impl < 'a , T , X > TransactionApi < 'a , T , X > where T : :: subxt :: Config , X : :: subxt :: extrinsic :: ExtrinsicParams < T > , { pub fn new (client : & 'a :: subxt :: Client < T >) -> Self { Self { client , marker : :: core :: marker :: PhantomData } } pub fn submit_signed_proposals (& self , props : :: std :: vec :: Vec < runtime_types :: dkg_runtime_primitives :: proposal :: Proposal > ,) -> Result < :: subxt :: SubmittableExtrinsic < 'a , T , X , SubmitSignedProposals , DispatchError , root_mod :: Event > , :: subxt :: BasicError > { if self . client . metadata () . call_hash :: < SubmitSignedProposals > () ? == [156u8 , 161u8 , 126u8 , 188u8 , 21u8 , 186u8 , 122u8 , 180u8 , 78u8 , 175u8 , 140u8 , 111u8 , 10u8 , 38u8 , 66u8 , 254u8 , 138u8 , 37u8 , 115u8 , 187u8 , 255u8 , 222u8 , 22u8 , 230u8 , 117u8 , 157u8 , 205u8 , 32u8 , 123u8 , 14u8 , 136u8 , 227u8 ,] { let call = SubmitSignedProposals { props , } ; Ok (:: subxt :: SubmittableExtrinsic :: new (self . client , call)) } else { Err (:: subxt :: MetadataError :: IncompatibleMetadata . into ()) } } # [doc = "Force submit an unsigned proposal to the DKG"] # [doc = ""] # [doc = "There are certain proposals we'd like to be proposable only"] # [doc = "through root actions. The currently supported proposals are"] # [doc = "\t1. Updating"] pub fn force_submit_unsigned_proposal (& self , prop : runtime_types :: dkg_runtime_primitives :: proposal :: Proposal ,) -> Result < :: subxt :: SubmittableExtrinsic < 'a , T , X , ForceSubmitUnsignedProposal , DispatchError , root_mod :: Event > , :: subxt :: BasicError > { if self . client . metadata () . call_hash :: < ForceSubmitUnsignedProposal > () ? == [62u8 , 173u8 , 173u8 , 166u8 , 248u8 , 172u8 , 104u8 , 204u8 , 165u8 , 8u8 , 141u8 , 253u8 , 205u8 , 111u8 , 129u8 , 47u8 , 141u8 , 29u8 , 122u8 , 66u8 , 68u8 , 231u8 , 26u8 , 48u8 , 165u8 , 189u8 , 16u8 , 180u8 , 140u8 , 232u8 , 18u8 , 41u8 ,] { let call = ForceSubmitUnsignedProposal { prop , } ; Ok (:: subxt :: SubmittableExtrinsic :: new (self . client , call)) } else { Err (:: subxt :: MetadataError :: IncompatibleMetadata . into ()) } } } } pub type Event = runtime_types :: pallet_dkg_proposal_handler :: pallet :: Event ; pub mod events { use super :: runtime_types ; # [derive (:: subxt :: codec :: Decode , :: subxt :: codec :: Encode , Clone , Debug , Eq , PartialEq)] # [doc = "Event Emitted when we encounter a Proposal with invalid Signature."] pub struct InvalidProposalSignature { pub kind : runtime_types :: dkg_runtime_primitives :: proposal :: ProposalKind , pub data : :: std :: vec :: Vec < :: core :: primitive :: u8 > , pub invalid_signature : :: std :: vec :: Vec < :: core :: primitive :: u8 > , pub expected_public_key : :: core :: option :: Option < :: std :: vec :: Vec < :: core :: primitive :: u8 > > , pub actual_public_key : :: core :: option :: Option < :: std :: vec :: Vec < :: core :: primitive :: u8 > > , } impl :: subxt :: Event for InvalidProposalSignature { const PALLET : & 'static str = "DKGProposalHandler" ; const EVENT : & 'static str = "InvalidProposalSignature" ; } # [derive (:: subxt :: codec :: Decode , :: subxt :: codec :: Encode , Clone , Debug , Eq , PartialEq)] # [doc = "Event When a Proposal Gets Signed by DKG."] pub struct ProposalSigned { pub key : runtime_types :: dkg_runtime_primitives :: proposal :: DKGPayloadKey , pub target_chain : runtime_types :: webb_proposals :: header :: TypedChainId , pub data : :: std :: vec :: Vec < :: core :: primitive :: u8 > , pub signature : :: std :: vec :: Vec < :: core :: primitive :: u8 > , } impl :: subxt :: Event for ProposalSigned { const PALLET : & 'static str = "DKGProposalHandler" ; const EVENT : & 'static str = "ProposalSigned" ; } } pub mod storage { use super :: runtime_types ; pub struct UnsignedProposalQueue < 'a > (pub & 'a runtime_types :: webb_proposals :: header :: TypedChainId , pub & 'a runtime_types :: dkg_runtime_primitives :: proposal :: DKGPayloadKey) ; impl :: subxt :: StorageEntry for UnsignedProposalQueue < '_ > { const PALLET : & 'static str = "DKGProposalHandler" ; const STORAGE : & 'static str = "UnsignedProposalQueue" ; type Value = runtime_types :: dkg_runtime_primitives :: proposal :: StoredUnsignedProposal < :: core :: primitive :: u32 > ; fn key (& self) -> :: subxt :: StorageEntryKey { :: subxt :: StorageEntryKey :: Map (vec ! [:: subxt :: StorageMapKey :: new (& self . 0 , :: subxt :: StorageHasher :: Blake2_128Concat) , :: subxt :: StorageMapKey :: new (& self . 1 , :: subxt :: StorageHasher :: Blake2_128Concat)]) } } pub struct SignedProposals < 'a > (pub & 'a runtime_types :: webb_proposals :: header :: TypedChainId , pub & 'a runtime_types :: dkg_runtime_primitives :: proposal :: DKGPayloadKey) ; impl :: subxt :: StorageEntry for SignedProposals < '_ > { const PALLET : & 'static str = "DKGProposalHandler" ; const STORAGE : & 'static str = "SignedProposals" ; type Value = runtime_types :: dkg_runtime_primitives :: proposal :: Proposal ; fn key (& self) -> :: subxt :: StorageEntryKey { :: subxt :: StorageEntryKey :: Map (vec ! [:: subxt :: StorageMapKey :: new (& self . 0 , :: subxt :: StorageHasher :: Blake2_128Concat) , :: subxt :: StorageMapKey :: new (& self . 1 , :: subxt :: StorageHasher :: Blake2_128Concat)]) } } pub struct StorageApi < 'a , T : :: subxt :: Config > { client : & 'a :: subxt :: Client < T > , } impl < 'a , T : :: subxt :: Config > StorageApi < 'a , T > { pub fn new (client : & 'a :: subxt :: Client < T >) -> Self { Self { client } } # [doc = " All unsigned proposals."] pub async fn unsigned_proposal_queue (& self , _0 : & runtime_types :: webb_proposals :: header :: TypedChainId , _1 : & runtime_types :: dkg_runtime_primitives :: proposal :: DKGPayloadKey , block_hash : :: core :: option :: Option < T :: Hash > ,) -> :: core :: result :: Result < :: core :: option :: Option < runtime_types :: dkg_runtime_primitives :: proposal :: StoredUnsignedProposal < :: core :: primitive :: u32 > > , :: subxt :: BasicError > { if self . client . metadata () . storage_hash :: < UnsignedProposalQueue > () ? == [20u8 , 204u8 , 178u8 , 224u8 , 247u8 , 124u8 , 161u8 , 192u8 , 84u8 , 56u8 , 80u8 , 1u8 , 181u8 , 251u8 , 77u8 , 142u8 , 12u8 , 103u8 , 212u8 , 140u8 , 90u8 , 89u8 , 158u8 , 209u8 , 76u8 , 59u8 , 221u8 , 147u8 , 143u8 , 23u8 , 138u8 , 154u8 ,] { let entry = UnsignedProposalQueue (_0 , _1) ; self . client . storage () . fetch (& entry , block_hash) . await } else { Err (:: subxt :: MetadataError :: IncompatibleMetadata . into ()) } } # [doc = " All unsigned proposals."] pub async fn unsigned_proposal_queue_iter (& self , block_hash : :: core :: option :: Option < T :: Hash > ,) -> :: core :: result :: Result < :: subxt :: KeyIter < 'a , T , UnsignedProposalQueue < 'a > > , :: subxt :: BasicError > { if self . client . metadata () . storage_hash :: < UnsignedProposalQueue > () ? == [20u8 , 204u8 , 178u8 , 224u8 , 247u8 , 124u8 , 161u8 , 192u8 , 84u8 , 56u8 , 80u8 , 1u8 , 181u8 , 251u8 , 77u8 , 142u8 , 12u8 , 103u8 , 212u8 , 140u8 , 90u8 , 89u8 , 158u8 , 209u8 , 76u8 , 59u8 , 221u8 , 147u8 , 143u8 , 23u8 , 138u8 , 154u8 ,] { self . client . storage () . iter (block_hash) . await } else { Err (:: subxt :: MetadataError :: IncompatibleMetadata . into ()) } } # [doc = " All signed proposals."] pub async fn signed_proposals (& self , _0 : & runtime_types :: webb_proposals :: header :: TypedChainId , _1 : & runtime_types :: dkg_runtime_primitives :: proposal :: DKGPayloadKey , block_hash : :: core :: option :: Option < T :: Hash > ,) -> :: core :: result :: Result < :: core :: option :: Option < runtime_types :: dkg_runtime_primitives :: proposal :: Proposal > , :: subxt :: BasicError > { if self . client . metadata () . storage_hash :: < SignedProposals > () ? == [101u8 , 208u8 , 39u8 , 210u8 , 50u8 , 177u8 , 154u8 , 181u8 , 140u8 , 8u8 , 139u8 , 165u8 , 166u8 , 233u8 , 38u8 , 166u8 , 53u8 , 196u8 , 163u8 , 33u8 , 234u8 , 192u8 , 213u8 , 1u8 , 75u8 , 38u8 , 192u8 , 99u8 , 153u8 , 118u8 , 123u8 , 106u8 ,] { let entry = SignedProposals (_0 , _1) ; self . client . storage () . fetch (& entry , block_hash) . await } else { Err (:: subxt :: MetadataError :: IncompatibleMetadata . into ()) } } # [doc = " All signed proposals."] pub async fn signed_proposals_iter (& self , block_hash : :: core :: option :: Option < T :: Hash > ,) -> :: core :: result :: Result < :: subxt :: KeyIter < 'a , T , SignedProposals < 'a > > , :: subxt :: BasicError > { if self . client . metadata () . storage_hash :: < SignedProposals > () ? == [101u8 , 208u8 , 39u8 , 210u8 , 50u8 , 177u8 , 154u8 , 181u8 , 140u8 , 8u8 , 139u8 , 165u8 , 166u8 , 233u8 , 38u8 , 166u8 , 53u8 , 196u8 , 163u8 , 33u8 , 234u8 , 192u8 , 213u8 , 1u8 , 75u8 , 38u8 , 192u8 , 99u8 , 153u8 , 118u8 , 123u8 , 106u8 ,] { self . client . storage () . iter (block_hash) . await } else { Err (:: subxt :: MetadataError :: IncompatibleMetadata . into ()) } } } } pub mod constants { use super :: runtime_types ; pub struct ConstantsApi < 'a , T : :: subxt :: Config > { client : & 'a :: subxt :: Client < T > , } impl < 'a , T : :: subxt :: Config > ConstantsApi < 'a , T > { pub fn new (client : & 'a :: subxt :: Client < T >) -> Self { Self { client } } # [doc = " Max number of signed proposal submissions per batch;"] pub fn max_submissions_per_batch (& self) -> :: core :: result :: Result < :: core :: primitive :: u16 , :: subxt :: BasicError > { if self . client . metadata () . constant_hash ("DKGProposalHandler" , "MaxSubmissionsPerBatch") ? == [137u8 , 131u8 , 2u8 , 168u8 , 44u8 , 84u8 , 1u8 , 54u8 , 42u8 , 54u8 , 128u8 , 211u8 , 84u8 , 154u8 , 199u8 , 9u8 , 14u8 , 115u8 , 117u8 , 141u8 , 225u8 , 236u8 , 81u8 , 61u8 , 24u8 , 249u8 , 54u8 , 106u8 , 14u8 , 49u8 , 255u8 , 227u8 ,] { let pallet = self . client . metadata () . pallet ("DKGProposalHandler") ? ; let constant = pallet . constant ("MaxSubmissionsPerBatch") ? ; let value = :: subxt :: codec :: Decode :: decode (& mut & constant . value [..]) ? ; Ok (value) } else { Err (:: subxt :: MetadataError :: IncompatibleMetadata . into ()) } } # [doc = " Max blocks to store an unsigned proposal"] pub fn unsigned_proposal_expiry (& self) -> :: core :: result :: Result < :: core :: primitive :: u32 , :: subxt :: BasicError > { if self . client . metadata () . constant_hash ("DKGProposalHandler" , "UnsignedProposalExpiry") ? == [95u8 , 216u8 , 56u8 , 164u8 , 254u8 , 166u8 , 117u8 , 73u8 , 111u8 , 249u8 , 165u8 , 25u8 , 30u8 , 107u8 , 178u8 , 89u8 , 90u8 , 242u8 , 56u8 , 250u8 , 186u8 , 13u8 , 97u8 , 34u8 , 124u8 , 125u8 , 20u8 , 99u8 , 199u8 , 37u8 , 12u8 , 204u8 ,] { let pallet = self . client . metadata () . pallet ("DKGProposalHandler") ? ; let constant = pallet . constant ("UnsignedProposalExpiry") ? ; let value = :: subxt :: codec :: Decode :: decode (& mut & constant . value [..]) ? ; Ok (value) } else { Err (:: subxt :: MetadataError :: IncompatibleMetadata . into ()) } } } } } pub mod hasher_bn254 { use super :: root_mod ; use super :: runtime_types ; pub mod calls { use super :: root_mod ; use super :: runtime_types ; type DispatchError = runtime_types :: sp_runtime :: DispatchError ; # [derive (:: subxt :: codec :: Decode , :: subxt :: codec :: Encode , Clone , Debug , Eq , PartialEq)] pub struct ForceSetParameters { pub parameters : :: std :: vec :: Vec < :: core :: primitive :: u8 > , } impl :: subxt :: Call for ForceSetParameters { const PALLET : & 'static str = "HasherBn254" ; const FUNCTION : & 'static str = "force_set_parameters" ; } pub struct TransactionApi < 'a , T : :: subxt :: Config , X > { client : & 'a :: subxt :: Client < T > , marker : :: core :: marker :: PhantomData < X > , } impl < 'a , T , X > TransactionApi < 'a , T , X > where T : :: subxt :: Config , X : :: subxt :: extrinsic :: ExtrinsicParams < T > , { pub fn new (client : & 'a :: subxt :: Client < T >) -> Self { Self { client , marker : :: core :: marker :: PhantomData } } pub fn force_set_parameters (& self , parameters : :: std :: vec :: Vec < :: core :: primitive :: u8 > ,) -> Result < :: subxt :: SubmittableExtrinsic < 'a , T , X , ForceSetParameters , DispatchError , root_mod :: Event > , :: subxt :: BasicError > { if self . client . metadata () . call_hash :: < ForceSetParameters > () ? == [4u8 , 152u8 , 126u8 , 7u8 , 21u8 , 41u8 , 229u8 , 72u8 , 49u8 , 177u8 , 34u8 , 57u8 , 44u8 , 27u8 , 82u8 , 102u8 , 214u8 , 37u8 , 20u8 , 122u8 , 7u8 , 179u8 , 196u8 , 112u8 , 192u8 , 168u8 , 247u8 , 171u8 , 177u8 , 42u8 , 167u8 , 15u8 ,] { let call = ForceSetParameters { parameters , } ; Ok (:: subxt :: SubmittableExtrinsic :: new (self . client , call)) } else { Err (:: subxt :: MetadataError :: IncompatibleMetadata . into ()) } } } } pub type Event = runtime_types :: pallet_hasher :: pallet :: Event ; pub mod events { use super :: runtime_types ; } pub mod storage { use super :: runtime_types ; pub struct Parameters ; impl :: subxt :: StorageEntry for Parameters { const PALLET : & 'static str = "HasherBn254" ; const STORAGE : & 'static str = "Parameters" ; type Value = :: std :: vec :: Vec < :: core :: primitive :: u8 > ; fn key (& self) -> :: subxt :: StorageEntryKey { :: subxt :: StorageEntryKey :: Plain } } pub struct StorageApi < 'a , T : :: subxt :: Config > { client : & 'a :: subxt :: Client < T > , } impl < 'a , T : :: subxt :: Config > StorageApi < 'a , T > { pub fn new (client : & 'a :: subxt :: Client < T >) -> Self { Self { client } } # [doc = " Details of the module's parameters"] pub async fn parameters (& self , block_hash : :: core :: option :: Option < T :: Hash > ,) -> :: core :: result :: Result < :: std :: vec :: Vec < :: core :: primitive :: u8 > , :: subxt :: BasicError > { if self . client . metadata () . storage_hash :: < Parameters > () ? == [244u8 , 201u8 , 192u8 , 254u8 , 217u8 , 76u8 , 12u8 , 84u8 , 71u8 , 96u8 , 64u8 , 115u8 , 66u8 , 74u8 , 252u8 , 59u8 , 193u8 , 35u8 , 136u8 , 67u8 , 55u8 , 96u8 , 185u8 , 129u8 , 130u8 , 120u8 , 224u8 , 100u8 , 199u8 , 83u8 , 107u8 , 187u8 ,] { let entry = Parameters ; self . client . storage () . fetch_or_default (& entry , block_hash) . await } else { Err (:: subxt :: MetadataError :: IncompatibleMetadata . into ()) } } } } } pub mod asset_registry { use super :: root_mod ; use super :: runtime_types ; pub mod calls { use super :: root_mod ; use super :: runtime_types ; type DispatchError = runtime_types :: sp_runtime :: DispatchError ; # [derive (:: subxt :: codec :: Decode , :: subxt :: codec :: Encode , Clone , Debug , Eq , PartialEq)] pub struct Register { pub name : :: std :: vec :: Vec < :: core :: primitive :: u8 > , pub asset_type : runtime_types :: pallet_asset_registry :: types :: AssetType < :: core :: primitive :: u32 > , pub existential_deposit : :: core :: primitive :: u128 , } impl :: subxt :: Call for Register { const PALLET : & 'static str = "AssetRegistry" ; const FUNCTION : & 'static str = "register" ; } # [derive (:: subxt :: codec :: Decode , :: subxt :: codec :: Encode , Clone , Debug , Eq , PartialEq)] pub struct Update { pub asset_id : :: core :: primitive :: u32 , pub name : :: std :: vec :: Vec < :: core :: primitive :: u8 > , pub asset_type : runtime_types :: pallet_asset_registry :: types :: AssetType < :: core :: primitive :: u32 > , pub existential_deposit : :: core :: option :: Option < :: core :: primitive :: u128 > , } impl :: subxt :: Call for Update { const PALLET : & 'static str = "AssetRegistry" ; const FUNCTION : & 'static str = "update" ; } # [derive (:: subxt :: codec :: Decode , :: subxt :: codec :: Encode , Clone , Debug , Eq , PartialEq)] pub struct SetMetadata { pub asset_id : :: core :: primitive :: u32 , pub symbol : :: std :: vec :: Vec < :: core :: primitive :: u8 > , pub decimals : :: core :: primitive :: u8 , } impl :: subxt :: Call for SetMetadata { const PALLET : & 'static str = "AssetRegistry" ; const FUNCTION : & 'static str = "set_metadata" ; } # [derive (:: subxt :: codec :: Decode , :: subxt :: codec :: Encode , Clone , Debug , Eq , PartialEq)] pub struct SetLocation { pub asset_id : :: core :: primitive :: u32 , pub location : :: core :: primitive :: u32 , } impl :: subxt :: Call for SetLocation { const PALLET : & 'static str = "AssetRegistry" ; const FUNCTION : & 'static str = "set_location" ; } # [derive (:: subxt :: codec :: Decode , :: subxt :: codec :: Encode , Clone , Debug , Eq , PartialEq)] pub struct AddAssetToPool { pub pool : :: std :: vec :: Vec < :: core :: primitive :: u8 > , pub asset_id : :: core :: primitive :: u32 , } impl :: subxt :: Call for AddAssetToPool { const PALLET : & 'static str = "AssetRegistry" ; const FUNCTION : & 'static str = "add_asset_to_pool" ; } # [derive (:: subxt :: codec :: Decode , :: subxt :: codec :: Encode , Clone , Debug , Eq , PartialEq)] pub struct DeleteAssetFromPool { pub pool : :: std :: vec :: Vec < :: core :: primitive :: u8 > , pub asset_id : :: core :: primitive :: u32 , } impl :: subxt :: Call for DeleteAssetFromPool { const PALLET : & 'static str = "AssetRegistry" ; const FUNCTION : & 'static str = "delete_asset_from_pool" ; } pub struct TransactionApi < 'a , T : :: subxt :: Config , X > { client : & 'a :: subxt :: Client < T > , marker : :: core :: marker :: PhantomData < X > , } impl < 'a , T , X > TransactionApi < 'a , T , X > where T : :: subxt :: Config , X : :: subxt :: extrinsic :: ExtrinsicParams < T > , { pub fn new (client : & 'a :: subxt :: Client < T >) -> Self { Self { client , marker : :: core :: marker :: PhantomData } } # [doc = "Register a new asset."] # [doc = ""] # [doc = "Asset is identified by `name` and the name must not be used to"] # [doc = "register another asset."] # [doc = ""] # [doc = "New asset is given `NextAssetId` - sequential asset id"] # [doc = ""] # [doc = "Adds mapping between `name` and assigned `asset_id` so asset id can"] # [doc = "be retrieved by name too (Note: this approach is used in AMM"] # [doc = "implementation (xyk))"] # [doc = ""] # [doc = "Emits 'Registered` event when successful."] pub fn register (& self , name : :: std :: vec :: Vec < :: core :: primitive :: u8 > , asset_type : runtime_types :: pallet_asset_registry :: types :: AssetType < :: core :: primitive :: u32 > , existential_deposit : :: core :: primitive :: u128 ,) -> Result < :: subxt :: SubmittableExtrinsic < 'a , T , X , Register , DispatchError , root_mod :: Event > , :: subxt :: BasicError > { if self . client . metadata () . call_hash :: < Register > () ? == [44u8 , 233u8 , 244u8 , 188u8 , 16u8 , 33u8 , 214u8 , 55u8 , 123u8 , 36u8 , 6u8 , 68u8 , 159u8 , 64u8 , 81u8 , 225u8 , 134u8 , 144u8 , 80u8 , 199u8 , 20u8 , 250u8 , 231u8 , 197u8 , 15u8 , 154u8 , 237u8 , 148u8 , 66u8 , 46u8 , 89u8 , 148u8 ,] { let call = Register { name , asset_type , existential_deposit , } ; Ok (:: subxt :: SubmittableExtrinsic :: new (self . client , call)) } else { Err (:: subxt :: MetadataError :: IncompatibleMetadata . into ()) } } # [doc = "Update registered asset."] # [doc = ""] # [doc = "Updates also mapping between name and asset id if provided name is"] # [doc = "different than currently registered."] # [doc = ""] # [doc = "Emits `Updated` event when successful."] pub fn update (& self , asset_id : :: core :: primitive :: u32 , name : :: std :: vec :: Vec < :: core :: primitive :: u8 > , asset_type : runtime_types :: pallet_asset_registry :: types :: AssetType < :: core :: primitive :: u32 > , existential_deposit : :: core :: option :: Option < :: core :: primitive :: u128 > ,) -> Result < :: subxt :: SubmittableExtrinsic < 'a , T , X , Update , DispatchError , root_mod :: Event > , :: subxt :: BasicError > { if self . client . metadata () . call_hash :: < Update > () ? == [233u8 , 101u8 , 117u8 , 159u8 , 49u8 , 184u8 , 66u8 , 72u8 , 41u8 , 127u8 , 78u8 , 130u8 , 125u8 , 180u8 , 57u8 , 215u8 , 26u8 , 55u8 , 66u8 , 240u8 , 220u8 , 66u8 , 19u8 , 24u8 , 155u8 , 62u8 , 181u8 , 74u8 , 66u8 , 169u8 , 103u8 , 198u8 ,] { let call = Update { asset_id , name , asset_type , existential_deposit , } ; Ok (:: subxt :: SubmittableExtrinsic :: new (self . client , call)) } else { Err (:: subxt :: MetadataError :: IncompatibleMetadata . into ()) } } # [doc = "Set metadata for an asset."] # [doc = ""] # [doc = "- `asset_id`: Asset identifier."] # [doc = "- `symbol`: The exchange symbol for this asset. Limited in length by `StringLimit`."] # [doc = "- `decimals`: The number of decimals this asset uses to represent one unit."] # [doc = ""] # [doc = "Emits `MetadataSet` event when successful."] pub fn set_metadata (& self , asset_id : :: core :: primitive :: u32 , symbol : :: std :: vec :: Vec < :: core :: primitive :: u8 > , decimals : :: core :: primitive :: u8 ,) -> Result < :: subxt :: SubmittableExtrinsic < 'a , T , X , SetMetadata , DispatchError , root_mod :: Event > , :: subxt :: BasicError > { if self . client . metadata () . call_hash :: < SetMetadata > () ? == [127u8 , 134u8 , 111u8 , 245u8 , 15u8 , 251u8 , 178u8 , 68u8 , 145u8 , 205u8 , 54u8 , 247u8 , 108u8 , 40u8 , 241u8 , 134u8 , 35u8 , 136u8 , 210u8 , 138u8 , 180u8 , 153u8 , 148u8 , 225u8 , 208u8 , 46u8 , 251u8 , 242u8 , 60u8 , 144u8 , 74u8 , 44u8 ,] { let call = SetMetadata { asset_id , symbol , decimals , } ; Ok (:: subxt :: SubmittableExtrinsic :: new (self . client , call)) } else { Err (:: subxt :: MetadataError :: IncompatibleMetadata . into ()) } } # [doc = "Set asset native location."] # [doc = ""] # [doc = "Adds mapping between native location and local asset id and vice"] # [doc = "versa."] # [doc = ""] # [doc = "Mainly used in XCM."] # [doc = ""] # [doc = "Emits `LocationSet` event when successful."] pub fn set_location (& self , asset_id : :: core :: primitive :: u32 , location : :: core :: primitive :: u32 ,) -> Result < :: subxt :: SubmittableExtrinsic < 'a , T , X , SetLocation , DispatchError , root_mod :: Event > , :: subxt :: BasicError > { if self . client . metadata () . call_hash :: < SetLocation > () ? == [80u8 , 217u8 , 100u8 , 100u8 , 181u8 , 125u8 , 138u8 , 52u8 , 176u8 , 92u8 , 226u8 , 3u8 , 92u8 , 1u8 , 13u8 , 61u8 , 119u8 , 18u8 , 27u8 , 197u8 , 36u8 , 131u8 , 224u8 , 125u8 , 24u8 , 75u8 , 9u8 , 130u8 , 63u8 , 151u8 , 135u8 , 117u8 ,] { let call = SetLocation { asset_id , location , } ; Ok (:: subxt :: SubmittableExtrinsic :: new (self . client , call)) } else { Err (:: subxt :: MetadataError :: IncompatibleMetadata . into ()) } } # [doc = "Add an asset to an existing pool."] pub fn add_asset_to_pool (& self , pool : :: std :: vec :: Vec < :: core :: primitive :: u8 > , asset_id : :: core :: primitive :: u32 ,) -> Result < :: subxt :: SubmittableExtrinsic < 'a , T , X , AddAssetToPool , DispatchError , root_mod :: Event > , :: subxt :: BasicError > { if self . client . metadata () . call_hash :: < AddAssetToPool > () ? == [52u8 , 7u8 , 49u8 , 182u8 , 239u8 , 123u8 , 50u8 , 85u8 , 19u8 , 54u8 , 204u8 , 222u8 , 178u8 , 139u8 , 150u8 , 227u8 , 4u8 , 189u8 , 231u8 , 192u8 , 98u8 , 57u8 , 197u8 , 208u8 , 9u8 , 120u8 , 10u8 , 105u8 , 247u8 , 169u8 , 145u8 , 224u8 ,] { let call = AddAssetToPool { pool , asset_id , } ; Ok (:: subxt :: SubmittableExtrinsic :: new (self . client , call)) } else { Err (:: subxt :: MetadataError :: IncompatibleMetadata . into ()) } } # [doc = "Remove an asset from an existing pool."] pub fn delete_asset_from_pool (& self , pool : :: std :: vec :: Vec < :: core :: primitive :: u8 > , asset_id : :: core :: primitive :: u32 ,) -> Result < :: subxt :: SubmittableExtrinsic < 'a , T , X , DeleteAssetFromPool , DispatchError , root_mod :: Event > , :: subxt :: BasicError > { if self . client . metadata () . call_hash :: < DeleteAssetFromPool > () ? == [73u8 , 158u8 , 158u8 , 238u8 , 136u8 , 176u8 , 217u8 , 64u8 , 1u8 , 201u8 , 93u8 , 184u8 , 198u8 , 166u8 , 235u8 , 108u8 , 116u8 , 123u8 , 241u8 , 16u8 , 203u8 , 176u8 , 18u8 , 132u8 , 78u8 , 180u8 , 177u8 , 214u8 , 59u8 , 233u8 , 218u8 , 125u8 ,] { let call = DeleteAssetFromPool { pool , asset_id , } ; Ok (:: subxt :: SubmittableExtrinsic :: new (self . client , call)) } else { Err (:: subxt :: MetadataError :: IncompatibleMetadata . into ()) } } } } pub type Event = runtime_types :: pallet_asset_registry :: pallet :: Event ; pub mod events { use super :: runtime_types ; # [derive (:: subxt :: codec :: Decode , :: subxt :: codec :: Encode , Clone , Debug , Eq , PartialEq)] # [doc = "Asset was registered."] pub struct Registered { pub asset_id : :: core :: primitive :: u32 , pub name : runtime_types :: sp_runtime :: bounded :: bounded_vec :: BoundedVec < :: core :: primitive :: u8 > , pub asset_type : runtime_types :: pallet_asset_registry :: types :: AssetType < :: core :: primitive :: u32 > , } impl :: subxt :: Event for Registered { const PALLET : & 'static str = "AssetRegistry" ; const EVENT : & 'static str = "Registered" ; } # [derive (:: subxt :: codec :: Decode , :: subxt :: codec :: Encode , Clone , Debug , Eq , PartialEq)] # [doc = "Asset was updated."] pub struct Updated { pub asset_id : :: core :: primitive :: u32 , pub name : runtime_types :: sp_runtime :: bounded :: bounded_vec :: BoundedVec < :: core :: primitive :: u8 > , pub asset_type : runtime_types :: pallet_asset_registry :: types :: AssetType < :: core :: primitive :: u32 > , } impl :: subxt :: Event for Updated { const PALLET : & 'static str = "AssetRegistry" ; const EVENT : & 'static str = "Updated" ; } # [derive (:: subxt :: codec :: Decode , :: subxt :: codec :: Encode , Clone , Debug , Eq , PartialEq)] # [doc = "Metadata set for an asset."] pub struct MetadataSet { pub asset_id : :: core :: primitive :: u32 , pub symbol : runtime_types :: sp_runtime :: bounded :: bounded_vec :: BoundedVec < :: core :: primitive :: u8 > , pub decimals : :: core :: primitive :: u8 , } impl :: subxt :: Event for MetadataSet { const PALLET : & 'static str = "AssetRegistry" ; const EVENT : & 'static str = "MetadataSet" ; } # [derive (:: subxt :: codec :: Decode , :: subxt :: codec :: Encode , Clone , Debug , Eq , PartialEq)] # [doc = "Native location set for an asset."] pub struct LocationSet { pub asset_id : :: core :: primitive :: u32 , pub location : :: core :: primitive :: u32 , } impl :: subxt :: Event for LocationSet { const PALLET : & 'static str = "AssetRegistry" ; const EVENT : & 'static str = "LocationSet" ; } } pub mod storage { use super :: runtime_types ; pub struct Assets < 'a > (pub & 'a :: core :: primitive :: u32) ; impl :: subxt :: StorageEntry for Assets < '_ > { const PALLET : & 'static str = "AssetRegistry" ; const STORAGE : & 'static str = "Assets" ; type Value = runtime_types :: pallet_asset_registry :: types :: AssetDetails < :: core :: primitive :: u32 , :: core :: primitive :: u128 , runtime_types :: sp_runtime :: bounded :: bounded_vec :: BoundedVec < :: core :: primitive :: u8 > > ; fn key (& self) -> :: subxt :: StorageEntryKey { :: subxt :: StorageEntryKey :: Map (vec ! [:: subxt :: StorageMapKey :: new (& self . 0 , :: subxt :: StorageHasher :: Twox64Concat)]) } } pub struct NextAssetId ; impl :: subxt :: StorageEntry for NextAssetId { const PALLET : & 'static str = "AssetRegistry" ; const STORAGE : & 'static str = "NextAssetId" ; type Value = :: core :: primitive :: u32 ; fn key (& self) -> :: subxt :: StorageEntryKey { :: subxt :: StorageEntryKey :: Plain } } pub struct AssetIds < 'a > (pub & 'a runtime_types :: sp_runtime :: bounded :: bounded_vec :: BoundedVec < :: core :: primitive :: u8 >) ; impl :: subxt :: StorageEntry for AssetIds < '_ > { const PALLET : & 'static str = "AssetRegistry" ; const STORAGE : & 'static str = "AssetIds" ; type Value = :: core :: primitive :: u32 ; fn key (& self) -> :: subxt :: StorageEntryKey { :: subxt :: StorageEntryKey :: Map (vec ! [:: subxt :: StorageMapKey :: new (& self . 0 , :: subxt :: StorageHasher :: Blake2_128Concat)]) } } pub struct AssetLocations < 'a > (pub & 'a :: core :: primitive :: u32) ; impl :: subxt :: StorageEntry for AssetLocations < '_ > { const PALLET : & 'static str = "AssetRegistry" ; const STORAGE : & 'static str = "AssetLocations" ; type Value = :: core :: primitive :: u32 ; fn key (& self) -> :: subxt :: StorageEntryKey { :: subxt :: StorageEntryKey :: Map (vec ! [:: subxt :: StorageMapKey :: new (& self . 0 , :: subxt :: StorageHasher :: Twox64Concat)]) } } pub struct LocationAssets < 'a > (pub & 'a :: core :: primitive :: u32) ; impl :: subxt :: StorageEntry for LocationAssets < '_ > { const PALLET : & 'static str = "AssetRegistry" ; const STORAGE : & 'static str = "LocationAssets" ; type Value = :: core :: primitive :: u32 ; fn key (& self) -> :: subxt :: StorageEntryKey { :: subxt :: StorageEntryKey :: Map (vec ! [:: subxt :: StorageMapKey :: new (& self . 0 , :: subxt :: StorageHasher :: Blake2_128Concat)]) } } pub struct AssetMetadataMap < 'a > (pub & 'a :: core :: primitive :: u32) ; impl :: subxt :: StorageEntry for AssetMetadataMap < '_ > { const PALLET : & 'static str = "AssetRegistry" ; const STORAGE : & 'static str = "AssetMetadataMap" ; type Value = runtime_types :: pallet_asset_registry :: types :: AssetMetadata < runtime_types :: sp_runtime :: bounded :: bounded_vec :: BoundedVec < :: core :: primitive :: u8 > > ; fn key (& self) -> :: subxt :: StorageEntryKey { :: subxt :: StorageEntryKey :: Map (vec ! [:: subxt :: StorageMapKey :: new (& self . 0 , :: subxt :: StorageHasher :: Twox64Concat)]) } } pub struct StorageApi < 'a , T : :: subxt :: Config > { client : & 'a :: subxt :: Client < T > , } impl < 'a , T : :: subxt :: Config > StorageApi < 'a , T > { pub fn new (client : & 'a :: subxt :: Client < T >) -> Self { Self { client } } # [doc = " Details of an asset."] pub async fn assets (& self , _0 : & :: core :: primitive :: u32 , block_hash : :: core :: option :: Option < T :: Hash > ,) -> :: core :: result :: Result < :: core :: option :: Option < runtime_types :: pallet_asset_registry :: types :: AssetDetails < :: core :: primitive :: u32 , :: core :: primitive :: u128 , runtime_types :: sp_runtime :: bounded :: bounded_vec :: BoundedVec < :: core :: primitive :: u8 > > > , :: subxt :: BasicError > { if self . client . metadata () . storage_hash :: < Assets > () ? == [218u8 , 252u8 , 103u8 , 16u8 , 161u8 , 109u8 , 105u8 , 18u8 , 211u8 , 191u8 , 37u8 , 38u8 , 33u8 , 1u8 , 24u8 , 165u8 , 192u8 , 136u8 , 108u8 , 39u8 , 79u8 , 254u8 , 74u8 , 232u8 , 19u8 , 40u8 , 205u8 , 170u8 , 209u8 , 220u8 , 100u8 , 110u8 ,] { let entry = Assets (_0) ; self . client . storage () . fetch (& entry , block_hash) . await } else { Err (:: subxt :: MetadataError :: IncompatibleMetadata . into ()) } } # [doc = " Details of an asset."] pub async fn assets_iter (& self , block_hash : :: core :: option :: Option < T :: Hash > ,) -> :: core :: result :: Result < :: subxt :: KeyIter < 'a , T , Assets < 'a > > , :: subxt :: BasicError > { if self . client . metadata () . storage_hash :: < Assets > () ? == [218u8 , 252u8 , 103u8 , 16u8 , 161u8 , 109u8 , 105u8 , 18u8 , 211u8 , 191u8 , 37u8 , 38u8 , 33u8 , 1u8 , 24u8 , 165u8 , 192u8 , 136u8 , 108u8 , 39u8 , 79u8 , 254u8 , 74u8 , 232u8 , 19u8 , 40u8 , 205u8 , 170u8 , 209u8 , 220u8 , 100u8 , 110u8 ,] { self . client . storage () . iter (block_hash) . await } else { Err (:: subxt :: MetadataError :: IncompatibleMetadata . into ()) } } # [doc = " Next available asset id. This is sequential id assigned for each new"] # [doc = " registered asset."] pub async fn next_asset_id (& self , block_hash : :: core :: option :: Option < T :: Hash > ,) -> :: core :: result :: Result < :: core :: primitive :: u32 , :: subxt :: BasicError > { if self . client . metadata () . storage_hash :: < NextAssetId > () ? == [130u8 , 214u8 , 178u8 , 195u8 , 222u8 , 57u8 , 89u8 , 143u8 , 138u8 , 218u8 , 234u8 , 251u8 , 36u8 , 221u8 , 51u8 , 213u8 , 130u8 , 249u8 , 153u8 , 24u8 , 245u8 , 51u8 , 126u8 , 71u8 , 51u8 , 148u8 , 167u8 , 143u8 , 33u8 , 15u8 , 44u8 , 115u8 ,] { let entry = NextAssetId ; self . client . storage () . fetch_or_default (& entry , block_hash) . await } else { Err (:: subxt :: MetadataError :: IncompatibleMetadata . into ()) } } # [doc = " Mapping between asset name and asset id."] pub async fn asset_ids (& self , _0 : & runtime_types :: sp_runtime :: bounded :: bounded_vec :: BoundedVec < :: core :: primitive :: u8 > , block_hash : :: core :: option :: Option < T :: Hash > ,) -> :: core :: result :: Result < :: core :: option :: Option < :: core :: primitive :: u32 > , :: subxt :: BasicError > { if self . client . metadata () . storage_hash :: < AssetIds > () ? == [91u8 , 196u8 , 78u8 , 115u8 , 45u8 , 185u8 , 5u8 , 111u8 , 207u8 , 79u8 , 201u8 , 65u8 , 175u8 , 88u8 , 250u8 , 18u8 , 89u8 , 111u8 , 176u8 , 186u8 , 119u8 , 228u8 , 209u8 , 118u8 , 231u8 , 178u8 , 160u8 , 185u8 , 4u8 , 226u8 , 100u8 , 141u8 ,] { let entry = AssetIds (_0) ; self . client . storage () . fetch (& entry , block_hash) . await } else { Err (:: subxt :: MetadataError :: IncompatibleMetadata . into ()) } } # [doc = " Mapping between asset name and asset id."] pub async fn asset_ids_iter (& self , block_hash : :: core :: option :: Option < T :: Hash > ,) -> :: core :: result :: Result < :: subxt :: KeyIter < 'a , T , AssetIds < 'a > > , :: subxt :: BasicError > { if self . client . metadata () . storage_hash :: < AssetIds > () ? == [91u8 , 196u8 , 78u8 , 115u8 , 45u8 , 185u8 , 5u8 , 111u8 , 207u8 , 79u8 , 201u8 , 65u8 , 175u8 , 88u8 , 250u8 , 18u8 , 89u8 , 111u8 , 176u8 , 186u8 , 119u8 , 228u8 , 209u8 , 118u8 , 231u8 , 178u8 , 160u8 , 185u8 , 4u8 , 226u8 , 100u8 , 141u8 ,] { self . client . storage () . iter (block_hash) . await } else { Err (:: subxt :: MetadataError :: IncompatibleMetadata . into ()) } } # [doc = " Native location of an asset."] pub async fn asset_locations (& self , _0 : & :: core :: primitive :: u32 , block_hash : :: core :: option :: Option < T :: Hash > ,) -> :: core :: result :: Result < :: core :: option :: Option < :: core :: primitive :: u32 > , :: subxt :: BasicError > { if self . client . metadata () . storage_hash :: < AssetLocations > () ? == [146u8 , 222u8 , 59u8 , 210u8 , 64u8 , 240u8 , 139u8 , 32u8 , 171u8 , 75u8 , 247u8 , 43u8 , 179u8 , 108u8 , 20u8 , 64u8 , 24u8 , 154u8 , 133u8 , 154u8 , 208u8 , 98u8 , 241u8 , 62u8 , 158u8 , 126u8 , 19u8 , 188u8 , 237u8 , 70u8 , 178u8 , 197u8 ,] { let entry = AssetLocations (_0) ; self . client . storage () . fetch (& entry , block_hash) . await } else { Err (:: subxt :: MetadataError :: IncompatibleMetadata . into ()) } } # [doc = " Native location of an asset."] pub async fn asset_locations_iter (& self , block_hash : :: core :: option :: Option < T :: Hash > ,) -> :: core :: result :: Result < :: subxt :: KeyIter < 'a , T , AssetLocations < 'a > > , :: subxt :: BasicError > { if self . client . metadata () . storage_hash :: < AssetLocations > () ? == [146u8 , 222u8 , 59u8 , 210u8 , 64u8 , 240u8 , 139u8 , 32u8 , 171u8 , 75u8 , 247u8 , 43u8 , 179u8 , 108u8 , 20u8 , 64u8 , 24u8 , 154u8 , 133u8 , 154u8 , 208u8 , 98u8 , 241u8 , 62u8 , 158u8 , 126u8 , 19u8 , 188u8 , 237u8 , 70u8 , 178u8 , 197u8 ,] { self . client . storage () . iter (block_hash) . await } else { Err (:: subxt :: MetadataError :: IncompatibleMetadata . into ()) } } # [doc = " Local asset for native location."] pub async fn location_assets (& self , _0 : & :: core :: primitive :: u32 , block_hash : :: core :: option :: Option < T :: Hash > ,) -> :: core :: result :: Result < :: core :: option :: Option < :: core :: primitive :: u32 > , :: subxt :: BasicError > { if self . client . metadata () . storage_hash :: < LocationAssets > () ? == [82u8 , 140u8 , 248u8 , 178u8 , 200u8 , 49u8 , 11u8 , 121u8 , 43u8 , 2u8 , 125u8 , 44u8 , 253u8 , 10u8 , 29u8 , 242u8 , 56u8 , 45u8 , 249u8 , 223u8 , 136u8 , 40u8 , 155u8 , 201u8 , 99u8 , 166u8 , 243u8 , 79u8 , 47u8 , 93u8 , 211u8 , 241u8 ,] { let entry = LocationAssets (_0) ; self . client . storage () . fetch (& entry , block_hash) . await } else { Err (:: subxt :: MetadataError :: IncompatibleMetadata . into ()) } } # [doc = " Local asset for native location."] pub async fn location_assets_iter (& self , block_hash : :: core :: option :: Option < T :: Hash > ,) -> :: core :: result :: Result < :: subxt :: KeyIter < 'a , T , LocationAssets < 'a > > , :: subxt :: BasicError > { if self . client . metadata () . storage_hash :: < LocationAssets > () ? == [82u8 , 140u8 , 248u8 , 178u8 , 200u8 , 49u8 , 11u8 , 121u8 , 43u8 , 2u8 , 125u8 , 44u8 , 253u8 , 10u8 , 29u8 , 242u8 , 56u8 , 45u8 , 249u8 , 223u8 , 136u8 , 40u8 , 155u8 , 201u8 , 99u8 , 166u8 , 243u8 , 79u8 , 47u8 , 93u8 , 211u8 , 241u8 ,] { self . client . storage () . iter (block_hash) . await } else { Err (:: subxt :: MetadataError :: IncompatibleMetadata . into ()) } } # [doc = " Metadata of an asset."] pub async fn asset_metadata_map (& self , _0 : & :: core :: primitive :: u32 , block_hash : :: core :: option :: Option < T :: Hash > ,) -> :: core :: result :: Result < :: core :: option :: Option < runtime_types :: pallet_asset_registry :: types :: AssetMetadata < runtime_types :: sp_runtime :: bounded :: bounded_vec :: BoundedVec < :: core :: primitive :: u8 > > > , :: subxt :: BasicError > { if self . client . metadata () . storage_hash :: < AssetMetadataMap > () ? == [240u8 , 115u8 , 247u8 , 158u8 , 31u8 , 41u8 , 227u8 , 161u8 , 155u8 , 78u8 , 220u8 , 50u8 , 193u8 , 69u8 , 138u8 , 52u8 , 104u8 , 17u8 , 36u8 , 228u8 , 123u8 , 154u8 , 87u8 , 30u8 , 183u8 , 127u8 , 215u8 , 0u8 , 89u8 , 208u8 , 183u8 , 57u8 ,] { let entry = AssetMetadataMap (_0) ; self . client . storage () . fetch (& entry , block_hash) . await } else { Err (:: subxt :: MetadataError :: IncompatibleMetadata . into ()) } } # [doc = " Metadata of an asset."] pub async fn asset_metadata_map_iter (& self , block_hash : :: core :: option :: Option < T :: Hash > ,) -> :: core :: result :: Result < :: subxt :: KeyIter < 'a , T , AssetMetadataMap < 'a > > , :: subxt :: BasicError > { if self . client . metadata () . storage_hash :: < AssetMetadataMap > () ? == [240u8 , 115u8 , 247u8 , 158u8 , 31u8 , 41u8 , 227u8 , 161u8 , 155u8 , 78u8 , 220u8 , 50u8 , 193u8 , 69u8 , 138u8 , 52u8 , 104u8 , 17u8 , 36u8 , 228u8 , 123u8 , 154u8 , 87u8 , 30u8 , 183u8 , 127u8 , 215u8 , 0u8 , 89u8 , 208u8 , 183u8 , 57u8 ,] { self . client . storage () . iter (block_hash) . await } else { Err (:: subxt :: MetadataError :: IncompatibleMetadata . into ()) } } } } pub mod constants { use super :: runtime_types ; pub struct ConstantsApi < 'a , T : :: subxt :: Config > { client : & 'a :: subxt :: Client < T > , } impl < 'a , T : :: subxt :: Config > ConstantsApi < 'a , T > { pub fn new (client : & 'a :: subxt :: Client < T >) -> Self { Self { client } } # [doc = " Native Asset Id"] pub fn native_asset_id (& self) -> :: core :: result :: Result < :: core :: primitive :: u32 , :: subxt :: BasicError > { if self . client . metadata () . constant_hash ("AssetRegistry" , "NativeAssetId") ? == [111u8 , 131u8 , 117u8 , 221u8 , 20u8 , 90u8 , 37u8 , 20u8 , 170u8 , 233u8 , 183u8 , 240u8 , 217u8 , 30u8 , 80u8 , 229u8 , 143u8 , 168u8 , 8u8 , 131u8 , 211u8 , 145u8 , 165u8 , 219u8 , 118u8 , 145u8 , 233u8 , 178u8 , 67u8 , 131u8 , 199u8 , 239u8 ,] { let pallet = self . client . metadata () . pallet ("AssetRegistry") ? ; let constant = pallet . constant ("NativeAssetId") ? ; let value = :: subxt :: codec :: Decode :: decode (& mut & constant . value [..]) ? ; Ok (value) } else { Err (:: subxt :: MetadataError :: IncompatibleMetadata . into ()) } } } } } pub mod currencies { use super :: root_mod ; use super :: runtime_types ; pub mod calls { use super :: root_mod ; use super :: runtime_types ; type DispatchError = runtime_types :: sp_runtime :: DispatchError ; # [derive (:: subxt :: codec :: Decode , :: subxt :: codec :: Encode , Clone , Debug , Eq , PartialEq)] pub struct Transfer { pub dest : :: subxt :: sp_runtime :: MultiAddress < :: subxt :: sp_core :: crypto :: AccountId32 , :: core :: primitive :: u32 > , pub currency_id : :: core :: primitive :: u32 , # [codec (compact)] pub amount : :: core :: primitive :: u128 , } impl :: subxt :: Call for Transfer { const PALLET : & 'static str = "Currencies" ; const FUNCTION : & 'static str = "transfer" ; } # [derive (:: subxt :: codec :: Decode , :: subxt :: codec :: Encode , Clone , Debug , Eq , PartialEq)] pub struct TransferNativeCurrency { pub dest : :: subxt :: sp_runtime :: MultiAddress < :: subxt :: sp_core :: crypto :: AccountId32 , :: core :: primitive :: u32 > , # [codec (compact)] pub amount : :: core :: primitive :: u128 , } impl :: subxt :: Call for TransferNativeCurrency { const PALLET : & 'static str = "Currencies" ; const FUNCTION : & 'static str = "transfer_native_currency" ; } # [derive (:: subxt :: codec :: Decode , :: subxt :: codec :: Encode , Clone , Debug , Eq , PartialEq)] pub struct UpdateBalance { pub who : :: subxt :: sp_runtime :: MultiAddress < :: subxt :: sp_core :: crypto :: AccountId32 , :: core :: primitive :: u32 > , pub currency_id : :: core :: primitive :: u32 , pub amount : :: core :: primitive :: i128 , } impl :: subxt :: Call for UpdateBalance { const PALLET : & 'static str = "Currencies" ; const FUNCTION : & 'static str = "update_balance" ; } pub struct TransactionApi < 'a , T : :: subxt :: Config , X > { client : & 'a :: subxt :: Client < T > , marker : :: core :: marker :: PhantomData < X > , } impl < 'a , T , X > TransactionApi < 'a , T , X > where T : :: subxt :: Config , X : :: subxt :: extrinsic :: ExtrinsicParams < T > , { pub fn new (client : & 'a :: subxt :: Client < T >) -> Self { Self { client , marker : :: core :: marker :: PhantomData } } # [doc = "Transfer some balance to another account under `currency_id`."] # [doc = ""] # [doc = "The dispatch origin for this call must be `Signed` by the"] # [doc = "transactor."] pub fn transfer (& self , dest : :: subxt :: sp_runtime :: MultiAddress < :: subxt :: sp_core :: crypto :: AccountId32 , :: core :: primitive :: u32 > , currency_id : :: core :: primitive :: u32 , amount : :: core :: primitive :: u128 ,) -> Result < :: subxt :: SubmittableExtrinsic < 'a , T , X , Transfer , DispatchError , root_mod :: Event > , :: subxt :: BasicError > { if self . client . metadata () . call_hash :: < Transfer > () ? == [200u8 , 75u8 , 107u8 , 84u8 , 205u8 , 72u8 , 102u8 , 68u8 , 226u8 , 202u8 , 70u8 , 48u8 , 39u8 , 214u8 , 255u8 , 69u8 , 102u8 , 216u8 , 62u8 , 149u8 , 43u8 , 31u8 , 9u8 , 248u8 , 135u8 , 11u8 , 192u8 , 184u8 , 64u8 , 157u8 , 213u8 , 208u8 ,] { let call = Transfer { dest , currency_id , amount , } ; Ok (:: subxt :: SubmittableExtrinsic :: new (self . client , call)) } else { Err (:: subxt :: MetadataError :: IncompatibleMetadata . into ()) } } # [doc = "Transfer some native currency to another account."] # [doc = ""] # [doc = "The dispatch origin for this call must be `Signed` by the"] # [doc = "transactor."] pub fn transfer_native_currency (& self , dest : :: subxt :: sp_runtime :: MultiAddress < :: subxt :: sp_core :: crypto :: AccountId32 , :: core :: primitive :: u32 > , amount : :: core :: primitive :: u128 ,) -> Result < :: subxt :: SubmittableExtrinsic < 'a , T , X , TransferNativeCurrency , DispatchError , root_mod :: Event > , :: subxt :: BasicError > { if self . client . metadata () . call_hash :: < TransferNativeCurrency > () ? == [133u8 , 242u8 , 8u8 , 213u8 , 43u8 , 124u8 , 148u8 , 151u8 , 223u8 , 112u8 , 213u8 , 232u8 , 64u8 , 238u8 , 115u8 , 244u8 , 153u8 , 221u8 , 248u8 , 13u8 , 95u8 , 16u8 , 40u8 , 97u8 , 231u8 , 87u8 , 217u8 , 244u8 , 231u8 , 200u8 , 187u8 , 104u8 ,] { let call = TransferNativeCurrency { dest , amount , } ; Ok (:: subxt :: SubmittableExtrinsic :: new (self . client , call)) } else { Err (:: subxt :: MetadataError :: IncompatibleMetadata . into ()) } } # [doc = "update amount of account `who` under `currency_id`."] # [doc = ""] # [doc = "The dispatch origin of this call must be _Root_."] pub fn update_balance (& self , who : :: subxt :: sp_runtime :: MultiAddress < :: subxt :: sp_core :: crypto :: AccountId32 , :: core :: primitive :: u32 > , currency_id : :: core :: primitive :: u32 , amount : :: core :: primitive :: i128 ,) -> Result < :: subxt :: SubmittableExtrinsic < 'a , T , X , UpdateBalance , DispatchError , root_mod :: Event > , :: subxt :: BasicError > { if self . client . metadata () . call_hash :: < UpdateBalance > () ? == [248u8 , 238u8 , 185u8 , 136u8 , 86u8 , 116u8 , 97u8 , 82u8 , 136u8 , 48u8 , 189u8 , 192u8 , 125u8 , 37u8 , 159u8 , 198u8 , 161u8 , 42u8 , 61u8 , 17u8 , 246u8 , 115u8 , 224u8 , 247u8 , 70u8 , 247u8 , 54u8 , 121u8 , 198u8 , 11u8 , 43u8 , 243u8 ,] { let call = UpdateBalance { who , currency_id , amount , } ; Ok (:: subxt :: SubmittableExtrinsic :: new (self . client , call)) } else { Err (:: subxt :: MetadataError :: IncompatibleMetadata . into ()) } } } } pub mod constants { use super :: runtime_types ; pub struct ConstantsApi < 'a , T : :: subxt :: Config > { client : & 'a :: subxt :: Client < T > , } impl < 'a , T : :: subxt :: Config > ConstantsApi < 'a , T > { pub fn new (client : & 'a :: subxt :: Client < T >) -> Self { Self { client } } pub fn get_native_currency_id (& self) -> :: core :: result :: Result < :: core :: primitive :: u32 , :: subxt :: BasicError > { if self . client . metadata () . constant_hash ("Currencies" , "GetNativeCurrencyId") ? == [235u8 , 169u8 , 23u8 , 8u8 , 201u8 , 91u8 , 135u8 , 218u8 , 29u8 , 255u8 , 207u8 , 96u8 , 188u8 , 208u8 , 243u8 , 158u8 , 244u8 , 153u8 , 97u8 , 183u8 , 151u8 , 137u8 , 183u8 , 98u8 , 160u8 , 169u8 , 29u8 , 219u8 , 109u8 , 148u8 , 112u8 , 185u8 ,] { let pallet = self . client . metadata () . pallet ("Currencies") ? ; let constant = pallet . constant ("GetNativeCurrencyId") ? ; let value = :: subxt :: codec :: Decode :: decode (& mut & constant . value [..]) ? ; Ok (value) } else { Err (:: subxt :: MetadataError :: IncompatibleMetadata . into ()) } } } } } pub mod tokens { use super :: root_mod ; use super :: runtime_types ; pub mod calls { use super :: root_mod ; use super :: runtime_types ; type DispatchError = runtime_types :: sp_runtime :: DispatchError ; # [derive (:: subxt :: codec :: Decode , :: subxt :: codec :: Encode , Clone , Debug , Eq , PartialEq)] pub struct Transfer { pub dest : :: subxt :: sp_runtime :: MultiAddress < :: subxt :: sp_core :: crypto :: AccountId32 , :: core :: primitive :: u32 > , pub currency_id : :: core :: primitive :: u32 , # [codec (compact)] pub amount : :: core :: primitive :: u128 , } impl :: subxt :: Call for Transfer { const PALLET : & 'static str = "Tokens" ; const FUNCTION : & 'static str = "transfer" ; } # [derive (:: subxt :: codec :: Decode , :: subxt :: codec :: Encode , Clone , Debug , Eq , PartialEq)] pub struct TransferAll { pub dest : :: subxt :: sp_runtime :: MultiAddress < :: subxt :: sp_core :: crypto :: AccountId32 , :: core :: primitive :: u32 > , pub currency_id : :: core :: primitive :: u32 , pub keep_alive : :: core :: primitive :: bool , } impl :: subxt :: Call for TransferAll { const PALLET : & 'static str = "Tokens" ; const FUNCTION : & 'static str = "transfer_all" ; } # [derive (:: subxt :: codec :: Decode , :: subxt :: codec :: Encode , Clone , Debug , Eq , PartialEq)] pub struct TransferKeepAlive { pub dest : :: subxt :: sp_runtime :: MultiAddress < :: subxt :: sp_core :: crypto :: AccountId32 , :: core :: primitive :: u32 > , pub currency_id : :: core :: primitive :: u32 , # [codec (compact)] pub amount : :: core :: primitive :: u128 , } impl :: subxt :: Call for TransferKeepAlive { const PALLET : & 'static str = "Tokens" ; const FUNCTION : & 'static str = "transfer_keep_alive" ; } # [derive (:: subxt :: codec :: Decode , :: subxt :: codec :: Encode , Clone , Debug , Eq , PartialEq)] pub struct ForceTransfer { pub source : :: subxt :: sp_runtime :: MultiAddress < :: subxt :: sp_core :: crypto :: AccountId32 , :: core :: primitive :: u32 > , pub dest : :: subxt :: sp_runtime :: MultiAddress < :: subxt :: sp_core :: crypto :: AccountId32 , :: core :: primitive :: u32 > , pub currency_id : :: core :: primitive :: u32 , # [codec (compact)] pub amount : :: core :: primitive :: u128 , } impl :: subxt :: Call for ForceTransfer { const PALLET : & 'static str = "Tokens" ; const FUNCTION : & 'static str = "force_transfer" ; } # [derive (:: subxt :: codec :: Decode , :: subxt :: codec :: Encode , Clone , Debug , Eq , PartialEq)] pub struct SetBalance { pub who : :: subxt :: sp_runtime :: MultiAddress < :: subxt :: sp_core :: crypto :: AccountId32 , :: core :: primitive :: u32 > , pub currency_id : :: core :: primitive :: u32 , # [codec (compact)] pub new_free : :: core :: primitive :: u128 , # [codec (compact)] pub new_reserved : :: core :: primitive :: u128 , } impl :: subxt :: Call for SetBalance { const PALLET : & 'static str = "Tokens" ; const FUNCTION : & 'static str = "set_balance" ; } pub struct TransactionApi < 'a , T : :: subxt :: Config , X > { client : & 'a :: subxt :: Client < T > , marker : :: core :: marker :: PhantomData < X > , } impl < 'a , T , X > TransactionApi < 'a , T , X > where T : :: subxt :: Config , X : :: subxt :: extrinsic :: ExtrinsicParams < T > , { pub fn new (client : & 'a :: subxt :: Client < T >) -> Self { Self { client , marker : :: core :: marker :: PhantomData } } # [doc = "Transfer some liquid free balance to another account."] # [doc = ""] # [doc = "`transfer` will set the `FreeBalance` of the sender and receiver."] # [doc = "It will decrease the total issuance of the system by the"] # [doc = "`TransferFee`. If the sender's account is below the existential"] # [doc = "deposit as a result of the transfer, the account will be reaped."] # [doc = ""] # [doc = "The dispatch origin for this call must be `Signed` by the"] # [doc = "transactor."] # [doc = ""] # [doc = "- `dest`: The recipient of the transfer."] # [doc = "- `currency_id`: currency type."] # [doc = "- `amount`: free balance amount to tranfer."] pub fn transfer (& self , dest : :: subxt :: sp_runtime :: MultiAddress < :: subxt :: sp_core :: crypto :: AccountId32 , :: core :: primitive :: u32 > , currency_id : :: core :: primitive :: u32 , amount : :: core :: primitive :: u128 ,) -> Result < :: subxt :: SubmittableExtrinsic < 'a , T , X , Transfer , DispatchError , root_mod :: Event > , :: subxt :: BasicError > { if self . client . metadata () . call_hash :: < Transfer > () ? == [238u8 , 189u8 , 229u8 , 176u8 , 120u8 , 125u8 , 130u8 , 186u8 , 100u8 , 147u8 , 192u8 , 96u8 , 220u8 , 13u8 , 47u8 , 173u8 , 186u8 , 198u8 , 59u8 , 39u8 , 116u8 , 160u8 , 190u8 , 38u8 , 181u8 , 80u8 , 118u8 , 235u8 , 221u8 , 190u8 , 146u8 , 245u8 ,] { let call = Transfer { dest , currency_id , amount , } ; Ok (:: subxt :: SubmittableExtrinsic :: new (self . client , call)) } else { Err (:: subxt :: MetadataError :: IncompatibleMetadata . into ()) } } # [doc = "Transfer all remaining balance to the given account."] # [doc = ""] # [doc = "NOTE: This function only attempts to transfer _transferable_"] # [doc = "balances. This means that any locked, reserved, or existential"] # [doc = "deposits (when `keep_alive` is `true`), will not be transferred by"] # [doc = "this function. To ensure that this function results in a killed"] # [doc = "account, you might need to prepare the account by removing any"] # [doc = "reference counters, storage deposits, etc..."] # [doc = ""] # [doc = "The dispatch origin for this call must be `Signed` by the"] # [doc = "transactor."] # [doc = ""] # [doc = "- `dest`: The recipient of the transfer."] # [doc = "- `currency_id`: currency type."] # [doc = "- `keep_alive`: A boolean to determine if the `transfer_all`"] # [doc = "  operation should send all of the funds the account has, causing"] # [doc = "  the sender account to be killed (false), or transfer everything"] # [doc = "  except at least the existential deposit, which will guarantee to"] # [doc = "  keep the sender account alive (true)."] pub fn transfer_all (& self , dest : :: subxt :: sp_runtime :: MultiAddress < :: subxt :: sp_core :: crypto :: AccountId32 , :: core :: primitive :: u32 > , currency_id : :: core :: primitive :: u32 , keep_alive : :: core :: primitive :: bool ,) -> Result < :: subxt :: SubmittableExtrinsic < 'a , T , X , TransferAll , DispatchError , root_mod :: Event > , :: subxt :: BasicError > { if self . client . metadata () . call_hash :: < TransferAll > () ? == [104u8 , 124u8 , 117u8 , 8u8 , 94u8 , 27u8 , 17u8 , 26u8 , 32u8 , 73u8 , 71u8 , 106u8 , 172u8 , 2u8 , 154u8 , 220u8 , 18u8 , 36u8 , 78u8 , 243u8 , 177u8 , 68u8 , 163u8 , 231u8 , 141u8 , 253u8 , 234u8 , 26u8 , 33u8 , 12u8 , 249u8 , 92u8 ,] { let call = TransferAll { dest , currency_id , keep_alive , } ; Ok (:: subxt :: SubmittableExtrinsic :: new (self . client , call)) } else { Err (:: subxt :: MetadataError :: IncompatibleMetadata . into ()) } } # [doc = "Same as the [`transfer`] call, but with a check that the transfer"] # [doc = "will not kill the origin account."] # [doc = ""] # [doc = "99% of the time you want [`transfer`] instead."] # [doc = ""] # [doc = "The dispatch origin for this call must be `Signed` by the"] # [doc = "transactor."] # [doc = ""] # [doc = "- `dest`: The recipient of the transfer."] # [doc = "- `currency_id`: currency type."] # [doc = "- `amount`: free balance amount to tranfer."] pub fn transfer_keep_alive (& self , dest : :: subxt :: sp_runtime :: MultiAddress < :: subxt :: sp_core :: crypto :: AccountId32 , :: core :: primitive :: u32 > , currency_id : :: core :: primitive :: u32 , amount : :: core :: primitive :: u128 ,) -> Result < :: subxt :: SubmittableExtrinsic < 'a , T , X , TransferKeepAlive , DispatchError , root_mod :: Event > , :: subxt :: BasicError > { if self . client . metadata () . call_hash :: < TransferKeepAlive > () ? == [17u8 , 56u8 , 172u8 , 86u8 , 50u8 , 121u8 , 229u8 , 246u8 , 152u8 , 182u8 , 61u8 , 59u8 , 180u8 , 66u8 , 4u8 , 155u8 , 241u8 , 105u8 , 31u8 , 148u8 , 244u8 , 8u8 , 216u8 , 229u8 , 159u8 , 58u8 , 94u8 , 207u8 , 56u8 , 15u8 , 16u8 , 59u8 ,] { let call = TransferKeepAlive { dest , currency_id , amount , } ; Ok (:: subxt :: SubmittableExtrinsic :: new (self . client , call)) } else { Err (:: subxt :: MetadataError :: IncompatibleMetadata . into ()) } } # [doc = "Exactly as `transfer`, except the origin must be root and the source"] # [doc = "account may be specified."] # [doc = ""] # [doc = "The dispatch origin for this call must be _Root_."] # [doc = ""] # [doc = "- `source`: The sender of the transfer."] # [doc = "- `dest`: The recipient of the transfer."] # [doc = "- `currency_id`: currency type."] # [doc = "- `amount`: free balance amount to tranfer."] pub fn force_transfer (& self , source : :: subxt :: sp_runtime :: MultiAddress < :: subxt :: sp_core :: crypto :: AccountId32 , :: core :: primitive :: u32 > , dest : :: subxt :: sp_runtime :: MultiAddress < :: subxt :: sp_core :: crypto :: AccountId32 , :: core :: primitive :: u32 > , currency_id : :: core :: primitive :: u32 , amount : :: core :: primitive :: u128 ,) -> Result < :: subxt :: SubmittableExtrinsic < 'a , T , X , ForceTransfer , DispatchError , root_mod :: Event > , :: subxt :: BasicError > { if self . client . metadata () . call_hash :: < ForceTransfer > () ? == [113u8 , 131u8 , 163u8 , 102u8 , 73u8 , 25u8 , 142u8 , 243u8 , 251u8 , 247u8 , 212u8 , 65u8 , 166u8 , 41u8 , 215u8 , 145u8 , 242u8 , 52u8 , 67u8 , 42u8 , 107u8 , 182u8 , 231u8 , 165u8 , 246u8 , 160u8 , 139u8 , 190u8 , 248u8 , 52u8 , 238u8 , 150u8 ,] { let call = ForceTransfer { source , dest , currency_id , amount , } ; Ok (:: subxt :: SubmittableExtrinsic :: new (self . client , call)) } else { Err (:: subxt :: MetadataError :: IncompatibleMetadata . into ()) } } # [doc = "Set the balances of a given account."] # [doc = ""] # [doc = "This will alter `FreeBalance` and `ReservedBalance` in storage. it"] # [doc = "will also decrease the total issuance of the system"] # [doc = "(`TotalIssuance`). If the new free or reserved balance is below the"] # [doc = "existential deposit, it will reap the `AccountInfo`."] # [doc = ""] # [doc = "The dispatch origin for this call is `root`."] pub fn set_balance (& self , who : :: subxt :: sp_runtime :: MultiAddress < :: subxt :: sp_core :: crypto :: AccountId32 , :: core :: primitive :: u32 > , currency_id : :: core :: primitive :: u32 , new_free : :: core :: primitive :: u128 , new_reserved : :: core :: primitive :: u128 ,) -> Result < :: subxt :: SubmittableExtrinsic < 'a , T , X , SetBalance , DispatchError , root_mod :: Event > , :: subxt :: BasicError > { if self . client . metadata () . call_hash :: < SetBalance > () ? == [252u8 , 8u8 , 219u8 , 123u8 , 234u8 , 166u8 , 156u8 , 40u8 , 225u8 , 59u8 , 190u8 , 185u8 , 111u8 , 231u8 , 52u8 , 239u8 , 219u8 , 189u8 , 93u8 , 143u8 , 247u8 , 18u8 , 245u8 , 127u8 , 29u8 , 192u8 , 251u8 , 233u8 , 28u8 , 221u8 , 26u8 , 1u8 ,] { let call = SetBalance { who , currency_id , new_free , new_reserved , } ; Ok (:: subxt :: SubmittableExtrinsic :: new (self . client , call)) } else { Err (:: subxt :: MetadataError :: IncompatibleMetadata . into ()) } } } } pub type Event = runtime_types :: orml_tokens :: module :: Event ; pub mod events { use super :: runtime_types ; # [derive (:: subxt :: codec :: Decode , :: subxt :: codec :: Encode , Clone , Debug , Eq , PartialEq)] # [doc = "An account was created with some free balance."] pub struct Endowed { pub currency_id : :: core :: primitive :: u32 , pub who : :: subxt :: sp_core :: crypto :: AccountId32 , pub amount : :: core :: primitive :: u128 , } impl :: subxt :: Event for Endowed { const PALLET : & 'static str = "Tokens" ; const EVENT : & 'static str = "Endowed" ; } # [derive (:: subxt :: codec :: Decode , :: subxt :: codec :: Encode , Clone , Debug , Eq , PartialEq)] # [doc = "An account was removed whose balance was non-zero but below"] # [doc = "ExistentialDeposit, resulting in an outright loss."] pub struct DustLost { pub currency_id : :: core :: primitive :: u32 , pub who : :: subxt :: sp_core :: crypto :: AccountId32 , pub amount : :: core :: primitive :: u128 , } impl :: subxt :: Event for DustLost { const PALLET : & 'static str = "Tokens" ; const EVENT : & 'static str = "DustLost" ; } # [derive (:: subxt :: codec :: Decode , :: subxt :: codec :: Encode , Clone , Debug , Eq , PartialEq)] # [doc = "Transfer succeeded."] pub struct Transfer { pub currency_id : :: core :: primitive :: u32 , pub from : :: subxt :: sp_core :: crypto :: AccountId32 , pub to : :: subxt :: sp_core :: crypto :: AccountId32 , pub amount : :: core :: primitive :: u128 , } impl :: subxt :: Event for Transfer { const PALLET : & 'static str = "Tokens" ; const EVENT : & 'static str = "Transfer" ; } # [derive (:: subxt :: codec :: Decode , :: subxt :: codec :: Encode , Clone , Debug , Eq , PartialEq)] # [doc = "Some balance was reserved (moved from free to reserved)."] pub struct Reserved { pub currency_id : :: core :: primitive :: u32 , pub who : :: subxt :: sp_core :: crypto :: AccountId32 , pub amount : :: core :: primitive :: u128 , } impl :: subxt :: Event for Reserved { const PALLET : & 'static str = "Tokens" ; const EVENT : & 'static str = "Reserved" ; } # [derive (:: subxt :: codec :: Decode , :: subxt :: codec :: Encode , Clone , Debug , Eq , PartialEq)] # [doc = "Some balance was unreserved (moved from reserved to free)."] pub struct Unreserved { pub currency_id : :: core :: primitive :: u32 , pub who : :: subxt :: sp_core :: crypto :: AccountId32 , pub amount : :: core :: primitive :: u128 , } impl :: subxt :: Event for Unreserved { const PALLET : & 'static str = "Tokens" ; const EVENT : & 'static str = "Unreserved" ; } # [derive (:: subxt :: codec :: Decode , :: subxt :: codec :: Encode , Clone , Debug , Eq , PartialEq)] # [doc = "Some reserved balance was repatriated (moved from reserved to"] # [doc = "another account)."] pub struct ReserveRepatriated { pub currency_id : :: core :: primitive :: u32 , pub from : :: subxt :: sp_core :: crypto :: AccountId32 , pub to : :: subxt :: sp_core :: crypto :: AccountId32 , pub amount : :: core :: primitive :: u128 , pub status : runtime_types :: frame_support :: traits :: tokens :: misc :: BalanceStatus , } impl :: subxt :: Event for ReserveRepatriated { const PALLET : & 'static str = "Tokens" ; const EVENT : & 'static str = "ReserveRepatriated" ; } # [derive (:: subxt :: codec :: Decode , :: subxt :: codec :: Encode , Clone , Debug , Eq , PartialEq)] # [doc = "A balance was set by root."] pub struct BalanceSet { pub currency_id : :: core :: primitive :: u32 , pub who : :: subxt :: sp_core :: crypto :: AccountId32 , pub free : :: core :: primitive :: u128 , pub reserved : :: core :: primitive :: u128 , } impl :: subxt :: Event for BalanceSet { const PALLET : & 'static str = "Tokens" ; const EVENT : & 'static str = "BalanceSet" ; } # [derive (:: subxt :: codec :: Decode , :: subxt :: codec :: Encode , Clone , Debug , Eq , PartialEq)] # [doc = "The total issuance of an currency has been set"] pub struct TotalIssuanceSet { pub currency_id : :: core :: primitive :: u32 , pub amount : :: core :: primitive :: u128 , } impl :: subxt :: Event for TotalIssuanceSet { const PALLET : & 'static str = "Tokens" ; const EVENT : & 'static str = "TotalIssuanceSet" ; } # [derive (:: subxt :: codec :: Decode , :: subxt :: codec :: Encode , Clone , Debug , Eq , PartialEq)] # [doc = "Some balances were withdrawn (e.g. pay for transaction fee)"] pub struct Withdrawn { pub currency_id : :: core :: primitive :: u32 , pub who : :: subxt :: sp_core :: crypto :: AccountId32 , pub amount : :: core :: primitive :: u128 , } impl :: subxt :: Event for Withdrawn { const PALLET : & 'static str = "Tokens" ; const EVENT : & 'static str = "Withdrawn" ; } # [derive (:: subxt :: codec :: Decode , :: subxt :: codec :: Encode , Clone , Debug , Eq , PartialEq)] # [doc = "Some balances were slashed (e.g. due to mis-behavior)"] pub struct Slashed { pub currency_id : :: core :: primitive :: u32 , pub who : :: subxt :: sp_core :: crypto :: AccountId32 , pub free_amount : :: core :: primitive :: u128 , pub reserved_amount : :: core :: primitive :: u128 , } impl :: subxt :: Event for Slashed { const PALLET : & 'static str = "Tokens" ; const EVENT : & 'static str = "Slashed" ; } # [derive (:: subxt :: codec :: Decode , :: subxt :: codec :: Encode , Clone , Debug , Eq , PartialEq)] # [doc = "Deposited some balance into an account"] pub struct Deposited { pub currency_id : :: core :: primitive :: u32 , pub who : :: subxt :: sp_core :: crypto :: AccountId32 , pub amount : :: core :: primitive :: u128 , } impl :: subxt :: Event for Deposited { const PALLET : & 'static str = "Tokens" ; const EVENT : & 'static str = "Deposited" ; } # [derive (:: subxt :: codec :: Decode , :: subxt :: codec :: Encode , Clone , Debug , Eq , PartialEq)] # [doc = "Some funds are locked"] pub struct LockSet { pub lock_id : [:: core :: primitive :: u8 ; 8usize] , pub currency_id : :: core :: primitive :: u32 , pub who : :: subxt :: sp_core :: crypto :: AccountId32 , pub amount : :: core :: primitive :: u128 , } impl :: subxt :: Event for LockSet { const PALLET : & 'static str = "Tokens" ; const EVENT : & 'static str = "LockSet" ; } # [derive (:: subxt :: codec :: Decode , :: subxt :: codec :: Encode , Clone , Debug , Eq , PartialEq)] # [doc = "Some locked funds were unlocked"] pub struct LockRemoved { pub lock_id : [:: core :: primitive :: u8 ; 8usize] , pub currency_id : :: core :: primitive :: u32 , pub who : :: subxt :: sp_core :: crypto :: AccountId32 , } impl :: subxt :: Event for LockRemoved { const PALLET : & 'static str = "Tokens" ; const EVENT : & 'static str = "LockRemoved" ; } } pub mod storage { use super :: runtime_types ; pub struct TotalIssuance < 'a > (pub & 'a :: core :: primitive :: u32) ; impl :: subxt :: StorageEntry for TotalIssuance < '_ > { const PALLET : & 'static str = "Tokens" ; const STORAGE : & 'static str = "TotalIssuance" ; type Value = :: core :: primitive :: u128 ; fn key (& self) -> :: subxt :: StorageEntryKey { :: subxt :: StorageEntryKey :: Map (vec ! [:: subxt :: StorageMapKey :: new (& self . 0 , :: subxt :: StorageHasher :: Twox64Concat)]) } } pub struct Locks < 'a > (pub & 'a :: subxt :: sp_core :: crypto :: AccountId32 , pub & 'a :: core :: primitive :: u32) ; impl :: subxt :: StorageEntry for Locks < '_ > { const PALLET : & 'static str = "Tokens" ; const STORAGE : & 'static str = "Locks" ; type Value = runtime_types :: sp_runtime :: bounded :: bounded_vec :: BoundedVec < runtime_types :: orml_tokens :: BalanceLock < :: core :: primitive :: u128 > > ; fn key (& self) -> :: subxt :: StorageEntryKey { :: subxt :: StorageEntryKey :: Map (vec ! [:: subxt :: StorageMapKey :: new (& self . 0 , :: subxt :: StorageHasher :: Blake2_128Concat) , :: subxt :: StorageMapKey :: new (& self . 1 , :: subxt :: StorageHasher :: Twox64Concat)]) } } pub struct Accounts < 'a > (pub & 'a :: subxt :: sp_core :: crypto :: AccountId32 , pub & 'a :: core :: primitive :: u32) ; impl :: subxt :: StorageEntry for Accounts < '_ > { const PALLET : & 'static str = "Tokens" ; const STORAGE : & 'static str = "Accounts" ; type Value = runtime_types :: orml_tokens :: AccountData < :: core :: primitive :: u128 > ; fn key (& self) -> :: subxt :: StorageEntryKey { :: subxt :: StorageEntryKey :: Map (vec ! [:: subxt :: StorageMapKey :: new (& self . 0 , :: subxt :: StorageHasher :: Blake2_128Concat) , :: subxt :: StorageMapKey :: new (& self . 1 , :: subxt :: StorageHasher :: Twox64Concat)]) } } pub struct Reserves < 'a > (pub & 'a :: subxt :: sp_core :: crypto :: AccountId32 , pub & 'a :: core :: primitive :: u32) ; impl :: subxt :: StorageEntry for Reserves < '_ > { const PALLET : & 'static str = "Tokens" ; const STORAGE : & 'static str = "Reserves" ; type Value = runtime_types :: sp_runtime :: bounded :: bounded_vec :: BoundedVec < runtime_types :: orml_tokens :: ReserveData < [:: core :: primitive :: u8 ; 8usize] , :: core :: primitive :: u128 > > ; fn key (& self) -> :: subxt :: StorageEntryKey { :: subxt :: StorageEntryKey :: Map (vec ! [:: subxt :: StorageMapKey :: new (& self . 0 , :: subxt :: StorageHasher :: Blake2_128Concat) , :: subxt :: StorageMapKey :: new (& self . 1 , :: subxt :: StorageHasher :: Twox64Concat)]) } } pub struct StorageApi < 'a , T : :: subxt :: Config > { client : & 'a :: subxt :: Client < T > , } impl < 'a , T : :: subxt :: Config > StorageApi < 'a , T > { pub fn new (client : & 'a :: subxt :: Client < T >) -> Self { Self { client } } # [doc = " The total issuance of a token type."] pub async fn total_issuance (& self , _0 : & :: core :: primitive :: u32 , block_hash : :: core :: option :: Option < T :: Hash > ,) -> :: core :: result :: Result < :: core :: primitive :: u128 , :: subxt :: BasicError > { if self . client . metadata () . storage_hash :: < TotalIssuance > () ? == [98u8 , 233u8 , 210u8 , 150u8 , 87u8 , 41u8 , 162u8 , 54u8 , 32u8 , 221u8 , 211u8 , 10u8 , 170u8 , 237u8 , 65u8 , 73u8 , 46u8 , 4u8 , 5u8 , 209u8 , 170u8 , 13u8 , 231u8 , 113u8 , 196u8 , 133u8 , 38u8 , 213u8 , 225u8 , 160u8 , 31u8 , 122u8 ,] { let entry = TotalIssuance (_0) ; self . client . storage () . fetch_or_default (& entry , block_hash) . await } else { Err (:: subxt :: MetadataError :: IncompatibleMetadata . into ()) } } # [doc = " The total issuance of a token type."] pub async fn total_issuance_iter (& self , block_hash : :: core :: option :: Option < T :: Hash > ,) -> :: core :: result :: Result < :: subxt :: KeyIter < 'a , T , TotalIssuance < 'a > > , :: subxt :: BasicError > { if self . client . metadata () . storage_hash :: < TotalIssuance > () ? == [98u8 , 233u8 , 210u8 , 150u8 , 87u8 , 41u8 , 162u8 , 54u8 , 32u8 , 221u8 , 211u8 , 10u8 , 170u8 , 237u8 , 65u8 , 73u8 , 46u8 , 4u8 , 5u8 , 209u8 , 170u8 , 13u8 , 231u8 , 113u8 , 196u8 , 133u8 , 38u8 , 213u8 , 225u8 , 160u8 , 31u8 , 122u8 ,] { self . client . storage () . iter (block_hash) . await } else { Err (:: subxt :: MetadataError :: IncompatibleMetadata . into ()) } } # [doc = " Any liquidity locks of a token type under an account."] # [doc = " NOTE: Should only be accessed when setting, changing and freeing a lock."] pub async fn locks (& self , _0 : & :: subxt :: sp_core :: crypto :: AccountId32 , _1 : & :: core :: primitive :: u32 , block_hash : :: core :: option :: Option < T :: Hash > ,) -> :: core :: result :: Result < runtime_types :: sp_runtime :: bounded :: bounded_vec :: BoundedVec < runtime_types :: orml_tokens :: BalanceLock < :: core :: primitive :: u128 > > , :: subxt :: BasicError > { if self . client . metadata () . storage_hash :: < Locks > () ? == [54u8 , 228u8 , 55u8 , 85u8 , 74u8 , 86u8 , 166u8 , 102u8 , 140u8 , 247u8 , 154u8 , 86u8 , 11u8 , 98u8 , 248u8 , 79u8 , 135u8 , 146u8 , 87u8 , 227u8 , 3u8 , 21u8 , 104u8 , 70u8 , 100u8 , 88u8 , 213u8 , 26u8 , 59u8 , 206u8 , 84u8 , 230u8 ,] { let entry = Locks (_0 , _1) ; self . client . storage () . fetch_or_default (& entry , block_hash) . await } else { Err (:: subxt :: MetadataError :: IncompatibleMetadata . into ()) } } # [doc = " Any liquidity locks of a token type under an account."] # [doc = " NOTE: Should only be accessed when setting, changing and freeing a lock."] pub async fn locks_iter (& self , block_hash : :: core :: option :: Option < T :: Hash > ,) -> :: core :: result :: Result < :: subxt :: KeyIter < 'a , T , Locks < 'a > > , :: subxt :: BasicError > { if self . client . metadata () . storage_hash :: < Locks > () ? == [54u8 , 228u8 , 55u8 , 85u8 , 74u8 , 86u8 , 166u8 , 102u8 , 140u8 , 247u8 , 154u8 , 86u8 , 11u8 , 98u8 , 248u8 , 79u8 , 135u8 , 146u8 , 87u8 , 227u8 , 3u8 , 21u8 , 104u8 , 70u8 , 100u8 , 88u8 , 213u8 , 26u8 , 59u8 , 206u8 , 84u8 , 230u8 ,] { self . client . storage () . iter (block_hash) . await } else { Err (:: subxt :: MetadataError :: IncompatibleMetadata . into ()) } } # [doc = " The balance of a token type under an account."] # [doc = ""] # [doc = " NOTE: If the total is ever zero, decrease account ref account."] # [doc = ""] # [doc = " NOTE: This is only used in the case that this module is used to store"] # [doc = " balances."] pub async fn accounts (& self , _0 : & :: subxt :: sp_core :: crypto :: AccountId32 , _1 : & :: core :: primitive :: u32 , block_hash : :: core :: option :: Option < T :: Hash > ,) -> :: core :: result :: Result < runtime_types :: orml_tokens :: AccountData < :: core :: primitive :: u128 > , :: subxt :: BasicError > { if self . client . metadata () . storage_hash :: < Accounts > () ? == [247u8 , 96u8 , 196u8 , 145u8 , 234u8 , 198u8 , 245u8 , 217u8 , 145u8 , 89u8 , 51u8 , 83u8 , 147u8 , 232u8 , 253u8 , 45u8 , 196u8 , 227u8 , 118u8 , 220u8 , 153u8 , 244u8 , 228u8 , 7u8 , 99u8 , 9u8 , 188u8 , 49u8 , 143u8 , 230u8 , 90u8 , 58u8 ,] { let entry = Accounts (_0 , _1) ; self . client . storage () . fetch_or_default (& entry , block_hash) . await } else { Err (:: subxt :: MetadataError :: IncompatibleMetadata . into ()) } } # [doc = " The balance of a token type under an account."] # [doc = ""] # [doc = " NOTE: If the total is ever zero, decrease account ref account."] # [doc = ""] # [doc = " NOTE: This is only used in the case that this module is used to store"] # [doc = " balances."] pub async fn accounts_iter (& self , block_hash : :: core :: option :: Option < T :: Hash > ,) -> :: core :: result :: Result < :: subxt :: KeyIter < 'a , T , Accounts < 'a > > , :: subxt :: BasicError > { if self . client . metadata () . storage_hash :: < Accounts > () ? == [247u8 , 96u8 , 196u8 , 145u8 , 234u8 , 198u8 , 245u8 , 217u8 , 145u8 , 89u8 , 51u8 , 83u8 , 147u8 , 232u8 , 253u8 , 45u8 , 196u8 , 227u8 , 118u8 , 220u8 , 153u8 , 244u8 , 228u8 , 7u8 , 99u8 , 9u8 , 188u8 , 49u8 , 143u8 , 230u8 , 90u8 , 58u8 ,] { self . client . storage () . iter (block_hash) . await } else { Err (:: subxt :: MetadataError :: IncompatibleMetadata . into ()) } } # [doc = " Named reserves on some account balances."] pub async fn reserves (& self , _0 : & :: subxt :: sp_core :: crypto :: AccountId32 , _1 : & :: core :: primitive :: u32 , block_hash : :: core :: option :: Option < T :: Hash > ,) -> :: core :: result :: Result < runtime_types :: sp_runtime :: bounded :: bounded_vec :: BoundedVec < runtime_types :: orml_tokens :: ReserveData < [:: core :: primitive :: u8 ; 8usize] , :: core :: primitive :: u128 > > , :: subxt :: BasicError > { if self . client . metadata () . storage_hash :: < Reserves > () ? == [21u8 , 43u8 , 4u8 , 147u8 , 195u8 , 66u8 , 224u8 , 166u8 , 229u8 , 179u8 , 246u8 , 235u8 , 17u8 , 19u8 , 26u8 , 111u8 , 245u8 , 39u8 , 11u8 , 173u8 , 216u8 , 239u8 , 203u8 , 64u8 , 157u8 , 225u8 , 113u8 , 86u8 , 46u8 , 137u8 , 91u8 , 63u8 ,] { let entry = Reserves (_0 , _1) ; self . client . storage () . fetch_or_default (& entry , block_hash) . await } else { Err (:: subxt :: MetadataError :: IncompatibleMetadata . into ()) } } # [doc = " Named reserves on some account balances."] pub async fn reserves_iter (& self , block_hash : :: core :: option :: Option < T :: Hash > ,) -> :: core :: result :: Result < :: subxt :: KeyIter < 'a , T , Reserves < 'a > > , :: subxt :: BasicError > { if self . client . metadata () . storage_hash :: < Reserves > () ? == [21u8 , 43u8 , 4u8 , 147u8 , 195u8 , 66u8 , 224u8 , 166u8 , 229u8 , 179u8 , 246u8 , 235u8 , 17u8 , 19u8 , 26u8 , 111u8 , 245u8 , 39u8 , 11u8 , 173u8 , 216u8 , 239u8 , 203u8 , 64u8 , 157u8 , 225u8 , 113u8 , 86u8 , 46u8 , 137u8 , 91u8 , 63u8 ,] { self . client . storage () . iter (block_hash) . await } else { Err (:: subxt :: MetadataError :: IncompatibleMetadata . into ()) } } } } pub mod constants { use super :: runtime_types ; pub struct ConstantsApi < 'a , T : :: subxt :: Config > { client : & 'a :: subxt :: Client < T > , } impl < 'a , T : :: subxt :: Config > ConstantsApi < 'a , T > { pub fn new (client : & 'a :: subxt :: Client < T >) -> Self { Self { client } } pub fn max_locks (& self) -> :: core :: result :: Result < :: core :: primitive :: u32 , :: subxt :: BasicError > { if self . client . metadata () . constant_hash ("Tokens" , "MaxLocks") ? == [151u8 , 235u8 , 142u8 , 126u8 , 248u8 , 136u8 , 215u8 , 236u8 , 187u8 , 43u8 , 88u8 , 91u8 , 52u8 , 252u8 , 55u8 , 71u8 , 93u8 , 133u8 , 235u8 , 209u8 , 153u8 , 180u8 , 95u8 , 203u8 , 113u8 , 82u8 , 27u8 , 228u8 , 101u8 , 250u8 , 238u8 , 32u8 ,] { let pallet = self . client . metadata () . pallet ("Tokens") ? ; let constant = pallet . constant ("MaxLocks") ? ; let value = :: subxt :: codec :: Decode :: decode (& mut & constant . value [..]) ? ; Ok (value) } else { Err (:: subxt :: MetadataError :: IncompatibleMetadata . into ()) } } # [doc = " The maximum number of named reserves that can exist on an account."] pub fn max_reserves (& self) -> :: core :: result :: Result < :: core :: primitive :: u32 , :: subxt :: BasicError > { if self . client . metadata () . constant_hash ("Tokens" , "MaxReserves") ? == [117u8 , 207u8 , 208u8 , 40u8 , 3u8 , 139u8 , 184u8 , 190u8 , 227u8 , 156u8 , 207u8 , 252u8 , 250u8 , 235u8 , 170u8 , 16u8 , 211u8 , 218u8 , 21u8 , 251u8 , 32u8 , 22u8 , 8u8 , 3u8 , 224u8 , 40u8 , 165u8 , 131u8 , 30u8 , 97u8 , 205u8 , 19u8 ,] { let pallet = self . client . metadata () . pallet ("Tokens") ? ; let constant = pallet . constant ("MaxReserves") ? ; let value = :: subxt :: codec :: Decode :: decode (& mut & constant . value [..]) ? ; Ok (value) } else { Err (:: subxt :: MetadataError :: IncompatibleMetadata . into ()) } } } } } pub mod token_wrapper { use super :: root_mod ; use super :: runtime_types ; pub mod calls { use super :: root_mod ; use super :: runtime_types ; type DispatchError = runtime_types :: sp_runtime :: DispatchError ; # [derive (:: subxt :: codec :: Decode , :: subxt :: codec :: Encode , Clone , Debug , Eq , PartialEq)] pub struct SetWrappingFee { pub fee : :: core :: primitive :: u128 , pub into_pool_share_id : :: core :: primitive :: u32 , } impl :: subxt :: Call for SetWrappingFee { const PALLET : & 'static str = "TokenWrapper" ; const FUNCTION : & 'static str = "set_wrapping_fee" ; } # [derive (:: subxt :: codec :: Decode , :: subxt :: codec :: Encode , Clone , Debug , Eq , PartialEq)] pub struct Wrap { pub from_asset_id : :: core :: primitive :: u32 , pub into_pool_share_id : :: core :: primitive :: u32 , pub amount : :: core :: primitive :: u128 , pub recipient : :: subxt :: sp_core :: crypto :: AccountId32 , } impl :: subxt :: Call for Wrap { const PALLET : & 'static str = "TokenWrapper" ; const FUNCTION : & 'static str = "wrap" ; } # [derive (:: subxt :: codec :: Decode , :: subxt :: codec :: Encode , Clone , Debug , Eq , PartialEq)] pub struct Unwrap { pub from_pool_share_id : :: core :: primitive :: u32 , pub into_asset_id : :: core :: primitive :: u32 , pub amount : :: core :: primitive :: u128 , pub recipient : :: subxt :: sp_core :: crypto :: AccountId32 , } impl :: subxt :: Call for Unwrap { const PALLET : & 'static str = "TokenWrapper" ; const FUNCTION : & 'static str = "unwrap" ; } pub struct TransactionApi < 'a , T : :: subxt :: Config , X > { client : & 'a :: subxt :: Client < T > , marker : :: core :: marker :: PhantomData < X > , } impl < 'a , T , X > TransactionApi < 'a , T , X > where T : :: subxt :: Config , X : :: subxt :: extrinsic :: ExtrinsicParams < T > , { pub fn new (client : & 'a :: subxt :: Client < T >) -> Self { Self { client , marker : :: core :: marker :: PhantomData } } pub fn set_wrapping_fee (& self , fee : :: core :: primitive :: u128 , into_pool_share_id : :: core :: primitive :: u32 ,) -> Result < :: subxt :: SubmittableExtrinsic < 'a , T , X , SetWrappingFee , DispatchError , root_mod :: Event > , :: subxt :: BasicError > { if self . client . metadata () . call_hash :: < SetWrappingFee > () ? == [10u8 , 250u8 , 102u8 , 11u8 , 15u8 , 203u8 , 46u8 , 110u8 , 135u8 , 90u8 , 28u8 , 234u8 , 157u8 , 120u8 , 239u8 , 15u8 , 201u8 , 98u8 , 8u8 , 60u8 , 157u8 , 166u8 , 183u8 , 76u8 , 63u8 , 84u8 , 134u8 , 89u8 , 109u8 , 21u8 , 179u8 , 157u8 ,] { let call = SetWrappingFee { fee , into_pool_share_id , } ; Ok (:: subxt :: SubmittableExtrinsic :: new (self . client , call)) } else { Err (:: subxt :: MetadataError :: IncompatibleMetadata . into ()) } } pub fn wrap (& self , from_asset_id : :: core :: primitive :: u32 , into_pool_share_id : :: core :: primitive :: u32 , amount : :: core :: primitive :: u128 , recipient : :: subxt :: sp_core :: crypto :: AccountId32 ,) -> Result < :: subxt :: SubmittableExtrinsic < 'a , T , X , Wrap , DispatchError , root_mod :: Event > , :: subxt :: BasicError > { if self . client . metadata () . call_hash :: < Wrap > () ? == [24u8 , 202u8 , 148u8 , 237u8 , 110u8 , 116u8 , 255u8 , 26u8 , 204u8 , 139u8 , 59u8 , 59u8 , 92u8 , 123u8 , 153u8 , 190u8 , 43u8 , 22u8 , 243u8 , 2u8 , 8u8 , 138u8 , 248u8 , 153u8 , 216u8 , 183u8 , 172u8 , 112u8 , 174u8 , 104u8 , 153u8 , 2u8 ,] { let call = Wrap { from_asset_id , into_pool_share_id , amount , recipient , } ; Ok (:: subxt :: SubmittableExtrinsic :: new (self . client , call)) } else { Err (:: subxt :: MetadataError :: IncompatibleMetadata . into ()) } } pub fn unwrap (& self , from_pool_share_id : :: core :: primitive :: u32 , into_asset_id : :: core :: primitive :: u32 , amount : :: core :: primitive :: u128 , recipient : :: subxt :: sp_core :: crypto :: AccountId32 ,) -> Result < :: subxt :: SubmittableExtrinsic < 'a , T , X , Unwrap , DispatchError , root_mod :: Event > , :: subxt :: BasicError > { if self . client . metadata () . call_hash :: < Unwrap > () ? == [123u8 , 178u8 , 250u8 , 58u8 , 95u8 , 71u8 , 71u8 , 30u8 , 68u8 , 214u8 , 199u8 , 92u8 , 241u8 , 252u8 , 74u8 , 225u8 , 15u8 , 167u8 , 198u8 , 184u8 , 46u8 , 131u8 , 210u8 , 233u8 , 217u8 , 79u8 , 34u8 , 120u8 , 112u8 , 99u8 , 55u8 , 47u8 ,] { let call = Unwrap { from_pool_share_id , into_asset_id , amount , recipient , } ; Ok (:: subxt :: SubmittableExtrinsic :: new (self . client , call)) } else { Err (:: subxt :: MetadataError :: IncompatibleMetadata . into ()) } } } } pub type Event = runtime_types :: pallet_token_wrapper :: pallet :: Event ; pub mod events { use super :: runtime_types ; # [derive (:: subxt :: codec :: Decode , :: subxt :: codec :: Encode , Clone , Debug , Eq , PartialEq)] pub struct WrappedToken { pub pool_share_asset : :: core :: primitive :: u32 , pub asset_id : :: core :: primitive :: u32 , pub amount : :: core :: primitive :: u128 , pub recipient : :: subxt :: sp_core :: crypto :: AccountId32 , } impl :: subxt :: Event for WrappedToken { const PALLET : & 'static str = "TokenWrapper" ; const EVENT : & 'static str = "WrappedToken" ; } # [derive (:: subxt :: codec :: Decode , :: subxt :: codec :: Encode , Clone , Debug , Eq , PartialEq)] pub struct UnwrappedToken { pub pool_share_asset : :: core :: primitive :: u32 , pub asset_id : :: core :: primitive :: u32 , pub amount : :: core :: primitive :: u128 , pub recipient : :: subxt :: sp_core :: crypto :: AccountId32 , } impl :: subxt :: Event for UnwrappedToken { const PALLET : & 'static str = "TokenWrapper" ; const EVENT : & 'static str = "UnwrappedToken" ; } # [derive (:: subxt :: codec :: Decode , :: subxt :: codec :: Encode , Clone , Debug , Eq , PartialEq)] pub struct UpdatedWrappingFeePercent { pub into_pool_share_id : :: core :: primitive :: u32 , pub wrapping_fee_percent : :: core :: primitive :: u128 , } impl :: subxt :: Event for UpdatedWrappingFeePercent { const PALLET : & 'static str = "TokenWrapper" ; const EVENT : & 'static str = "UpdatedWrappingFeePercent" ; } } pub mod storage { use super :: runtime_types ; pub struct WrappingFeePercent < 'a > (pub & 'a :: core :: primitive :: u32) ; impl :: subxt :: StorageEntry for WrappingFeePercent < '_ > { const PALLET : & 'static str = "TokenWrapper" ; const STORAGE : & 'static str = "WrappingFeePercent" ; type Value = :: core :: primitive :: u128 ; fn key (& self) -> :: subxt :: StorageEntryKey { :: subxt :: StorageEntryKey :: Map (vec ! [:: subxt :: StorageMapKey :: new (& self . 0 , :: subxt :: StorageHasher :: Blake2_128Concat)]) } } pub struct StorageApi < 'a , T : :: subxt :: Config > { client : & 'a :: subxt :: Client < T > , } impl < 'a , T : :: subxt :: Config > StorageApi < 'a , T > { pub fn new (client : & 'a :: subxt :: Client < T >) -> Self { Self { client } } # [doc = " Percentage of amount to be used as wrapping fee"] pub async fn wrapping_fee_percent (& self , _0 : & :: core :: primitive :: u32 , block_hash : :: core :: option :: Option < T :: Hash > ,) -> :: core :: result :: Result < :: core :: option :: Option < :: core :: primitive :: u128 > , :: subxt :: BasicError > { if self . client . metadata () . storage_hash :: < WrappingFeePercent > () ? == [31u8 , 126u8 , 185u8 , 195u8 , 250u8 , 224u8 , 247u8 , 225u8 , 251u8 , 232u8 , 118u8 , 36u8 , 104u8 , 42u8 , 118u8 , 184u8 , 232u8 , 148u8 , 238u8 , 142u8 , 123u8 , 71u8 , 37u8 , 218u8 , 200u8 , 216u8 , 84u8 , 184u8 , 4u8 , 56u8 , 13u8 , 94u8 ,] { let entry = WrappingFeePercent (_0) ; self . client . storage () . fetch (& entry , block_hash) . await } else { Err (:: subxt :: MetadataError :: IncompatibleMetadata . into ()) } } # [doc = " Percentage of amount to be used as wrapping fee"] pub async fn wrapping_fee_percent_iter (& self , block_hash : :: core :: option :: Option < T :: Hash > ,) -> :: core :: result :: Result < :: subxt :: KeyIter < 'a , T , WrappingFeePercent < 'a > > , :: subxt :: BasicError > { if self . client . metadata () . storage_hash :: < WrappingFeePercent > () ? == [31u8 , 126u8 , 185u8 , 195u8 , 250u8 , 224u8 , 247u8 , 225u8 , 251u8 , 232u8 , 118u8 , 36u8 , 104u8 , 42u8 , 118u8 , 184u8 , 232u8 , 148u8 , 238u8 , 142u8 , 123u8 , 71u8 , 37u8 , 218u8 , 200u8 , 216u8 , 84u8 , 184u8 , 4u8 , 56u8 , 13u8 , 94u8 ,] { self . client . storage () . iter (block_hash) . await } else { Err (:: subxt :: MetadataError :: IncompatibleMetadata . into ()) } } } } pub mod constants { use super :: runtime_types ; pub struct ConstantsApi < 'a , T : :: subxt :: Config > { client : & 'a :: subxt :: Client < T > , } impl < 'a , T : :: subxt :: Config > ConstantsApi < 'a , T > { pub fn new (client : & 'a :: subxt :: Client < T >) -> Self { Self { client } } pub fn pallet_id (& self) -> :: core :: result :: Result < runtime_types :: frame_support :: PalletId , :: subxt :: BasicError > { if self . client . metadata () . constant_hash ("TokenWrapper" , "PalletId") ? == [72u8 , 22u8 , 72u8 , 130u8 , 86u8 , 144u8 , 205u8 , 158u8 , 69u8 , 184u8 , 150u8 , 19u8 , 142u8 , 62u8 , 213u8 , 93u8 , 168u8 , 249u8 , 178u8 , 247u8 , 41u8 , 166u8 , 244u8 , 182u8 , 59u8 , 227u8 , 159u8 , 43u8 , 54u8 , 80u8 , 123u8 , 11u8 ,] { let pallet = self . client . metadata () . pallet ("TokenWrapper") ? ; let constant = pallet . constant ("PalletId") ? ; let value = :: subxt :: codec :: Decode :: decode (& mut & constant . value [..]) ? ; Ok (value) } else { Err (:: subxt :: MetadataError :: IncompatibleMetadata . into ()) } } pub fn treasury_id (& self) -> :: core :: result :: Result < runtime_types :: frame_support :: PalletId , :: subxt :: BasicError > { if self . client . metadata () . constant_hash ("TokenWrapper" , "TreasuryId") ? == [129u8 , 6u8 , 230u8 , 249u8 , 236u8 , 151u8 , 80u8 , 236u8 , 102u8 , 52u8 , 38u8 , 149u8 , 129u8 , 59u8 , 97u8 , 1u8 , 149u8 , 218u8 , 17u8 , 248u8 , 246u8 , 178u8 , 170u8 , 254u8 , 175u8 , 62u8 , 172u8 , 71u8 , 86u8 , 171u8 , 244u8 , 100u8 ,] { let pallet = self . client . metadata () . pallet ("TokenWrapper") ? ; let constant = pallet . constant ("TreasuryId") ? ; let value = :: subxt :: codec :: Decode :: decode (& mut & constant . value [..]) ? ; Ok (value) } else { Err (:: subxt :: MetadataError :: IncompatibleMetadata . into ()) } } pub fn wrapping_fee_divider (& self) -> :: core :: result :: Result < :: core :: primitive :: u128 , :: subxt :: BasicError > { if self . client . metadata () . constant_hash ("TokenWrapper" , "WrappingFeeDivider") ? == [178u8 , 173u8 , 218u8 , 254u8 , 162u8 , 199u8 , 24u8 , 69u8 , 155u8 , 199u8 , 62u8 , 121u8 , 140u8 , 161u8 , 123u8 , 108u8 , 91u8 , 232u8 , 63u8 , 71u8 , 143u8 , 104u8 , 62u8 , 6u8 , 93u8 , 101u8 , 215u8 , 63u8 , 63u8 , 37u8 , 49u8 , 113u8 ,] { let pallet = self . client . metadata () . pallet ("TokenWrapper") ? ; let constant = pallet . constant ("WrappingFeeDivider") ? ; let value = :: subxt :: codec :: Decode :: decode (& mut & constant . value [..]) ? ; Ok (value) } else { Err (:: subxt :: MetadataError :: IncompatibleMetadata . into ()) } } } } } pub mod mixer_verifier_bn254 { use super :: root_mod ; use super :: runtime_types ; pub mod calls { use super :: root_mod ; use super :: runtime_types ; type DispatchError = runtime_types :: sp_runtime :: DispatchError ; # [derive (:: subxt :: codec :: Decode , :: subxt :: codec :: Encode , Clone , Debug , Eq , PartialEq)] pub struct ForceSetParameters { pub parameters : :: std :: vec :: Vec < :: core :: primitive :: u8 > , } impl :: subxt :: Call for ForceSetParameters { const PALLET : & 'static str = "MixerVerifierBn254" ; const FUNCTION : & 'static str = "force_set_parameters" ; } pub struct TransactionApi < 'a , T : :: subxt :: Config , X > { client : & 'a :: subxt :: Client < T > , marker : :: core :: marker :: PhantomData < X > , } impl < 'a , T , X > TransactionApi < 'a , T , X > where T : :: subxt :: Config , X : :: subxt :: extrinsic :: ExtrinsicParams < T > , { pub fn new (client : & 'a :: subxt :: Client < T >) -> Self { Self { client , marker : :: core :: marker :: PhantomData } } pub fn force_set_parameters (& self , parameters : :: std :: vec :: Vec < :: core :: primitive :: u8 > ,) -> Result < :: subxt :: SubmittableExtrinsic < 'a , T , X , ForceSetParameters , DispatchError , root_mod :: Event > , :: subxt :: BasicError > { if self . client . metadata () . call_hash :: < ForceSetParameters > () ? == [4u8 , 152u8 , 126u8 , 7u8 , 21u8 , 41u8 , 229u8 , 72u8 , 49u8 , 177u8 , 34u8 , 57u8 , 44u8 , 27u8 , 82u8 , 102u8 , 214u8 , 37u8 , 20u8 , 122u8 , 7u8 , 179u8 , 196u8 , 112u8 , 192u8 , 168u8 , 247u8 , 171u8 , 177u8 , 42u8 , 167u8 , 15u8 ,] { let call = ForceSetParameters { parameters , } ; Ok (:: subxt :: SubmittableExtrinsic :: new (self . client , call)) } else { Err (:: subxt :: MetadataError :: IncompatibleMetadata . into ()) } } } } pub type Event = runtime_types :: pallet_verifier :: pallet :: Event ; pub mod events { use super :: runtime_types ; } pub mod storage { use super :: runtime_types ; pub struct Parameters ; impl :: subxt :: StorageEntry for Parameters { const PALLET : & 'static str = "MixerVerifierBn254" ; const STORAGE : & 'static str = "Parameters" ; type Value = :: std :: vec :: Vec < :: core :: primitive :: u8 > ; fn key (& self) -> :: subxt :: StorageEntryKey { :: subxt :: StorageEntryKey :: Plain } } pub struct StorageApi < 'a , T : :: subxt :: Config > { client : & 'a :: subxt :: Client < T > , } impl < 'a , T : :: subxt :: Config > StorageApi < 'a , T > { pub fn new (client : & 'a :: subxt :: Client < T >) -> Self { Self { client } } # [doc = " Details of the module's parameters"] pub async fn parameters (& self , block_hash : :: core :: option :: Option < T :: Hash > ,) -> :: core :: result :: Result < :: std :: vec :: Vec < :: core :: primitive :: u8 > , :: subxt :: BasicError > { if self . client . metadata () . storage_hash :: < Parameters > () ? == [244u8 , 201u8 , 192u8 , 254u8 , 217u8 , 76u8 , 12u8 , 84u8 , 71u8 , 96u8 , 64u8 , 115u8 , 66u8 , 74u8 , 252u8 , 59u8 , 193u8 , 35u8 , 136u8 , 67u8 , 55u8 , 96u8 , 185u8 , 129u8 , 130u8 , 120u8 , 224u8 , 100u8 , 199u8 , 83u8 , 107u8 , 187u8 ,] { let entry = Parameters ; self . client . storage () . fetch_or_default (& entry , block_hash) . await } else { Err (:: subxt :: MetadataError :: IncompatibleMetadata . into ()) } } } } } pub mod anchor_verifier_bn254 { use super :: root_mod ; use super :: runtime_types ; pub mod calls { use super :: root_mod ; use super :: runtime_types ; type DispatchError = runtime_types :: sp_runtime :: DispatchError ; # [derive (:: subxt :: codec :: Decode , :: subxt :: codec :: Encode , Clone , Debug , Eq , PartialEq)] pub struct ForceSetParameters { pub parameters : :: std :: vec :: Vec < :: core :: primitive :: u8 > , } impl :: subxt :: Call for ForceSetParameters { const PALLET : & 'static str = "AnchorVerifierBn254" ; const FUNCTION : & 'static str = "force_set_parameters" ; } pub struct TransactionApi < 'a , T : :: subxt :: Config , X > { client : & 'a :: subxt :: Client < T > , marker : :: core :: marker :: PhantomData < X > , } impl < 'a , T , X > TransactionApi < 'a , T , X > where T : :: subxt :: Config , X : :: subxt :: extrinsic :: ExtrinsicParams < T > , { pub fn new (client : & 'a :: subxt :: Client < T >) -> Self { Self { client , marker : :: core :: marker :: PhantomData } } pub fn force_set_parameters (& self , parameters : :: std :: vec :: Vec < :: core :: primitive :: u8 > ,) -> Result < :: subxt :: SubmittableExtrinsic < 'a , T , X , ForceSetParameters , DispatchError , root_mod :: Event > , :: subxt :: BasicError > { if self . client . metadata () . call_hash :: < ForceSetParameters > () ? == [4u8 , 152u8 , 126u8 , 7u8 , 21u8 , 41u8 , 229u8 , 72u8 , 49u8 , 177u8 , 34u8 , 57u8 , 44u8 , 27u8 , 82u8 , 102u8 , 214u8 , 37u8 , 20u8 , 122u8 , 7u8 , 179u8 , 196u8 , 112u8 , 192u8 , 168u8 , 247u8 , 171u8 , 177u8 , 42u8 , 167u8 , 15u8 ,] { let call = ForceSetParameters { parameters , } ; Ok (:: subxt :: SubmittableExtrinsic :: new (self . client , call)) } else { Err (:: subxt :: MetadataError :: IncompatibleMetadata . into ()) } } } } pub type Event = runtime_types :: pallet_verifier :: pallet :: Event ; pub mod events { use super :: runtime_types ; } pub mod storage { use super :: runtime_types ; pub struct Parameters ; impl :: subxt :: StorageEntry for Parameters { const PALLET : & 'static str = "AnchorVerifierBn254" ; const STORAGE : & 'static str = "Parameters" ; type Value = :: std :: vec :: Vec < :: core :: primitive :: u8 > ; fn key (& self) -> :: subxt :: StorageEntryKey { :: subxt :: StorageEntryKey :: Plain } } pub struct StorageApi < 'a , T : :: subxt :: Config > { client : & 'a :: subxt :: Client < T > , } impl < 'a , T : :: subxt :: Config > StorageApi < 'a , T > { pub fn new (client : & 'a :: subxt :: Client < T >) -> Self { Self { client } } # [doc = " Details of the module's parameters"] pub async fn parameters (& self , block_hash : :: core :: option :: Option < T :: Hash > ,) -> :: core :: result :: Result < :: std :: vec :: Vec < :: core :: primitive :: u8 > , :: subxt :: BasicError > { if self . client . metadata () . storage_hash :: < Parameters > () ? == [244u8 , 201u8 , 192u8 , 254u8 , 217u8 , 76u8 , 12u8 , 84u8 , 71u8 , 96u8 , 64u8 , 115u8 , 66u8 , 74u8 , 252u8 , 59u8 , 193u8 , 35u8 , 136u8 , 67u8 , 55u8 , 96u8 , 185u8 , 129u8 , 130u8 , 120u8 , 224u8 , 100u8 , 199u8 , 83u8 , 107u8 , 187u8 ,] { let entry = Parameters ; self . client . storage () . fetch_or_default (& entry , block_hash) . await } else { Err (:: subxt :: MetadataError :: IncompatibleMetadata . into ()) } } } } } pub mod merkle_tree_bn254 { use super :: root_mod ; use super :: runtime_types ; pub mod calls { use super :: root_mod ; use super :: runtime_types ; type DispatchError = runtime_types :: sp_runtime :: DispatchError ; # [derive (:: subxt :: codec :: CompactAs , :: subxt :: codec :: Decode , :: subxt :: codec :: Encode , Clone , Debug , Eq , PartialEq)] pub struct Create { pub depth : :: core :: primitive :: u8 , } impl :: subxt :: Call for Create { const PALLET : & 'static str = "MerkleTreeBn254" ; const FUNCTION : & 'static str = "create" ; } # [derive (:: subxt :: codec :: Decode , :: subxt :: codec :: Encode , Clone , Debug , Eq , PartialEq)] pub struct Insert { pub tree_id : :: core :: primitive :: u32 , pub leaf : runtime_types :: egg_standalone_runtime :: protocol_substrate_config :: Element , } impl :: subxt :: Call for Insert { const PALLET : & 'static str = "MerkleTreeBn254" ; const FUNCTION : & 'static str = "insert" ; } # [derive (:: subxt :: codec :: Decode , :: subxt :: codec :: Encode , Clone , Debug , Eq , PartialEq)] pub struct ForceSetDefaultHashes { pub default_hashes : :: std :: vec :: Vec < runtime_types :: egg_standalone_runtime :: protocol_substrate_config :: Element > , } impl :: subxt :: Call for ForceSetDefaultHashes { const PALLET : & 'static str = "MerkleTreeBn254" ; const FUNCTION : & 'static str = "force_set_default_hashes" ; } pub struct TransactionApi < 'a , T : :: subxt :: Config , X > { client : & 'a :: subxt :: Client < T > , marker : :: core :: marker :: PhantomData < X > , } impl < 'a , T , X > TransactionApi < 'a , T , X > where T : :: subxt :: Config , X : :: subxt :: extrinsic :: ExtrinsicParams < T > , { pub fn new (client : & 'a :: subxt :: Client < T >) -> Self { Self { client , marker : :: core :: marker :: PhantomData } } pub fn create (& self , depth : :: core :: primitive :: u8 ,) -> Result < :: subxt :: SubmittableExtrinsic < 'a , T , X , Create , DispatchError , root_mod :: Event > , :: subxt :: BasicError > { if self . client . metadata () . call_hash :: < Create > () ? == [173u8 , 83u8 , 24u8 , 171u8 , 197u8 , 45u8 , 93u8 , 45u8 , 13u8 , 134u8 , 248u8 , 211u8 , 87u8 , 89u8 , 209u8 , 153u8 , 46u8 , 153u8 , 168u8 , 202u8 , 44u8 , 137u8 , 119u8 , 167u8 , 30u8 , 182u8 , 99u8 , 85u8 , 151u8 , 136u8 , 151u8 , 119u8 ,] { let call = Create { depth , } ; Ok (:: subxt :: SubmittableExtrinsic :: new (self . client , call)) } else { Err (:: subxt :: MetadataError :: IncompatibleMetadata . into ()) } } pub fn insert (& self , tree_id : :: core :: primitive :: u32 , leaf : runtime_types :: egg_standalone_runtime :: protocol_substrate_config :: Element ,) -> Result < :: subxt :: SubmittableExtrinsic < 'a , T , X , Insert , DispatchError , root_mod :: Event > , :: subxt :: BasicError > { if self . client . metadata () . call_hash :: < Insert > () ? == [66u8 , 125u8 , 60u8 , 130u8 , 111u8 , 176u8 , 140u8 , 176u8 , 225u8 , 47u8 , 93u8 , 1u8 , 65u8 , 79u8 , 1u8 , 157u8 , 15u8 , 160u8 , 50u8 , 7u8 , 35u8 , 74u8 , 120u8 , 114u8 , 226u8 , 14u8 , 145u8 , 70u8 , 41u8 , 196u8 , 131u8 , 97u8 ,] { let call = Insert { tree_id , leaf , } ; Ok (:: subxt :: SubmittableExtrinsic :: new (self . client , call)) } else { Err (:: subxt :: MetadataError :: IncompatibleMetadata . into ()) } } pub fn force_set_default_hashes (& self , default_hashes : :: std :: vec :: Vec < runtime_types :: egg_standalone_runtime :: protocol_substrate_config :: Element > ,) -> Result < :: subxt :: SubmittableExtrinsic < 'a , T , X , ForceSetDefaultHashes , DispatchError , root_mod :: Event > , :: subxt :: BasicError > { if self . client . metadata () . call_hash :: < ForceSetDefaultHashes > () ? == [228u8 , 57u8 , 118u8 , 249u8 , 172u8 , 104u8 , 14u8 , 250u8 , 241u8 , 128u8 , 7u8 , 5u8 , 104u8 , 196u8 , 237u8 , 93u8 , 50u8 , 77u8 , 97u8 , 111u8 , 251u8 , 217u8 , 93u8 , 15u8 , 243u8 , 70u8 , 238u8 , 30u8 , 224u8 , 68u8 , 30u8 , 236u8 ,] { let call = ForceSetDefaultHashes { default_hashes , } ; Ok (:: subxt :: SubmittableExtrinsic :: new (self . client , call)) } else { Err (:: subxt :: MetadataError :: IncompatibleMetadata . into ()) } } } } pub type Event = runtime_types :: pallet_mt :: pallet :: Event ; pub mod events { use super :: runtime_types ; # [derive (:: subxt :: codec :: Decode , :: subxt :: codec :: Encode , Clone , Debug , Eq , PartialEq)] # [doc = "New tree created"] pub struct TreeCreation { pub tree_id : :: core :: primitive :: u32 , pub who : :: subxt :: sp_core :: crypto :: AccountId32 , } impl :: subxt :: Event for TreeCreation { const PALLET : & 'static str = "MerkleTreeBn254" ; const EVENT : & 'static str = "TreeCreation" ; } # [derive (:: subxt :: codec :: Decode , :: subxt :: codec :: Encode , Clone , Debug , Eq , PartialEq)] # [doc = "New leaf inserted"] pub struct LeafInsertion { pub tree_id : :: core :: primitive :: u32 , pub leaf_index : :: core :: primitive :: u32 , pub leaf : runtime_types :: egg_standalone_runtime :: protocol_substrate_config :: Element , } impl :: subxt :: Event for LeafInsertion { const PALLET : & 'static str = "MerkleTreeBn254" ; const EVENT : & 'static str = "LeafInsertion" ; } } pub mod storage { use super :: runtime_types ; pub struct Deposit ; impl :: subxt :: StorageEntry for Deposit { const PALLET : & 'static str = "MerkleTreeBn254" ; const STORAGE : & 'static str = "Deposit" ; type Value = runtime_types :: webb_primitives :: types :: DepositDetails < :: subxt :: sp_core :: crypto :: AccountId32 , :: core :: primitive :: u128 > ; fn key (& self) -> :: subxt :: StorageEntryKey { :: subxt :: StorageEntryKey :: Plain } } pub struct NextTreeId ; impl :: subxt :: StorageEntry for NextTreeId { const PALLET : & 'static str = "MerkleTreeBn254" ; const STORAGE : & 'static str = "NextTreeId" ; type Value = :: core :: primitive :: u32 ; fn key (& self) -> :: subxt :: StorageEntryKey { :: subxt :: StorageEntryKey :: Plain } } pub struct Trees < 'a > (pub & 'a :: core :: primitive :: u32) ; impl :: subxt :: StorageEntry for Trees < '_ > { const PALLET : & 'static str = "MerkleTreeBn254" ; const STORAGE : & 'static str = "Trees" ; type Value = runtime_types :: pallet_mt :: types :: TreeMetadata < :: subxt :: sp_core :: crypto :: AccountId32 , :: core :: primitive :: u32 , runtime_types :: egg_standalone_runtime :: protocol_substrate_config :: Element > ; fn key (& self) -> :: subxt :: StorageEntryKey { :: subxt :: StorageEntryKey :: Map (vec ! [:: subxt :: StorageMapKey :: new (& self . 0 , :: subxt :: StorageHasher :: Blake2_128Concat)]) } } pub struct DefaultHashes ; impl :: subxt :: StorageEntry for DefaultHashes { const PALLET : & 'static str = "MerkleTreeBn254" ; const STORAGE : & 'static str = "DefaultHashes" ; type Value = :: std :: vec :: Vec < runtime_types :: egg_standalone_runtime :: protocol_substrate_config :: Element > ; fn key (& self) -> :: subxt :: StorageEntryKey { :: subxt :: StorageEntryKey :: Plain } } pub struct Leaves < 'a > (pub & 'a :: core :: primitive :: u32 , pub & 'a :: core :: primitive :: u32) ; impl :: subxt :: StorageEntry for Leaves < '_ > { const PALLET : & 'static str = "MerkleTreeBn254" ; const STORAGE : & 'static str = "Leaves" ; type Value = runtime_types :: egg_standalone_runtime :: protocol_substrate_config :: Element ; fn key (& self) -> :: subxt :: StorageEntryKey { :: subxt :: StorageEntryKey :: Map (vec ! [:: subxt :: StorageMapKey :: new (& self . 0 , :: subxt :: StorageHasher :: Blake2_128Concat) , :: subxt :: StorageMapKey :: new (& self . 1 , :: subxt :: StorageHasher :: Blake2_128Concat)]) } } pub struct NextRootIndex ; impl :: subxt :: StorageEntry for NextRootIndex { const PALLET : & 'static str = "MerkleTreeBn254" ; const STORAGE : & 'static str = "NextRootIndex" ; type Value = :: core :: primitive :: u32 ; fn key (& self) -> :: subxt :: StorageEntryKey { :: subxt :: StorageEntryKey :: Plain } } pub struct NextLeafIndex < 'a > (pub & 'a :: core :: primitive :: u32) ; impl :: subxt :: StorageEntry for NextLeafIndex < '_ > { const PALLET : & 'static str = "MerkleTreeBn254" ; const STORAGE : & 'static str = "NextLeafIndex" ; type Value = :: core :: primitive :: u32 ; fn key (& self) -> :: subxt :: StorageEntryKey { :: subxt :: StorageEntryKey :: Map (vec ! [:: subxt :: StorageMapKey :: new (& self . 0 , :: subxt :: StorageHasher :: Blake2_128Concat)]) } } pub struct CachedRoots < 'a > (pub & 'a :: core :: primitive :: u32 , pub & 'a :: core :: primitive :: u32) ; impl :: subxt :: StorageEntry for CachedRoots < '_ > { const PALLET : & 'static str = "MerkleTreeBn254" ; const STORAGE : & 'static str = "CachedRoots" ; type Value = runtime_types :: egg_standalone_runtime :: protocol_substrate_config :: Element ; fn key (& self) -> :: subxt :: StorageEntryKey { :: subxt :: StorageEntryKey :: Map (vec ! [:: subxt :: StorageMapKey :: new (& self . 0 , :: subxt :: StorageHasher :: Blake2_128Concat) , :: subxt :: StorageMapKey :: new (& self . 1 , :: subxt :: StorageHasher :: Blake2_128Concat)]) } } pub struct StorageApi < 'a , T : :: subxt :: Config > { client : & 'a :: subxt :: Client < T > , } impl < 'a , T : :: subxt :: Config > StorageApi < 'a , T > { pub fn new (client : & 'a :: subxt :: Client < T >) -> Self { Self { client } } # [doc = " Details of the module's parameters"] pub async fn deposit (& self , block_hash : :: core :: option :: Option < T :: Hash > ,) -> :: core :: result :: Result < :: core :: option :: Option < runtime_types :: webb_primitives :: types :: DepositDetails < :: subxt :: sp_core :: crypto :: AccountId32 , :: core :: primitive :: u128 > > , :: subxt :: BasicError > { if self . client . metadata () . storage_hash :: < Deposit > () ? == [0u8 , 255u8 , 162u8 , 150u8 , 176u8 , 195u8 , 39u8 , 204u8 , 228u8 , 91u8 , 211u8 , 41u8 , 129u8 , 156u8 , 255u8 , 6u8 , 228u8 , 124u8 , 247u8 , 205u8 , 154u8 , 94u8 , 71u8 , 30u8 , 131u8 , 181u8 , 210u8 , 134u8 , 147u8 , 182u8 , 24u8 , 17u8 ,] { let entry = Deposit ; self . client . storage () . fetch (& entry , block_hash) . await } else { Err (:: subxt :: MetadataError :: IncompatibleMetadata . into ()) } } # [doc = " The next tree identifier up for grabs"] pub async fn next_tree_id (& self , block_hash : :: core :: option :: Option < T :: Hash > ,) -> :: core :: result :: Result < :: core :: primitive :: u32 , :: subxt :: BasicError > { if self . client . metadata () . storage_hash :: < NextTreeId > () ? == [173u8 , 89u8 , 80u8 , 58u8 , 200u8 , 64u8 , 201u8 , 3u8 , 169u8 , 139u8 , 75u8 , 117u8 , 56u8 , 52u8 , 163u8 , 25u8 , 83u8 , 189u8 , 66u8 , 245u8 , 249u8 , 30u8 , 211u8 , 225u8 , 16u8 , 47u8 , 232u8 , 148u8 , 75u8 , 156u8 , 233u8 , 74u8 ,] { let entry = NextTreeId ; self . client . storage () . fetch_or_default (& entry , block_hash) . await } else { Err (:: subxt :: MetadataError :: IncompatibleMetadata . into ()) } } # [doc = " The map of trees to their metadata"] pub async fn trees (& self , _0 : & :: core :: primitive :: u32 , block_hash : :: core :: option :: Option < T :: Hash > ,) -> :: core :: result :: Result < :: core :: option :: Option < runtime_types :: pallet_mt :: types :: TreeMetadata < :: subxt :: sp_core :: crypto :: AccountId32 , :: core :: primitive :: u32 , runtime_types :: egg_standalone_runtime :: protocol_substrate_config :: Element > > , :: subxt :: BasicError > { if self . client . metadata () . storage_hash :: < Trees > () ? == [170u8 , 235u8 , 206u8 , 120u8 , 5u8 , 25u8 , 170u8 , 19u8 , 11u8 , 158u8 , 121u8 , 253u8 , 36u8 , 200u8 , 138u8 , 226u8 , 11u8 , 11u8 , 141u8 , 193u8 , 160u8 , 140u8 , 125u8 , 37u8 , 52u8 , 250u8 , 241u8 , 232u8 , 15u8 , 6u8 , 252u8 , 115u8 ,] { let entry = Trees (_0) ; self . client . storage () . fetch (& entry , block_hash) . await } else { Err (:: subxt :: MetadataError :: IncompatibleMetadata . into ()) } } # [doc = " The map of trees to their metadata"] pub async fn trees_iter (& self , block_hash : :: core :: option :: Option < T :: Hash > ,) -> :: core :: result :: Result < :: subxt :: KeyIter < 'a , T , Trees < 'a > > , :: subxt :: BasicError > { if self . client . metadata () . storage_hash :: < Trees > () ? == [170u8 , 235u8 , 206u8 , 120u8 , 5u8 , 25u8 , 170u8 , 19u8 , 11u8 , 158u8 , 121u8 , 253u8 , 36u8 , 200u8 , 138u8 , 226u8 , 11u8 , 11u8 , 141u8 , 193u8 , 160u8 , 140u8 , 125u8 , 37u8 , 52u8 , 250u8 , 241u8 , 232u8 , 15u8 , 6u8 , 252u8 , 115u8 ,] { self . client . storage () . iter (block_hash) . await } else { Err (:: subxt :: MetadataError :: IncompatibleMetadata . into ()) } } # [doc = " The default hashes for this tree pallet"] pub async fn default_hashes (& self , block_hash : :: core :: option :: Option < T :: Hash > ,) -> :: core :: result :: Result < :: std :: vec :: Vec < runtime_types :: egg_standalone_runtime :: protocol_substrate_config :: Element > , :: subxt :: BasicError > { if self . client . metadata () . storage_hash :: < DefaultHashes > () ? == [181u8 , 196u8 , 187u8 , 53u8 , 228u8 , 169u8 , 212u8 , 210u8 , 188u8 , 11u8 , 173u8 , 69u8 , 183u8 , 238u8 , 185u8 , 226u8 , 166u8 , 188u8 , 223u8 , 104u8 , 235u8 , 236u8 , 142u8 , 52u8 , 216u8 , 86u8 , 225u8 , 176u8 , 193u8 , 144u8 , 16u8 , 2u8 ,] { let entry = DefaultHashes ; self . client . storage () . fetch_or_default (& entry , block_hash) . await } else { Err (:: subxt :: MetadataError :: IncompatibleMetadata . into ()) } } # [doc = " The map of (tree_id, index) to the leaf commitment"] pub async fn leaves (& self , _0 : & :: core :: primitive :: u32 , _1 : & :: core :: primitive :: u32 , block_hash : :: core :: option :: Option < T :: Hash > ,) -> :: core :: result :: Result < runtime_types :: egg_standalone_runtime :: protocol_substrate_config :: Element , :: subxt :: BasicError > { if self . client . metadata () . storage_hash :: < Leaves > () ? == [212u8 , 188u8 , 85u8 , 30u8 , 118u8 , 172u8 , 173u8 , 36u8 , 50u8 , 39u8 , 95u8 , 159u8 , 222u8 , 220u8 , 38u8 , 87u8 , 167u8 , 103u8 , 74u8 , 200u8 , 13u8 , 175u8 , 254u8 , 124u8 , 215u8 , 216u8 , 252u8 , 51u8 , 53u8 , 230u8 , 9u8 , 152u8 ,] { let entry = Leaves (_0 , _1) ; self . client . storage () . fetch_or_default (& entry , block_hash) . await } else { Err (:: subxt :: MetadataError :: IncompatibleMetadata . into ()) } } # [doc = " The map of (tree_id, index) to the leaf commitment"] pub async fn leaves_iter (& self , block_hash : :: core :: option :: Option < T :: Hash > ,) -> :: core :: result :: Result < :: subxt :: KeyIter < 'a , T , Leaves < 'a > > , :: subxt :: BasicError > { if self . client . metadata () . storage_hash :: < Leaves > () ? == [212u8 , 188u8 , 85u8 , 30u8 , 118u8 , 172u8 , 173u8 , 36u8 , 50u8 , 39u8 , 95u8 , 159u8 , 222u8 , 220u8 , 38u8 , 87u8 , 167u8 , 103u8 , 74u8 , 200u8 , 13u8 , 175u8 , 254u8 , 124u8 , 215u8 , 216u8 , 252u8 , 51u8 , 53u8 , 230u8 , 9u8 , 152u8 ,] { self . client . storage () . iter (block_hash) . await } else { Err (:: subxt :: MetadataError :: IncompatibleMetadata . into ()) } } # [doc = " The next tree identifier up for grabs"] pub async fn next_root_index (& self , block_hash : :: core :: option :: Option < T :: Hash > ,) -> :: core :: result :: Result < :: core :: primitive :: u32 , :: subxt :: BasicError > { if self . client . metadata () . storage_hash :: < NextRootIndex > () ? == [175u8 , 70u8 , 212u8 , 119u8 , 231u8 , 181u8 , 88u8 , 15u8 , 186u8 , 22u8 , 1u8 , 117u8 , 56u8 , 178u8 , 191u8 , 154u8 , 150u8 , 203u8 , 131u8 , 128u8 , 22u8 , 141u8 , 171u8 , 148u8 , 160u8 , 177u8 , 38u8 , 48u8 , 76u8 , 198u8 , 224u8 , 126u8 ,] { let entry = NextRootIndex ; self . client . storage () . fetch_or_default (& entry , block_hash) . await } else { Err (:: subxt :: MetadataError :: IncompatibleMetadata . into ()) } } # [doc = " The next tree identifier up for grabs"] pub async fn next_leaf_index (& self , _0 : & :: core :: primitive :: u32 , block_hash : :: core :: option :: Option < T :: Hash > ,) -> :: core :: result :: Result < :: core :: primitive :: u32 , :: subxt :: BasicError > { if self . client . metadata () . storage_hash :: < NextLeafIndex > () ? == [50u8 , 243u8 , 135u8 , 181u8 , 149u8 , 69u8 , 42u8 , 31u8 , 72u8 , 206u8 , 86u8 , 230u8 , 207u8 , 247u8 , 60u8 , 27u8 , 91u8 , 95u8 , 103u8 , 48u8 , 101u8 , 252u8 , 136u8 , 220u8 , 56u8 , 246u8 , 184u8 , 208u8 , 140u8 , 82u8 , 250u8 , 22u8 ,] { let entry = NextLeafIndex (_0) ; self . client . storage () . fetch_or_default (& entry , block_hash) . await } else { Err (:: subxt :: MetadataError :: IncompatibleMetadata . into ()) } } # [doc = " The next tree identifier up for grabs"] pub async fn next_leaf_index_iter (& self , block_hash : :: core :: option :: Option < T :: Hash > ,) -> :: core :: result :: Result < :: subxt :: KeyIter < 'a , T , NextLeafIndex < 'a > > , :: subxt :: BasicError > { if self . client . metadata () . storage_hash :: < NextLeafIndex > () ? == [50u8 , 243u8 , 135u8 , 181u8 , 149u8 , 69u8 , 42u8 , 31u8 , 72u8 , 206u8 , 86u8 , 230u8 , 207u8 , 247u8 , 60u8 , 27u8 , 91u8 , 95u8 , 103u8 , 48u8 , 101u8 , 252u8 , 136u8 , 220u8 , 56u8 , 246u8 , 184u8 , 208u8 , 140u8 , 82u8 , 250u8 , 22u8 ,] { self . client . storage () . iter (block_hash) . await } else { Err (:: subxt :: MetadataError :: IncompatibleMetadata . into ()) } } # [doc = " Map of root history from tree id to root index to root values"] pub async fn cached_roots (& self , _0 : & :: core :: primitive :: u32 , _1 : & :: core :: primitive :: u32 , block_hash : :: core :: option :: Option < T :: Hash > ,) -> :: core :: result :: Result < runtime_types :: egg_standalone_runtime :: protocol_substrate_config :: Element , :: subxt :: BasicError > { if self . client . metadata () . storage_hash :: < CachedRoots > () ? == [22u8 , 164u8 , 82u8 , 3u8 , 227u8 , 128u8 , 179u8 , 143u8 , 121u8 , 253u8 , 211u8 , 67u8 , 223u8 , 219u8 , 108u8 , 144u8 , 113u8 , 49u8 , 200u8 , 110u8 , 75u8 , 69u8 , 154u8 , 25u8 , 137u8 , 38u8 , 245u8 , 102u8 , 91u8 , 26u8 , 100u8 , 252u8 ,] { let entry = CachedRoots (_0 , _1) ; self . client . storage () . fetch_or_default (& entry , block_hash) . await } else { Err (:: subxt :: MetadataError :: IncompatibleMetadata . into ()) } } # [doc = " Map of root history from tree id to root index to root values"] pub async fn cached_roots_iter (& self , block_hash : :: core :: option :: Option < T :: Hash > ,) -> :: core :: result :: Result < :: subxt :: KeyIter < 'a , T , CachedRoots < 'a > > , :: subxt :: BasicError > { if self . client . metadata () . storage_hash :: < CachedRoots > () ? == [22u8 , 164u8 , 82u8 , 3u8 , 227u8 , 128u8 , 179u8 , 143u8 , 121u8 , 253u8 , 211u8 , 67u8 , 223u8 , 219u8 , 108u8 , 144u8 , 113u8 , 49u8 , 200u8 , 110u8 , 75u8 , 69u8 , 154u8 , 25u8 , 137u8 , 38u8 , 245u8 , 102u8 , 91u8 , 26u8 , 100u8 , 252u8 ,] { self . client . storage () . iter (block_hash) . await } else { Err (:: subxt :: MetadataError :: IncompatibleMetadata . into ()) } } } } } pub mod linkable_tree_bn254 { use super :: root_mod ; use super :: runtime_types ; pub mod calls { use super :: root_mod ; use super :: runtime_types ; type DispatchError = runtime_types :: sp_runtime :: DispatchError ; # [derive (:: subxt :: codec :: Decode , :: subxt :: codec :: Encode , Clone , Debug , Eq , PartialEq)] pub struct Create { pub max_edges : :: core :: primitive :: u32 , pub depth : :: core :: primitive :: u8 , } impl :: subxt :: Call for Create { const PALLET : & 'static str = "LinkableTreeBn254" ; const FUNCTION : & 'static str = "create" ; } pub struct TransactionApi < 'a , T : :: subxt :: Config , X > { client : & 'a :: subxt :: Client < T > , marker : :: core :: marker :: PhantomData < X > , } impl < 'a , T , X > TransactionApi < 'a , T , X > where T : :: subxt :: Config , X : :: subxt :: extrinsic :: ExtrinsicParams < T > , { pub fn new (client : & 'a :: subxt :: Client < T >) -> Self { Self { client , marker : :: core :: marker :: PhantomData } } pub fn create (& self , max_edges : :: core :: primitive :: u32 , depth : :: core :: primitive :: u8 ,) -> Result < :: subxt :: SubmittableExtrinsic < 'a , T , X , Create , DispatchError , root_mod :: Event > , :: subxt :: BasicError > { if self . client . metadata () . call_hash :: < Create > () ? == [111u8 , 132u8 , 97u8 , 194u8 , 137u8 , 78u8 , 176u8 , 138u8 , 233u8 , 83u8 , 66u8 , 183u8 , 198u8 , 54u8 , 47u8 , 148u8 , 74u8 , 91u8 , 44u8 , 102u8 , 175u8 , 66u8 , 30u8 , 80u8 , 53u8 , 66u8 , 248u8 , 51u8 , 239u8 , 209u8 , 186u8 , 19u8 ,] { let call = Create { max_edges , depth , } ; Ok (:: subxt :: SubmittableExtrinsic :: new (self . client , call)) } else { Err (:: subxt :: MetadataError :: IncompatibleMetadata . into ()) } } } } pub type Event = runtime_types :: pallet_linkable_tree :: pallet :: Event ; pub mod events { use super :: runtime_types ; # [derive (:: subxt :: codec :: CompactAs , :: subxt :: codec :: Decode , :: subxt :: codec :: Encode , Clone , Debug , Eq , PartialEq)] # [doc = "New tree created"] pub struct LinkableTreeCreation { pub tree_id : :: core :: primitive :: u32 , } impl :: subxt :: Event for LinkableTreeCreation { const PALLET : & 'static str = "LinkableTreeBn254" ; const EVENT : & 'static str = "LinkableTreeCreation" ; } } pub mod storage { use super :: runtime_types ; pub struct MaxEdges < 'a > (pub & 'a :: core :: primitive :: u32) ; impl :: subxt :: StorageEntry for MaxEdges < '_ > { const PALLET : & 'static str = "LinkableTreeBn254" ; const STORAGE : & 'static str = "MaxEdges" ; type Value = :: core :: primitive :: u32 ; fn key (& self) -> :: subxt :: StorageEntryKey { :: subxt :: StorageEntryKey :: Map (vec ! [:: subxt :: StorageMapKey :: new (& self . 0 , :: subxt :: StorageHasher :: Blake2_128Concat)]) } } pub struct EdgeList < 'a > (pub & 'a :: core :: primitive :: u32 , pub & 'a :: core :: primitive :: u64) ; impl :: subxt :: StorageEntry for EdgeList < '_ > { const PALLET : & 'static str = "LinkableTreeBn254" ; const STORAGE : & 'static str = "EdgeList" ; type Value = runtime_types :: pallet_linkable_tree :: types :: EdgeMetadata < :: core :: primitive :: u64 , runtime_types :: egg_standalone_runtime :: protocol_substrate_config :: Element , :: core :: primitive :: u32 > ; fn key (& self) -> :: subxt :: StorageEntryKey { :: subxt :: StorageEntryKey :: Map (vec ! [:: subxt :: StorageMapKey :: new (& self . 0 , :: subxt :: StorageHasher :: Blake2_128Concat) , :: subxt :: StorageMapKey :: new (& self . 1 , :: subxt :: StorageHasher :: Blake2_128Concat)]) } } pub struct LinkableTreeHasEdge < 'a > (pub & 'a :: core :: primitive :: u32 , pub & 'a :: core :: primitive :: u64) ; impl :: subxt :: StorageEntry for LinkableTreeHasEdge < '_ > { const PALLET : & 'static str = "LinkableTreeBn254" ; const STORAGE : & 'static str = "LinkableTreeHasEdge" ; type Value = :: core :: primitive :: bool ; fn key (& self) -> :: subxt :: StorageEntryKey { :: subxt :: StorageEntryKey :: Map (vec ! [:: subxt :: StorageMapKey :: new (& (& self . 0 , & self . 1) , :: subxt :: StorageHasher :: Blake2_128Concat)]) } } pub struct NeighborRoots < 'a > (pub & 'a (:: core :: primitive :: u32 , :: core :: primitive :: u64 ,) , pub & 'a :: core :: primitive :: u32) ; impl :: subxt :: StorageEntry for NeighborRoots < '_ > { const PALLET : & 'static str = "LinkableTreeBn254" ; const STORAGE : & 'static str = "NeighborRoots" ; type Value = runtime_types :: egg_standalone_runtime :: protocol_substrate_config :: Element ; fn key (& self) -> :: subxt :: StorageEntryKey { :: subxt :: StorageEntryKey :: Map (vec ! [:: subxt :: StorageMapKey :: new (& self . 0 , :: subxt :: StorageHasher :: Blake2_128Concat) , :: subxt :: StorageMapKey :: new (& self . 1 , :: subxt :: StorageHasher :: Blake2_128Concat)]) } } pub struct CurrentNeighborRootIndex < 'a > (pub & 'a :: core :: primitive :: u32 , pub & 'a :: core :: primitive :: u64) ; impl :: subxt :: StorageEntry for CurrentNeighborRootIndex < '_ > { const PALLET : & 'static str = "LinkableTreeBn254" ; const STORAGE : & 'static str = "CurrentNeighborRootIndex" ; type Value = :: core :: primitive :: u32 ; fn key (& self) -> :: subxt :: StorageEntryKey { :: subxt :: StorageEntryKey :: Map (vec ! [:: subxt :: StorageMapKey :: new (& (& self . 0 , & self . 1) , :: subxt :: StorageHasher :: Blake2_128Concat)]) } } pub struct StorageApi < 'a , T : :: subxt :: Config > { client : & 'a :: subxt :: Client < T > , } impl < 'a , T : :: subxt :: Config > StorageApi < 'a , T > { pub fn new (client : & 'a :: subxt :: Client < T >) -> Self { Self { client } } # [doc = " The map of trees to the maximum number of anchor edges they can have"] pub async fn max_edges (& self , _0 : & :: core :: primitive :: u32 , block_hash : :: core :: option :: Option < T :: Hash > ,) -> :: core :: result :: Result < :: core :: primitive :: u32 , :: subxt :: BasicError > { if self . client . metadata () . storage_hash :: < MaxEdges > () ? == [198u8 , 254u8 , 155u8 , 234u8 , 177u8 , 109u8 , 109u8 , 57u8 , 207u8 , 37u8 , 12u8 , 234u8 , 187u8 , 187u8 , 77u8 , 227u8 , 100u8 , 135u8 , 111u8 , 195u8 , 194u8 , 104u8 , 52u8 , 186u8 , 10u8 , 128u8 , 248u8 , 88u8 , 87u8 , 154u8 , 229u8 , 90u8 ,] { let entry = MaxEdges (_0) ; self . client . storage () . fetch_or_default (& entry , block_hash) . await } else { Err (:: subxt :: MetadataError :: IncompatibleMetadata . into ()) } } # [doc = " The map of trees to the maximum number of anchor edges they can have"] pub async fn max_edges_iter (& self , block_hash : :: core :: option :: Option < T :: Hash > ,) -> :: core :: result :: Result < :: subxt :: KeyIter < 'a , T , MaxEdges < 'a > > , :: subxt :: BasicError > { if self . client . metadata () . storage_hash :: < MaxEdges > () ? == [198u8 , 254u8 , 155u8 , 234u8 , 177u8 , 109u8 , 109u8 , 57u8 , 207u8 , 37u8 , 12u8 , 234u8 , 187u8 , 187u8 , 77u8 , 227u8 , 100u8 , 135u8 , 111u8 , 195u8 , 194u8 , 104u8 , 52u8 , 186u8 , 10u8 , 128u8 , 248u8 , 88u8 , 87u8 , 154u8 , 229u8 , 90u8 ,] { self . client . storage () . iter (block_hash) . await } else { Err (:: subxt :: MetadataError :: IncompatibleMetadata . into ()) } } # [doc = " The map of trees and chain ids to their edge metadata"] pub async fn edge_list (& self , _0 : & :: core :: primitive :: u32 , _1 : & :: core :: primitive :: u64 , block_hash : :: core :: option :: Option < T :: Hash > ,) -> :: core :: result :: Result < runtime_types :: pallet_linkable_tree :: types :: EdgeMetadata < :: core :: primitive :: u64 , runtime_types :: egg_standalone_runtime :: protocol_substrate_config :: Element , :: core :: primitive :: u32 > , :: subxt :: BasicError > { if self . client . metadata () . storage_hash :: < EdgeList > () ? == [50u8 , 83u8 , 22u8 , 206u8 , 1u8 , 102u8 , 199u8 , 24u8 , 209u8 , 105u8 , 50u8 , 25u8 , 114u8 , 130u8 , 245u8 , 101u8 , 93u8 , 151u8 , 5u8 , 219u8 , 197u8 , 223u8 , 127u8 , 6u8 , 183u8 , 125u8 , 123u8 , 87u8 , 166u8 , 216u8 , 60u8 , 35u8 ,] { let entry = EdgeList (_0 , _1) ; self . client . storage () . fetch_or_default (& entry , block_hash) . await } else { Err (:: subxt :: MetadataError :: IncompatibleMetadata . into ()) } } # [doc = " The map of trees and chain ids to their edge metadata"] pub async fn edge_list_iter (& self , block_hash : :: core :: option :: Option < T :: Hash > ,) -> :: core :: result :: Result < :: subxt :: KeyIter < 'a , T , EdgeList < 'a > > , :: subxt :: BasicError > { if self . client . metadata () . storage_hash :: < EdgeList > () ? == [50u8 , 83u8 , 22u8 , 206u8 , 1u8 , 102u8 , 199u8 , 24u8 , 209u8 , 105u8 , 50u8 , 25u8 , 114u8 , 130u8 , 245u8 , 101u8 , 93u8 , 151u8 , 5u8 , 219u8 , 197u8 , 223u8 , 127u8 , 6u8 , 183u8 , 125u8 , 123u8 , 87u8 , 166u8 , 216u8 , 60u8 , 35u8 ,] { self . client . storage () . iter (block_hash) . await } else { Err (:: subxt :: MetadataError :: IncompatibleMetadata . into ()) } } # [doc = " A helper map for denoting whether an tree is bridged to given chain"] pub async fn linkable_tree_has_edge (& self , _0 : & :: core :: primitive :: u32 , _1 : & :: core :: primitive :: u64 , block_hash : :: core :: option :: Option < T :: Hash > ,) -> :: core :: result :: Result < :: core :: primitive :: bool , :: subxt :: BasicError > { if self . client . metadata () . storage_hash :: < LinkableTreeHasEdge > () ? == [159u8 , 137u8 , 120u8 , 239u8 , 119u8 , 134u8 , 14u8 , 74u8 , 253u8 , 30u8 , 22u8 , 29u8 , 177u8 , 255u8 , 4u8 , 81u8 , 86u8 , 20u8 , 141u8 , 192u8 , 23u8 , 16u8 , 200u8 , 87u8 , 93u8 , 252u8 , 91u8 , 240u8 , 162u8 , 163u8 , 146u8 , 163u8 ,] { let entry = LinkableTreeHasEdge (_0 , _1) ; self . client . storage () . fetch_or_default (& entry , block_hash) . await } else { Err (:: subxt :: MetadataError :: IncompatibleMetadata . into ()) } } # [doc = " A helper map for denoting whether an tree is bridged to given chain"] pub async fn linkable_tree_has_edge_iter (& self , block_hash : :: core :: option :: Option < T :: Hash > ,) -> :: core :: result :: Result < :: subxt :: KeyIter < 'a , T , LinkableTreeHasEdge < 'a > > , :: subxt :: BasicError > { if self . client . metadata () . storage_hash :: < LinkableTreeHasEdge > () ? == [159u8 , 137u8 , 120u8 , 239u8 , 119u8 , 134u8 , 14u8 , 74u8 , 253u8 , 30u8 , 22u8 , 29u8 , 177u8 , 255u8 , 4u8 , 81u8 , 86u8 , 20u8 , 141u8 , 192u8 , 23u8 , 16u8 , 200u8 , 87u8 , 93u8 , 252u8 , 91u8 , 240u8 , 162u8 , 163u8 , 146u8 , 163u8 ,] { self . client . storage () . iter (block_hash) . await } else { Err (:: subxt :: MetadataError :: IncompatibleMetadata . into ()) } } # [doc = " The map of (tree, chain id) pairs to their latest recorded merkle root"] pub async fn neighbor_roots (& self , _0 : & (:: core :: primitive :: u32 , :: core :: primitive :: u64 ,) , _1 : & :: core :: primitive :: u32 , block_hash : :: core :: option :: Option < T :: Hash > ,) -> :: core :: result :: Result < :: core :: option :: Option < runtime_types :: egg_standalone_runtime :: protocol_substrate_config :: Element > , :: subxt :: BasicError > { if self . client . metadata () . storage_hash :: < NeighborRoots > () ? == [218u8 , 213u8 , 4u8 , 18u8 , 37u8 , 129u8 , 231u8 , 205u8 , 216u8 , 211u8 , 63u8 , 3u8 , 34u8 , 70u8 , 238u8 , 232u8 , 232u8 , 227u8 , 124u8 , 49u8 , 38u8 , 22u8 , 106u8 , 221u8 , 162u8 , 85u8 , 108u8 , 64u8 , 250u8 , 3u8 , 159u8 , 246u8 ,] { let entry = NeighborRoots (_0 , _1) ; self . client . storage () . fetch (& entry , block_hash) . await } else { Err (:: subxt :: MetadataError :: IncompatibleMetadata . into ()) } } # [doc = " The map of (tree, chain id) pairs to their latest recorded merkle root"] pub async fn neighbor_roots_iter (& self , block_hash : :: core :: option :: Option < T :: Hash > ,) -> :: core :: result :: Result < :: subxt :: KeyIter < 'a , T , NeighborRoots < 'a > > , :: subxt :: BasicError > { if self . client . metadata () . storage_hash :: < NeighborRoots > () ? == [218u8 , 213u8 , 4u8 , 18u8 , 37u8 , 129u8 , 231u8 , 205u8 , 216u8 , 211u8 , 63u8 , 3u8 , 34u8 , 70u8 , 238u8 , 232u8 , 232u8 , 227u8 , 124u8 , 49u8 , 38u8 , 22u8 , 106u8 , 221u8 , 162u8 , 85u8 , 108u8 , 64u8 , 250u8 , 3u8 , 159u8 , 246u8 ,] { self . client . storage () . iter (block_hash) . await } else { Err (:: subxt :: MetadataError :: IncompatibleMetadata . into ()) } } # [doc = " The next neighbor root index to store the merkle root update record"] pub async fn current_neighbor_root_index (& self , _0 : & :: core :: primitive :: u32 , _1 : & :: core :: primitive :: u64 , block_hash : :: core :: option :: Option < T :: Hash > ,) -> :: core :: result :: Result < :: core :: primitive :: u32 , :: subxt :: BasicError > { if self . client . metadata () . storage_hash :: < CurrentNeighborRootIndex > () ? == [114u8 , 40u8 , 99u8 , 72u8 , 241u8 , 89u8 , 253u8 , 122u8 , 226u8 , 181u8 , 168u8 , 58u8 , 70u8 , 0u8 , 110u8 , 141u8 , 58u8 , 12u8 , 177u8 , 129u8 , 103u8 , 45u8 , 160u8 , 139u8 , 99u8 , 198u8 , 181u8 , 154u8 , 78u8 , 62u8 , 201u8 , 227u8 ,] { let entry = CurrentNeighborRootIndex (_0 , _1) ; self . client . storage () . fetch_or_default (& entry , block_hash) . await } else { Err (:: subxt :: MetadataError :: IncompatibleMetadata . into ()) } } # [doc = " The next neighbor root index to store the merkle root update record"] pub async fn current_neighbor_root_index_iter (& self , block_hash : :: core :: option :: Option < T :: Hash > ,) -> :: core :: result :: Result < :: subxt :: KeyIter < 'a , T , CurrentNeighborRootIndex < 'a > > , :: subxt :: BasicError > { if self . client . metadata () . storage_hash :: < CurrentNeighborRootIndex > () ? == [114u8 , 40u8 , 99u8 , 72u8 , 241u8 , 89u8 , 253u8 , 122u8 , 226u8 , 181u8 , 168u8 , 58u8 , 70u8 , 0u8 , 110u8 , 141u8 , 58u8 , 12u8 , 177u8 , 129u8 , 103u8 , 45u8 , 160u8 , 139u8 , 99u8 , 198u8 , 181u8 , 154u8 , 78u8 , 62u8 , 201u8 , 227u8 ,] { self . client . storage () . iter (block_hash) . await } else { Err (:: subxt :: MetadataError :: IncompatibleMetadata . into ()) } } } } pub mod constants { use super :: runtime_types ; pub struct ConstantsApi < 'a , T : :: subxt :: Config > { client : & 'a :: subxt :: Client < T > , } impl < 'a , T : :: subxt :: Config > ConstantsApi < 'a , T > { pub fn new (client : & 'a :: subxt :: Client < T >) -> Self { Self { client } } # [doc = " ChainID type for this chain"] pub fn chain_type (& self) -> :: core :: result :: Result < [:: core :: primitive :: u8 ; 2usize] , :: subxt :: BasicError > { if self . client . metadata () . constant_hash ("LinkableTreeBn254" , "ChainType") ? == [63u8 , 194u8 , 199u8 , 163u8 , 106u8 , 87u8 , 76u8 , 171u8 , 237u8 , 240u8 , 200u8 , 1u8 , 224u8 , 207u8 , 104u8 , 144u8 , 174u8 , 60u8 , 82u8 , 99u8 , 113u8 , 153u8 , 220u8 , 75u8 , 154u8 , 72u8 , 151u8 , 213u8 , 38u8 , 50u8 , 170u8 , 129u8 ,] { let pallet = self . client . metadata () . pallet ("LinkableTreeBn254") ? ; let constant = pallet . constant ("ChainType") ? ; let value = :: subxt :: codec :: Decode :: decode (& mut & constant . value [..]) ? ; Ok (value) } else { Err (:: subxt :: MetadataError :: IncompatibleMetadata . into ()) } } pub fn chain_identifier (& self) -> :: core :: result :: Result < :: core :: primitive :: u64 , :: subxt :: BasicError > { if self . client . metadata () . constant_hash ("LinkableTreeBn254" , "ChainIdentifier") ? == [64u8 , 119u8 , 115u8 , 96u8 , 239u8 , 19u8 , 100u8 , 82u8 , 69u8 , 155u8 , 95u8 , 49u8 , 160u8 , 144u8 , 56u8 , 190u8 , 6u8 , 28u8 , 33u8 , 186u8 , 44u8 , 100u8 , 181u8 , 251u8 , 153u8 , 5u8 , 76u8 , 55u8 , 50u8 , 89u8 , 81u8 , 0u8 ,] { let pallet = self . client . metadata () . pallet ("LinkableTreeBn254") ? ; let constant = pallet . constant ("ChainIdentifier") ? ; let value = :: subxt :: codec :: Decode :: decode (& mut & constant . value [..]) ? ; Ok (value) } else { Err (:: subxt :: MetadataError :: IncompatibleMetadata . into ()) } } # [doc = " The pruning length for neighbor root histories"] pub fn history_length (& self) -> :: core :: result :: Result < :: core :: primitive :: u32 , :: subxt :: BasicError > { if self . client . metadata () . constant_hash ("LinkableTreeBn254" , "HistoryLength") ? == [116u8 , 45u8 , 154u8 , 21u8 , 158u8 , 57u8 , 9u8 , 115u8 , 116u8 , 232u8 , 186u8 , 166u8 , 156u8 , 25u8 , 146u8 , 187u8 , 127u8 , 26u8 , 251u8 , 204u8 , 216u8 , 151u8 , 14u8 , 243u8 , 130u8 , 222u8 , 9u8 , 35u8 , 103u8 , 184u8 , 229u8 , 71u8 ,] { let pallet = self . client . metadata () . pallet ("LinkableTreeBn254") ? ; let constant = pallet . constant ("HistoryLength") ? ; let value = :: subxt :: codec :: Decode :: decode (& mut & constant . value [..]) ? ; Ok (value) } else { Err (:: subxt :: MetadataError :: IncompatibleMetadata . into ()) } } } } } pub mod mixer_bn254 { use super :: root_mod ; use super :: runtime_types ; pub mod calls { use super :: root_mod ; use super :: runtime_types ; type DispatchError = runtime_types :: sp_runtime :: DispatchError ; # [derive (:: subxt :: codec :: Decode , :: subxt :: codec :: Encode , Clone , Debug , Eq , PartialEq)] pub struct Create { pub deposit_size : :: core :: primitive :: u128 , pub depth : :: core :: primitive :: u8 , pub asset : :: core :: primitive :: u32 , } impl :: subxt :: Call for Create { const PALLET : & 'static str = "MixerBn254" ; const FUNCTION : & 'static str = "create" ; } # [derive (:: subxt :: codec :: Decode , :: subxt :: codec :: Encode , Clone , Debug , Eq , PartialEq)] pub struct Deposit { pub tree_id : :: core :: primitive :: u32 , pub leaf : runtime_types :: egg_standalone_runtime :: protocol_substrate_config :: Element , } impl :: subxt :: Call for Deposit { const PALLET : & 'static str = "MixerBn254" ; const FUNCTION : & 'static str = "deposit" ; } # [derive (:: subxt :: codec :: Decode , :: subxt :: codec :: Encode , Clone , Debug , Eq , PartialEq)] pub struct Withdraw { pub id : :: core :: primitive :: u32 , pub proof_bytes : :: std :: vec :: Vec < :: core :: primitive :: u8 > , pub root : runtime_types :: egg_standalone_runtime :: protocol_substrate_config :: Element , pub nullifier_hash : runtime_types :: egg_standalone_runtime :: protocol_substrate_config :: Element , pub recipient : :: subxt :: sp_core :: crypto :: AccountId32 , pub relayer : :: subxt :: sp_core :: crypto :: AccountId32 , pub fee : :: core :: primitive :: u128 , pub refund : :: core :: primitive :: u128 , } impl :: subxt :: Call for Withdraw { const PALLET : & 'static str = "MixerBn254" ; const FUNCTION : & 'static str = "withdraw" ; } pub struct TransactionApi < 'a , T : :: subxt :: Config , X > { client : & 'a :: subxt :: Client < T > , marker : :: core :: marker :: PhantomData < X > , } impl < 'a , T , X > TransactionApi < 'a , T , X > where T : :: subxt :: Config , X : :: subxt :: extrinsic :: ExtrinsicParams < T > , { pub fn new (client : & 'a :: subxt :: Client < T >) -> Self { Self { client , marker : :: core :: marker :: PhantomData } } pub fn create (& self , deposit_size : :: core :: primitive :: u128 , depth : :: core :: primitive :: u8 , asset : :: core :: primitive :: u32 ,) -> Result < :: subxt :: SubmittableExtrinsic < 'a , T , X , Create , DispatchError , root_mod :: Event > , :: subxt :: BasicError > { if self . client . metadata () . call_hash :: < Create > () ? == [172u8 , 133u8 , 37u8 , 211u8 , 41u8 , 200u8 , 56u8 , 22u8 , 85u8 , 68u8 , 155u8 , 126u8 , 97u8 , 83u8 , 118u8 , 43u8 , 126u8 , 205u8 , 223u8 , 223u8 , 60u8 , 32u8 , 190u8 , 74u8 , 115u8 , 91u8 , 37u8 , 34u8 , 131u8 , 76u8 , 232u8 , 185u8 ,] { let call = Create { deposit_size , depth , asset , } ; Ok (:: subxt :: SubmittableExtrinsic :: new (self . client , call)) } else { Err (:: subxt :: MetadataError :: IncompatibleMetadata . into ()) } } pub fn deposit (& self , tree_id : :: core :: primitive :: u32 , leaf : runtime_types :: egg_standalone_runtime :: protocol_substrate_config :: Element ,) -> Result < :: subxt :: SubmittableExtrinsic < 'a , T , X , Deposit , DispatchError , root_mod :: Event > , :: subxt :: BasicError > { if self . client . metadata () . call_hash :: < Deposit > () ? == [156u8 , 22u8 , 122u8 , 20u8 , 188u8 , 139u8 , 94u8 , 254u8 , 189u8 , 192u8 , 155u8 , 154u8 , 239u8 , 162u8 , 220u8 , 64u8 , 163u8 , 13u8 , 149u8 , 31u8 , 62u8 , 130u8 , 51u8 , 206u8 , 248u8 , 14u8 , 205u8 , 170u8 , 17u8 , 235u8 , 186u8 , 77u8 ,] { let call = Deposit { tree_id , leaf , } ; Ok (:: subxt :: SubmittableExtrinsic :: new (self . client , call)) } else { Err (:: subxt :: MetadataError :: IncompatibleMetadata . into ()) } } pub fn withdraw (& self , id : :: core :: primitive :: u32 , proof_bytes : :: std :: vec :: Vec < :: core :: primitive :: u8 > , root : runtime_types :: egg_standalone_runtime :: protocol_substrate_config :: Element , nullifier_hash : runtime_types :: egg_standalone_runtime :: protocol_substrate_config :: Element , recipient : :: subxt :: sp_core :: crypto :: AccountId32 , relayer : :: subxt :: sp_core :: crypto :: AccountId32 , fee : :: core :: primitive :: u128 , refund : :: core :: primitive :: u128 ,) -> Result < :: subxt :: SubmittableExtrinsic < 'a , T , X , Withdraw , DispatchError , root_mod :: Event > , :: subxt :: BasicError > { if self . client . metadata () . call_hash :: < Withdraw > () ? == [99u8 , 210u8 , 150u8 , 7u8 , 111u8 , 165u8 , 80u8 , 209u8 , 59u8 , 241u8 , 114u8 , 212u8 , 101u8 , 54u8 , 164u8 , 22u8 , 10u8 , 236u8 , 178u8 , 59u8 , 249u8 , 22u8 , 101u8 , 168u8 , 122u8 , 222u8 , 193u8 , 118u8 , 24u8 , 49u8 , 180u8 , 143u8 ,] { let call = Withdraw { id , proof_bytes , root , nullifier_hash , recipient , relayer , fee , refund , } ; Ok (:: subxt :: SubmittableExtrinsic :: new (self . client , call)) } else { Err (:: subxt :: MetadataError :: IncompatibleMetadata . into ()) } } } } pub type Event = runtime_types :: pallet_mixer :: pallet :: Event ; pub mod events { use super :: runtime_types ; # [derive (:: subxt :: codec :: CompactAs , :: subxt :: codec :: Decode , :: subxt :: codec :: Encode , Clone , Debug , Eq , PartialEq)] # [doc = "New tree created"] pub struct MixerCreation { pub tree_id : :: core :: primitive :: u32 , } impl :: subxt :: Event for MixerCreation { const PALLET : & 'static str = "MixerBn254" ; const EVENT : & 'static str = "MixerCreation" ; } # [derive (:: subxt :: codec :: Decode , :: subxt :: codec :: Encode , Clone , Debug , Eq , PartialEq)] pub struct Deposit { pub tree_id : :: core :: primitive :: u32 , pub leaf : runtime_types :: egg_standalone_runtime :: protocol_substrate_config :: Element , } impl :: subxt :: Event for Deposit { const PALLET : & 'static str = "MixerBn254" ; const EVENT : & 'static str = "Deposit" ; } # [derive (:: subxt :: codec :: Decode , :: subxt :: codec :: Encode , Clone , Debug , Eq , PartialEq)] pub struct Withdraw { pub tree_id : :: core :: primitive :: u32 , pub recipient : :: subxt :: sp_core :: crypto :: AccountId32 , } impl :: subxt :: Event for Withdraw { const PALLET : & 'static str = "MixerBn254" ; const EVENT : & 'static str = "Withdraw" ; } } pub mod storage { use super :: runtime_types ; pub struct Mixers < 'a > (pub & 'a :: core :: primitive :: u32) ; impl :: subxt :: StorageEntry for Mixers < '_ > { const PALLET : & 'static str = "MixerBn254" ; const STORAGE : & 'static str = "Mixers" ; type Value = runtime_types :: pallet_mixer :: types :: MixerMetadata < :: core :: primitive :: u128 , :: core :: primitive :: u32 > ; fn key (& self) -> :: subxt :: StorageEntryKey { :: subxt :: StorageEntryKey :: Map (vec ! [:: subxt :: StorageMapKey :: new (& self . 0 , :: subxt :: StorageHasher :: Blake2_128Concat)]) } } pub struct NullifierHashes < 'a > (pub & 'a :: core :: primitive :: u32 , pub & 'a runtime_types :: egg_standalone_runtime :: protocol_substrate_config :: Element) ; impl :: subxt :: StorageEntry for NullifierHashes < '_ > { const PALLET : & 'static str = "MixerBn254" ; const STORAGE : & 'static str = "NullifierHashes" ; type Value = :: core :: primitive :: bool ; fn key (& self) -> :: subxt :: StorageEntryKey { :: subxt :: StorageEntryKey :: Map (vec ! [:: subxt :: StorageMapKey :: new (& self . 0 , :: subxt :: StorageHasher :: Blake2_128Concat) , :: subxt :: StorageMapKey :: new (& self . 1 , :: subxt :: StorageHasher :: Blake2_128Concat)]) } } pub struct StorageApi < 'a , T : :: subxt :: Config > { client : & 'a :: subxt :: Client < T > , } impl < 'a , T : :: subxt :: Config > StorageApi < 'a , T > { pub fn new (client : & 'a :: subxt :: Client < T >) -> Self { Self { client } } # [doc = " The map of trees to their mixer metadata"] pub async fn mixers (& self , _0 : & :: core :: primitive :: u32 , block_hash : :: core :: option :: Option < T :: Hash > ,) -> :: core :: result :: Result < :: core :: option :: Option < runtime_types :: pallet_mixer :: types :: MixerMetadata < :: core :: primitive :: u128 , :: core :: primitive :: u32 > > , :: subxt :: BasicError > { if self . client . metadata () . storage_hash :: < Mixers > () ? == [243u8 , 60u8 , 107u8 , 82u8 , 79u8 , 29u8 , 152u8 , 19u8 , 43u8 , 78u8 , 38u8 , 27u8 , 172u8 , 222u8 , 183u8 , 217u8 , 58u8 , 154u8 , 178u8 , 188u8 , 10u8 , 29u8 , 220u8 , 10u8 , 254u8 , 75u8 , 65u8 , 81u8 , 135u8 , 176u8 , 117u8 , 80u8 ,] { let entry = Mixers (_0) ; self . client . storage () . fetch (& entry , block_hash) . await } else { Err (:: subxt :: MetadataError :: IncompatibleMetadata . into ()) } } # [doc = " The map of trees to their mixer metadata"] pub async fn mixers_iter (& self , block_hash : :: core :: option :: Option < T :: Hash > ,) -> :: core :: result :: Result < :: subxt :: KeyIter < 'a , T , Mixers < 'a > > , :: subxt :: BasicError > { if self . client . metadata () . storage_hash :: < Mixers > () ? == [243u8 , 60u8 , 107u8 , 82u8 , 79u8 , 29u8 , 152u8 , 19u8 , 43u8 , 78u8 , 38u8 , 27u8 , 172u8 , 222u8 , 183u8 , 217u8 , 58u8 , 154u8 , 178u8 , 188u8 , 10u8 , 29u8 , 220u8 , 10u8 , 254u8 , 75u8 , 65u8 , 81u8 , 135u8 , 176u8 , 117u8 , 80u8 ,] { self . client . storage () . iter (block_hash) . await } else { Err (:: subxt :: MetadataError :: IncompatibleMetadata . into ()) } } # [doc = " The map of trees to their spent nullifier hashes"] pub async fn nullifier_hashes (& self , _0 : & :: core :: primitive :: u32 , _1 : & runtime_types :: egg_standalone_runtime :: protocol_substrate_config :: Element , block_hash : :: core :: option :: Option < T :: Hash > ,) -> :: core :: result :: Result < :: core :: primitive :: bool , :: subxt :: BasicError > { if self . client . metadata () . storage_hash :: < NullifierHashes > () ? == [26u8 , 245u8 , 38u8 , 181u8 , 82u8 , 104u8 , 95u8 , 163u8 , 44u8 , 122u8 , 225u8 , 212u8 , 85u8 , 103u8 , 242u8 , 46u8 , 111u8 , 97u8 , 196u8 , 211u8 , 169u8 , 130u8 , 189u8 , 33u8 , 56u8 , 70u8 , 110u8 , 141u8 , 185u8 , 101u8 , 248u8 , 56u8 ,] { let entry = NullifierHashes (_0 , _1) ; self . client . storage () . fetch_or_default (& entry , block_hash) . await } else { Err (:: subxt :: MetadataError :: IncompatibleMetadata . into ()) } } # [doc = " The map of trees to their spent nullifier hashes"] pub async fn nullifier_hashes_iter (& self , block_hash : :: core :: option :: Option < T :: Hash > ,) -> :: core :: result :: Result < :: subxt :: KeyIter < 'a , T , NullifierHashes < 'a > > , :: subxt :: BasicError > { if self . client . metadata () . storage_hash :: < NullifierHashes > () ? == [26u8 , 245u8 , 38u8 , 181u8 , 82u8 , 104u8 , 95u8 , 163u8 , 44u8 , 122u8 , 225u8 , 212u8 , 85u8 , 103u8 , 242u8 , 46u8 , 111u8 , 97u8 , 196u8 , 211u8 , 169u8 , 130u8 , 189u8 , 33u8 , 56u8 , 70u8 , 110u8 , 141u8 , 185u8 , 101u8 , 248u8 , 56u8 ,] { self . client . storage () . iter (block_hash) . await } else { Err (:: subxt :: MetadataError :: IncompatibleMetadata . into ()) } } } } pub mod constants { use super :: runtime_types ; pub struct ConstantsApi < 'a , T : :: subxt :: Config > { client : & 'a :: subxt :: Client < T > , } impl < 'a , T : :: subxt :: Config > ConstantsApi < 'a , T > { pub fn new (client : & 'a :: subxt :: Client < T >) -> Self { Self { client } } pub fn pallet_id (& self) -> :: core :: result :: Result < runtime_types :: frame_support :: PalletId , :: subxt :: BasicError > { if self . client . metadata () . constant_hash ("MixerBn254" , "PalletId") ? == [146u8 , 131u8 , 44u8 , 224u8 , 55u8 , 232u8 , 2u8 , 109u8 , 147u8 , 52u8 , 229u8 , 47u8 , 29u8 , 92u8 , 138u8 , 56u8 , 9u8 , 112u8 , 235u8 , 133u8 , 98u8 , 92u8 , 95u8 , 108u8 , 86u8 , 101u8 , 13u8 , 39u8 , 74u8 , 30u8 , 117u8 , 142u8 ,] { let pallet = self . client . metadata () . pallet ("MixerBn254") ? ; let constant = pallet . constant ("PalletId") ? ; let value = :: subxt :: codec :: Decode :: decode (& mut & constant . value [..]) ? ; Ok (value) } else { Err (:: subxt :: MetadataError :: IncompatibleMetadata . into ()) } } # [doc = " Native currency id"] pub fn native_currency_id (& self) -> :: core :: result :: Result < :: core :: primitive :: u32 , :: subxt :: BasicError > { if self . client . metadata () . constant_hash ("MixerBn254" , "NativeCurrencyId") ? == [101u8 , 251u8 , 209u8 , 1u8 , 140u8 , 211u8 , 189u8 , 23u8 , 78u8 , 144u8 , 68u8 , 58u8 , 160u8 , 52u8 , 207u8 , 11u8 , 246u8 , 174u8 , 219u8 , 39u8 , 180u8 , 243u8 , 224u8 , 166u8 , 219u8 , 113u8 , 20u8 , 106u8 , 196u8 , 121u8 , 193u8 , 137u8 ,] { let pallet = self . client . metadata () . pallet ("MixerBn254") ? ; let constant = pallet . constant ("NativeCurrencyId") ? ; let value = :: subxt :: codec :: Decode :: decode (& mut & constant . value [..]) ? ; Ok (value) } else { Err (:: subxt :: MetadataError :: IncompatibleMetadata . into ()) } } } } } pub mod signature_bridge { use super :: root_mod ; use super :: runtime_types ; pub mod calls { use super :: root_mod ; use super :: runtime_types ; type DispatchError = runtime_types :: sp_runtime :: DispatchError ; # [derive (:: subxt :: codec :: Decode , :: subxt :: codec :: Encode , Clone , Debug , Eq , PartialEq)] pub struct SetMaintainer { pub message : :: std :: vec :: Vec < :: core :: primitive :: u8 > , pub signature : :: std :: vec :: Vec < :: core :: primitive :: u8 > , } impl :: subxt :: Call for SetMaintainer { const PALLET : & 'static str = "SignatureBridge" ; const FUNCTION : & 'static str = "set_maintainer" ; } # [derive (:: subxt :: codec :: Decode , :: subxt :: codec :: Encode , Clone , Debug , Eq , PartialEq)] pub struct ForceSetMaintainer { pub new_maintainer : :: std :: vec :: Vec < :: core :: primitive :: u8 > , } impl :: subxt :: Call for ForceSetMaintainer { const PALLET : & 'static str = "SignatureBridge" ; const FUNCTION : & 'static str = "force_set_maintainer" ; } # [derive (:: subxt :: codec :: Decode , :: subxt :: codec :: Encode , Clone , Debug , Eq , PartialEq)] pub struct SetResource { pub id : [:: core :: primitive :: u8 ; 32usize] , } impl :: subxt :: Call for SetResource { const PALLET : & 'static str = "SignatureBridge" ; const FUNCTION : & 'static str = "set_resource" ; } # [derive (:: subxt :: codec :: Decode , :: subxt :: codec :: Encode , Clone , Debug , Eq , PartialEq)] pub struct RemoveResource { pub id : [:: core :: primitive :: u8 ; 32usize] , } impl :: subxt :: Call for RemoveResource { const PALLET : & 'static str = "SignatureBridge" ; const FUNCTION : & 'static str = "remove_resource" ; } # [derive (:: subxt :: codec :: CompactAs , :: subxt :: codec :: Decode , :: subxt :: codec :: Encode , Clone , Debug , Eq , PartialEq)] pub struct WhitelistChain { pub id : :: core :: primitive :: u64 , } impl :: subxt :: Call for WhitelistChain { const PALLET : & 'static str = "SignatureBridge" ; const FUNCTION : & 'static str = "whitelist_chain" ; } # [derive (:: subxt :: codec :: Decode , :: subxt :: codec :: Encode , Clone , Debug , Eq , PartialEq)] pub struct SetResourceWithSignature { pub src_id : :: core :: primitive :: u64 , pub call : :: std :: boxed :: Box < runtime_types :: egg_standalone_runtime :: Call > , pub proposal_data : :: std :: vec :: Vec < :: core :: primitive :: u8 > , pub signature : :: std :: vec :: Vec < :: core :: primitive :: u8 > , } impl :: subxt :: Call for SetResourceWithSignature { const PALLET : & 'static str = "SignatureBridge" ; const FUNCTION : & 'static str = "set_resource_with_signature" ; } # [derive (:: subxt :: codec :: Decode , :: subxt :: codec :: Encode , Clone , Debug , Eq , PartialEq)] pub struct ExecuteProposal { pub src_id : :: core :: primitive :: u64 , pub call : :: std :: boxed :: Box < runtime_types :: egg_standalone_runtime :: Call > , pub proposal_data : :: std :: vec :: Vec < :: core :: primitive :: u8 > , pub signature : :: std :: vec :: Vec < :: core :: primitive :: u8 > , } impl :: subxt :: Call for ExecuteProposal { const PALLET : & 'static str = "SignatureBridge" ; const FUNCTION : & 'static str = "execute_proposal" ; } pub struct TransactionApi < 'a , T : :: subxt :: Config , X > { client : & 'a :: subxt :: Client < T > , marker : :: core :: marker :: PhantomData < X > , } impl < 'a , T , X > TransactionApi < 'a , T , X > where T : :: subxt :: Config , X : :: subxt :: extrinsic :: ExtrinsicParams < T > , { pub fn new (client : & 'a :: subxt :: Client < T >) -> Self { Self { client , marker : :: core :: marker :: PhantomData } } # [doc = "Sets the maintainer."] pub fn set_maintainer (& self , message : :: std :: vec :: Vec < :: core :: primitive :: u8 > , signature : :: std :: vec :: Vec < :: core :: primitive :: u8 > ,) -> Result < :: subxt :: SubmittableExtrinsic < 'a , T , X , SetMaintainer , DispatchError , root_mod :: Event > , :: subxt :: BasicError > { if self . client . metadata () . call_hash :: < SetMaintainer > () ? == [247u8 , 133u8 , 4u8 , 54u8 , 140u8 , 33u8 , 82u8 , 117u8 , 85u8 , 124u8 , 56u8 , 176u8 , 95u8 , 49u8 , 167u8 , 57u8 , 131u8 , 250u8 , 126u8 , 254u8 , 251u8 , 73u8 , 133u8 , 72u8 , 32u8 , 238u8 , 44u8 , 224u8 , 248u8 , 118u8 , 120u8 , 11u8 ,] { let call = SetMaintainer { message , signature , } ; Ok (:: subxt :: SubmittableExtrinsic :: new (self . client , call)) } else { Err (:: subxt :: MetadataError :: IncompatibleMetadata . into ()) } } pub fn force_set_maintainer (& self , new_maintainer : :: std :: vec :: Vec < :: core :: primitive :: u8 > ,) -> Result < :: subxt :: SubmittableExtrinsic < 'a , T , X , ForceSetMaintainer , DispatchError , root_mod :: Event > , :: subxt :: BasicError > { if self . client . metadata () . call_hash :: < ForceSetMaintainer > () ? == [192u8 , 94u8 , 178u8 , 57u8 , 82u8 , 161u8 , 209u8 , 102u8 , 30u8 , 18u8 , 90u8 , 155u8 , 145u8 , 216u8 , 121u8 , 243u8 , 238u8 , 100u8 , 32u8 , 69u8 , 140u8 , 96u8 , 134u8 , 115u8 , 196u8 , 79u8 , 144u8 , 10u8 , 216u8 , 191u8 , 11u8 , 242u8 ,] { let call = ForceSetMaintainer { new_maintainer , } ; Ok (:: subxt :: SubmittableExtrinsic :: new (self . client , call)) } else { Err (:: subxt :: MetadataError :: IncompatibleMetadata . into ()) } } # [doc = "Stores a method name on chain under an associated resource ID."] # [doc = ""] # [doc = "# <weight>"] # [doc = "- O(1) write"] # [doc = "# </weight>"] pub fn set_resource (& self , id : [:: core :: primitive :: u8 ; 32usize] ,) -> Result < :: subxt :: SubmittableExtrinsic < 'a , T , X , SetResource , DispatchError , root_mod :: Event > , :: subxt :: BasicError > { if self . client . metadata () . call_hash :: < SetResource > () ? == [100u8 , 44u8 , 212u8 , 120u8 , 8u8 , 138u8 , 129u8 , 98u8 , 209u8 , 139u8 , 169u8 , 124u8 , 161u8 , 63u8 , 63u8 , 74u8 , 241u8 , 135u8 , 2u8 , 230u8 , 140u8 , 249u8 , 245u8 , 152u8 , 182u8 , 139u8 , 53u8 , 126u8 , 189u8 , 153u8 , 221u8 , 197u8 ,] { let call = SetResource { id , } ; Ok (:: subxt :: SubmittableExtrinsic :: new (self . client , call)) } else { Err (:: subxt :: MetadataError :: IncompatibleMetadata . into ()) } } # [doc = "Removes a resource ID from the resource mapping."] # [doc = ""] # [doc = "After this call, bridge transfers with the associated resource ID"] # [doc = "will be rejected."] # [doc = ""] # [doc = "# <weight>"] # [doc = "- O(1) removal"] # [doc = "# </weight>"] pub fn remove_resource (& self , id : [:: core :: primitive :: u8 ; 32usize] ,) -> Result < :: subxt :: SubmittableExtrinsic < 'a , T , X , RemoveResource , DispatchError , root_mod :: Event > , :: subxt :: BasicError > { if self . client . metadata () . call_hash :: < RemoveResource > () ? == [246u8 , 55u8 , 247u8 , 249u8 , 78u8 , 215u8 , 150u8 , 199u8 , 124u8 , 136u8 , 18u8 , 166u8 , 157u8 , 107u8 , 80u8 , 105u8 , 105u8 , 2u8 , 157u8 , 128u8 , 212u8 , 110u8 , 36u8 , 174u8 , 182u8 , 142u8 , 251u8 , 136u8 , 218u8 , 43u8 , 119u8 , 194u8 ,] { let call = RemoveResource { id , } ; Ok (:: subxt :: SubmittableExtrinsic :: new (self . client , call)) } else { Err (:: subxt :: MetadataError :: IncompatibleMetadata . into ()) } } # [doc = "Enables a chain ID as a source or destination for a bridge transfer."] # [doc = ""] # [doc = "# <weight>"] # [doc = "- O(1) lookup and insert"] # [doc = "# </weight>"] pub fn whitelist_chain (& self , id : :: core :: primitive :: u64 ,) -> Result < :: subxt :: SubmittableExtrinsic < 'a , T , X , WhitelistChain , DispatchError , root_mod :: Event > , :: subxt :: BasicError > { if self . client . metadata () . call_hash :: < WhitelistChain > () ? == [228u8 , 70u8 , 217u8 , 65u8 , 146u8 , 159u8 , 16u8 , 28u8 , 107u8 , 47u8 , 169u8 , 13u8 , 208u8 , 57u8 , 138u8 , 150u8 , 217u8 , 46u8 , 73u8 , 154u8 , 74u8 , 143u8 , 85u8 , 31u8 , 24u8 , 73u8 , 160u8 , 95u8 , 23u8 , 86u8 , 51u8 , 74u8 ,] { let call = WhitelistChain { id , } ; Ok (:: subxt :: SubmittableExtrinsic :: new (self . client , call)) } else { Err (:: subxt :: MetadataError :: IncompatibleMetadata . into ()) } } # [doc = "@param origin"] # [doc = "@param src_id"] # [doc = "@param call: the dispatchable call corresponding to a"] # [doc = "handler function"] # [doc = "@param proposal_data: (r_id, nonce, 4 bytes of zeroes, call)"] # [doc = "@param signature: a signature over the proposal_data"] # [doc = ""] # [doc = "We check:"] # [doc = "1. That the signature is actually over the proposal data"] # [doc = "2. Add ResourceId to the Storage"] # [doc = "3. That the call from the proposal data and the call input parameter to the function are"] # [doc = "consistent with each other 4. That the execution chain id type parsed from the r_id is"] # [doc = "indeed this chain's id type"] # [doc = ""] # [doc = "If all these checks pass then we call finalize_execution which actually executes the"] # [doc = "dispatchable call. The dispatchable call is usually a handler function, for instance in"] # [doc = "the anchor-handler or token-wrapper-handler pallet."] # [doc = ""] # [doc = "There are a few TODOs left in the function."] # [doc = ""] # [doc = "In the set_resource_with_signature"] # [doc = "# <weight>"] # [doc = "- weight of proposed call, regardless of whether execution is performed"] # [doc = "# </weight>"] pub fn set_resource_with_signature (& self , src_id : :: core :: primitive :: u64 , call : runtime_types :: egg_standalone_runtime :: Call , proposal_data : :: std :: vec :: Vec < :: core :: primitive :: u8 > , signature : :: std :: vec :: Vec < :: core :: primitive :: u8 > ,) -> Result < :: subxt :: SubmittableExtrinsic < 'a , T , X , SetResourceWithSignature , DispatchError , root_mod :: Event > , :: subxt :: BasicError > { if self . client . metadata () . call_hash :: < SetResourceWithSignature > () ? == [130u8 , 76u8 , 6u8 , 66u8 , 171u8 , 234u8 , 248u8 , 110u8 , 75u8 , 117u8 , 10u8 , 118u8 , 29u8 , 171u8 , 5u8 , 131u8 , 106u8 , 144u8 , 240u8 , 248u8 , 201u8 , 75u8 , 34u8 , 161u8 , 26u8 , 218u8 , 156u8 , 176u8 , 85u8 , 246u8 , 134u8 , 154u8 ,] { let call = SetResourceWithSignature { src_id , call : :: std :: boxed :: Box :: new (call) , proposal_data , signature , } ; Ok (:: subxt :: SubmittableExtrinsic :: new (self . client , call)) } else { Err (:: subxt :: MetadataError :: IncompatibleMetadata . into ()) } } # [doc = "@param origin"] # [doc = "@param src_id"] # [doc = "@param call: the dispatchable call corresponding to a"] # [doc = "handler function"] # [doc = "@param proposal_data: (r_id, nonce, 4 bytes of zeroes, call)"] # [doc = "@param signature: a signature over the proposal_data"] # [doc = ""] # [doc = "We check:"] # [doc = "1. That the signature is actually over the proposal data"] # [doc = "2. That the r_id parsed from the proposal data exists"] # [doc = "3. That the call from the proposal data and the call input parameter to the function are"] # [doc = "consistent with each other 4. That the execution chain id type parsed from the r_id is"] # [doc = "indeed this chain's id type"] # [doc = ""] # [doc = "If all these checks pass then we call finalize_execution which actually executes the"] # [doc = "dispatchable call. The dispatchable call is usually a handler function, for instance in"] # [doc = "the anchor-handler or token-wrapper-handler pallet."] # [doc = ""] # [doc = "There are a few TODOs left in the function."] # [doc = ""] # [doc = "In the execute_proposal"] # [doc = "# <weight>"] # [doc = "- weight of proposed call, regardless of whether execution is performed"] # [doc = "# </weight>"] pub fn execute_proposal (& self , src_id : :: core :: primitive :: u64 , call : runtime_types :: egg_standalone_runtime :: Call , proposal_data : :: std :: vec :: Vec < :: core :: primitive :: u8 > , signature : :: std :: vec :: Vec < :: core :: primitive :: u8 > ,) -> Result < :: subxt :: SubmittableExtrinsic < 'a , T , X , ExecuteProposal , DispatchError , root_mod :: Event > , :: subxt :: BasicError > { if self . client . metadata () . call_hash :: < ExecuteProposal > () ? == [171u8 , 115u8 , 27u8 , 196u8 , 246u8 , 189u8 , 198u8 , 96u8 , 29u8 , 189u8 , 122u8 , 173u8 , 59u8 , 20u8 , 1u8 , 37u8 , 68u8 , 6u8 , 191u8 , 190u8 , 50u8 , 206u8 , 238u8 , 178u8 , 169u8 , 170u8 , 60u8 , 24u8 , 167u8 , 221u8 , 18u8 , 33u8 ,] { let call = ExecuteProposal { src_id , call : :: std :: boxed :: Box :: new (call) , proposal_data , signature , } ; Ok (:: subxt :: SubmittableExtrinsic :: new (self . client , call)) } else { Err (:: subxt :: MetadataError :: IncompatibleMetadata . into ()) } } } } pub type Event = runtime_types :: pallet_signature_bridge :: pallet :: Event ; pub mod events { use super :: runtime_types ; # [derive (:: subxt :: codec :: Decode , :: subxt :: codec :: Encode , Clone , Debug , Eq , PartialEq)] # [doc = "Maintainer is set"] pub struct MaintainerSet { pub old_maintainer : :: std :: vec :: Vec < :: core :: primitive :: u8 > , pub new_maintainer : :: std :: vec :: Vec < :: core :: primitive :: u8 > , } impl :: subxt :: Event for MaintainerSet { const PALLET : & 'static str = "SignatureBridge" ; const EVENT : & 'static str = "MaintainerSet" ; } # [derive (:: subxt :: codec :: CompactAs , :: subxt :: codec :: Decode , :: subxt :: codec :: Encode , Clone , Debug , Eq , PartialEq)] # [doc = "Chain now available for transfers (chain_id)"] pub struct ChainWhitelisted { pub chain_id : :: core :: primitive :: u64 , } impl :: subxt :: Event for ChainWhitelisted { const PALLET : & 'static str = "SignatureBridge" ; const EVENT : & 'static str = "ChainWhitelisted" ; } # [derive (:: subxt :: codec :: Decode , :: subxt :: codec :: Encode , Clone , Debug , Eq , PartialEq)] # [doc = "Proposal has been approved"] pub struct ProposalApproved { pub chain_id : :: core :: primitive :: u64 , pub proposal_nonce : :: core :: primitive :: u32 , } impl :: subxt :: Event for ProposalApproved { const PALLET : & 'static str = "SignatureBridge" ; const EVENT : & 'static str = "ProposalApproved" ; } # [derive (:: subxt :: codec :: Decode , :: subxt :: codec :: Encode , Clone , Debug , Eq , PartialEq)] # [doc = "Execution of call succeeded"] pub struct ProposalSucceeded { pub chain_id : :: core :: primitive :: u64 , pub proposal_nonce : :: core :: primitive :: u32 , } impl :: subxt :: Event for ProposalSucceeded { const PALLET : & 'static str = "SignatureBridge" ; const EVENT : & 'static str = "ProposalSucceeded" ; } # [derive (:: subxt :: codec :: Decode , :: subxt :: codec :: Encode , Clone , Debug , Eq , PartialEq)] # [doc = "Execution of call failed"] pub struct ProposalFailed { pub chain_id : :: core :: primitive :: u64 , pub proposal_nonce : :: core :: primitive :: u32 , } impl :: subxt :: Event for ProposalFailed { const PALLET : & 'static str = "SignatureBridge" ; const EVENT : & 'static str = "ProposalFailed" ; } } pub mod storage { use super :: runtime_types ; pub struct Maintainer ; impl :: subxt :: StorageEntry for Maintainer { const PALLET : & 'static str = "SignatureBridge" ; const STORAGE : & 'static str = "Maintainer" ; type Value = :: std :: vec :: Vec < :: core :: primitive :: u8 > ; fn key (& self) -> :: subxt :: StorageEntryKey { :: subxt :: StorageEntryKey :: Plain } } pub struct ChainNonces < 'a > (pub & 'a :: core :: primitive :: u64) ; impl :: subxt :: StorageEntry for ChainNonces < '_ > { const PALLET : & 'static str = "SignatureBridge" ; const STORAGE : & 'static str = "ChainNonces" ; type Value = :: core :: primitive :: u32 ; fn key (& self) -> :: subxt :: StorageEntryKey { :: subxt :: StorageEntryKey :: Map (vec ! [:: subxt :: StorageMapKey :: new (& self . 0 , :: subxt :: StorageHasher :: Blake2_256)]) } } pub struct Resources < 'a > (pub & 'a [:: core :: primitive :: u8 ; 32usize]) ; impl :: subxt :: StorageEntry for Resources < '_ > { const PALLET : & 'static str = "SignatureBridge" ; const STORAGE : & 'static str = "Resources" ; type Value = () ; fn key (& self) -> :: subxt :: StorageEntryKey { :: subxt :: StorageEntryKey :: Map (vec ! [:: subxt :: StorageMapKey :: new (& self . 0 , :: subxt :: StorageHasher :: Blake2_256)]) } } pub struct ProposalNonce ; impl :: subxt :: StorageEntry for ProposalNonce { const PALLET : & 'static str = "SignatureBridge" ; const STORAGE : & 'static str = "ProposalNonce" ; type Value = :: core :: primitive :: u32 ; fn key (& self) -> :: subxt :: StorageEntryKey { :: subxt :: StorageEntryKey :: Plain } } pub struct MaintainerNonce ; impl :: subxt :: StorageEntry for MaintainerNonce { const PALLET : & 'static str = "SignatureBridge" ; const STORAGE : & 'static str = "MaintainerNonce" ; type Value = :: core :: primitive :: u32 ; fn key (& self) -> :: subxt :: StorageEntryKey { :: subxt :: StorageEntryKey :: Plain } } pub struct StorageApi < 'a , T : :: subxt :: Config > { client : & 'a :: subxt :: Client < T > , } impl < 'a , T : :: subxt :: Config > StorageApi < 'a , T > { pub fn new (client : & 'a :: subxt :: Client < T >) -> Self { Self { client } } # [doc = " The parameter maintainer who can change the parameters"] pub async fn maintainer (& self , block_hash : :: core :: option :: Option < T :: Hash > ,) -> :: core :: result :: Result < :: std :: vec :: Vec < :: core :: primitive :: u8 > , :: subxt :: BasicError > { if self . client . metadata () . storage_hash :: < Maintainer > () ? == [239u8 , 211u8 , 64u8 , 35u8 , 178u8 , 81u8 , 121u8 , 92u8 , 205u8 , 163u8 , 92u8 , 166u8 , 203u8 , 187u8 , 237u8 , 67u8 , 0u8 , 188u8 , 105u8 , 189u8 , 122u8 , 54u8 , 181u8 , 217u8 , 25u8 , 135u8 , 80u8 , 38u8 , 34u8 , 3u8 , 156u8 , 230u8 ,] { let entry = Maintainer ; self . client . storage () . fetch_or_default (& entry , block_hash) . await } else { Err (:: subxt :: MetadataError :: IncompatibleMetadata . into ()) } } # [doc = " All whitelisted chains and their respective transaction counts"] pub async fn chain_nonces (& self , _0 : & :: core :: primitive :: u64 , block_hash : :: core :: option :: Option < T :: Hash > ,) -> :: core :: result :: Result < :: core :: option :: Option < :: core :: primitive :: u32 > , :: subxt :: BasicError > { if self . client . metadata () . storage_hash :: < ChainNonces > () ? == [46u8 , 115u8 , 113u8 , 107u8 , 117u8 , 64u8 , 44u8 , 249u8 , 225u8 , 85u8 , 228u8 , 126u8 , 121u8 , 101u8 , 13u8 , 244u8 , 174u8 , 210u8 , 21u8 , 34u8 , 248u8 , 203u8 , 38u8 , 35u8 , 113u8 , 149u8 , 100u8 , 157u8 , 8u8 , 100u8 , 113u8 , 68u8 ,] { let entry = ChainNonces (_0) ; self . client . storage () . fetch (& entry , block_hash) . await } else { Err (:: subxt :: MetadataError :: IncompatibleMetadata . into ()) } } # [doc = " All whitelisted chains and their respective transaction counts"] pub async fn chain_nonces_iter (& self , block_hash : :: core :: option :: Option < T :: Hash > ,) -> :: core :: result :: Result < :: subxt :: KeyIter < 'a , T , ChainNonces < 'a > > , :: subxt :: BasicError > { if self . client . metadata () . storage_hash :: < ChainNonces > () ? == [46u8 , 115u8 , 113u8 , 107u8 , 117u8 , 64u8 , 44u8 , 249u8 , 225u8 , 85u8 , 228u8 , 126u8 , 121u8 , 101u8 , 13u8 , 244u8 , 174u8 , 210u8 , 21u8 , 34u8 , 248u8 , 203u8 , 38u8 , 35u8 , 113u8 , 149u8 , 100u8 , 157u8 , 8u8 , 100u8 , 113u8 , 68u8 ,] { self . client . storage () . iter (block_hash) . await } else { Err (:: subxt :: MetadataError :: IncompatibleMetadata . into ()) } } # [doc = " Utilized by the bridge software to map resource IDs to actual methods"] pub async fn resources (& self , _0 : & [:: core :: primitive :: u8 ; 32usize] , block_hash : :: core :: option :: Option < T :: Hash > ,) -> :: core :: result :: Result < :: core :: option :: Option < () > , :: subxt :: BasicError > { if self . client . metadata () . storage_hash :: < Resources > () ? == [83u8 , 68u8 , 123u8 , 152u8 , 160u8 , 232u8 , 194u8 , 136u8 , 246u8 , 188u8 , 141u8 , 172u8 , 71u8 , 164u8 , 102u8 , 49u8 , 170u8 , 212u8 , 0u8 , 227u8 , 226u8 , 47u8 , 28u8 , 54u8 , 131u8 , 186u8 , 23u8 , 38u8 , 64u8 , 61u8 , 106u8 , 172u8 ,] { let entry = Resources (_0) ; self . client . storage () . fetch (& entry , block_hash) . await } else { Err (:: subxt :: MetadataError :: IncompatibleMetadata . into ()) } } # [doc = " Utilized by the bridge software to map resource IDs to actual methods"] pub async fn resources_iter (& self , block_hash : :: core :: option :: Option < T :: Hash > ,) -> :: core :: result :: Result < :: subxt :: KeyIter < 'a , T , Resources < 'a > > , :: subxt :: BasicError > { if self . client . metadata () . storage_hash :: < Resources > () ? == [83u8 , 68u8 , 123u8 , 152u8 , 160u8 , 232u8 , 194u8 , 136u8 , 246u8 , 188u8 , 141u8 , 172u8 , 71u8 , 164u8 , 102u8 , 49u8 , 170u8 , 212u8 , 0u8 , 227u8 , 226u8 , 47u8 , 28u8 , 54u8 , 131u8 , 186u8 , 23u8 , 38u8 , 64u8 , 61u8 , 106u8 , 172u8 ,] { self . client . storage () . iter (block_hash) . await } else { Err (:: subxt :: MetadataError :: IncompatibleMetadata . into ()) } } # [doc = " The proposal nonce used to prevent replay attacks on execute_proposal"] pub async fn proposal_nonce (& self , block_hash : :: core :: option :: Option < T :: Hash > ,) -> :: core :: result :: Result < :: core :: primitive :: u32 , :: subxt :: BasicError > { if self . client . metadata () . storage_hash :: < ProposalNonce > () ? == [154u8 , 253u8 , 37u8 , 31u8 , 8u8 , 75u8 , 192u8 , 196u8 , 188u8 , 21u8 , 59u8 , 170u8 , 99u8 , 150u8 , 145u8 , 96u8 , 22u8 , 161u8 , 68u8 , 112u8 , 214u8 , 239u8 , 240u8 , 5u8 , 99u8 , 141u8 , 14u8 , 94u8 , 183u8 , 202u8 , 78u8 , 42u8 ,] { let entry = ProposalNonce ; self . client . storage () . fetch_or_default (& entry , block_hash) . await } else { Err (:: subxt :: MetadataError :: IncompatibleMetadata . into ()) } } pub async fn maintainer_nonce (& self , block_hash : :: core :: option :: Option < T :: Hash > ,) -> :: core :: result :: Result < :: core :: primitive :: u32 , :: subxt :: BasicError > { if self . client . metadata () . storage_hash :: < MaintainerNonce > () ? == [139u8 , 246u8 , 239u8 , 180u8 , 188u8 , 73u8 , 234u8 , 114u8 , 211u8 , 68u8 , 84u8 , 178u8 , 142u8 , 49u8 , 24u8 , 160u8 , 32u8 , 180u8 , 211u8 , 16u8 , 75u8 , 91u8 , 40u8 , 132u8 , 120u8 , 68u8 , 221u8 , 167u8 , 138u8 , 53u8 , 71u8 , 250u8 ,] { let entry = MaintainerNonce ; self . client . storage () . fetch_or_default (& entry , block_hash) . await } else { Err (:: subxt :: MetadataError :: IncompatibleMetadata . into ()) } } } } pub mod constants { use super :: runtime_types ; pub struct ConstantsApi < 'a , T : :: subxt :: Config > { client : & 'a :: subxt :: Client < T > , } impl < 'a , T : :: subxt :: Config > ConstantsApi < 'a , T > { pub fn new (client : & 'a :: subxt :: Client < T >) -> Self { Self { client } } # [doc = " The identifier for this chain."] # [doc = " This must be unique and must not collide with existing IDs within a"] # [doc = " set of bridged chains."] pub fn chain_identifier (& self) -> :: core :: result :: Result < :: core :: primitive :: u64 , :: subxt :: BasicError > { if self . client . metadata () . constant_hash ("SignatureBridge" , "ChainIdentifier") ? == [64u8 , 119u8 , 115u8 , 96u8 , 239u8 , 19u8 , 100u8 , 82u8 , 69u8 , 155u8 , 95u8 , 49u8 , 160u8 , 144u8 , 56u8 , 190u8 , 6u8 , 28u8 , 33u8 , 186u8 , 44u8 , 100u8 , 181u8 , 251u8 , 153u8 , 5u8 , 76u8 , 55u8 , 50u8 , 89u8 , 81u8 , 0u8 ,] { let pallet = self . client . metadata () . pallet ("SignatureBridge") ? ; let constant = pallet . constant ("ChainIdentifier") ? ; let value = :: subxt :: codec :: Decode :: decode (& mut & constant . value [..]) ? ; Ok (value) } else { Err (:: subxt :: MetadataError :: IncompatibleMetadata . into ()) } } # [doc = " The chain type for this chain."] # [doc = " This is either a standalone Substrate chain, relay chain, or parachain"] pub fn chain_type (& self) -> :: core :: result :: Result < [:: core :: primitive :: u8 ; 2usize] , :: subxt :: BasicError > { if self . client . metadata () . constant_hash ("SignatureBridge" , "ChainType") ? == [63u8 , 194u8 , 199u8 , 163u8 , 106u8 , 87u8 , 76u8 , 171u8 , 237u8 , 240u8 , 200u8 , 1u8 , 224u8 , 207u8 , 104u8 , 144u8 , 174u8 , 60u8 , 82u8 , 99u8 , 113u8 , 153u8 , 220u8 , 75u8 , 154u8 , 72u8 , 151u8 , 213u8 , 38u8 , 50u8 , 170u8 , 129u8 ,] { let pallet = self . client . metadata () . pallet ("SignatureBridge") ? ; let constant = pallet . constant ("ChainType") ? ; let value = :: subxt :: codec :: Decode :: decode (& mut & constant . value [..]) ? ; Ok (value) } else { Err (:: subxt :: MetadataError :: IncompatibleMetadata . into ()) } } pub fn proposal_lifetime (& self) -> :: core :: result :: Result < :: core :: primitive :: u32 , :: subxt :: BasicError > { if self . client . metadata () . constant_hash ("SignatureBridge" , "ProposalLifetime") ? == [32u8 , 65u8 , 139u8 , 255u8 , 16u8 , 174u8 , 54u8 , 144u8 , 194u8 , 248u8 , 219u8 , 78u8 , 66u8 , 165u8 , 249u8 , 89u8 , 210u8 , 40u8 , 194u8 , 180u8 , 174u8 , 145u8 , 20u8 , 152u8 , 46u8 , 235u8 , 255u8 , 149u8 , 46u8 , 4u8 , 174u8 , 65u8 ,] { let pallet = self . client . metadata () . pallet ("SignatureBridge") ? ; let constant = pallet . constant ("ProposalLifetime") ? ; let value = :: subxt :: codec :: Decode :: decode (& mut & constant . value [..]) ? ; Ok (value) } else { Err (:: subxt :: MetadataError :: IncompatibleMetadata . into ()) } } pub fn bridge_account_id (& self) -> :: core :: result :: Result < runtime_types :: frame_support :: PalletId , :: subxt :: BasicError > { if self . client . metadata () . constant_hash ("SignatureBridge" , "BridgeAccountId") ? == [235u8 , 164u8 , 124u8 , 149u8 , 101u8 , 22u8 , 120u8 , 2u8 , 210u8 , 204u8 , 38u8 , 10u8 , 149u8 , 152u8 , 78u8 , 191u8 , 165u8 , 55u8 , 233u8 , 43u8 , 156u8 , 67u8 , 79u8 , 54u8 , 198u8 , 252u8 , 246u8 , 144u8 , 35u8 , 39u8 , 79u8 , 243u8 ,] { let pallet = self . client . metadata () . pallet ("SignatureBridge") ? ; let constant = pallet . constant ("BridgeAccountId") ? ; let value = :: subxt :: codec :: Decode :: decode (& mut & constant . value [..]) ? ; Ok (value) } else { Err (:: subxt :: MetadataError :: IncompatibleMetadata . into ()) } } } } } pub mod v_anchor_verifier2x2_bn254 { use super :: root_mod ; use super :: runtime_types ; pub mod calls { use super :: root_mod ; use super :: runtime_types ; type DispatchError = runtime_types :: sp_runtime :: DispatchError ; # [derive (:: subxt :: codec :: Decode , :: subxt :: codec :: Encode , Clone , Debug , Eq , PartialEq)] pub struct ForceSetParameters { pub parameters : :: std :: vec :: Vec < :: core :: primitive :: u8 > , } impl :: subxt :: Call for ForceSetParameters { const PALLET : & 'static str = "VAnchorVerifier2x2Bn254" ; const FUNCTION : & 'static str = "force_set_parameters" ; } pub struct TransactionApi < 'a , T : :: subxt :: Config , X > { client : & 'a :: subxt :: Client < T > , marker : :: core :: marker :: PhantomData < X > , } impl < 'a , T , X > TransactionApi < 'a , T , X > where T : :: subxt :: Config , X : :: subxt :: extrinsic :: ExtrinsicParams < T > , { pub fn new (client : & 'a :: subxt :: Client < T >) -> Self { Self { client , marker : :: core :: marker :: PhantomData } } pub fn force_set_parameters (& self , parameters : :: std :: vec :: Vec < :: core :: primitive :: u8 > ,) -> Result < :: subxt :: SubmittableExtrinsic < 'a , T , X , ForceSetParameters , DispatchError , root_mod :: Event > , :: subxt :: BasicError > { if self . client . metadata () . call_hash :: < ForceSetParameters > () ? == [4u8 , 152u8 , 126u8 , 7u8 , 21u8 , 41u8 , 229u8 , 72u8 , 49u8 , 177u8 , 34u8 , 57u8 , 44u8 , 27u8 , 82u8 , 102u8 , 214u8 , 37u8 , 20u8 , 122u8 , 7u8 , 179u8 , 196u8 , 112u8 , 192u8 , 168u8 , 247u8 , 171u8 , 177u8 , 42u8 , 167u8 , 15u8 ,] { let call = ForceSetParameters { parameters , } ; Ok (:: subxt :: SubmittableExtrinsic :: new (self . client , call)) } else { Err (:: subxt :: MetadataError :: IncompatibleMetadata . into ()) } } } } pub type Event = runtime_types :: pallet_verifier :: pallet :: Event ; pub mod events { use super :: runtime_types ; } pub mod storage { use super :: runtime_types ; pub struct Parameters ; impl :: subxt :: StorageEntry for Parameters { const PALLET : & 'static str = "VAnchorVerifier2x2Bn254" ; const STORAGE : & 'static str = "Parameters" ; type Value = :: std :: vec :: Vec < :: core :: primitive :: u8 > ; fn key (& self) -> :: subxt :: StorageEntryKey { :: subxt :: StorageEntryKey :: Plain } } pub struct StorageApi < 'a , T : :: subxt :: Config > { client : & 'a :: subxt :: Client < T > , } impl < 'a , T : :: subxt :: Config > StorageApi < 'a , T > { pub fn new (client : & 'a :: subxt :: Client < T >) -> Self { Self { client } } # [doc = " Details of the module's parameters"] pub async fn parameters (& self , block_hash : :: core :: option :: Option < T :: Hash > ,) -> :: core :: result :: Result < :: std :: vec :: Vec < :: core :: primitive :: u8 > , :: subxt :: BasicError > { if self . client . metadata () . storage_hash :: < Parameters > () ? == [244u8 , 201u8 , 192u8 , 254u8 , 217u8 , 76u8 , 12u8 , 84u8 , 71u8 , 96u8 , 64u8 , 115u8 , 66u8 , 74u8 , 252u8 , 59u8 , 193u8 , 35u8 , 136u8 , 67u8 , 55u8 , 96u8 , 185u8 , 129u8 , 130u8 , 120u8 , 224u8 , 100u8 , 199u8 , 83u8 , 107u8 , 187u8 ,] { let entry = Parameters ; self . client . storage () . fetch_or_default (& entry , block_hash) . await } else { Err (:: subxt :: MetadataError :: IncompatibleMetadata . into ()) } } } } } pub mod bridge { use super :: root_mod ; use super :: runtime_types ; pub mod calls { use super :: root_mod ; use super :: runtime_types ; type DispatchError = runtime_types :: sp_runtime :: DispatchError ; # [derive (:: subxt :: codec :: CompactAs , :: subxt :: codec :: Decode , :: subxt :: codec :: Encode , Clone , Debug , Eq , PartialEq)] pub struct SetThreshold { pub threshold : :: core :: primitive :: u32 , } impl :: subxt :: Call for SetThreshold { const PALLET : & 'static str = "Bridge" ; const FUNCTION : & 'static str = "set_threshold" ; } # [derive (:: subxt :: codec :: Decode , :: subxt :: codec :: Encode , Clone , Debug , Eq , PartialEq)] pub struct SetResource { pub id : [:: core :: primitive :: u8 ; 32usize] , pub method : :: std :: vec :: Vec < :: core :: primitive :: u8 > , } impl :: subxt :: Call for SetResource { const PALLET : & 'static str = "Bridge" ; const FUNCTION : & 'static str = "set_resource" ; } # [derive (:: subxt :: codec :: Decode , :: subxt :: codec :: Encode , Clone , Debug , Eq , PartialEq)] pub struct RemoveResource { pub id : [:: core :: primitive :: u8 ; 32usize] , } impl :: subxt :: Call for RemoveResource { const PALLET : & 'static str = "Bridge" ; const FUNCTION : & 'static str = "remove_resource" ; } # [derive (:: subxt :: codec :: CompactAs , :: subxt :: codec :: Decode , :: subxt :: codec :: Encode , Clone , Debug , Eq , PartialEq)] pub struct WhitelistChain { pub id : :: core :: primitive :: u64 , } impl :: subxt :: Call for WhitelistChain { const PALLET : & 'static str = "Bridge" ; const FUNCTION : & 'static str = "whitelist_chain" ; } # [derive (:: subxt :: codec :: Decode , :: subxt :: codec :: Encode , Clone , Debug , Eq , PartialEq)] pub struct AddRelayer { pub v : :: subxt :: sp_core :: crypto :: AccountId32 , } impl :: subxt :: Call for AddRelayer { const PALLET : & 'static str = "Bridge" ; const FUNCTION : & 'static str = "add_relayer" ; } # [derive (:: subxt :: codec :: Decode , :: subxt :: codec :: Encode , Clone , Debug , Eq , PartialEq)] pub struct RemoveRelayer { pub v : :: subxt :: sp_core :: crypto :: AccountId32 , } impl :: subxt :: Call for RemoveRelayer { const PALLET : & 'static str = "Bridge" ; const FUNCTION : & 'static str = "remove_relayer" ; } # [derive (:: subxt :: codec :: Decode , :: subxt :: codec :: Encode , Clone , Debug , Eq , PartialEq)] pub struct AcknowledgeProposal { pub nonce : :: core :: primitive :: u64 , pub src_id : :: core :: primitive :: u64 , pub r_id : [:: core :: primitive :: u8 ; 32usize] , pub call : :: std :: boxed :: Box < runtime_types :: egg_standalone_runtime :: Call > , } impl :: subxt :: Call for AcknowledgeProposal { const PALLET : & 'static str = "Bridge" ; const FUNCTION : & 'static str = "acknowledge_proposal" ; } # [derive (:: subxt :: codec :: Decode , :: subxt :: codec :: Encode , Clone , Debug , Eq , PartialEq)] pub struct RejectProposal { pub nonce : :: core :: primitive :: u64 , pub src_id : :: core :: primitive :: u64 , pub r_id : [:: core :: primitive :: u8 ; 32usize] , pub call : :: std :: boxed :: Box < runtime_types :: egg_standalone_runtime :: Call > , } impl :: subxt :: Call for RejectProposal { const PALLET : & 'static str = "Bridge" ; const FUNCTION : & 'static str = "reject_proposal" ; } # [derive (:: subxt :: codec :: Decode , :: subxt :: codec :: Encode , Clone , Debug , Eq , PartialEq)] pub struct EvalVoteState { pub nonce : :: core :: primitive :: u64 , pub src_id : :: core :: primitive :: u64 , pub prop : :: std :: boxed :: Box < runtime_types :: egg_standalone_runtime :: Call > , } impl :: subxt :: Call for EvalVoteState { const PALLET : & 'static str = "Bridge" ; const FUNCTION : & 'static str = "eval_vote_state" ; } pub struct TransactionApi < 'a , T : :: subxt :: Config , X > { client : & 'a :: subxt :: Client < T > , marker : :: core :: marker :: PhantomData < X > , } impl < 'a , T , X > TransactionApi < 'a , T , X > where T : :: subxt :: Config , X : :: subxt :: extrinsic :: ExtrinsicParams < T > , { pub fn new (client : & 'a :: subxt :: Client < T >) -> Self { Self { client , marker : :: core :: marker :: PhantomData } } # [doc = "Sets the vote threshold for proposals."] # [doc = ""] # [doc = "This threshold is used to determine how many votes are required"] # [doc = "before a proposal is executed."] # [doc = ""] # [doc = "# <weight>"] # [doc = "- O(1) lookup and insert"] # [doc = "# </weight>"] pub fn set_threshold (& self , threshold : :: core :: primitive :: u32 ,) -> Result < :: subxt :: SubmittableExtrinsic < 'a , T , X , SetThreshold , DispatchError , root_mod :: Event > , :: subxt :: BasicError > { if self . client . metadata () . call_hash :: < SetThreshold > () ? == [52u8 , 167u8 , 254u8 , 240u8 , 138u8 , 213u8 , 67u8 , 65u8 , 79u8 , 11u8 , 193u8 , 17u8 , 248u8 , 153u8 , 47u8 , 179u8 , 218u8 , 86u8 , 157u8 , 230u8 , 186u8 , 234u8 , 123u8 , 36u8 , 22u8 , 164u8 , 17u8 , 183u8 , 180u8 , 111u8 , 252u8 , 206u8 ,] { let call = SetThreshold { threshold , } ; Ok (:: subxt :: SubmittableExtrinsic :: new (self . client , call)) } else { Err (:: subxt :: MetadataError :: IncompatibleMetadata . into ()) } } # [doc = "Stores a method name on chain under an associated resource ID."] # [doc = ""] # [doc = "# <weight>"] # [doc = "- O(1) write"] # [doc = "# </weight>"] pub fn set_resource (& self , id : [:: core :: primitive :: u8 ; 32usize] , method : :: std :: vec :: Vec < :: core :: primitive :: u8 > ,) -> Result < :: subxt :: SubmittableExtrinsic < 'a , T , X , SetResource , DispatchError , root_mod :: Event > , :: subxt :: BasicError > { if self . client . metadata () . call_hash :: < SetResource > () ? == [243u8 , 25u8 , 3u8 , 44u8 , 185u8 , 245u8 , 35u8 , 7u8 , 113u8 , 119u8 , 142u8 , 3u8 , 60u8 , 121u8 , 208u8 , 130u8 , 232u8 , 27u8 , 120u8 , 86u8 , 41u8 , 26u8 , 169u8 , 139u8 , 108u8 , 0u8 , 253u8 , 151u8 , 127u8 , 144u8 , 201u8 , 74u8 ,] { let call = SetResource { id , method , } ; Ok (:: subxt :: SubmittableExtrinsic :: new (self . client , call)) } else { Err (:: subxt :: MetadataError :: IncompatibleMetadata . into ()) } } # [doc = "Removes a resource ID from the resource mapping."] # [doc = ""] # [doc = "After this call, bridge transfers with the associated resource ID"] # [doc = "will be rejected."] # [doc = ""] # [doc = "# <weight>"] # [doc = "- O(1) removal"] # [doc = "# </weight>"] pub fn remove_resource (& self , id : [:: core :: primitive :: u8 ; 32usize] ,) -> Result < :: subxt :: SubmittableExtrinsic < 'a , T , X , RemoveResource , DispatchError , root_mod :: Event > , :: subxt :: BasicError > { if self . client . metadata () . call_hash :: < RemoveResource > () ? == [246u8 , 55u8 , 247u8 , 249u8 , 78u8 , 215u8 , 150u8 , 199u8 , 124u8 , 136u8 , 18u8 , 166u8 , 157u8 , 107u8 , 80u8 , 105u8 , 105u8 , 2u8 , 157u8 , 128u8 , 212u8 , 110u8 , 36u8 , 174u8 , 182u8 , 142u8 , 251u8 , 136u8 , 218u8 , 43u8 , 119u8 , 194u8 ,] { let call = RemoveResource { id , } ; Ok (:: subxt :: SubmittableExtrinsic :: new (self . client , call)) } else { Err (:: subxt :: MetadataError :: IncompatibleMetadata . into ()) } } # [doc = "Enables a chain ID as a source or destination for a bridge transfer."] # [doc = ""] # [doc = "# <weight>"] # [doc = "- O(1) lookup and insert"] # [doc = "# </weight>"] pub fn whitelist_chain (& self , id : :: core :: primitive :: u64 ,) -> Result < :: subxt :: SubmittableExtrinsic < 'a , T , X , WhitelistChain , DispatchError , root_mod :: Event > , :: subxt :: BasicError > { if self . client . metadata () . call_hash :: < WhitelistChain > () ? == [228u8 , 70u8 , 217u8 , 65u8 , 146u8 , 159u8 , 16u8 , 28u8 , 107u8 , 47u8 , 169u8 , 13u8 , 208u8 , 57u8 , 138u8 , 150u8 , 217u8 , 46u8 , 73u8 , 154u8 , 74u8 , 143u8 , 85u8 , 31u8 , 24u8 , 73u8 , 160u8 , 95u8 , 23u8 , 86u8 , 51u8 , 74u8 ,] { let call = WhitelistChain { id , } ; Ok (:: subxt :: SubmittableExtrinsic :: new (self . client , call)) } else { Err (:: subxt :: MetadataError :: IncompatibleMetadata . into ()) } } # [doc = "Adds a new relayer to the relayer set."] # [doc = ""] # [doc = "# <weight>"] # [doc = "- O(1) lookup and insert"] # [doc = "# </weight>"] pub fn add_relayer (& self , v : :: subxt :: sp_core :: crypto :: AccountId32 ,) -> Result < :: subxt :: SubmittableExtrinsic < 'a , T , X , AddRelayer , DispatchError , root_mod :: Event > , :: subxt :: BasicError > { if self . client . metadata () . call_hash :: < AddRelayer > () ? == [234u8 , 173u8 , 241u8 , 208u8 , 226u8 , 184u8 , 9u8 , 215u8 , 59u8 , 188u8 , 135u8 , 210u8 , 79u8 , 101u8 , 210u8 , 32u8 , 226u8 , 129u8 , 86u8 , 121u8 , 124u8 , 248u8 , 67u8 , 154u8 , 63u8 , 66u8 , 103u8 , 98u8 , 94u8 , 77u8 , 158u8 , 72u8 ,] { let call = AddRelayer { v , } ; Ok (:: subxt :: SubmittableExtrinsic :: new (self . client , call)) } else { Err (:: subxt :: MetadataError :: IncompatibleMetadata . into ()) } } # [doc = "Removes an existing relayer from the set."] # [doc = ""] # [doc = "# <weight>"] # [doc = "- O(1) lookup and removal"] # [doc = "# </weight>"] pub fn remove_relayer (& self , v : :: subxt :: sp_core :: crypto :: AccountId32 ,) -> Result < :: subxt :: SubmittableExtrinsic < 'a , T , X , RemoveRelayer , DispatchError , root_mod :: Event > , :: subxt :: BasicError > { if self . client . metadata () . call_hash :: < RemoveRelayer > () ? == [32u8 , 177u8 , 132u8 , 130u8 , 123u8 , 81u8 , 28u8 , 190u8 , 104u8 , 126u8 , 217u8 , 98u8 , 83u8 , 177u8 , 113u8 , 16u8 , 237u8 , 37u8 , 223u8 , 118u8 , 23u8 , 33u8 , 62u8 , 140u8 , 17u8 , 242u8 , 34u8 , 76u8 , 118u8 , 47u8 , 114u8 , 23u8 ,] { let call = RemoveRelayer { v , } ; Ok (:: subxt :: SubmittableExtrinsic :: new (self . client , call)) } else { Err (:: subxt :: MetadataError :: IncompatibleMetadata . into ()) } } # [doc = "Commits a vote in favour of the provided proposal."] # [doc = ""] # [doc = "If a proposal with the given nonce and source chain ID does not"] # [doc = "already exist, it will be created with an initial vote in favour"] # [doc = "from the caller."] # [doc = ""] # [doc = "# <weight>"] # [doc = "- weight of proposed call, regardless of whether execution is performed"] # [doc = "# </weight>"] pub fn acknowledge_proposal (& self , nonce : :: core :: primitive :: u64 , src_id : :: core :: primitive :: u64 , r_id : [:: core :: primitive :: u8 ; 32usize] , call : runtime_types :: egg_standalone_runtime :: Call ,) -> Result < :: subxt :: SubmittableExtrinsic < 'a , T , X , AcknowledgeProposal , DispatchError , root_mod :: Event > , :: subxt :: BasicError > { if self . client . metadata () . call_hash :: < AcknowledgeProposal > () ? == [207u8 , 12u8 , 100u8 , 145u8 , 60u8 , 241u8 , 227u8 , 160u8 , 79u8 , 255u8 , 179u8 , 82u8 , 115u8 , 209u8 , 168u8 , 132u8 , 194u8 , 116u8 , 138u8 , 5u8 , 203u8 , 195u8 , 36u8 , 37u8 , 47u8 , 250u8 , 225u8 , 88u8 , 124u8 , 188u8 , 199u8 , 62u8 ,] { let call = AcknowledgeProposal { nonce , src_id , r_id , call : :: std :: boxed :: Box :: new (call) , } ; Ok (:: subxt :: SubmittableExtrinsic :: new (self . client , call)) } else { Err (:: subxt :: MetadataError :: IncompatibleMetadata . into ()) } } # [doc = "Commits a vote against a provided proposal."] # [doc = ""] # [doc = "# <weight>"] # [doc = "- Fixed, since execution of proposal should not be included"] # [doc = "# </weight>"] pub fn reject_proposal (& self , nonce : :: core :: primitive :: u64 , src_id : :: core :: primitive :: u64 , r_id : [:: core :: primitive :: u8 ; 32usize] , call : runtime_types :: egg_standalone_runtime :: Call ,) -> Result < :: subxt :: SubmittableExtrinsic < 'a , T , X , RejectProposal , DispatchError , root_mod :: Event > , :: subxt :: BasicError > { if self . client . metadata () . call_hash :: < RejectProposal > () ? == [6u8 , 99u8 , 126u8 , 85u8 , 46u8 , 34u8 , 57u8 , 223u8 , 11u8 , 186u8 , 134u8 , 210u8 , 121u8 , 223u8 , 85u8 , 71u8 , 153u8 , 65u8 , 60u8 , 153u8 , 212u8 , 44u8 , 191u8 , 143u8 , 51u8 , 124u8 , 44u8 , 14u8 , 207u8 , 205u8 , 22u8 , 15u8 ,] { let call = RejectProposal { nonce , src_id , r_id , call : :: std :: boxed :: Box :: new (call) , } ; Ok (:: subxt :: SubmittableExtrinsic :: new (self . client , call)) } else { Err (:: subxt :: MetadataError :: IncompatibleMetadata . into ()) } } # [doc = "Evaluate the state of a proposal given the current vote threshold."] # [doc = ""] # [doc = "A proposal with enough votes will be either executed or cancelled,"] # [doc = "and the status will be updated accordingly."] # [doc = ""] # [doc = "# <weight>"] # [doc = "- weight of proposed call, regardless of whether execution is performed"] # [doc = "# </weight>"] pub fn eval_vote_state (& self , nonce : :: core :: primitive :: u64 , src_id : :: core :: primitive :: u64 , prop : runtime_types :: egg_standalone_runtime :: Call ,) -> Result < :: subxt :: SubmittableExtrinsic < 'a , T , X , EvalVoteState , DispatchError , root_mod :: Event > , :: subxt :: BasicError > { if self . client . metadata () . call_hash :: < EvalVoteState > () ? == [246u8 , 160u8 , 241u8 , 224u8 , 175u8 , 193u8 , 29u8 , 33u8 , 127u8 , 82u8 , 35u8 , 167u8 , 16u8 , 143u8 , 127u8 , 109u8 , 241u8 , 21u8 , 255u8 , 12u8 , 0u8 , 129u8 , 96u8 , 220u8 , 6u8 , 236u8 , 12u8 , 185u8 , 180u8 , 199u8 , 237u8 , 82u8 ,] { let call = EvalVoteState { nonce , src_id , prop : :: std :: boxed :: Box :: new (prop) , } ; Ok (:: subxt :: SubmittableExtrinsic :: new (self . client , call)) } else { Err (:: subxt :: MetadataError :: IncompatibleMetadata . into ()) } } } } pub type Event = runtime_types :: pallet_bridge :: pallet :: Event ; pub mod events { use super :: runtime_types ; # [derive (:: subxt :: codec :: CompactAs , :: subxt :: codec :: Decode , :: subxt :: codec :: Encode , Clone , Debug , Eq , PartialEq)] # [doc = "Vote threshold has changed (new_threshold)"] pub struct RelayerThresholdChanged { pub new_threshold : :: core :: primitive :: u32 , } impl :: subxt :: Event for RelayerThresholdChanged { const PALLET : & 'static str = "Bridge" ; const EVENT : & 'static str = "RelayerThresholdChanged" ; } # [derive (:: subxt :: codec :: CompactAs , :: subxt :: codec :: Decode , :: subxt :: codec :: Encode , Clone , Debug , Eq , PartialEq)] # [doc = "Chain now available for transfers (chain_id)"] pub struct ChainWhitelisted { pub chain_id : :: core :: primitive :: u64 , } impl :: subxt :: Event for ChainWhitelisted { const PALLET : & 'static str = "Bridge" ; const EVENT : & 'static str = "ChainWhitelisted" ; } # [derive (:: subxt :: codec :: Decode , :: subxt :: codec :: Encode , Clone , Debug , Eq , PartialEq)] # [doc = "Relayer added to set"] pub struct RelayerAdded { pub relayer_id : :: subxt :: sp_core :: crypto :: AccountId32 , } impl :: subxt :: Event for RelayerAdded { const PALLET : & 'static str = "Bridge" ; const EVENT : & 'static str = "RelayerAdded" ; } # [derive (:: subxt :: codec :: Decode , :: subxt :: codec :: Encode , Clone , Debug , Eq , PartialEq)] # [doc = "Relayer removed from set"] pub struct RelayerRemoved { pub relayer_id : :: subxt :: sp_core :: crypto :: AccountId32 , } impl :: subxt :: Event for RelayerRemoved { const PALLET : & 'static str = "Bridge" ; const EVENT : & 'static str = "RelayerRemoved" ; } # [derive (:: subxt :: codec :: Decode , :: subxt :: codec :: Encode , Clone , Debug , Eq , PartialEq)] # [doc = "Vote submitted in favour of proposal"] pub struct VoteFor { pub chain_id : :: core :: primitive :: u64 , pub deposit_nonce : :: core :: primitive :: u64 , pub who : :: subxt :: sp_core :: crypto :: AccountId32 , } impl :: subxt :: Event for VoteFor { const PALLET : & 'static str = "Bridge" ; const EVENT : & 'static str = "VoteFor" ; } # [derive (:: subxt :: codec :: Decode , :: subxt :: codec :: Encode , Clone , Debug , Eq , PartialEq)] # [doc = "Vot submitted against proposal"] pub struct VoteAgainst { pub chain_id : :: core :: primitive :: u64 , pub deposit_nonce : :: core :: primitive :: u64 , pub who : :: subxt :: sp_core :: crypto :: AccountId32 , } impl :: subxt :: Event for VoteAgainst { const PALLET : & 'static str = "Bridge" ; const EVENT : & 'static str = "VoteAgainst" ; } # [derive (:: subxt :: codec :: Decode , :: subxt :: codec :: Encode , Clone , Debug , Eq , PartialEq)] # [doc = "Voting successful for a proposal"] pub struct ProposalApproved { pub chain_id : :: core :: primitive :: u64 , pub deposit_nonce : :: core :: primitive :: u64 , } impl :: subxt :: Event for ProposalApproved { const PALLET : & 'static str = "Bridge" ; const EVENT : & 'static str = "ProposalApproved" ; } # [derive (:: subxt :: codec :: Decode , :: subxt :: codec :: Encode , Clone , Debug , Eq , PartialEq)] # [doc = "Voting rejected a proposal"] pub struct ProposalRejected { pub chain_id : :: core :: primitive :: u64 , pub deposit_nonce : :: core :: primitive :: u64 , } impl :: subxt :: Event for ProposalRejected { const PALLET : & 'static str = "Bridge" ; const EVENT : & 'static str = "ProposalRejected" ; } # [derive (:: subxt :: codec :: Decode , :: subxt :: codec :: Encode , Clone , Debug , Eq , PartialEq)] # [doc = "Execution of call succeeded"] pub struct ProposalSucceeded { pub chain_id : :: core :: primitive :: u64 , pub deposit_nonce : :: core :: primitive :: u64 , } impl :: subxt :: Event for ProposalSucceeded { const PALLET : & 'static str = "Bridge" ; const EVENT : & 'static str = "ProposalSucceeded" ; } # [derive (:: subxt :: codec :: Decode , :: subxt :: codec :: Encode , Clone , Debug , Eq , PartialEq)] # [doc = "Execution of call failed"] pub struct ProposalFailed { pub chain_id : :: core :: primitive :: u64 , pub deposit_nonce : :: core :: primitive :: u64 , } impl :: subxt :: Event for ProposalFailed { const PALLET : & 'static str = "Bridge" ; const EVENT : & 'static str = "ProposalFailed" ; } } pub mod storage { use super :: runtime_types ; pub struct ChainNonces < 'a > (pub & 'a :: core :: primitive :: u64) ; impl :: subxt :: StorageEntry for ChainNonces < '_ > { const PALLET : & 'static str = "Bridge" ; const STORAGE : & 'static str = "ChainNonces" ; type Value = :: core :: primitive :: u64 ; fn key (& self) -> :: subxt :: StorageEntryKey { :: subxt :: StorageEntryKey :: Map (vec ! [:: subxt :: StorageMapKey :: new (& self . 0 , :: subxt :: StorageHasher :: Blake2_256)]) } } pub struct RelayerThreshold ; impl :: subxt :: StorageEntry for RelayerThreshold { const PALLET : & 'static str = "Bridge" ; const STORAGE : & 'static str = "RelayerThreshold" ; type Value = :: core :: primitive :: u32 ; fn key (& self) -> :: subxt :: StorageEntryKey { :: subxt :: StorageEntryKey :: Plain } } pub struct Relayers < 'a > (pub & 'a :: subxt :: sp_core :: crypto :: AccountId32) ; impl :: subxt :: StorageEntry for Relayers < '_ > { const PALLET : & 'static str = "Bridge" ; const STORAGE : & 'static str = "Relayers" ; type Value = :: core :: primitive :: bool ; fn key (& self) -> :: subxt :: StorageEntryKey { :: subxt :: StorageEntryKey :: Map (vec ! [:: subxt :: StorageMapKey :: new (& self . 0 , :: subxt :: StorageHasher :: Blake2_256)]) } } pub struct RelayerCount ; impl :: subxt :: StorageEntry for RelayerCount { const PALLET : & 'static str = "Bridge" ; const STORAGE : & 'static str = "RelayerCount" ; type Value = :: core :: primitive :: u32 ; fn key (& self) -> :: subxt :: StorageEntryKey { :: subxt :: StorageEntryKey :: Plain } } pub struct Votes < 'a > (pub & 'a :: core :: primitive :: u64 , pub & 'a (:: core :: primitive :: u64 , runtime_types :: egg_standalone_runtime :: Call ,)) ; impl :: subxt :: StorageEntry for Votes < '_ > { const PALLET : & 'static str = "Bridge" ; const STORAGE : & 'static str = "Votes" ; type Value = runtime_types :: pallet_bridge :: types :: ProposalVotes < :: subxt :: sp_core :: crypto :: AccountId32 , :: core :: primitive :: u32 > ; fn key (& self) -> :: subxt :: StorageEntryKey { :: subxt :: StorageEntryKey :: Map (vec ! [:: subxt :: StorageMapKey :: new (& self . 0 , :: subxt :: StorageHasher :: Blake2_256) , :: subxt :: StorageMapKey :: new (& self . 1 , :: subxt :: StorageHasher :: Blake2_256)]) } } pub struct Resources < 'a > (pub & 'a [:: core :: primitive :: u8 ; 32usize]) ; impl :: subxt :: StorageEntry for Resources < '_ > { const PALLET : & 'static str = "Bridge" ; const STORAGE : & 'static str = "Resources" ; type Value = :: std :: vec :: Vec < :: core :: primitive :: u8 > ; fn key (& self) -> :: subxt :: StorageEntryKey { :: subxt :: StorageEntryKey :: Map (vec ! [:: subxt :: StorageMapKey :: new (& self . 0 , :: subxt :: StorageHasher :: Blake2_256)]) } } pub struct StorageApi < 'a , T : :: subxt :: Config > { client : & 'a :: subxt :: Client < T > , } impl < 'a , T : :: subxt :: Config > StorageApi < 'a , T > { pub fn new (client : & 'a :: subxt :: Client < T >) -> Self { Self { client } } # [doc = " All whitelisted chains and their respective transaction counts"] pub async fn chain_nonces (& self , _0 : & :: core :: primitive :: u64 , block_hash : :: core :: option :: Option < T :: Hash > ,) -> :: core :: result :: Result < :: core :: option :: Option < :: core :: primitive :: u64 > , :: subxt :: BasicError > { if self . client . metadata () . storage_hash :: < ChainNonces > () ? == [69u8 , 121u8 , 145u8 , 131u8 , 63u8 , 83u8 , 81u8 , 64u8 , 108u8 , 255u8 , 245u8 , 240u8 , 239u8 , 3u8 , 126u8 , 107u8 , 175u8 , 231u8 , 11u8 , 225u8 , 34u8 , 204u8 , 215u8 , 153u8 , 1u8 , 252u8 , 237u8 , 34u8 , 246u8 , 144u8 , 168u8 , 249u8 ,] { let entry = ChainNonces (_0) ; self . client . storage () . fetch (& entry , block_hash) . await } else { Err (:: subxt :: MetadataError :: IncompatibleMetadata . into ()) } } # [doc = " All whitelisted chains and their respective transaction counts"] pub async fn chain_nonces_iter (& self , block_hash : :: core :: option :: Option < T :: Hash > ,) -> :: core :: result :: Result < :: subxt :: KeyIter < 'a , T , ChainNonces < 'a > > , :: subxt :: BasicError > { if self . client . metadata () . storage_hash :: < ChainNonces > () ? == [69u8 , 121u8 , 145u8 , 131u8 , 63u8 , 83u8 , 81u8 , 64u8 , 108u8 , 255u8 , 245u8 , 240u8 , 239u8 , 3u8 , 126u8 , 107u8 , 175u8 , 231u8 , 11u8 , 225u8 , 34u8 , 204u8 , 215u8 , 153u8 , 1u8 , 252u8 , 237u8 , 34u8 , 246u8 , 144u8 , 168u8 , 249u8 ,] { self . client . storage () . iter (block_hash) . await } else { Err (:: subxt :: MetadataError :: IncompatibleMetadata . into ()) } } # [doc = " Number of votes required for a proposal to execute"] pub async fn relayer_threshold (& self , block_hash : :: core :: option :: Option < T :: Hash > ,) -> :: core :: result :: Result < :: core :: primitive :: u32 , :: subxt :: BasicError > { if self . client . metadata () . storage_hash :: < RelayerThreshold > () ? == [100u8 , 0u8 , 1u8 , 138u8 , 187u8 , 25u8 , 203u8 , 121u8 , 174u8 , 58u8 , 112u8 , 32u8 , 225u8 , 233u8 , 133u8 , 251u8 , 32u8 , 216u8 , 15u8 , 4u8 , 104u8 , 153u8 , 229u8 , 175u8 , 62u8 , 53u8 , 184u8 , 228u8 , 151u8 , 122u8 , 222u8 , 251u8 ,] { let entry = RelayerThreshold ; self . client . storage () . fetch_or_default (& entry , block_hash) . await } else { Err (:: subxt :: MetadataError :: IncompatibleMetadata . into ()) } } # [doc = " Tracks current relayer set"] pub async fn relayers (& self , _0 : & :: subxt :: sp_core :: crypto :: AccountId32 , block_hash : :: core :: option :: Option < T :: Hash > ,) -> :: core :: result :: Result < :: core :: option :: Option < :: core :: primitive :: bool > , :: subxt :: BasicError > { if self . client . metadata () . storage_hash :: < Relayers > () ? == [206u8 , 44u8 , 192u8 , 148u8 , 239u8 , 118u8 , 11u8 , 43u8 , 1u8 , 139u8 , 84u8 , 64u8 , 39u8 , 140u8 , 90u8 , 139u8 , 21u8 , 71u8 , 253u8 , 163u8 , 35u8 , 139u8 , 141u8 , 20u8 , 212u8 , 61u8 , 27u8 , 114u8 , 99u8 , 37u8 , 230u8 , 129u8 ,] { let entry = Relayers (_0) ; self . client . storage () . fetch (& entry , block_hash) . await } else { Err (:: subxt :: MetadataError :: IncompatibleMetadata . into ()) } } # [doc = " Tracks current relayer set"] pub async fn relayers_iter (& self , block_hash : :: core :: option :: Option < T :: Hash > ,) -> :: core :: result :: Result < :: subxt :: KeyIter < 'a , T , Relayers < 'a > > , :: subxt :: BasicError > { if self . client . metadata () . storage_hash :: < Relayers > () ? == [206u8 , 44u8 , 192u8 , 148u8 , 239u8 , 118u8 , 11u8 , 43u8 , 1u8 , 139u8 , 84u8 , 64u8 , 39u8 , 140u8 , 90u8 , 139u8 , 21u8 , 71u8 , 253u8 , 163u8 , 35u8 , 139u8 , 141u8 , 20u8 , 212u8 , 61u8 , 27u8 , 114u8 , 99u8 , 37u8 , 230u8 , 129u8 ,] { self . client . storage () . iter (block_hash) . await } else { Err (:: subxt :: MetadataError :: IncompatibleMetadata . into ()) } } # [doc = " Number of relayers in set"] pub async fn relayer_count (& self , block_hash : :: core :: option :: Option < T :: Hash > ,) -> :: core :: result :: Result < :: core :: primitive :: u32 , :: subxt :: BasicError > { if self . client . metadata () . storage_hash :: < RelayerCount > () ? == [114u8 , 213u8 , 81u8 , 78u8 , 243u8 , 126u8 , 15u8 , 35u8 , 3u8 , 12u8 , 128u8 , 113u8 , 97u8 , 158u8 , 122u8 , 47u8 , 251u8 , 16u8 , 236u8 , 1u8 , 148u8 , 109u8 , 242u8 , 114u8 , 204u8 , 83u8 , 167u8 , 87u8 , 100u8 , 89u8 , 171u8 , 86u8 ,] { let entry = RelayerCount ; self . client . storage () . fetch_or_default (& entry , block_hash) . await } else { Err (:: subxt :: MetadataError :: IncompatibleMetadata . into ()) } } # [doc = " All known proposals."] # [doc = " The key is the hash of the call and the deposit ID, to ensure it's"] # [doc = " unique."] pub async fn votes (& self , _0 : & :: core :: primitive :: u64 , _1 : & (:: core :: primitive :: u64 , runtime_types :: egg_standalone_runtime :: Call ,) , block_hash : :: core :: option :: Option < T :: Hash > ,) -> :: core :: result :: Result < :: core :: option :: Option < runtime_types :: pallet_bridge :: types :: ProposalVotes < :: subxt :: sp_core :: crypto :: AccountId32 , :: core :: primitive :: u32 > > , :: subxt :: BasicError > { if self . client . metadata () . storage_hash :: < Votes > () ? == [154u8 , 63u8 , 54u8 , 240u8 , 244u8 , 177u8 , 134u8 , 8u8 , 53u8 , 170u8 , 97u8 , 165u8 , 150u8 , 21u8 , 242u8 , 251u8 , 210u8 , 252u8 , 67u8 , 94u8 , 126u8 , 34u8 , 157u8 , 67u8 , 166u8 , 77u8 , 107u8 , 119u8 , 16u8 , 64u8 , 97u8 , 107u8 ,] { let entry = Votes (_0 , _1) ; self . client . storage () . fetch (& entry , block_hash) . await } else { Err (:: subxt :: MetadataError :: IncompatibleMetadata . into ()) } } # [doc = " All known proposals."] # [doc = " The key is the hash of the call and the deposit ID, to ensure it's"] # [doc = " unique."] pub async fn votes_iter (& self , block_hash : :: core :: option :: Option < T :: Hash > ,) -> :: core :: result :: Result < :: subxt :: KeyIter < 'a , T , Votes < 'a > > , :: subxt :: BasicError > { if self . client . metadata () . storage_hash :: < Votes > () ? == [154u8 , 63u8 , 54u8 , 240u8 , 244u8 , 177u8 , 134u8 , 8u8 , 53u8 , 170u8 , 97u8 , 165u8 , 150u8 , 21u8 , 242u8 , 251u8 , 210u8 , 252u8 , 67u8 , 94u8 , 126u8 , 34u8 , 157u8 , 67u8 , 166u8 , 77u8 , 107u8 , 119u8 , 16u8 , 64u8 , 97u8 , 107u8 ,] { self . client . storage () . iter (block_hash) . await } else { Err (:: subxt :: MetadataError :: IncompatibleMetadata . into ()) } } # [doc = " Utilized by the bridge software to map resource IDs to actual methods"] pub async fn resources (& self , _0 : & [:: core :: primitive :: u8 ; 32usize] , block_hash : :: core :: option :: Option < T :: Hash > ,) -> :: core :: result :: Result < :: core :: option :: Option < :: std :: vec :: Vec < :: core :: primitive :: u8 > > , :: subxt :: BasicError > { if self . client . metadata () . storage_hash :: < Resources > () ? == [143u8 , 101u8 , 64u8 , 185u8 , 7u8 , 45u8 , 158u8 , 77u8 , 193u8 , 0u8 , 255u8 , 148u8 , 2u8 , 142u8 , 226u8 , 49u8 , 219u8 , 196u8 , 211u8 , 67u8 , 75u8 , 207u8 , 43u8 , 90u8 , 55u8 , 100u8 , 183u8 , 144u8 , 169u8 , 113u8 , 123u8 , 202u8 ,] { let entry = Resources (_0) ; self . client . storage () . fetch (& entry , block_hash) . await } else { Err (:: subxt :: MetadataError :: IncompatibleMetadata . into ()) } } # [doc = " Utilized by the bridge software to map resource IDs to actual methods"] pub async fn resources_iter (& self , block_hash : :: core :: option :: Option < T :: Hash > ,) -> :: core :: result :: Result < :: subxt :: KeyIter < 'a , T , Resources < 'a > > , :: subxt :: BasicError > { if self . client . metadata () . storage_hash :: < Resources > () ? == [143u8 , 101u8 , 64u8 , 185u8 , 7u8 , 45u8 , 158u8 , 77u8 , 193u8 , 0u8 , 255u8 , 148u8 , 2u8 , 142u8 , 226u8 , 49u8 , 219u8 , 196u8 , 211u8 , 67u8 , 75u8 , 207u8 , 43u8 , 90u8 , 55u8 , 100u8 , 183u8 , 144u8 , 169u8 , 113u8 , 123u8 , 202u8 ,] { self . client . storage () . iter (block_hash) . await } else { Err (:: subxt :: MetadataError :: IncompatibleMetadata . into ()) } } } } pub mod constants { use super :: runtime_types ; pub struct ConstantsApi < 'a , T : :: subxt :: Config > { client : & 'a :: subxt :: Client < T > , } impl < 'a , T : :: subxt :: Config > ConstantsApi < 'a , T > { pub fn new (client : & 'a :: subxt :: Client < T >) -> Self { Self { client } } # [doc = " The identifier for this chain."] # [doc = " This must be unique and must not collide with existing IDs within a"] # [doc = " set of bridged chains."] pub fn chain_identifier (& self) -> :: core :: result :: Result < :: core :: primitive :: u64 , :: subxt :: BasicError > { if self . client . metadata () . constant_hash ("Bridge" , "ChainIdentifier") ? == [64u8 , 119u8 , 115u8 , 96u8 , 239u8 , 19u8 , 100u8 , 82u8 , 69u8 , 155u8 , 95u8 , 49u8 , 160u8 , 144u8 , 56u8 , 190u8 , 6u8 , 28u8 , 33u8 , 186u8 , 44u8 , 100u8 , 181u8 , 251u8 , 153u8 , 5u8 , 76u8 , 55u8 , 50u8 , 89u8 , 81u8 , 0u8 ,] { let pallet = self . client . metadata () . pallet ("Bridge") ? ; let constant = pallet . constant ("ChainIdentifier") ? ; let value = :: subxt :: codec :: Decode :: decode (& mut & constant . value [..]) ? ; Ok (value) } else { Err (:: subxt :: MetadataError :: IncompatibleMetadata . into ()) } } # [doc = " The chain type for this chain."] # [doc = " This is either a standalone Substrate chain, relay chain, or parachain"] pub fn chain_type (& self) -> :: core :: result :: Result < [:: core :: primitive :: u8 ; 2usize] , :: subxt :: BasicError > { if self . client . metadata () . constant_hash ("Bridge" , "ChainType") ? == [63u8 , 194u8 , 199u8 , 163u8 , 106u8 , 87u8 , 76u8 , 171u8 , 237u8 , 240u8 , 200u8 , 1u8 , 224u8 , 207u8 , 104u8 , 144u8 , 174u8 , 60u8 , 82u8 , 99u8 , 113u8 , 153u8 , 220u8 , 75u8 , 154u8 , 72u8 , 151u8 , 213u8 , 38u8 , 50u8 , 170u8 , 129u8 ,] { let pallet = self . client . metadata () . pallet ("Bridge") ? ; let constant = pallet . constant ("ChainType") ? ; let value = :: subxt :: codec :: Decode :: decode (& mut & constant . value [..]) ? ; Ok (value) } else { Err (:: subxt :: MetadataError :: IncompatibleMetadata . into ()) } } pub fn proposal_lifetime (& self) -> :: core :: result :: Result < :: core :: primitive :: u32 , :: subxt :: BasicError > { if self . client . metadata () . constant_hash ("Bridge" , "ProposalLifetime") ? == [32u8 , 65u8 , 139u8 , 255u8 , 16u8 , 174u8 , 54u8 , 144u8 , 194u8 , 248u8 , 219u8 , 78u8 , 66u8 , 165u8 , 249u8 , 89u8 , 210u8 , 40u8 , 194u8 , 180u8 , 174u8 , 145u8 , 20u8 , 152u8 , 46u8 , 235u8 , 255u8 , 149u8 , 46u8 , 4u8 , 174u8 , 65u8 ,] { let pallet = self . client . metadata () . pallet ("Bridge") ? ; let constant = pallet . constant ("ProposalLifetime") ? ; let value = :: subxt :: codec :: Decode :: decode (& mut & constant . value [..]) ? ; Ok (value) } else { Err (:: subxt :: MetadataError :: IncompatibleMetadata . into ()) } } pub fn bridge_account_id (& self) -> :: core :: result :: Result < runtime_types :: frame_support :: PalletId , :: subxt :: BasicError > { if self . client . metadata () . constant_hash ("Bridge" , "BridgeAccountId") ? == [235u8 , 164u8 , 124u8 , 149u8 , 101u8 , 22u8 , 120u8 , 2u8 , 210u8 , 204u8 , 38u8 , 10u8 , 149u8 , 152u8 , 78u8 , 191u8 , 165u8 , 55u8 , 233u8 , 43u8 , 156u8 , 67u8 , 79u8 , 54u8 , 198u8 , 252u8 , 246u8 , 144u8 , 35u8 , 39u8 , 79u8 , 243u8 ,] { let pallet = self . client . metadata () . pallet ("Bridge") ? ; let constant = pallet . constant ("BridgeAccountId") ? ; let value = :: subxt :: codec :: Decode :: decode (& mut & constant . value [..]) ? ; Ok (value) } else { Err (:: subxt :: MetadataError :: IncompatibleMetadata . into ()) } } } } } pub mod v_anchor_bn254 { use super :: root_mod ; use super :: runtime_types ; pub mod calls { use super :: root_mod ; use super :: runtime_types ; type DispatchError = runtime_types :: sp_runtime :: DispatchError ; # [derive (:: subxt :: codec :: Decode , :: subxt :: codec :: Encode , Clone , Debug , Eq , PartialEq)] pub struct Create { pub max_edges : :: core :: primitive :: u32 , pub depth : :: core :: primitive :: u8 , pub asset : :: core :: primitive :: u32 , } impl :: subxt :: Call for Create { const PALLET : & 'static str = "VAnchorBn254" ; const FUNCTION : & 'static str = "create" ; } # [derive (:: subxt :: codec :: Decode , :: subxt :: codec :: Encode , Clone , Debug , Eq , PartialEq)] pub struct Transact { pub id : :: core :: primitive :: u32 , pub proof_data : runtime_types :: webb_primitives :: types :: vanchor :: ProofData < runtime_types :: egg_standalone_runtime :: protocol_substrate_config :: Element > , pub ext_data : runtime_types :: webb_primitives :: types :: vanchor :: ExtData < :: subxt :: sp_core :: crypto :: AccountId32 , :: core :: primitive :: i128 , :: core :: primitive :: u128 > , } impl :: subxt :: Call for Transact { const PALLET : & 'static str = "VAnchorBn254" ; const FUNCTION : & 'static str = "transact" ; } # [derive (:: subxt :: codec :: CompactAs , :: subxt :: codec :: Decode , :: subxt :: codec :: Encode , Clone , Debug , Eq , PartialEq)] pub struct SetMaxDepositAmount { pub max_deposit_amount : :: core :: primitive :: u128 , } impl :: subxt :: Call for SetMaxDepositAmount { const PALLET : & 'static str = "VAnchorBn254" ; const FUNCTION : & 'static str = "set_max_deposit_amount" ; } # [derive (:: subxt :: codec :: CompactAs , :: subxt :: codec :: Decode , :: subxt :: codec :: Encode , Clone , Debug , Eq , PartialEq)] pub struct SetMinWithdrawAmount { pub min_withdraw_amount : :: core :: primitive :: u128 , } impl :: subxt :: Call for SetMinWithdrawAmount { const PALLET : & 'static str = "VAnchorBn254" ; const FUNCTION : & 'static str = "set_min_withdraw_amount" ; } pub struct TransactionApi < 'a , T : :: subxt :: Config , X > { client : & 'a :: subxt :: Client < T > , marker : :: core :: marker :: PhantomData < X > , } impl < 'a , T , X > TransactionApi < 'a , T , X > where T : :: subxt :: Config , X : :: subxt :: extrinsic :: ExtrinsicParams < T > , { pub fn new (client : & 'a :: subxt :: Client < T >) -> Self { Self { client , marker : :: core :: marker :: PhantomData } } pub fn create (& self , max_edges : :: core :: primitive :: u32 , depth : :: core :: primitive :: u8 , asset : :: core :: primitive :: u32 ,) -> Result < :: subxt :: SubmittableExtrinsic < 'a , T , X , Create , DispatchError , root_mod :: Event > , :: subxt :: BasicError > { if self . client . metadata () . call_hash :: < Create > () ? == [117u8 , 9u8 , 138u8 , 62u8 , 165u8 , 18u8 , 127u8 , 8u8 , 31u8 , 227u8 , 150u8 , 23u8 , 164u8 , 231u8 , 21u8 , 173u8 , 233u8 , 13u8 , 105u8 , 56u8 , 252u8 , 175u8 , 168u8 , 121u8 , 5u8 , 224u8 , 120u8 , 149u8 , 51u8 , 242u8 , 254u8 , 127u8 ,] { let call = Create { max_edges , depth , asset , } ; Ok (:: subxt :: SubmittableExtrinsic :: new (self . client , call)) } else { Err (:: subxt :: MetadataError :: IncompatibleMetadata . into ()) } } pub fn transact (& self , id : :: core :: primitive :: u32 , proof_data : runtime_types :: webb_primitives :: types :: vanchor :: ProofData < runtime_types :: egg_standalone_runtime :: protocol_substrate_config :: Element > , ext_data : runtime_types :: webb_primitives :: types :: vanchor :: ExtData < :: subxt :: sp_core :: crypto :: AccountId32 , :: core :: primitive :: i128 , :: core :: primitive :: u128 > ,) -> Result < :: subxt :: SubmittableExtrinsic < 'a , T , X , Transact , DispatchError , root_mod :: Event > , :: subxt :: BasicError > { if self . client . metadata () . call_hash :: < Transact > () ? == [235u8 , 0u8 , 65u8 , 197u8 , 213u8 , 14u8 , 210u8 , 236u8 , 28u8 , 1u8 , 223u8 , 205u8 , 37u8 , 139u8 , 62u8 , 30u8 , 168u8 , 146u8 , 244u8 , 52u8 , 47u8 , 251u8 , 155u8 , 38u8 , 214u8 , 51u8 , 26u8 , 222u8 , 100u8 , 134u8 , 102u8 , 232u8 ,] { let call = Transact { id , proof_data , ext_data , } ; Ok (:: subxt :: SubmittableExtrinsic :: new (self . client , call)) } else { Err (:: subxt :: MetadataError :: IncompatibleMetadata . into ()) } } pub fn set_max_deposit_amount (& self , max_deposit_amount : :: core :: primitive :: u128 ,) -> Result < :: subxt :: SubmittableExtrinsic < 'a , T , X , SetMaxDepositAmount , DispatchError , root_mod :: Event > , :: subxt :: BasicError > { if self . client . metadata () . call_hash :: < SetMaxDepositAmount > () ? == [38u8 , 76u8 , 104u8 , 50u8 , 252u8 , 96u8 , 93u8 , 167u8 , 67u8 , 75u8 , 164u8 , 4u8 , 100u8 , 210u8 , 41u8 , 181u8 , 67u8 , 154u8 , 220u8 , 60u8 , 146u8 , 230u8 , 216u8 , 204u8 , 119u8 , 28u8 , 122u8 , 89u8 , 59u8 , 108u8 , 176u8 , 165u8 ,] { let call = SetMaxDepositAmount { max_deposit_amount , } ; Ok (:: subxt :: SubmittableExtrinsic :: new (self . client , call)) } else { Err (:: subxt :: MetadataError :: IncompatibleMetadata . into ()) } } pub fn set_min_withdraw_amount (& self , min_withdraw_amount : :: core :: primitive :: u128 ,) -> Result < :: subxt :: SubmittableExtrinsic < 'a , T , X , SetMinWithdrawAmount , DispatchError , root_mod :: Event > , :: subxt :: BasicError > { if self . client . metadata () . call_hash :: < SetMinWithdrawAmount > () ? == [92u8 , 84u8 , 102u8 , 113u8 , 235u8 , 27u8 , 38u8 , 46u8 , 238u8 , 27u8 , 222u8 , 192u8 , 6u8 , 33u8 , 123u8 , 177u8 , 210u8 , 247u8 , 196u8 , 212u8 , 250u8 , 222u8 , 47u8 , 4u8 , 83u8 , 23u8 , 194u8 , 66u8 , 28u8 , 111u8 , 116u8 , 122u8 ,] { let call = SetMinWithdrawAmount { min_withdraw_amount , } ; Ok (:: subxt :: SubmittableExtrinsic :: new (self . client , call)) } else { Err (:: subxt :: MetadataError :: IncompatibleMetadata . into ()) } } } } pub type Event = runtime_types :: pallet_vanchor :: pallet :: Event ; pub mod events { use super :: runtime_types ; # [derive (:: subxt :: codec :: CompactAs , :: subxt :: codec :: Decode , :: subxt :: codec :: Encode , Clone , Debug , Eq , PartialEq)] # [doc = "New tree created"] pub struct VAnchorCreation { pub tree_id : :: core :: primitive :: u32 , } impl :: subxt :: Event for VAnchorCreation { const PALLET : & 'static str = "VAnchorBn254" ; const EVENT : & 'static str = "VAnchorCreation" ; } # [derive (:: subxt :: codec :: Decode , :: subxt :: codec :: Encode , Clone , Debug , Eq , PartialEq)] # [doc = "Transaction has been made"] pub struct Transaction { pub transactor : :: subxt :: sp_core :: crypto :: AccountId32 , pub tree_id : :: core :: primitive :: u32 , pub leafs : :: std :: vec :: Vec < runtime_types :: egg_standalone_runtime :: protocol_substrate_config :: Element > , pub amount : :: core :: primitive :: i128 , } impl :: subxt :: Event for Transaction { const PALLET : & 'static str = "VAnchorBn254" ; const EVENT : & 'static str = "Transaction" ; } # [derive (:: subxt :: codec :: Decode , :: subxt :: codec :: Encode , Clone , Debug , Eq , PartialEq)] # [doc = "Deposit hook has executed successfully"] pub struct Deposit { pub depositor : :: subxt :: sp_core :: crypto :: AccountId32 , pub tree_id : :: core :: primitive :: u32 , pub leaf : runtime_types :: egg_standalone_runtime :: protocol_substrate_config :: Element , } impl :: subxt :: Event for Deposit { const PALLET : & 'static str = "VAnchorBn254" ; const EVENT : & 'static str = "Deposit" ; } # [derive (:: subxt :: codec :: CompactAs , :: subxt :: codec :: Decode , :: subxt :: codec :: Encode , Clone , Debug , Eq , PartialEq)] pub struct MaxDepositAmountChanged { pub max_deposit_amount : :: core :: primitive :: u128 , } impl :: subxt :: Event for MaxDepositAmountChanged { const PALLET : & 'static str = "VAnchorBn254" ; const EVENT : & 'static str = "MaxDepositAmountChanged" ; } # [derive (:: subxt :: codec :: CompactAs , :: subxt :: codec :: Decode , :: subxt :: codec :: Encode , Clone , Debug , Eq , PartialEq)] pub struct MinWithdrawAmountChanged { pub min_withdraw_amount : :: core :: primitive :: u128 , } impl :: subxt :: Event for MinWithdrawAmountChanged { const PALLET : & 'static str = "VAnchorBn254" ; const EVENT : & 'static str = "MinWithdrawAmountChanged" ; } } pub mod storage { use super :: runtime_types ; pub struct MaxDepositAmount ; impl :: subxt :: StorageEntry for MaxDepositAmount { const PALLET : & 'static str = "VAnchorBn254" ; const STORAGE : & 'static str = "MaxDepositAmount" ; type Value = :: core :: primitive :: u128 ; fn key (& self) -> :: subxt :: StorageEntryKey { :: subxt :: StorageEntryKey :: Plain } } pub struct MinWithdrawAmount ; impl :: subxt :: StorageEntry for MinWithdrawAmount { const PALLET : & 'static str = "VAnchorBn254" ; const STORAGE : & 'static str = "MinWithdrawAmount" ; type Value = :: core :: primitive :: u128 ; fn key (& self) -> :: subxt :: StorageEntryKey { :: subxt :: StorageEntryKey :: Plain } } pub struct VAnchors < 'a > (pub & 'a :: core :: primitive :: u32) ; impl :: subxt :: StorageEntry for VAnchors < '_ > { const PALLET : & 'static str = "VAnchorBn254" ; const STORAGE : & 'static str = "VAnchors" ; type Value = runtime_types :: webb_primitives :: types :: vanchor :: VAnchorMetadata < :: subxt :: sp_core :: crypto :: AccountId32 , :: core :: primitive :: u32 > ; fn key (& self) -> :: subxt :: StorageEntryKey { :: subxt :: StorageEntryKey :: Map (vec ! [:: subxt :: StorageMapKey :: new (& self . 0 , :: subxt :: StorageHasher :: Blake2_128Concat)]) } } pub struct NullifierHashes < 'a > (pub & 'a :: core :: primitive :: u32 , pub & 'a runtime_types :: egg_standalone_runtime :: protocol_substrate_config :: Element) ; impl :: subxt :: StorageEntry for NullifierHashes < '_ > { const PALLET : & 'static str = "VAnchorBn254" ; const STORAGE : & 'static str = "NullifierHashes" ; type Value = :: core :: primitive :: bool ; fn key (& self) -> :: subxt :: StorageEntryKey { :: subxt :: StorageEntryKey :: Map (vec ! [:: subxt :: StorageMapKey :: new (& self . 0 , :: subxt :: StorageHasher :: Blake2_128Concat) , :: subxt :: StorageMapKey :: new (& self . 1 , :: subxt :: StorageHasher :: Blake2_128Concat)]) } } pub struct StorageApi < 'a , T : :: subxt :: Config > { client : & 'a :: subxt :: Client < T > , } impl < 'a , T : :: subxt :: Config > StorageApi < 'a , T > { pub fn new (client : & 'a :: subxt :: Client < T >) -> Self { Self { client } } pub async fn max_deposit_amount (& self , block_hash : :: core :: option :: Option < T :: Hash > ,) -> :: core :: result :: Result < :: core :: primitive :: u128 , :: subxt :: BasicError > { if self . client . metadata () . storage_hash :: < MaxDepositAmount > () ? == [103u8 , 143u8 , 218u8 , 145u8 , 13u8 , 227u8 , 200u8 , 72u8 , 147u8 , 151u8 , 21u8 , 63u8 , 38u8 , 101u8 , 23u8 , 45u8 , 67u8 , 250u8 , 184u8 , 206u8 , 10u8 , 184u8 , 98u8 , 179u8 , 120u8 , 62u8 , 92u8 , 199u8 , 30u8 , 255u8 , 26u8 , 84u8 ,] { let entry = MaxDepositAmount ; self . client . storage () . fetch_or_default (& entry , block_hash) . await } else { Err (:: subxt :: MetadataError :: IncompatibleMetadata . into ()) } } pub async fn min_withdraw_amount (& self , block_hash : :: core :: option :: Option < T :: Hash > ,) -> :: core :: result :: Result < :: core :: primitive :: u128 , :: subxt :: BasicError > { if self . client . metadata () . storage_hash :: < MinWithdrawAmount > () ? == [217u8 , 143u8 , 57u8 , 19u8 , 253u8 , 60u8 , 103u8 , 182u8 , 70u8 , 55u8 , 27u8 , 66u8 , 117u8 , 86u8 , 196u8 , 163u8 , 41u8 , 18u8 , 117u8 , 125u8 , 232u8 , 109u8 , 197u8 , 177u8 , 54u8 , 157u8 , 165u8 , 251u8 , 16u8 , 49u8 , 113u8 , 240u8 ,] { let entry = MinWithdrawAmount ; self . client . storage () . fetch_or_default (& entry , block_hash) . await } else { Err (:: subxt :: MetadataError :: IncompatibleMetadata . into ()) } } # [doc = " The map of trees to their anchor metadata"] pub async fn v_anchors (& self , _0 : & :: core :: primitive :: u32 , block_hash : :: core :: option :: Option < T :: Hash > ,) -> :: core :: result :: Result < :: core :: option :: Option < runtime_types :: webb_primitives :: types :: vanchor :: VAnchorMetadata < :: subxt :: sp_core :: crypto :: AccountId32 , :: core :: primitive :: u32 > > , :: subxt :: BasicError > { if self . client . metadata () . storage_hash :: < VAnchors > () ? == [228u8 , 116u8 , 71u8 , 132u8 , 168u8 , 25u8 , 56u8 , 84u8 , 54u8 , 173u8 , 176u8 , 49u8 , 126u8 , 0u8 , 188u8 , 158u8 , 240u8 , 186u8 , 66u8 , 225u8 , 234u8 , 152u8 , 43u8 , 197u8 , 38u8 , 117u8 , 137u8 , 178u8 , 236u8 , 92u8 , 80u8 , 210u8 ,] { let entry = VAnchors (_0) ; self . client . storage () . fetch (& entry , block_hash) . await } else { Err (:: subxt :: MetadataError :: IncompatibleMetadata . into ()) } } # [doc = " The map of trees to their anchor metadata"] pub async fn v_anchors_iter (& self , block_hash : :: core :: option :: Option < T :: Hash > ,) -> :: core :: result :: Result < :: subxt :: KeyIter < 'a , T , VAnchors < 'a > > , :: subxt :: BasicError > { if self . client . metadata () . storage_hash :: < VAnchors > () ? == [228u8 , 116u8 , 71u8 , 132u8 , 168u8 , 25u8 , 56u8 , 84u8 , 54u8 , 173u8 , 176u8 , 49u8 , 126u8 , 0u8 , 188u8 , 158u8 , 240u8 , 186u8 , 66u8 , 225u8 , 234u8 , 152u8 , 43u8 , 197u8 , 38u8 , 117u8 , 137u8 , 178u8 , 236u8 , 92u8 , 80u8 , 210u8 ,] { self . client . storage () . iter (block_hash) . await } else { Err (:: subxt :: MetadataError :: IncompatibleMetadata . into ()) } } # [doc = " The map of trees to their spent nullifier hashes"] pub async fn nullifier_hashes (& self , _0 : & :: core :: primitive :: u32 , _1 : & runtime_types :: egg_standalone_runtime :: protocol_substrate_config :: Element , block_hash : :: core :: option :: Option < T :: Hash > ,) -> :: core :: result :: Result < :: core :: primitive :: bool , :: subxt :: BasicError > { if self . client . metadata () . storage_hash :: < NullifierHashes > () ? == [26u8 , 245u8 , 38u8 , 181u8 , 82u8 , 104u8 , 95u8 , 163u8 , 44u8 , 122u8 , 225u8 , 212u8 , 85u8 , 103u8 , 242u8 , 46u8 , 111u8 , 97u8 , 196u8 , 211u8 , 169u8 , 130u8 , 189u8 , 33u8 , 56u8 , 70u8 , 110u8 , 141u8 , 185u8 , 101u8 , 248u8 , 56u8 ,] { let entry = NullifierHashes (_0 , _1) ; self . client . storage () . fetch_or_default (& entry , block_hash) . await } else { Err (:: subxt :: MetadataError :: IncompatibleMetadata . into ()) } } # [doc = " The map of trees to their spent nullifier hashes"] pub async fn nullifier_hashes_iter (& self , block_hash : :: core :: option :: Option < T :: Hash > ,) -> :: core :: result :: Result < :: subxt :: KeyIter < 'a , T , NullifierHashes < 'a > > , :: subxt :: BasicError > { if self . client . metadata () . storage_hash :: < NullifierHashes > () ? == [26u8 , 245u8 , 38u8 , 181u8 , 82u8 , 104u8 , 95u8 , 163u8 , 44u8 , 122u8 , 225u8 , 212u8 , 85u8 , 103u8 , 242u8 , 46u8 , 111u8 , 97u8 , 196u8 , 211u8 , 169u8 , 130u8 , 189u8 , 33u8 , 56u8 , 70u8 , 110u8 , 141u8 , 185u8 , 101u8 , 248u8 , 56u8 ,] { self . client . storage () . iter (block_hash) . await } else { Err (:: subxt :: MetadataError :: IncompatibleMetadata . into ()) } } } } pub mod constants { use super :: runtime_types ; pub struct ConstantsApi < 'a , T : :: subxt :: Config > { client : & 'a :: subxt :: Client < T > , } impl < 'a , T : :: subxt :: Config > ConstantsApi < 'a , T > { pub fn new (client : & 'a :: subxt :: Client < T >) -> Self { Self { client } } pub fn pallet_id (& self) -> :: core :: result :: Result < runtime_types :: frame_support :: PalletId , :: subxt :: BasicError > { if self . client . metadata () . constant_hash ("VAnchorBn254" , "PalletId") ? == [238u8 , 30u8 , 50u8 , 69u8 , 156u8 , 201u8 , 246u8 , 133u8 , 219u8 , 2u8 , 225u8 , 72u8 , 137u8 , 129u8 , 66u8 , 224u8 , 172u8 , 213u8 , 197u8 , 90u8 , 123u8 , 37u8 , 16u8 , 43u8 , 161u8 , 24u8 , 78u8 , 9u8 , 231u8 , 165u8 , 222u8 , 46u8 ,] { let pallet = self . client . metadata () . pallet ("VAnchorBn254") ? ; let constant = pallet . constant ("PalletId") ? ; let value = :: subxt :: codec :: Decode :: decode (& mut & constant . value [..]) ? ; Ok (value) } else { Err (:: subxt :: MetadataError :: IncompatibleMetadata . into ()) } } # [doc = " Native currency id"] pub fn native_currency_id (& self) -> :: core :: result :: Result < :: core :: primitive :: u32 , :: subxt :: BasicError > { if self . client . metadata () . constant_hash ("VAnchorBn254" , "NativeCurrencyId") ? == [101u8 , 251u8 , 209u8 , 1u8 , 140u8 , 211u8 , 189u8 , 23u8 , 78u8 , 144u8 , 68u8 , 58u8 , 160u8 , 52u8 , 207u8 , 11u8 , 246u8 , 174u8 , 219u8 , 39u8 , 180u8 , 243u8 , 224u8 , 166u8 , 219u8 , 113u8 , 20u8 , 106u8 , 196u8 , 121u8 , 193u8 , 137u8 ,] { let pallet = self . client . metadata () . pallet ("VAnchorBn254") ? ; let constant = pallet . constant ("NativeCurrencyId") ? ; let value = :: subxt :: codec :: Decode :: decode (& mut & constant . value [..]) ? ; Ok (value) } else { Err (:: subxt :: MetadataError :: IncompatibleMetadata . into ()) } } } } } pub mod v_anchor_handler_bn254 { use super :: root_mod ; use super :: runtime_types ; pub mod calls { use super :: root_mod ; use super :: runtime_types ; type DispatchError = runtime_types :: sp_runtime :: DispatchError ; # [derive (:: subxt :: codec :: Decode , :: subxt :: codec :: Encode , Clone , Debug , Eq , PartialEq)] pub struct ExecuteVanchorCreateProposal { pub src_chain_id : :: core :: primitive :: u64 , pub r_id : [:: core :: primitive :: u8 ; 32usize] , pub max_edges : :: core :: primitive :: u32 , pub tree_depth : :: core :: primitive :: u8 , pub asset : :: core :: primitive :: u32 , } impl :: subxt :: Call for ExecuteVanchorCreateProposal { const PALLET : & 'static str = "VAnchorHandlerBn254" ; const FUNCTION : & 'static str = "execute_vanchor_create_proposal" ; } # [derive (:: subxt :: codec :: Decode , :: subxt :: codec :: Encode , Clone , Debug , Eq , PartialEq)] pub struct ExecuteVanchorUpdateProposal { pub r_id : [:: core :: primitive :: u8 ; 32usize] , pub vanchor_metadata : runtime_types :: pallet_linkable_tree :: types :: EdgeMetadata < :: core :: primitive :: u64 , runtime_types :: egg_standalone_runtime :: protocol_substrate_config :: Element , :: core :: primitive :: u32 > , } impl :: subxt :: Call for ExecuteVanchorUpdateProposal { const PALLET : & 'static str = "VAnchorHandlerBn254" ; const FUNCTION : & 'static str = "execute_vanchor_update_proposal" ; } # [derive (:: subxt :: codec :: Decode , :: subxt :: codec :: Encode , Clone , Debug , Eq , PartialEq)] pub struct ExecuteSetResourceProposal { pub r_id : [:: core :: primitive :: u8 ; 32usize] , pub target : runtime_types :: webb_proposals :: header :: TargetSystem , } impl :: subxt :: Call for ExecuteSetResourceProposal { const PALLET : & 'static str = "VAnchorHandlerBn254" ; const FUNCTION : & 'static str = "execute_set_resource_proposal" ; } pub struct TransactionApi < 'a , T : :: subxt :: Config , X > { client : & 'a :: subxt :: Client < T > , marker : :: core :: marker :: PhantomData < X > , } impl < 'a , T , X > TransactionApi < 'a , T , X > where T : :: subxt :: Config , X : :: subxt :: extrinsic :: ExtrinsicParams < T > , { pub fn new (client : & 'a :: subxt :: Client < T >) -> Self { Self { client , marker : :: core :: marker :: PhantomData } } # [doc = "This will be called by bridge when proposal to create a"] # [doc = "vanchor has been successfully voted on."] pub fn execute_vanchor_create_proposal (& self , src_chain_id : :: core :: primitive :: u64 , r_id : [:: core :: primitive :: u8 ; 32usize] , max_edges : :: core :: primitive :: u32 , tree_depth : :: core :: primitive :: u8 , asset : :: core :: primitive :: u32 ,) -> Result < :: subxt :: SubmittableExtrinsic < 'a , T , X , ExecuteVanchorCreateProposal , DispatchError , root_mod :: Event > , :: subxt :: BasicError > { if self . client . metadata () . call_hash :: < ExecuteVanchorCreateProposal > () ? == [34u8 , 169u8 , 142u8 , 97u8 , 93u8 , 97u8 , 25u8 , 19u8 , 50u8 , 194u8 , 103u8 , 34u8 , 240u8 , 254u8 , 146u8 , 69u8 , 25u8 , 3u8 , 241u8 , 11u8 , 68u8 , 115u8 , 144u8 , 219u8 , 28u8 , 0u8 , 158u8 , 237u8 , 107u8 , 177u8 , 99u8 , 139u8 ,] { let call = ExecuteVanchorCreateProposal { src_chain_id , r_id , max_edges , tree_depth , asset , } ; Ok (:: subxt :: SubmittableExtrinsic :: new (self . client , call)) } else { Err (:: subxt :: MetadataError :: IncompatibleMetadata . into ()) } } # [doc = "This will be called by bridge when proposal to add/update edge of a"] # [doc = "vanchor has been successfully voted on."] pub fn execute_vanchor_update_proposal (& self , r_id : [:: core :: primitive :: u8 ; 32usize] , vanchor_metadata : runtime_types :: pallet_linkable_tree :: types :: EdgeMetadata < :: core :: primitive :: u64 , runtime_types :: egg_standalone_runtime :: protocol_substrate_config :: Element , :: core :: primitive :: u32 > ,) -> Result < :: subxt :: SubmittableExtrinsic < 'a , T , X , ExecuteVanchorUpdateProposal , DispatchError , root_mod :: Event > , :: subxt :: BasicError > { if self . client . metadata () . call_hash :: < ExecuteVanchorUpdateProposal > () ? == [73u8 , 67u8 , 191u8 , 13u8 , 246u8 , 15u8 , 103u8 , 187u8 , 41u8 , 21u8 , 124u8 , 250u8 , 30u8 , 235u8 , 170u8 , 141u8 , 8u8 , 3u8 , 88u8 , 21u8 , 147u8 , 139u8 , 52u8 , 167u8 , 218u8 , 128u8 , 126u8 , 141u8 , 118u8 , 135u8 , 163u8 , 142u8 ,] { let call = ExecuteVanchorUpdateProposal { r_id , vanchor_metadata , } ; Ok (:: subxt :: SubmittableExtrinsic :: new (self . client , call)) } else { Err (:: subxt :: MetadataError :: IncompatibleMetadata . into ()) } } # [doc = "This will by called by bridge when proposal to set new resource for"] # [doc = "handler has been successfully voted on"] pub fn execute_set_resource_proposal (& self , r_id : [:: core :: primitive :: u8 ; 32usize] , target : runtime_types :: webb_proposals :: header :: TargetSystem ,) -> Result < :: subxt :: SubmittableExtrinsic < 'a , T , X , ExecuteSetResourceProposal , DispatchError , root_mod :: Event > , :: subxt :: BasicError > { if self . client . metadata () . call_hash :: < ExecuteSetResourceProposal > () ? == [59u8 , 187u8 , 49u8 , 240u8 , 6u8 , 37u8 , 17u8 , 83u8 , 244u8 , 4u8 , 161u8 , 211u8 , 238u8 , 78u8 , 51u8 , 246u8 , 194u8 , 115u8 , 103u8 , 112u8 , 111u8 , 189u8 , 230u8 , 217u8 , 124u8 , 215u8 , 186u8 , 146u8 , 190u8 , 110u8 , 233u8 , 146u8 ,] { let call = ExecuteSetResourceProposal { r_id , target , } ; Ok (:: subxt :: SubmittableExtrinsic :: new (self . client , call)) } else { Err (:: subxt :: MetadataError :: IncompatibleMetadata . into ()) } } } } pub type Event = runtime_types :: pallet_vanchor_handler :: pallet :: Event ; pub mod events { use super :: runtime_types ; # [derive (:: subxt :: codec :: Decode , :: subxt :: codec :: Encode , Clone , Debug , Eq , PartialEq)] pub struct AnchorCreated ; impl :: subxt :: Event for AnchorCreated { const PALLET : & 'static str = "VAnchorHandlerBn254" ; const EVENT : & 'static str = "AnchorCreated" ; } # [derive (:: subxt :: codec :: Decode , :: subxt :: codec :: Encode , Clone , Debug , Eq , PartialEq)] pub struct AnchorEdgeAdded ; impl :: subxt :: Event for AnchorEdgeAdded { const PALLET : & 'static str = "VAnchorHandlerBn254" ; const EVENT : & 'static str = "AnchorEdgeAdded" ; } # [derive (:: subxt :: codec :: Decode , :: subxt :: codec :: Encode , Clone , Debug , Eq , PartialEq)] pub struct AnchorEdgeUpdated ; impl :: subxt :: Event for AnchorEdgeUpdated { const PALLET : & 'static str = "VAnchorHandlerBn254" ; const EVENT : & 'static str = "AnchorEdgeUpdated" ; } # [derive (:: subxt :: codec :: Decode , :: subxt :: codec :: Encode , Clone , Debug , Eq , PartialEq)] pub struct ResourceAnchored ; impl :: subxt :: Event for ResourceAnchored { const PALLET : & 'static str = "VAnchorHandlerBn254" ; const EVENT : & 'static str = "ResourceAnchored" ; } } pub mod storage { use super :: runtime_types ; pub struct AnchorList < 'a > (pub & 'a [:: core :: primitive :: u8 ; 32usize]) ; impl :: subxt :: StorageEntry for AnchorList < '_ > { const PALLET : & 'static str = "VAnchorHandlerBn254" ; const STORAGE : & 'static str = "AnchorList" ; type Value = :: core :: primitive :: u32 ; fn key (& self) -> :: subxt :: StorageEntryKey { :: subxt :: StorageEntryKey :: Map (vec ! [:: subxt :: StorageMapKey :: new (& self . 0 , :: subxt :: StorageHasher :: Blake2_128Concat)]) } } pub struct UpdateRecords < 'a > (pub & 'a :: core :: primitive :: u64 , pub & 'a :: core :: primitive :: u64) ; impl :: subxt :: StorageEntry for UpdateRecords < '_ > { const PALLET : & 'static str = "VAnchorHandlerBn254" ; const STORAGE : & 'static str = "UpdateRecords" ; type Value = runtime_types :: pallet_vanchor_handler :: types :: UpdateRecord < :: core :: primitive :: u32 , [:: core :: primitive :: u8 ; 32usize] , :: core :: primitive :: u64 , runtime_types :: egg_standalone_runtime :: protocol_substrate_config :: Element , :: core :: primitive :: u32 > ; fn key (& self) -> :: subxt :: StorageEntryKey { :: subxt :: StorageEntryKey :: Map (vec ! [:: subxt :: StorageMapKey :: new (& self . 0 , :: subxt :: StorageHasher :: Blake2_128Concat) , :: subxt :: StorageMapKey :: new (& self . 1 , :: subxt :: StorageHasher :: Blake2_128Concat)]) } } pub struct Counts < 'a > (pub & 'a :: core :: primitive :: u64) ; impl :: subxt :: StorageEntry for Counts < '_ > { const PALLET : & 'static str = "VAnchorHandlerBn254" ; const STORAGE : & 'static str = "Counts" ; type Value = :: core :: primitive :: u64 ; fn key (& self) -> :: subxt :: StorageEntryKey { :: subxt :: StorageEntryKey :: Map (vec ! [:: subxt :: StorageMapKey :: new (& self . 0 , :: subxt :: StorageHasher :: Blake2_128Concat)]) } } pub struct StorageApi < 'a , T : :: subxt :: Config > { client : & 'a :: subxt :: Client < T > , } impl < 'a , T : :: subxt :: Config > StorageApi < 'a , T > { pub fn new (client : & 'a :: subxt :: Client < T >) -> Self { Self { client } } # [doc = " The map of trees to their anchor metadata"] pub async fn anchor_list (& self , _0 : & [:: core :: primitive :: u8 ; 32usize] , block_hash : :: core :: option :: Option < T :: Hash > ,) -> :: core :: result :: Result < :: core :: primitive :: u32 , :: subxt :: BasicError > { if self . client . metadata () . storage_hash :: < AnchorList > () ? == [119u8 , 143u8 , 232u8 , 251u8 , 245u8 , 242u8 , 120u8 , 50u8 , 100u8 , 36u8 , 177u8 , 168u8 , 131u8 , 64u8 , 236u8 , 38u8 , 45u8 , 241u8 , 201u8 , 146u8 , 134u8 , 66u8 , 242u8 , 38u8 , 199u8 , 152u8 , 243u8 , 84u8 , 44u8 , 169u8 , 120u8 , 157u8 ,] { let entry = AnchorList (_0) ; self . client . storage () . fetch_or_default (& entry , block_hash) . await } else { Err (:: subxt :: MetadataError :: IncompatibleMetadata . into ()) } } # [doc = " The map of trees to their anchor metadata"] pub async fn anchor_list_iter (& self , block_hash : :: core :: option :: Option < T :: Hash > ,) -> :: core :: result :: Result < :: subxt :: KeyIter < 'a , T , AnchorList < 'a > > , :: subxt :: BasicError > { if self . client . metadata () . storage_hash :: < AnchorList > () ? == [119u8 , 143u8 , 232u8 , 251u8 , 245u8 , 242u8 , 120u8 , 50u8 , 100u8 , 36u8 , 177u8 , 168u8 , 131u8 , 64u8 , 236u8 , 38u8 , 45u8 , 241u8 , 201u8 , 146u8 , 134u8 , 66u8 , 242u8 , 38u8 , 199u8 , 152u8 , 243u8 , 84u8 , 44u8 , 169u8 , 120u8 , 157u8 ,] { self . client . storage () . iter (block_hash) . await } else { Err (:: subxt :: MetadataError :: IncompatibleMetadata . into ()) } } # [doc = " sourceChainID => nonce => Update Record"] pub async fn update_records (& self , _0 : & :: core :: primitive :: u64 , _1 : & :: core :: primitive :: u64 , block_hash : :: core :: option :: Option < T :: Hash > ,) -> :: core :: result :: Result < runtime_types :: pallet_vanchor_handler :: types :: UpdateRecord < :: core :: primitive :: u32 , [:: core :: primitive :: u8 ; 32usize] , :: core :: primitive :: u64 , runtime_types :: egg_standalone_runtime :: protocol_substrate_config :: Element , :: core :: primitive :: u32 > , :: subxt :: BasicError > { if self . client . metadata () . storage_hash :: < UpdateRecords > () ? == [216u8 , 83u8 , 7u8 , 202u8 , 224u8 , 171u8 , 207u8 , 13u8 , 110u8 , 120u8 , 176u8 , 149u8 , 233u8 , 2u8 , 138u8 , 17u8 , 29u8 , 228u8 , 129u8 , 229u8 , 241u8 , 196u8 , 13u8 , 118u8 , 138u8 , 7u8 , 56u8 , 53u8 , 170u8 , 158u8 , 58u8 , 198u8 ,] { let entry = UpdateRecords (_0 , _1) ; self . client . storage () . fetch_or_default (& entry , block_hash) . await } else { Err (:: subxt :: MetadataError :: IncompatibleMetadata . into ()) } } # [doc = " sourceChainID => nonce => Update Record"] pub async fn update_records_iter (& self , block_hash : :: core :: option :: Option < T :: Hash > ,) -> :: core :: result :: Result < :: subxt :: KeyIter < 'a , T , UpdateRecords < 'a > > , :: subxt :: BasicError > { if self . client . metadata () . storage_hash :: < UpdateRecords > () ? == [216u8 , 83u8 , 7u8 , 202u8 , 224u8 , 171u8 , 207u8 , 13u8 , 110u8 , 120u8 , 176u8 , 149u8 , 233u8 , 2u8 , 138u8 , 17u8 , 29u8 , 228u8 , 129u8 , 229u8 , 241u8 , 196u8 , 13u8 , 118u8 , 138u8 , 7u8 , 56u8 , 53u8 , 170u8 , 158u8 , 58u8 , 198u8 ,] { self . client . storage () . iter (block_hash) . await } else { Err (:: subxt :: MetadataError :: IncompatibleMetadata . into ()) } } # [doc = " The number of updates"] pub async fn counts (& self , _0 : & :: core :: primitive :: u64 , block_hash : :: core :: option :: Option < T :: Hash > ,) -> :: core :: result :: Result < :: core :: primitive :: u64 , :: subxt :: BasicError > { if self . client . metadata () . storage_hash :: < Counts > () ? == [86u8 , 26u8 , 24u8 , 236u8 , 36u8 , 118u8 , 53u8 , 152u8 , 62u8 , 237u8 , 203u8 , 191u8 , 180u8 , 174u8 , 186u8 , 122u8 , 236u8 , 198u8 , 121u8 , 159u8 , 15u8 , 190u8 , 75u8 , 43u8 , 124u8 , 255u8 , 207u8 , 46u8 , 28u8 , 232u8 , 198u8 , 231u8 ,] { let entry = Counts (_0) ; self . client . storage () . fetch_or_default (& entry , block_hash) . await } else { Err (:: subxt :: MetadataError :: IncompatibleMetadata . into ()) } } # [doc = " The number of updates"] pub async fn counts_iter (& self , block_hash : :: core :: option :: Option < T :: Hash > ,) -> :: core :: result :: Result < :: subxt :: KeyIter < 'a , T , Counts < 'a > > , :: subxt :: BasicError > { if self . client . metadata () . storage_hash :: < Counts > () ? == [86u8 , 26u8 , 24u8 , 236u8 , 36u8 , 118u8 , 53u8 , 152u8 , 62u8 , 237u8 , 203u8 , 191u8 , 180u8 , 174u8 , 186u8 , 122u8 , 236u8 , 198u8 , 121u8 , 159u8 , 15u8 , 190u8 , 75u8 , 43u8 , 124u8 , 255u8 , 207u8 , 46u8 , 28u8 , 232u8 , 198u8 , 231u8 ,] { self . client . storage () . iter (block_hash) . await } else { Err (:: subxt :: MetadataError :: IncompatibleMetadata . into ()) } } } } } pub mod runtime_types { use super :: runtime_types ; pub mod dkg_runtime_primitives { use super :: runtime_types ; pub mod crypto { use super :: runtime_types ; # [derive (:: subxt :: codec :: Decode , :: subxt :: codec :: Encode , Clone , Debug , Eq , PartialEq)] pub struct Public (pub runtime_types :: sp_core :: ecdsa :: Public ,) ; } pub mod proposal { use super :: runtime_types ; # [derive (:: subxt :: codec :: Decode , :: subxt :: codec :: Encode , Clone , Debug , Eq , PartialEq)] pub enum DKGPayloadKey { # [codec (index = 0)] EVMProposal (runtime_types :: webb_proposals :: nonce :: Nonce ,) , # [codec (index = 1)] RefreshVote (runtime_types :: webb_proposals :: nonce :: Nonce ,) , # [codec (index = 2)] ProposerSetUpdateProposal (runtime_types :: webb_proposals :: nonce :: Nonce ,) , # [codec (index = 3)] AnchorCreateProposal (runtime_types :: webb_proposals :: nonce :: Nonce ,) , # [codec (index = 4)] AnchorUpdateProposal (runtime_types :: webb_proposals :: nonce :: Nonce ,) , # [codec (index = 5)] TokenAddProposal (runtime_types :: webb_proposals :: nonce :: Nonce ,) , # [codec (index = 6)] TokenRemoveProposal (runtime_types :: webb_proposals :: nonce :: Nonce ,) , # [codec (index = 7)] WrappingFeeUpdateProposal (runtime_types :: webb_proposals :: nonce :: Nonce ,) , # [codec (index = 8)] ResourceIdUpdateProposal (runtime_types :: webb_proposals :: nonce :: Nonce ,) , # [codec (index = 9)] RescueTokensProposal (runtime_types :: webb_proposals :: nonce :: Nonce ,) , # [codec (index = 10)] MaxDepositLimitUpdateProposal (runtime_types :: webb_proposals :: nonce :: Nonce ,) , # [codec (index = 11)] MinWithdrawalLimitUpdateProposal (runtime_types :: webb_proposals :: nonce :: Nonce ,) , # [codec (index = 12)] SetVerifierProposal (runtime_types :: webb_proposals :: nonce :: Nonce ,) , # [codec (index = 13)] SetTreasuryHandlerProposal (runtime_types :: webb_proposals :: nonce :: Nonce ,) , # [codec (index = 14)] FeeRecipientUpdateProposal (runtime_types :: webb_proposals :: nonce :: Nonce ,) , } # [derive (:: subxt :: codec :: Decode , :: subxt :: codec :: Encode , Clone , Debug , Eq , PartialEq)] pub enum Proposal { # [codec (index = 0)] Signed { kind : runtime_types :: dkg_runtime_primitives :: proposal :: ProposalKind , data : :: std :: vec :: Vec < :: core :: primitive :: u8 > , signature : :: std :: vec :: Vec < :: core :: primitive :: u8 > , } , # [codec (index = 1)] Unsigned { kind : runtime_types :: dkg_runtime_primitives :: proposal :: ProposalKind , data : :: std :: vec :: Vec < :: core :: primitive :: u8 > , } , } # [derive (:: subxt :: codec :: Decode , :: subxt :: codec :: Encode , Clone , Debug , Eq , PartialEq)] pub enum ProposalKind { # [codec (index = 0)] Refresh , # [codec (index = 1)] ProposerSetUpdate , # [codec (index = 2)] EVM , # [codec (index = 3)] AnchorCreate , # [codec (index = 4)] AnchorUpdate , # [codec (index = 5)] TokenAdd , # [codec (index = 6)] TokenRemove , # [codec (index = 7)] WrappingFeeUpdate , # [codec (index = 8)] ResourceIdUpdate , # [codec (index = 9)] RescueTokens , # [codec (index = 10)] MaxDepositLimitUpdate , # [codec (index = 11)] MinWithdrawalLimitUpdate , # [codec (index = 12)] SetVerifier , # [codec (index = 13)] SetTreasuryHandler , # [codec (index = 14)] FeeRecipientUpdate , } # [derive (:: subxt :: codec :: Decode , :: subxt :: codec :: Encode , Clone , Debug , Eq , PartialEq)] pub struct RefreshProposalSigned { pub nonce : runtime_types :: webb_proposals :: nonce :: Nonce , pub signature : :: std :: vec :: Vec < :: core :: primitive :: u8 > , } # [derive (:: subxt :: codec :: Decode , :: subxt :: codec :: Encode , Clone , Debug , Eq , PartialEq)] pub struct StoredUnsignedProposal < _0 > { pub proposal : runtime_types :: dkg_runtime_primitives :: proposal :: Proposal , pub timestamp : _0 , } } # [derive (:: subxt :: codec :: Decode , :: subxt :: codec :: Encode , Clone , Debug , Eq , PartialEq)] pub struct AggregatedMisbehaviourReports < _0 > { pub misbehaviour_type : runtime_types :: dkg_runtime_primitives :: MisbehaviourType , pub round_id : :: core :: primitive :: u64 , pub offender : _0 , pub reporters : :: std :: vec :: Vec < _0 > , pub signatures : :: std :: vec :: Vec < :: std :: vec :: Vec < :: core :: primitive :: u8 > > , } # [derive (:: subxt :: codec :: Decode , :: subxt :: codec :: Encode , Clone , Debug , Eq , PartialEq)] pub struct AggregatedPublicKeys { pub keys_and_signatures : :: std :: vec :: Vec < (:: std :: vec :: Vec < :: core :: primitive :: u8 > , :: std :: vec :: Vec < :: core :: primitive :: u8 > ,) > , } # [derive (:: subxt :: codec :: Decode , :: subxt :: codec :: Encode , Clone , Debug , Eq , PartialEq)] pub enum MisbehaviourType { # [codec (index = 0)] Keygen , # [codec (index = 1)] Sign , } } pub mod egg_standalone_runtime { use super :: runtime_types ; pub mod opaque { use super :: runtime_types ; # [derive (:: subxt :: codec :: Decode , :: subxt :: codec :: Encode , Clone , Debug , Eq , PartialEq)] pub struct SessionKeys { pub aura : runtime_types :: sp_consensus_aura :: sr25519 :: app_sr25519 :: Public , pub grandpa : runtime_types :: sp_finality_grandpa :: app :: Public , pub dkg : runtime_types :: dkg_runtime_primitives :: crypto :: Public , } } pub mod protocol_substrate_config { use super :: runtime_types ; # [derive (:: subxt :: codec :: Decode , :: subxt :: codec :: Encode , Clone , Debug , Eq , PartialEq)] pub struct Element (pub [:: core :: primitive :: u8 ; 32usize] ,) ; } # [derive (:: subxt :: codec :: Decode , :: subxt :: codec :: Encode , Clone , Debug , Eq , PartialEq)] pub enum Call { # [codec (index = 0)] System (runtime_types :: frame_system :: pallet :: Call ,) , # [codec (index = 1)] Timestamp (runtime_types :: pallet_timestamp :: pallet :: Call ,) , # [codec (index = 2)] Sudo (runtime_types :: pallet_sudo :: pallet :: Call ,) , # [codec (index = 4)] Balances (runtime_types :: pallet_balances :: pallet :: Call ,) , # [codec (index = 6)] Authorship (runtime_types :: pallet_authorship :: pallet :: Call ,) , # [codec (index = 8)] Grandpa (runtime_types :: pallet_grandpa :: pallet :: Call ,) , # [codec (index = 9)] Indices (runtime_types :: pallet_indices :: pallet :: Call ,) , # [codec (index = 10)] Democracy (runtime_types :: pallet_democracy :: pallet :: Call ,) , # [codec (index = 11)] Council (runtime_types :: pallet_collective :: pallet :: Call ,) , # [codec (index = 12)] Elections (runtime_types :: pallet_elections_phragmen :: pallet :: Call ,) , # [codec (index = 13)] ElectionProviderMultiPhase (runtime_types :: pallet_election_provider_multi_phase :: pallet :: Call ,) , # [codec (index = 14)] Staking (runtime_types :: pallet_staking :: pallet :: pallet :: Call ,) , # [codec (index = 15)] Session (runtime_types :: pallet_session :: pallet :: Call ,) , # [codec (index = 17)] Treasury (runtime_types :: pallet_treasury :: pallet :: Call ,) , # [codec (index = 18)] Bounties (runtime_types :: pallet_bounties :: pallet :: Call ,) , # [codec (index = 19)] ChildBounties (runtime_types :: pallet_child_bounties :: pallet :: Call ,) , # [codec (index = 20)] BagsList (runtime_types :: pallet_bags_list :: pallet :: Call ,) , # [codec (index = 21)] NominationPools (runtime_types :: pallet_nomination_pools :: pallet :: Call ,) , # [codec (index = 22)] Scheduler (runtime_types :: pallet_scheduler :: pallet :: Call ,) , # [codec (index = 23)] Preimage (runtime_types :: pallet_preimage :: pallet :: Call ,) , # [codec (index = 25)] DKG (runtime_types :: pallet_dkg_metadata :: pallet :: Call ,) , # [codec (index = 26)] DKGProposals (runtime_types :: pallet_dkg_proposals :: pallet :: Call ,) , # [codec (index = 27)] DKGProposalHandler (runtime_types :: pallet_dkg_proposal_handler :: pallet :: Call ,) , # [codec (index = 28)] HasherBn254 (runtime_types :: pallet_hasher :: pallet :: Call ,) , # [codec (index = 29)] AssetRegistry (runtime_types :: pallet_asset_registry :: pallet :: Call ,) , # [codec (index = 30)] Currencies (runtime_types :: orml_currencies :: module :: Call ,) , # [codec (index = 31)] Tokens (runtime_types :: orml_tokens :: module :: Call ,) , # [codec (index = 32)] TokenWrapper (runtime_types :: pallet_token_wrapper :: pallet :: Call ,) , # [codec (index = 33)] MixerVerifierBn254 (runtime_types :: pallet_verifier :: pallet :: Call ,) , # [codec (index = 34)] AnchorVerifierBn254 (runtime_types :: pallet_verifier :: pallet :: Call ,) , # [codec (index = 35)] MerkleTreeBn254 (runtime_types :: pallet_mt :: pallet :: Call ,) , # [codec (index = 36)] LinkableTreeBn254 (runtime_types :: pallet_linkable_tree :: pallet :: Call ,) , # [codec (index = 37)] MixerBn254 (runtime_types :: pallet_mixer :: pallet :: Call ,) , # [codec (index = 38)] SignatureBridge (runtime_types :: pallet_signature_bridge :: pallet :: Call ,) , # [codec (index = 39)] VAnchorVerifier2x2Bn254 (runtime_types :: pallet_verifier :: pallet :: Call ,) , # [codec (index = 40)] Bridge (runtime_types :: pallet_bridge :: pallet :: Call ,) , # [codec (index = 41)] VAnchorBn254 (runtime_types :: pallet_vanchor :: pallet :: Call ,) , # [codec (index = 42)] VAnchorHandlerBn254 (runtime_types :: pallet_vanchor_handler :: pallet :: Call ,) , } # [derive (:: subxt :: codec :: Decode , :: subxt :: codec :: Encode , Clone , Debug , Eq , PartialEq)] pub enum Event { # [codec (index = 0)] System (runtime_types :: frame_system :: pallet :: Event ,) , # [codec (index = 2)] Sudo (runtime_types :: pallet_sudo :: pallet :: Event ,) , # [codec (index = 4)] Balances (runtime_types :: pallet_balances :: pallet :: Event ,) , # [codec (index = 5)] TransactionPayment (runtime_types :: pallet_transaction_payment :: pallet :: Event ,) , # [codec (index = 8)] Grandpa (runtime_types :: pallet_grandpa :: pallet :: Event ,) , # [codec (index = 9)] Indices (runtime_types :: pallet_indices :: pallet :: Event ,) , # [codec (index = 10)] Democracy (runtime_types :: pallet_democracy :: pallet :: Event ,) , # [codec (index = 11)] Council (runtime_types :: pallet_collective :: pallet :: Event ,) , # [codec (index = 12)] Elections (runtime_types :: pallet_elections_phragmen :: pallet :: Event ,) , # [codec (index = 13)] ElectionProviderMultiPhase (runtime_types :: pallet_election_provider_multi_phase :: pallet :: Event ,) , # [codec (index = 14)] Staking (runtime_types :: pallet_staking :: pallet :: pallet :: Event ,) , # [codec (index = 15)] Session (runtime_types :: pallet_session :: pallet :: Event ,) , # [codec (index = 17)] Treasury (runtime_types :: pallet_treasury :: pallet :: Event ,) , # [codec (index = 18)] Bounties (runtime_types :: pallet_bounties :: pallet :: Event ,) , # [codec (index = 19)] ChildBounties (runtime_types :: pallet_child_bounties :: pallet :: Event ,) , # [codec (index = 20)] BagsList (runtime_types :: pallet_bags_list :: pallet :: Event ,) , # [codec (index = 21)] NominationPools (runtime_types :: pallet_nomination_pools :: pallet :: Event ,) , # [codec (index = 22)] Scheduler (runtime_types :: pallet_scheduler :: pallet :: Event ,) , # [codec (index = 23)] Preimage (runtime_types :: pallet_preimage :: pallet :: Event ,) , # [codec (index = 24)] Offences (runtime_types :: pallet_offences :: pallet :: Event ,) , # [codec (index = 25)] DKG (runtime_types :: pallet_dkg_metadata :: pallet :: Event ,) , # [codec (index = 26)] DKGProposals (runtime_types :: pallet_dkg_proposals :: pallet :: Event ,) , # [codec (index = 27)] DKGProposalHandler (runtime_types :: pallet_dkg_proposal_handler :: pallet :: Event ,) , # [codec (index = 28)] HasherBn254 (runtime_types :: pallet_hasher :: pallet :: Event ,) , # [codec (index = 29)] AssetRegistry (runtime_types :: pallet_asset_registry :: pallet :: Event ,) , # [codec (index = 31)] Tokens (runtime_types :: orml_tokens :: module :: Event ,) , # [codec (index = 32)] TokenWrapper (runtime_types :: pallet_token_wrapper :: pallet :: Event ,) , # [codec (index = 33)] MixerVerifierBn254 (runtime_types :: pallet_verifier :: pallet :: Event ,) , # [codec (index = 34)] AnchorVerifierBn254 (runtime_types :: pallet_verifier :: pallet :: Event ,) , # [codec (index = 35)] MerkleTreeBn254 (runtime_types :: pallet_mt :: pallet :: Event ,) , # [codec (index = 36)] LinkableTreeBn254 (runtime_types :: pallet_linkable_tree :: pallet :: Event ,) , # [codec (index = 37)] MixerBn254 (runtime_types :: pallet_mixer :: pallet :: Event ,) , # [codec (index = 38)] SignatureBridge (runtime_types :: pallet_signature_bridge :: pallet :: Event ,) , # [codec (index = 39)] VAnchorVerifier2x2Bn254 (runtime_types :: pallet_verifier :: pallet :: Event ,) , # [codec (index = 40)] Bridge (runtime_types :: pallet_bridge :: pallet :: Event ,) , # [codec (index = 41)] VAnchorBn254 (runtime_types :: pallet_vanchor :: pallet :: Event ,) , # [codec (index = 42)] VAnchorHandlerBn254 (runtime_types :: pallet_vanchor_handler :: pallet :: Event ,) , } # [derive (:: subxt :: codec :: Decode , :: subxt :: codec :: Encode , Clone , Debug , Eq , PartialEq)] pub struct NposSolution16 { pub votes1 : :: std :: vec :: Vec < (:: core :: primitive :: u32 , :: core :: primitive :: u16 ,) > , pub votes2 : :: std :: vec :: Vec < (:: core :: primitive :: u32 , (:: core :: primitive :: u16 , runtime_types :: sp_arithmetic :: per_things :: PerU16 ,) , :: core :: primitive :: u16 ,) > , pub votes3 : :: std :: vec :: Vec < (:: core :: primitive :: u32 , [(:: core :: primitive :: u16 , runtime_types :: sp_arithmetic :: per_things :: PerU16 ,) ; 2usize] , :: core :: primitive :: u16 ,) > , pub votes4 : :: std :: vec :: Vec < (:: core :: primitive :: u32 , [(:: core :: primitive :: u16 , runtime_types :: sp_arithmetic :: per_things :: PerU16 ,) ; 3usize] , :: core :: primitive :: u16 ,) > , pub votes5 : :: std :: vec :: Vec < (:: core :: primitive :: u32 , [(:: core :: primitive :: u16 , runtime_types :: sp_arithmetic :: per_things :: PerU16 ,) ; 4usize] , :: core :: primitive :: u16 ,) > , pub votes6 : :: std :: vec :: Vec < (:: core :: primitive :: u32 , [(:: core :: primitive :: u16 , runtime_types :: sp_arithmetic :: per_things :: PerU16 ,) ; 5usize] , :: core :: primitive :: u16 ,) > , pub votes7 : :: std :: vec :: Vec < (:: core :: primitive :: u32 , [(:: core :: primitive :: u16 , runtime_types :: sp_arithmetic :: per_things :: PerU16 ,) ; 6usize] , :: core :: primitive :: u16 ,) > , pub votes8 : :: std :: vec :: Vec < (:: core :: primitive :: u32 , [(:: core :: primitive :: u16 , runtime_types :: sp_arithmetic :: per_things :: PerU16 ,) ; 7usize] , :: core :: primitive :: u16 ,) > , pub votes9 : :: std :: vec :: Vec < (:: core :: primitive :: u32 , [(:: core :: primitive :: u16 , runtime_types :: sp_arithmetic :: per_things :: PerU16 ,) ; 8usize] , :: core :: primitive :: u16 ,) > , pub votes10 : :: std :: vec :: Vec < (:: core :: primitive :: u32 , [(:: core :: primitive :: u16 , runtime_types :: sp_arithmetic :: per_things :: PerU16 ,) ; 9usize] , :: core :: primitive :: u16 ,) > , pub votes11 : :: std :: vec :: Vec < (:: core :: primitive :: u32 , [(:: core :: primitive :: u16 , runtime_types :: sp_arithmetic :: per_things :: PerU16 ,) ; 10usize] , :: core :: primitive :: u16 ,) > , pub votes12 : :: std :: vec :: Vec < (:: core :: primitive :: u32 , [(:: core :: primitive :: u16 , runtime_types :: sp_arithmetic :: per_things :: PerU16 ,) ; 11usize] , :: core :: primitive :: u16 ,) > , pub votes13 : :: std :: vec :: Vec < (:: core :: primitive :: u32 , [(:: core :: primitive :: u16 , runtime_types :: sp_arithmetic :: per_things :: PerU16 ,) ; 12usize] , :: core :: primitive :: u16 ,) > , pub votes14 : :: std :: vec :: Vec < (:: core :: primitive :: u32 , [(:: core :: primitive :: u16 , runtime_types :: sp_arithmetic :: per_things :: PerU16 ,) ; 13usize] , :: core :: primitive :: u16 ,) > , pub votes15 : :: std :: vec :: Vec < (:: core :: primitive :: u32 , [(:: core :: primitive :: u16 , runtime_types :: sp_arithmetic :: per_things :: PerU16 ,) ; 14usize] , :: core :: primitive :: u16 ,) > , pub votes16 : :: std :: vec :: Vec < (:: core :: primitive :: u32 , [(:: core :: primitive :: u16 , runtime_types :: sp_arithmetic :: per_things :: PerU16 ,) ; 15usize] , :: core :: primitive :: u16 ,) > , } # [derive (:: subxt :: codec :: Decode , :: subxt :: codec :: Encode , Clone , Debug , Eq , PartialEq)] pub enum OriginCaller { # [codec (index = 0)] system (runtime_types :: frame_support :: dispatch :: RawOrigin < :: subxt :: sp_core :: crypto :: AccountId32 > ,) , # [codec (index = 11)] Council (runtime_types :: pallet_collective :: RawOrigin < :: subxt :: sp_core :: crypto :: AccountId32 > ,) , # [codec (index = 2)] Void (runtime_types :: sp_core :: Void ,) , } # [derive (:: subxt :: codec :: Decode , :: subxt :: codec :: Encode , Clone , Debug , Eq , PartialEq)] pub struct Runtime ; } pub mod finality_grandpa { use super :: runtime_types ; # [derive (:: subxt :: codec :: Decode , :: subxt :: codec :: Encode , Clone , Debug , Eq , PartialEq)] pub struct Equivocation < _0 , _1 , _2 > { pub round_number : :: core :: primitive :: u64 , pub identity : _0 , pub first : (_1 , _2 ,) , pub second : (_1 , _2 ,) , } # [derive (:: subxt :: codec :: Decode , :: subxt :: codec :: Encode , Clone , Debug , Eq , PartialEq)] pub struct Precommit < _0 , _1 > { pub target_hash : _0 , pub target_number : _1 , } # [derive (:: subxt :: codec :: Decode , :: subxt :: codec :: Encode , Clone , Debug , Eq , PartialEq)] pub struct Prevote < _0 , _1 > { pub target_hash : _0 , pub target_number : _1 , } } pub mod frame_support { use super :: runtime_types ; pub mod dispatch { use super :: runtime_types ; # [derive (:: subxt :: codec :: Decode , :: subxt :: codec :: Encode , Clone , Debug , Eq , PartialEq)] pub enum RawOrigin < _0 > { # [codec (index = 0)] Root , # [codec (index = 1)] Signed (_0 ,) , # [codec (index = 2)] None , } } pub mod traits { use super :: runtime_types ; pub mod schedule { use super :: runtime_types ; # [derive (:: subxt :: codec :: Decode , :: subxt :: codec :: Encode , Clone , Debug , Eq , PartialEq)] pub enum LookupError { # [codec (index = 0)] Unknown , # [codec (index = 1)] BadFormat , } # [derive (:: subxt :: codec :: Decode , :: subxt :: codec :: Encode , Clone , Debug , Eq , PartialEq)] pub enum MaybeHashed < _0 , _1 > { # [codec (index = 0)] Value (_0 ,) , # [codec (index = 1)] Hash (_1 ,) , } } pub mod tokens { use super :: runtime_types ; pub mod misc { use super :: runtime_types ; # [derive (:: subxt :: codec :: Decode , :: subxt :: codec :: Encode , Clone , Debug , Eq , PartialEq)] pub enum BalanceStatus { # [codec (index = 0)] Free , # [codec (index = 1)] Reserved , } } } } pub mod weights { use super :: runtime_types ; # [derive (:: subxt :: codec :: Decode , :: subxt :: codec :: Encode , Clone , Debug , Eq , PartialEq)] pub enum DispatchClass { # [codec (index = 0)] Normal , # [codec (index = 1)] Operational , # [codec (index = 2)] Mandatory , } # [derive (:: subxt :: codec :: Decode , :: subxt :: codec :: Encode , Clone , Debug , Eq , PartialEq)] pub struct DispatchInfo { pub weight : :: core :: primitive :: u64 , pub class : runtime_types :: frame_support :: weights :: DispatchClass , pub pays_fee : runtime_types :: frame_support :: weights :: Pays , } # [derive (:: subxt :: codec :: Decode , :: subxt :: codec :: Encode , Clone , Debug , Eq , PartialEq)] pub enum Pays { # [codec (index = 0)] Yes , # [codec (index = 1)] No , } # [derive (:: subxt :: codec :: Decode , :: subxt :: codec :: Encode , Clone , Debug , Eq , PartialEq)] pub struct PerDispatchClass < _0 > { pub normal : _0 , pub operational : _0 , pub mandatory : _0 , } # [derive (:: subxt :: codec :: Decode , :: subxt :: codec :: Encode , Clone , Debug , Eq , PartialEq)] pub struct RuntimeDbWeight { pub read : :: core :: primitive :: u64 , pub write : :: core :: primitive :: u64 , } } # [derive (:: subxt :: codec :: Decode , :: subxt :: codec :: Encode , Clone , Debug , Eq , PartialEq)] pub struct PalletId (pub [:: core :: primitive :: u8 ; 8usize] ,) ; } pub mod frame_system { use super :: runtime_types ; pub mod extensions { use super :: runtime_types ; pub mod check_genesis { use super :: runtime_types ; # [derive (:: subxt :: codec :: Decode , :: subxt :: codec :: Encode , Clone , Debug , Eq , PartialEq)] pub struct CheckGenesis ; } pub mod check_mortality { use super :: runtime_types ; # [derive (:: subxt :: codec :: Decode , :: subxt :: codec :: Encode , Clone , Debug , Eq , PartialEq)] pub struct CheckMortality (pub runtime_types :: sp_runtime :: generic :: era :: Era ,) ; } pub mod check_non_zero_sender { use super :: runtime_types ; # [derive (:: subxt :: codec :: Decode , :: subxt :: codec :: Encode , Clone , Debug , Eq , PartialEq)] pub struct CheckNonZeroSender ; } pub mod check_nonce { use super :: runtime_types ; # [derive (:: subxt :: codec :: Decode , :: subxt :: codec :: Encode , Clone , Debug , Eq , PartialEq)] pub struct CheckNonce (# [codec (compact)] pub :: core :: primitive :: u32 ,) ; } pub mod check_spec_version { use super :: runtime_types ; # [derive (:: subxt :: codec :: Decode , :: subxt :: codec :: Encode , Clone , Debug , Eq , PartialEq)] pub struct CheckSpecVersion ; } pub mod check_tx_version { use super :: runtime_types ; # [derive (:: subxt :: codec :: Decode , :: subxt :: codec :: Encode , Clone , Debug , Eq , PartialEq)] pub struct CheckTxVersion ; } pub mod check_weight { use super :: runtime_types ; # [derive (:: subxt :: codec :: Decode , :: subxt :: codec :: Encode , Clone , Debug , Eq , PartialEq)] pub struct CheckWeight ; } } pub mod limits { use super :: runtime_types ; # [derive (:: subxt :: codec :: Decode , :: subxt :: codec :: Encode , Clone , Debug , Eq , PartialEq)] pub struct BlockLength { pub max : runtime_types :: frame_support :: weights :: PerDispatchClass < :: core :: primitive :: u32 > , } # [derive (:: subxt :: codec :: Decode , :: subxt :: codec :: Encode , Clone , Debug , Eq , PartialEq)] pub struct BlockWeights { pub base_block : :: core :: primitive :: u64 , pub max_block : :: core :: primitive :: u64 , pub per_class : runtime_types :: frame_support :: weights :: PerDispatchClass < runtime_types :: frame_system :: limits :: WeightsPerClass > , } # [derive (:: subxt :: codec :: Decode , :: subxt :: codec :: Encode , Clone , Debug , Eq , PartialEq)] pub struct WeightsPerClass { pub base_extrinsic : :: core :: primitive :: u64 , pub max_extrinsic : :: core :: option :: Option < :: core :: primitive :: u64 > , pub max_total : :: core :: option :: Option < :: core :: primitive :: u64 > , pub reserved : :: core :: option :: Option < :: core :: primitive :: u64 > , } } pub mod pallet { use super :: runtime_types ; # [derive (:: subxt :: codec :: Decode , :: subxt :: codec :: Encode , Clone , Debug , Eq , PartialEq)] pub enum Call { # [codec (index = 0)] # [doc = "A dispatch that will fill the block weight up to the given ratio."] fill_block { ratio : runtime_types :: sp_arithmetic :: per_things :: Perbill , } , # [codec (index = 1)] # [doc = "Make some on-chain remark."] # [doc = ""] # [doc = "# <weight>"] # [doc = "- `O(1)`"] # [doc = "# </weight>"] remark { remark : :: std :: vec :: Vec < :: core :: primitive :: u8 > , } , # [codec (index = 2)] # [doc = "Set the number of pages in the WebAssembly environment's heap."] set_heap_pages { pages : :: core :: primitive :: u64 , } , # [codec (index = 3)] # [doc = "Set the new runtime code."] # [doc = ""] # [doc = "# <weight>"] # [doc = "- `O(C + S)` where `C` length of `code` and `S` complexity of `can_set_code`"] # [doc = "- 1 call to `can_set_code`: `O(S)` (calls `sp_io::misc::runtime_version` which is"] # [doc = "  expensive)."] # [doc = "- 1 storage write (codec `O(C)`)."] # [doc = "- 1 digest item."] # [doc = "- 1 event."] # [doc = "The weight of this function is dependent on the runtime, but generally this is very"] # [doc = "expensive. We will treat this as a full block."] # [doc = "# </weight>"] set_code { code : :: std :: vec :: Vec < :: core :: primitive :: u8 > , } , # [codec (index = 4)] # [doc = "Set the new runtime code without doing any checks of the given `code`."] # [doc = ""] # [doc = "# <weight>"] # [doc = "- `O(C)` where `C` length of `code`"] # [doc = "- 1 storage write (codec `O(C)`)."] # [doc = "- 1 digest item."] # [doc = "- 1 event."] # [doc = "The weight of this function is dependent on the runtime. We will treat this as a full"] # [doc = "block. # </weight>"] set_code_without_checks { code : :: std :: vec :: Vec < :: core :: primitive :: u8 > , } , # [codec (index = 5)] # [doc = "Set some items of storage."] set_storage { items : :: std :: vec :: Vec < (:: std :: vec :: Vec < :: core :: primitive :: u8 > , :: std :: vec :: Vec < :: core :: primitive :: u8 > ,) > , } , # [codec (index = 6)] # [doc = "Kill some items from storage."] kill_storage { keys : :: std :: vec :: Vec < :: std :: vec :: Vec < :: core :: primitive :: u8 > > , } , # [codec (index = 7)] # [doc = "Kill all storage items with a key that starts with the given prefix."] # [doc = ""] # [doc = "**NOTE:** We rely on the Root origin to provide us the number of subkeys under"] # [doc = "the prefix we are removing to accurately calculate the weight of this function."] kill_prefix { prefix : :: std :: vec :: Vec < :: core :: primitive :: u8 > , subkeys : :: core :: primitive :: u32 , } , # [codec (index = 8)] # [doc = "Make some on-chain remark and emit event."] remark_with_event { remark : :: std :: vec :: Vec < :: core :: primitive :: u8 > , } , } # [derive (:: subxt :: codec :: Decode , :: subxt :: codec :: Encode , Clone , Debug , Eq , PartialEq)] pub enum Error { # [codec (index = 0)] # [doc = "The name of specification does not match between the current runtime"] # [doc = "and the new runtime."] InvalidSpecName , # [codec (index = 1)] # [doc = "The specification version is not allowed to decrease between the current runtime"] # [doc = "and the new runtime."] SpecVersionNeedsToIncrease , # [codec (index = 2)] # [doc = "Failed to extract the runtime version from the new runtime."] # [doc = ""] # [doc = "Either calling `Core_version` or decoding `RuntimeVersion` failed."] FailedToExtractRuntimeVersion , # [codec (index = 3)] # [doc = "Suicide called when the account has non-default composite data."] NonDefaultComposite , # [codec (index = 4)] # [doc = "There is a non-zero reference count preventing the account from being purged."] NonZeroRefCount , # [codec (index = 5)] # [doc = "The origin filter prevent the call to be dispatched."] CallFiltered , } # [derive (:: subxt :: codec :: Decode , :: subxt :: codec :: Encode , Clone , Debug , Eq , PartialEq)] pub enum Event { # [codec (index = 0)] # [doc = "An extrinsic completed successfully."] ExtrinsicSuccess { dispatch_info : runtime_types :: frame_support :: weights :: DispatchInfo , } , # [codec (index = 1)] # [doc = "An extrinsic failed."] ExtrinsicFailed { dispatch_error : runtime_types :: sp_runtime :: DispatchError , dispatch_info : runtime_types :: frame_support :: weights :: DispatchInfo , } , # [codec (index = 2)] # [doc = "`:code` was updated."] CodeUpdated , # [codec (index = 3)] # [doc = "A new account was created."] NewAccount { account : :: subxt :: sp_core :: crypto :: AccountId32 , } , # [codec (index = 4)] # [doc = "An account was reaped."] KilledAccount { account : :: subxt :: sp_core :: crypto :: AccountId32 , } , # [codec (index = 5)] # [doc = "On on-chain remark happened."] Remarked { sender : :: subxt :: sp_core :: crypto :: AccountId32 , hash : :: subxt :: sp_core :: H256 , } , } } # [derive (:: subxt :: codec :: Decode , :: subxt :: codec :: Encode , Clone , Debug , Eq , PartialEq)] pub struct AccountInfo < _0 , _1 > { pub nonce : _0 , pub consumers : _0 , pub providers : _0 , pub sufficients : _0 , pub data : _1 , } # [derive (:: subxt :: codec :: Decode , :: subxt :: codec :: Encode , Clone , Debug , Eq , PartialEq)] pub struct EventRecord < _0 , _1 > { pub phase : runtime_types :: frame_system :: Phase , pub event : _0 , pub topics : :: std :: vec :: Vec < _1 > , } # [derive (:: subxt :: codec :: Decode , :: subxt :: codec :: Encode , Clone , Debug , Eq , PartialEq)] pub struct LastRuntimeUpgradeInfo { # [codec (compact)] pub spec_version : :: core :: primitive :: u32 , pub spec_name : :: std :: string :: String , } # [derive (:: subxt :: codec :: Decode , :: subxt :: codec :: Encode , Clone , Debug , Eq , PartialEq)] pub enum Phase { # [codec (index = 0)] ApplyExtrinsic (:: core :: primitive :: u32 ,) , # [codec (index = 1)] Finalization , # [codec (index = 2)] Initialization , } } pub mod orml_currencies { use super :: runtime_types ; pub mod module { use super :: runtime_types ; # [derive (:: subxt :: codec :: Decode , :: subxt :: codec :: Encode , Clone , Debug , Eq , PartialEq)] pub enum Call { # [codec (index = 0)] # [doc = "Transfer some balance to another account under `currency_id`."] # [doc = ""] # [doc = "The dispatch origin for this call must be `Signed` by the"] # [doc = "transactor."] transfer { dest : :: subxt :: sp_runtime :: MultiAddress < :: subxt :: sp_core :: crypto :: AccountId32 , :: core :: primitive :: u32 > , currency_id : :: core :: primitive :: u32 , # [codec (compact)] amount : :: core :: primitive :: u128 , } , # [codec (index = 1)] # [doc = "Transfer some native currency to another account."] # [doc = ""] # [doc = "The dispatch origin for this call must be `Signed` by the"] # [doc = "transactor."] transfer_native_currency { dest : :: subxt :: sp_runtime :: MultiAddress < :: subxt :: sp_core :: crypto :: AccountId32 , :: core :: primitive :: u32 > , # [codec (compact)] amount : :: core :: primitive :: u128 , } , # [codec (index = 2)] # [doc = "update amount of account `who` under `currency_id`."] # [doc = ""] # [doc = "The dispatch origin of this call must be _Root_."] update_balance { who : :: subxt :: sp_runtime :: MultiAddress < :: subxt :: sp_core :: crypto :: AccountId32 , :: core :: primitive :: u32 > , currency_id : :: core :: primitive :: u32 , amount : :: core :: primitive :: i128 , } , } # [derive (:: subxt :: codec :: Decode , :: subxt :: codec :: Encode , Clone , Debug , Eq , PartialEq)] pub enum Error { # [codec (index = 0)] # [doc = "Unable to convert the Amount type into Balance."] AmountIntoBalanceFailed , # [codec (index = 1)] # [doc = "Balance is too low."] BalanceTooLow , # [codec (index = 2)] # [doc = "Deposit result is not expected"] DepositFailed , } } } pub mod orml_tokens { use super :: runtime_types ; pub mod module { use super :: runtime_types ; # [derive (:: subxt :: codec :: Decode , :: subxt :: codec :: Encode , Clone , Debug , Eq , PartialEq)] pub enum Call { # [codec (index = 0)] # [doc = "Transfer some liquid free balance to another account."] # [doc = ""] # [doc = "`transfer` will set the `FreeBalance` of the sender and receiver."] # [doc = "It will decrease the total issuance of the system by the"] # [doc = "`TransferFee`. If the sender's account is below the existential"] # [doc = "deposit as a result of the transfer, the account will be reaped."] # [doc = ""] # [doc = "The dispatch origin for this call must be `Signed` by the"] # [doc = "transactor."] # [doc = ""] # [doc = "- `dest`: The recipient of the transfer."] # [doc = "- `currency_id`: currency type."] # [doc = "- `amount`: free balance amount to tranfer."] transfer { dest : :: subxt :: sp_runtime :: MultiAddress < :: subxt :: sp_core :: crypto :: AccountId32 , :: core :: primitive :: u32 > , currency_id : :: core :: primitive :: u32 , # [codec (compact)] amount : :: core :: primitive :: u128 , } , # [codec (index = 1)] # [doc = "Transfer all remaining balance to the given account."] # [doc = ""] # [doc = "NOTE: This function only attempts to transfer _transferable_"] # [doc = "balances. This means that any locked, reserved, or existential"] # [doc = "deposits (when `keep_alive` is `true`), will not be transferred by"] # [doc = "this function. To ensure that this function results in a killed"] # [doc = "account, you might need to prepare the account by removing any"] # [doc = "reference counters, storage deposits, etc..."] # [doc = ""] # [doc = "The dispatch origin for this call must be `Signed` by the"] # [doc = "transactor."] # [doc = ""] # [doc = "- `dest`: The recipient of the transfer."] # [doc = "- `currency_id`: currency type."] # [doc = "- `keep_alive`: A boolean to determine if the `transfer_all`"] # [doc = "  operation should send all of the funds the account has, causing"] # [doc = "  the sender account to be killed (false), or transfer everything"] # [doc = "  except at least the existential deposit, which will guarantee to"] # [doc = "  keep the sender account alive (true)."] transfer_all { dest : :: subxt :: sp_runtime :: MultiAddress < :: subxt :: sp_core :: crypto :: AccountId32 , :: core :: primitive :: u32 > , currency_id : :: core :: primitive :: u32 , keep_alive : :: core :: primitive :: bool , } , # [codec (index = 2)] # [doc = "Same as the [`transfer`] call, but with a check that the transfer"] # [doc = "will not kill the origin account."] # [doc = ""] # [doc = "99% of the time you want [`transfer`] instead."] # [doc = ""] # [doc = "The dispatch origin for this call must be `Signed` by the"] # [doc = "transactor."] # [doc = ""] # [doc = "- `dest`: The recipient of the transfer."] # [doc = "- `currency_id`: currency type."] # [doc = "- `amount`: free balance amount to tranfer."] transfer_keep_alive { dest : :: subxt :: sp_runtime :: MultiAddress < :: subxt :: sp_core :: crypto :: AccountId32 , :: core :: primitive :: u32 > , currency_id : :: core :: primitive :: u32 , # [codec (compact)] amount : :: core :: primitive :: u128 , } , # [codec (index = 3)] # [doc = "Exactly as `transfer`, except the origin must be root and the source"] # [doc = "account may be specified."] # [doc = ""] # [doc = "The dispatch origin for this call must be _Root_."] # [doc = ""] # [doc = "- `source`: The sender of the transfer."] # [doc = "- `dest`: The recipient of the transfer."] # [doc = "- `currency_id`: currency type."] # [doc = "- `amount`: free balance amount to tranfer."] force_transfer { source : :: subxt :: sp_runtime :: MultiAddress < :: subxt :: sp_core :: crypto :: AccountId32 , :: core :: primitive :: u32 > , dest : :: subxt :: sp_runtime :: MultiAddress < :: subxt :: sp_core :: crypto :: AccountId32 , :: core :: primitive :: u32 > , currency_id : :: core :: primitive :: u32 , # [codec (compact)] amount : :: core :: primitive :: u128 , } , # [codec (index = 4)] # [doc = "Set the balances of a given account."] # [doc = ""] # [doc = "This will alter `FreeBalance` and `ReservedBalance` in storage. it"] # [doc = "will also decrease the total issuance of the system"] # [doc = "(`TotalIssuance`). If the new free or reserved balance is below the"] # [doc = "existential deposit, it will reap the `AccountInfo`."] # [doc = ""] # [doc = "The dispatch origin for this call is `root`."] set_balance { who : :: subxt :: sp_runtime :: MultiAddress < :: subxt :: sp_core :: crypto :: AccountId32 , :: core :: primitive :: u32 > , currency_id : :: core :: primitive :: u32 , # [codec (compact)] new_free : :: core :: primitive :: u128 , # [codec (compact)] new_reserved : :: core :: primitive :: u128 , } , } # [derive (:: subxt :: codec :: Decode , :: subxt :: codec :: Encode , Clone , Debug , Eq , PartialEq)] pub enum Error { # [codec (index = 0)] # [doc = "The balance is too low"] BalanceTooLow , # [codec (index = 1)] # [doc = "Cannot convert Amount into Balance type"] AmountIntoBalanceFailed , # [codec (index = 2)] # [doc = "Failed because liquidity restrictions due to locking"] LiquidityRestrictions , # [codec (index = 3)] # [doc = "Failed because the maximum locks was exceeded"] MaxLocksExceeded , # [codec (index = 4)] # [doc = "Transfer/payment would kill account"] KeepAlive , # [codec (index = 5)] # [doc = "Value too low to create account due to existential deposit"] ExistentialDeposit , # [codec (index = 6)] # [doc = "Beneficiary account must pre-exist"] DeadAccount , # [codec (index = 7)] TooManyReserves , } # [derive (:: subxt :: codec :: Decode , :: subxt :: codec :: Encode , Clone , Debug , Eq , PartialEq)] pub enum Event { # [codec (index = 0)] # [doc = "An account was created with some free balance."] Endowed { currency_id : :: core :: primitive :: u32 , who : :: subxt :: sp_core :: crypto :: AccountId32 , amount : :: core :: primitive :: u128 , } , # [codec (index = 1)] # [doc = "An account was removed whose balance was non-zero but below"] # [doc = "ExistentialDeposit, resulting in an outright loss."] DustLost { currency_id : :: core :: primitive :: u32 , who : :: subxt :: sp_core :: crypto :: AccountId32 , amount : :: core :: primitive :: u128 , } , # [codec (index = 2)] # [doc = "Transfer succeeded."] Transfer { currency_id : :: core :: primitive :: u32 , from : :: subxt :: sp_core :: crypto :: AccountId32 , to : :: subxt :: sp_core :: crypto :: AccountId32 , amount : :: core :: primitive :: u128 , } , # [codec (index = 3)] # [doc = "Some balance was reserved (moved from free to reserved)."] Reserved { currency_id : :: core :: primitive :: u32 , who : :: subxt :: sp_core :: crypto :: AccountId32 , amount : :: core :: primitive :: u128 , } , # [codec (index = 4)] # [doc = "Some balance was unreserved (moved from reserved to free)."] Unreserved { currency_id : :: core :: primitive :: u32 , who : :: subxt :: sp_core :: crypto :: AccountId32 , amount : :: core :: primitive :: u128 , } , # [codec (index = 5)] # [doc = "Some reserved balance was repatriated (moved from reserved to"] # [doc = "another account)."] ReserveRepatriated { currency_id : :: core :: primitive :: u32 , from : :: subxt :: sp_core :: crypto :: AccountId32 , to : :: subxt :: sp_core :: crypto :: AccountId32 , amount : :: core :: primitive :: u128 , status : runtime_types :: frame_support :: traits :: tokens :: misc :: BalanceStatus , } , # [codec (index = 6)] # [doc = "A balance was set by root."] BalanceSet { currency_id : :: core :: primitive :: u32 , who : :: subxt :: sp_core :: crypto :: AccountId32 , free : :: core :: primitive :: u128 , reserved : :: core :: primitive :: u128 , } , # [codec (index = 7)] # [doc = "The total issuance of an currency has been set"] TotalIssuanceSet { currency_id : :: core :: primitive :: u32 , amount : :: core :: primitive :: u128 , } , # [codec (index = 8)] # [doc = "Some balances were withdrawn (e.g. pay for transaction fee)"] Withdrawn { currency_id : :: core :: primitive :: u32 , who : :: subxt :: sp_core :: crypto :: AccountId32 , amount : :: core :: primitive :: u128 , } , # [codec (index = 9)] # [doc = "Some balances were slashed (e.g. due to mis-behavior)"] Slashed { currency_id : :: core :: primitive :: u32 , who : :: subxt :: sp_core :: crypto :: AccountId32 , free_amount : :: core :: primitive :: u128 , reserved_amount : :: core :: primitive :: u128 , } , # [codec (index = 10)] # [doc = "Deposited some balance into an account"] Deposited { currency_id : :: core :: primitive :: u32 , who : :: subxt :: sp_core :: crypto :: AccountId32 , amount : :: core :: primitive :: u128 , } , # [codec (index = 11)] # [doc = "Some funds are locked"] LockSet { lock_id : [:: core :: primitive :: u8 ; 8usize] , currency_id : :: core :: primitive :: u32 , who : :: subxt :: sp_core :: crypto :: AccountId32 , amount : :: core :: primitive :: u128 , } , # [codec (index = 12)] # [doc = "Some locked funds were unlocked"] LockRemoved { lock_id : [:: core :: primitive :: u8 ; 8usize] , currency_id : :: core :: primitive :: u32 , who : :: subxt :: sp_core :: crypto :: AccountId32 , } , } } # [derive (:: subxt :: codec :: Decode , :: subxt :: codec :: Encode , Clone , Debug , Eq , PartialEq)] pub struct AccountData < _0 > { pub free : _0 , pub reserved : _0 , pub frozen : _0 , } # [derive (:: subxt :: codec :: Decode , :: subxt :: codec :: Encode , Clone , Debug , Eq , PartialEq)] pub struct BalanceLock < _0 > { pub id : [:: core :: primitive :: u8 ; 8usize] , pub amount : _0 , } # [derive (:: subxt :: codec :: Decode , :: subxt :: codec :: Encode , Clone , Debug , Eq , PartialEq)] pub struct ReserveData < _0 , _1 > { pub id : _0 , pub amount : _1 , } } pub mod pallet_asset_registry { use super :: runtime_types ; pub mod pallet { use super :: runtime_types ; # [derive (:: subxt :: codec :: Decode , :: subxt :: codec :: Encode , Clone , Debug , Eq , PartialEq)] pub enum Call { # [codec (index = 0)] # [doc = "Register a new asset."] # [doc = ""] # [doc = "Asset is identified by `name` and the name must not be used to"] # [doc = "register another asset."] # [doc = ""] # [doc = "New asset is given `NextAssetId` - sequential asset id"] # [doc = ""] # [doc = "Adds mapping between `name` and assigned `asset_id` so asset id can"] # [doc = "be retrieved by name too (Note: this approach is used in AMM"] # [doc = "implementation (xyk))"] # [doc = ""] # [doc = "Emits 'Registered` event when successful."] register { name : :: std :: vec :: Vec < :: core :: primitive :: u8 > , asset_type : runtime_types :: pallet_asset_registry :: types :: AssetType < :: core :: primitive :: u32 > , existential_deposit : :: core :: primitive :: u128 , } , # [codec (index = 1)] # [doc = "Update registered asset."] # [doc = ""] # [doc = "Updates also mapping between name and asset id if provided name is"] # [doc = "different than currently registered."] # [doc = ""] # [doc = "Emits `Updated` event when successful."] update { asset_id : :: core :: primitive :: u32 , name : :: std :: vec :: Vec < :: core :: primitive :: u8 > , asset_type : runtime_types :: pallet_asset_registry :: types :: AssetType < :: core :: primitive :: u32 > , existential_deposit : :: core :: option :: Option < :: core :: primitive :: u128 > , } , # [codec (index = 2)] # [doc = "Set metadata for an asset."] # [doc = ""] # [doc = "- `asset_id`: Asset identifier."] # [doc = "- `symbol`: The exchange symbol for this asset. Limited in length by `StringLimit`."] # [doc = "- `decimals`: The number of decimals this asset uses to represent one unit."] # [doc = ""] # [doc = "Emits `MetadataSet` event when successful."] set_metadata { asset_id : :: core :: primitive :: u32 , symbol : :: std :: vec :: Vec < :: core :: primitive :: u8 > , decimals : :: core :: primitive :: u8 , } , # [codec (index = 3)] # [doc = "Set asset native location."] # [doc = ""] # [doc = "Adds mapping between native location and local asset id and vice"] # [doc = "versa."] # [doc = ""] # [doc = "Mainly used in XCM."] # [doc = ""] # [doc = "Emits `LocationSet` event when successful."] set_location { asset_id : :: core :: primitive :: u32 , location : :: core :: primitive :: u32 , } , # [codec (index = 4)] # [doc = "Add an asset to an existing pool."] add_asset_to_pool { pool : :: std :: vec :: Vec < :: core :: primitive :: u8 > , asset_id : :: core :: primitive :: u32 , } , # [codec (index = 5)] # [doc = "Remove an asset from an existing pool."] delete_asset_from_pool { pool : :: std :: vec :: Vec < :: core :: primitive :: u8 > , asset_id : :: core :: primitive :: u32 , } , } # [derive (:: subxt :: codec :: Decode , :: subxt :: codec :: Encode , Clone , Debug , Eq , PartialEq)] pub enum Error { # [codec (index = 0)] # [doc = "Asset Id is not available. This only happens when it reaches the MAX"] # [doc = "value of given id type."] NoIdAvailable , # [codec (index = 1)] # [doc = "Invalid asset name or symbol."] AssetNotFound , # [codec (index = 2)] # [doc = "Invalid asset name or symbol."] TooLong , # [codec (index = 3)] # [doc = "Asset ID is not registered in the asset-registry."] AssetNotRegistered , # [codec (index = 4)] # [doc = "Asset is already registered."] AssetAlreadyRegistered , # [codec (index = 5)] # [doc = "Incorrect number of assets provided to create shared asset."] InvalidSharedAssetLen , # [codec (index = 6)] # [doc = "Asset exists in to pool"] AssetExistsInPool , # [codec (index = 7)] # [doc = "Asset not found in pool"] AssetNotFoundInPool , } # [derive (:: subxt :: codec :: Decode , :: subxt :: codec :: Encode , Clone , Debug , Eq , PartialEq)] pub enum Event { # [codec (index = 0)] # [doc = "Asset was registered."] Registered { asset_id : :: core :: primitive :: u32 , name : runtime_types :: sp_runtime :: bounded :: bounded_vec :: BoundedVec < :: core :: primitive :: u8 > , asset_type : runtime_types :: pallet_asset_registry :: types :: AssetType < :: core :: primitive :: u32 > , } , # [codec (index = 1)] # [doc = "Asset was updated."] Updated { asset_id : :: core :: primitive :: u32 , name : runtime_types :: sp_runtime :: bounded :: bounded_vec :: BoundedVec < :: core :: primitive :: u8 > , asset_type : runtime_types :: pallet_asset_registry :: types :: AssetType < :: core :: primitive :: u32 > , } , # [codec (index = 2)] # [doc = "Metadata set for an asset."] MetadataSet { asset_id : :: core :: primitive :: u32 , symbol : runtime_types :: sp_runtime :: bounded :: bounded_vec :: BoundedVec < :: core :: primitive :: u8 > , decimals : :: core :: primitive :: u8 , } , # [codec (index = 3)] # [doc = "Native location set for an asset."] LocationSet { asset_id : :: core :: primitive :: u32 , location : :: core :: primitive :: u32 , } , } } pub mod types { use super :: runtime_types ; # [derive (:: subxt :: codec :: Decode , :: subxt :: codec :: Encode , Clone , Debug , Eq , PartialEq)] pub struct AssetDetails < _0 , _1 , _2 > { pub name : _2 , pub asset_type : runtime_types :: pallet_asset_registry :: types :: AssetType < _0 > , pub existential_deposit : _1 , pub locked : :: core :: primitive :: bool , } # [derive (:: subxt :: codec :: Decode , :: subxt :: codec :: Encode , Clone , Debug , Eq , PartialEq)] pub struct AssetMetadata < _0 > { pub symbol : _0 , pub decimals : :: core :: primitive :: u8 , } # [derive (:: subxt :: codec :: Decode , :: subxt :: codec :: Encode , Clone , Debug , Eq , PartialEq)] pub enum AssetType < _0 > { # [codec (index = 0)] Token , # [codec (index = 1)] PoolShare (:: std :: vec :: Vec < _0 > ,) , } } } pub mod pallet_authorship { use super :: runtime_types ; pub mod pallet { use super :: runtime_types ; # [derive (:: subxt :: codec :: Decode , :: subxt :: codec :: Encode , Clone , Debug , Eq , PartialEq)] pub enum Call { # [codec (index = 0)] # [doc = "Provide a set of uncles."] set_uncles { new_uncles : :: std :: vec :: Vec < runtime_types :: sp_runtime :: generic :: header :: Header < :: core :: primitive :: u32 , runtime_types :: sp_runtime :: traits :: BlakeTwo256 > > , } , } # [derive (:: subxt :: codec :: Decode , :: subxt :: codec :: Encode , Clone , Debug , Eq , PartialEq)] pub enum Error { # [codec (index = 0)] # [doc = "The uncle parent not in the chain."] InvalidUncleParent , # [codec (index = 1)] # [doc = "Uncles already set in the block."] UnclesAlreadySet , # [codec (index = 2)] # [doc = "Too many uncles."] TooManyUncles , # [codec (index = 3)] # [doc = "The uncle is genesis."] GenesisUncle , # [codec (index = 4)] # [doc = "The uncle is too high in chain."] TooHighUncle , # [codec (index = 5)] # [doc = "The uncle is already included."] UncleAlreadyIncluded , # [codec (index = 6)] # [doc = "The uncle isn't recent enough to be included."] OldUncle , } } # [derive (:: subxt :: codec :: Decode , :: subxt :: codec :: Encode , Clone , Debug , Eq , PartialEq)] pub enum UncleEntryItem < _0 , _1 , _2 > { # [codec (index = 0)] InclusionHeight (_0 ,) , # [codec (index = 1)] Uncle (_1 , :: core :: option :: Option < _2 > ,) , } } pub mod pallet_bags_list { use super :: runtime_types ; pub mod list { use super :: runtime_types ; # [derive (:: subxt :: codec :: Decode , :: subxt :: codec :: Encode , Clone , Debug , Eq , PartialEq)] pub struct Bag { pub head : :: core :: option :: Option < :: subxt :: sp_core :: crypto :: AccountId32 > , pub tail : :: core :: option :: Option < :: subxt :: sp_core :: crypto :: AccountId32 > , } # [derive (:: subxt :: codec :: Decode , :: subxt :: codec :: Encode , Clone , Debug , Eq , PartialEq)] pub enum ListError { # [codec (index = 0)] Duplicate , # [codec (index = 1)] NotHeavier , # [codec (index = 2)] NotInSameBag , # [codec (index = 3)] NodeNotFound , } # [derive (:: subxt :: codec :: Decode , :: subxt :: codec :: Encode , Clone , Debug , Eq , PartialEq)] pub struct Node { pub id : :: subxt :: sp_core :: crypto :: AccountId32 , pub prev : :: core :: option :: Option < :: subxt :: sp_core :: crypto :: AccountId32 > , pub next : :: core :: option :: Option < :: subxt :: sp_core :: crypto :: AccountId32 > , pub bag_upper : :: core :: primitive :: u64 , pub score : :: core :: primitive :: u64 , } } pub mod pallet { use super :: runtime_types ; # [derive (:: subxt :: codec :: Decode , :: subxt :: codec :: Encode , Clone , Debug , Eq , PartialEq)] pub enum Call { # [codec (index = 0)] # [doc = "Declare that some `dislocated` account has, through rewards or penalties, sufficiently"] # [doc = "changed its score that it should properly fall into a different bag than its current"] # [doc = "one."] # [doc = ""] # [doc = "Anyone can call this function about any potentially dislocated account."] # [doc = ""] # [doc = "Will always update the stored score of `dislocated` to the correct score, based on"] # [doc = "`ScoreProvider`."] # [doc = ""] # [doc = "If `dislocated` does not exists, it returns an error."] rebag { dislocated : :: subxt :: sp_core :: crypto :: AccountId32 , } , # [codec (index = 1)] # [doc = "Move the caller's Id directly in front of `lighter`."] # [doc = ""] # [doc = "The dispatch origin for this call must be _Signed_ and can only be called by the Id of"] # [doc = "the account going in front of `lighter`."] # [doc = ""] # [doc = "Only works if"] # [doc = "- both nodes are within the same bag,"] # [doc = "- and `origin` has a greater `Score` than `lighter`."] put_in_front_of { lighter : :: subxt :: sp_core :: crypto :: AccountId32 , } , } # [derive (:: subxt :: codec :: Decode , :: subxt :: codec :: Encode , Clone , Debug , Eq , PartialEq)] pub enum Error { # [codec (index = 0)] # [doc = "A error in the list interface implementation."] List (runtime_types :: pallet_bags_list :: list :: ListError ,) , } # [derive (:: subxt :: codec :: Decode , :: subxt :: codec :: Encode , Clone , Debug , Eq , PartialEq)] pub enum Event { # [codec (index = 0)] # [doc = "Moved an account from one bag to another."] Rebagged { who : :: subxt :: sp_core :: crypto :: AccountId32 , from : :: core :: primitive :: u64 , to : :: core :: primitive :: u64 , } , # [codec (index = 1)] # [doc = "Updated the score of some account to the given amount."] ScoreUpdated { who : :: subxt :: sp_core :: crypto :: AccountId32 , new_score : :: core :: primitive :: u64 , } , } } } pub mod pallet_balances { use super :: runtime_types ; pub mod pallet { use super :: runtime_types ; # [derive (:: subxt :: codec :: Decode , :: subxt :: codec :: Encode , Clone , Debug , Eq , PartialEq)] pub enum Call { # [codec (index = 0)] # [doc = "Transfer some liquid free balance to another account."] # [doc = ""] # [doc = "`transfer` will set the `FreeBalance` of the sender and receiver."] # [doc = "If the sender's account is below the existential deposit as a result"] # [doc = "of the transfer, the account will be reaped."] # [doc = ""] # [doc = "The dispatch origin for this call must be `Signed` by the transactor."] # [doc = ""] # [doc = "# <weight>"] # [doc = "- Dependent on arguments but not critical, given proper implementations for input config"] # [doc = "  types. See related functions below."] # [doc = "- It contains a limited number of reads and writes internally and no complex"] # [doc = "  computation."] # [doc = ""] # [doc = "Related functions:"] # [doc = ""] # [doc = "  - `ensure_can_withdraw` is always called internally but has a bounded complexity."] # [doc = "  - Transferring balances to accounts that did not exist before will cause"] # [doc = "    `T::OnNewAccount::on_new_account` to be called."] # [doc = "  - Removing enough funds from an account will trigger `T::DustRemoval::on_unbalanced`."] # [doc = "  - `transfer_keep_alive` works the same way as `transfer`, but has an additional check"] # [doc = "    that the transfer will not kill the origin account."] # [doc = "---------------------------------"] # [doc = "- Origin account is already in memory, so no DB operations for them."] # [doc = "# </weight>"] transfer { dest : :: subxt :: sp_runtime :: MultiAddress < :: subxt :: sp_core :: crypto :: AccountId32 , :: core :: primitive :: u32 > , # [codec (compact)] value : :: core :: primitive :: u128 , } , # [codec (index = 1)] # [doc = "Set the balances of a given account."] # [doc = ""] # [doc = "This will alter `FreeBalance` and `ReservedBalance` in storage. it will"] # [doc = "also alter the total issuance of the system (`TotalIssuance`) appropriately."] # [doc = "If the new free or reserved balance is below the existential deposit,"] # [doc = "it will reset the account nonce (`frame_system::AccountNonce`)."] # [doc = ""] # [doc = "The dispatch origin for this call is `root`."] set_balance { who : :: subxt :: sp_runtime :: MultiAddress < :: subxt :: sp_core :: crypto :: AccountId32 , :: core :: primitive :: u32 > , # [codec (compact)] new_free : :: core :: primitive :: u128 , # [codec (compact)] new_reserved : :: core :: primitive :: u128 , } , # [codec (index = 2)] # [doc = "Exactly as `transfer`, except the origin must be root and the source account may be"] # [doc = "specified."] # [doc = "# <weight>"] # [doc = "- Same as transfer, but additional read and write because the source account is not"] # [doc = "  assumed to be in the overlay."] # [doc = "# </weight>"] force_transfer { source : :: subxt :: sp_runtime :: MultiAddress < :: subxt :: sp_core :: crypto :: AccountId32 , :: core :: primitive :: u32 > , dest : :: subxt :: sp_runtime :: MultiAddress < :: subxt :: sp_core :: crypto :: AccountId32 , :: core :: primitive :: u32 > , # [codec (compact)] value : :: core :: primitive :: u128 , } , # [codec (index = 3)] # [doc = "Same as the [`transfer`] call, but with a check that the transfer will not kill the"] # [doc = "origin account."] # [doc = ""] # [doc = "99% of the time you want [`transfer`] instead."] # [doc = ""] # [doc = "[`transfer`]: struct.Pallet.html#method.transfer"] transfer_keep_alive { dest : :: subxt :: sp_runtime :: MultiAddress < :: subxt :: sp_core :: crypto :: AccountId32 , :: core :: primitive :: u32 > , # [codec (compact)] value : :: core :: primitive :: u128 , } , # [codec (index = 4)] # [doc = "Transfer the entire transferable balance from the caller account."] # [doc = ""] # [doc = "NOTE: This function only attempts to transfer _transferable_ balances. This means that"] # [doc = "any locked, reserved, or existential deposits (when `keep_alive` is `true`), will not be"] # [doc = "transferred by this function. To ensure that this function results in a killed account,"] # [doc = "you might need to prepare the account by removing any reference counters, storage"] # [doc = "deposits, etc..."] # [doc = ""] # [doc = "The dispatch origin of this call must be Signed."] # [doc = ""] # [doc = "- `dest`: The recipient of the transfer."] # [doc = "- `keep_alive`: A boolean to determine if the `transfer_all` operation should send all"] # [doc = "  of the funds the account has, causing the sender account to be killed (false), or"] # [doc = "  transfer everything except at least the existential deposit, which will guarantee to"] # [doc = "  keep the sender account alive (true). # <weight>"] # [doc = "- O(1). Just like transfer, but reading the user's transferable balance first."] # [doc = "  #</weight>"] transfer_all { dest : :: subxt :: sp_runtime :: MultiAddress < :: subxt :: sp_core :: crypto :: AccountId32 , :: core :: primitive :: u32 > , keep_alive : :: core :: primitive :: bool , } , # [codec (index = 5)] # [doc = "Unreserve some balance from a user by force."] # [doc = ""] # [doc = "Can only be called by ROOT."] force_unreserve { who : :: subxt :: sp_runtime :: MultiAddress < :: subxt :: sp_core :: crypto :: AccountId32 , :: core :: primitive :: u32 > , amount : :: core :: primitive :: u128 , } , } # [derive (:: subxt :: codec :: Decode , :: subxt :: codec :: Encode , Clone , Debug , Eq , PartialEq)] pub enum Error { # [codec (index = 0)] # [doc = "Vesting balance too high to send value"] VestingBalance , # [codec (index = 1)] # [doc = "Account liquidity restrictions prevent withdrawal"] LiquidityRestrictions , # [codec (index = 2)] # [doc = "Balance too low to send value"] InsufficientBalance , # [codec (index = 3)] # [doc = "Value too low to create account due to existential deposit"] ExistentialDeposit , # [codec (index = 4)] # [doc = "Transfer/payment would kill account"] KeepAlive , # [codec (index = 5)] # [doc = "A vesting schedule already exists for this account"] ExistingVestingSchedule , # [codec (index = 6)] # [doc = "Beneficiary account must pre-exist"] DeadAccount , # [codec (index = 7)] # [doc = "Number of named reserves exceed MaxReserves"] TooManyReserves , } # [derive (:: subxt :: codec :: Decode , :: subxt :: codec :: Encode , Clone , Debug , Eq , PartialEq)] pub enum Event { # [codec (index = 0)] # [doc = "An account was created with some free balance."] Endowed { account : :: subxt :: sp_core :: crypto :: AccountId32 , free_balance : :: core :: primitive :: u128 , } , # [codec (index = 1)] # [doc = "An account was removed whose balance was non-zero but below ExistentialDeposit,"] # [doc = "resulting in an outright loss."] DustLost { account : :: subxt :: sp_core :: crypto :: AccountId32 , amount : :: core :: primitive :: u128 , } , # [codec (index = 2)] # [doc = "Transfer succeeded."] Transfer { from : :: subxt :: sp_core :: crypto :: AccountId32 , to : :: subxt :: sp_core :: crypto :: AccountId32 , amount : :: core :: primitive :: u128 , } , # [codec (index = 3)] # [doc = "A balance was set by root."] BalanceSet { who : :: subxt :: sp_core :: crypto :: AccountId32 , free : :: core :: primitive :: u128 , reserved : :: core :: primitive :: u128 , } , # [codec (index = 4)] # [doc = "Some balance was reserved (moved from free to reserved)."] Reserved { who : :: subxt :: sp_core :: crypto :: AccountId32 , amount : :: core :: primitive :: u128 , } , # [codec (index = 5)] # [doc = "Some balance was unreserved (moved from reserved to free)."] Unreserved { who : :: subxt :: sp_core :: crypto :: AccountId32 , amount : :: core :: primitive :: u128 , } , # [codec (index = 6)] # [doc = "Some balance was moved from the reserve of the first account to the second account."] # [doc = "Final argument indicates the destination balance type."] ReserveRepatriated { from : :: subxt :: sp_core :: crypto :: AccountId32 , to : :: subxt :: sp_core :: crypto :: AccountId32 , amount : :: core :: primitive :: u128 , destination_status : runtime_types :: frame_support :: traits :: tokens :: misc :: BalanceStatus , } , # [codec (index = 7)] # [doc = "Some amount was deposited (e.g. for transaction fees)."] Deposit { who : :: subxt :: sp_core :: crypto :: AccountId32 , amount : :: core :: primitive :: u128 , } , # [codec (index = 8)] # [doc = "Some amount was withdrawn from the account (e.g. for transaction fees)."] Withdraw { who : :: subxt :: sp_core :: crypto :: AccountId32 , amount : :: core :: primitive :: u128 , } , # [codec (index = 9)] # [doc = "Some amount was removed from the account (e.g. for misbehavior)."] Slashed { who : :: subxt :: sp_core :: crypto :: AccountId32 , amount : :: core :: primitive :: u128 , } , } } # [derive (:: subxt :: codec :: Decode , :: subxt :: codec :: Encode , Clone , Debug , Eq , PartialEq)] pub struct AccountData < _0 > { pub free : _0 , pub reserved : _0 , pub misc_frozen : _0 , pub fee_frozen : _0 , } # [derive (:: subxt :: codec :: Decode , :: subxt :: codec :: Encode , Clone , Debug , Eq , PartialEq)] pub struct BalanceLock < _0 > { pub id : [:: core :: primitive :: u8 ; 8usize] , pub amount : _0 , pub reasons : runtime_types :: pallet_balances :: Reasons , } # [derive (:: subxt :: codec :: Decode , :: subxt :: codec :: Encode , Clone , Debug , Eq , PartialEq)] pub enum Reasons { # [codec (index = 0)] Fee , # [codec (index = 1)] Misc , # [codec (index = 2)] All , } # [derive (:: subxt :: codec :: Decode , :: subxt :: codec :: Encode , Clone , Debug , Eq , PartialEq)] pub enum Releases { # [codec (index = 0)] V1_0_0 , # [codec (index = 1)] V2_0_0 , } # [derive (:: subxt :: codec :: Decode , :: subxt :: codec :: Encode , Clone , Debug , Eq , PartialEq)] pub struct ReserveData < _0 , _1 > { pub id : _0 , pub amount : _1 , } } pub mod pallet_bounties { use super :: runtime_types ; pub mod pallet { use super :: runtime_types ; # [derive (:: subxt :: codec :: Decode , :: subxt :: codec :: Encode , Clone , Debug , Eq , PartialEq)] pub enum Call { # [codec (index = 0)] # [doc = "Propose a new bounty."] # [doc = ""] # [doc = "The dispatch origin for this call must be _Signed_."] # [doc = ""] # [doc = "Payment: `TipReportDepositBase` will be reserved from the origin account, as well as"] # [doc = "`DataDepositPerByte` for each byte in `reason`. It will be unreserved upon approval,"] # [doc = "or slashed when rejected."] # [doc = ""] # [doc = "- `curator`: The curator account whom will manage this bounty."] # [doc = "- `fee`: The curator fee."] # [doc = "- `value`: The total payment amount of this bounty, curator fee included."] # [doc = "- `description`: The description of this bounty."] propose_bounty { # [codec (compact)] value : :: core :: primitive :: u128 , description : :: std :: vec :: Vec < :: core :: primitive :: u8 > , } , # [codec (index = 1)] # [doc = "Approve a bounty proposal. At a later time, the bounty will be funded and become active"] # [doc = "and the original deposit will be returned."] # [doc = ""] # [doc = "May only be called from `T::ApproveOrigin`."] # [doc = ""] # [doc = "# <weight>"] # [doc = "- O(1)."] # [doc = "# </weight>"] approve_bounty { # [codec (compact)] bounty_id : :: core :: primitive :: u32 , } , # [codec (index = 2)] # [doc = "Assign a curator to a funded bounty."] # [doc = ""] # [doc = "May only be called from `T::ApproveOrigin`."] # [doc = ""] # [doc = "# <weight>"] # [doc = "- O(1)."] # [doc = "# </weight>"] propose_curator { # [codec (compact)] bounty_id : :: core :: primitive :: u32 , curator : :: subxt :: sp_runtime :: MultiAddress < :: subxt :: sp_core :: crypto :: AccountId32 , :: core :: primitive :: u32 > , # [codec (compact)] fee : :: core :: primitive :: u128 , } , # [codec (index = 3)] # [doc = "Unassign curator from a bounty."] # [doc = ""] # [doc = "This function can only be called by the `RejectOrigin` a signed origin."] # [doc = ""] # [doc = "If this function is called by the `RejectOrigin`, we assume that the curator is"] # [doc = "malicious or inactive. As a result, we will slash the curator when possible."] # [doc = ""] # [doc = "If the origin is the curator, we take this as a sign they are unable to do their job and"] # [doc = "they willingly give up. We could slash them, but for now we allow them to recover their"] # [doc = "deposit and exit without issue. (We may want to change this if it is abused.)"] # [doc = ""] # [doc = "Finally, the origin can be anyone if and only if the curator is \"inactive\". This allows"] # [doc = "anyone in the community to call out that a curator is not doing their due diligence, and"] # [doc = "we should pick a new curator. In this case the curator should also be slashed."] # [doc = ""] # [doc = "# <weight>"] # [doc = "- O(1)."] # [doc = "# </weight>"] unassign_curator { # [codec (compact)] bounty_id : :: core :: primitive :: u32 , } , # [codec (index = 4)] # [doc = "Accept the curator role for a bounty."] # [doc = "A deposit will be reserved from curator and refund upon successful payout."] # [doc = ""] # [doc = "May only be called from the curator."] # [doc = ""] # [doc = "# <weight>"] # [doc = "- O(1)."] # [doc = "# </weight>"] accept_curator { # [codec (compact)] bounty_id : :: core :: primitive :: u32 , } , # [codec (index = 5)] # [doc = "Award bounty to a beneficiary account. The beneficiary will be able to claim the funds"] # [doc = "after a delay."] # [doc = ""] # [doc = "The dispatch origin for this call must be the curator of this bounty."] # [doc = ""] # [doc = "- `bounty_id`: Bounty ID to award."] # [doc = "- `beneficiary`: The beneficiary account whom will receive the payout."] # [doc = ""] # [doc = "# <weight>"] # [doc = "- O(1)."] # [doc = "# </weight>"] award_bounty { # [codec (compact)] bounty_id : :: core :: primitive :: u32 , beneficiary : :: subxt :: sp_runtime :: MultiAddress < :: subxt :: sp_core :: crypto :: AccountId32 , :: core :: primitive :: u32 > , } , # [codec (index = 6)] # [doc = "Claim the payout from an awarded bounty after payout delay."] # [doc = ""] # [doc = "The dispatch origin for this call must be the beneficiary of this bounty."] # [doc = ""] # [doc = "- `bounty_id`: Bounty ID to claim."] # [doc = ""] # [doc = "# <weight>"] # [doc = "- O(1)."] # [doc = "# </weight>"] claim_bounty { # [codec (compact)] bounty_id : :: core :: primitive :: u32 , } , # [codec (index = 7)] # [doc = "Cancel a proposed or active bounty. All the funds will be sent to treasury and"] # [doc = "the curator deposit will be unreserved if possible."] # [doc = ""] # [doc = "Only `T::RejectOrigin` is able to cancel a bounty."] # [doc = ""] # [doc = "- `bounty_id`: Bounty ID to cancel."] # [doc = ""] # [doc = "# <weight>"] # [doc = "- O(1)."] # [doc = "# </weight>"] close_bounty { # [codec (compact)] bounty_id : :: core :: primitive :: u32 , } , # [codec (index = 8)] # [doc = "Extend the expiry time of an active bounty."] # [doc = ""] # [doc = "The dispatch origin for this call must be the curator of this bounty."] # [doc = ""] # [doc = "- `bounty_id`: Bounty ID to extend."] # [doc = "- `remark`: additional information."] # [doc = ""] # [doc = "# <weight>"] # [doc = "- O(1)."] # [doc = "# </weight>"] extend_bounty_expiry { # [codec (compact)] bounty_id : :: core :: primitive :: u32 , remark : :: std :: vec :: Vec < :: core :: primitive :: u8 > , } , } # [derive (:: subxt :: codec :: Decode , :: subxt :: codec :: Encode , Clone , Debug , Eq , PartialEq)] pub enum Error { # [codec (index = 0)] # [doc = "Proposer's balance is too low."] InsufficientProposersBalance , # [codec (index = 1)] # [doc = "No proposal or bounty at that index."] InvalidIndex , # [codec (index = 2)] # [doc = "The reason given is just too big."] ReasonTooBig , # [codec (index = 3)] # [doc = "The bounty status is unexpected."] UnexpectedStatus , # [codec (index = 4)] # [doc = "Require bounty curator."] RequireCurator , # [codec (index = 5)] # [doc = "Invalid bounty value."] InvalidValue , # [codec (index = 6)] # [doc = "Invalid bounty fee."] InvalidFee , # [codec (index = 7)] # [doc = "A bounty payout is pending."] # [doc = "To cancel the bounty, you must unassign and slash the curator."] PendingPayout , # [codec (index = 8)] # [doc = "The bounties cannot be claimed/closed because it's still in the countdown period."] Premature , # [codec (index = 9)] # [doc = "The bounty cannot be closed because it has active child bounties."] HasActiveChildBounty , # [codec (index = 10)] # [doc = "Too many approvals are already queued."] TooManyQueued , } # [derive (:: subxt :: codec :: Decode , :: subxt :: codec :: Encode , Clone , Debug , Eq , PartialEq)] pub enum Event { # [codec (index = 0)] # [doc = "New bounty proposal."] BountyProposed { index : :: core :: primitive :: u32 , } , # [codec (index = 1)] # [doc = "A bounty proposal was rejected; funds were slashed."] BountyRejected { index : :: core :: primitive :: u32 , bond : :: core :: primitive :: u128 , } , # [codec (index = 2)] # [doc = "A bounty proposal is funded and became active."] BountyBecameActive { index : :: core :: primitive :: u32 , } , # [codec (index = 3)] # [doc = "A bounty is awarded to a beneficiary."] BountyAwarded { index : :: core :: primitive :: u32 , beneficiary : :: subxt :: sp_core :: crypto :: AccountId32 , } , # [codec (index = 4)] # [doc = "A bounty is claimed by beneficiary."] BountyClaimed { index : :: core :: primitive :: u32 , payout : :: core :: primitive :: u128 , beneficiary : :: subxt :: sp_core :: crypto :: AccountId32 , } , # [codec (index = 5)] # [doc = "A bounty is cancelled."] BountyCanceled { index : :: core :: primitive :: u32 , } , # [codec (index = 6)] # [doc = "A bounty expiry is extended."] BountyExtended { index : :: core :: primitive :: u32 , } , } } # [derive (:: subxt :: codec :: Decode , :: subxt :: codec :: Encode , Clone , Debug , Eq , PartialEq)] pub struct Bounty < _0 , _1 , _2 > { pub proposer : _0 , pub value : _1 , pub fee : _1 , pub curator_deposit : _1 , pub bond : _1 , pub status : runtime_types :: pallet_bounties :: BountyStatus < _0 , _2 > , } # [derive (:: subxt :: codec :: Decode , :: subxt :: codec :: Encode , Clone , Debug , Eq , PartialEq)] pub enum BountyStatus < _0 , _1 > { # [codec (index = 0)] Proposed , # [codec (index = 1)] Approved , # [codec (index = 2)] Funded , # [codec (index = 3)] CuratorProposed { curator : _0 , } , # [codec (index = 4)] Active { curator : _0 , update_due : _1 , } , # [codec (index = 5)] PendingPayout { curator : _0 , beneficiary : _0 , unlock_at : _1 , } , } } pub mod pallet_bridge { use super :: runtime_types ; pub mod pallet { use super :: runtime_types ; # [derive (:: subxt :: codec :: Decode , :: subxt :: codec :: Encode , Clone , Debug , Eq , PartialEq)] pub enum Call { # [codec (index = 0)] # [doc = "Sets the vote threshold for proposals."] # [doc = ""] # [doc = "This threshold is used to determine how many votes are required"] # [doc = "before a proposal is executed."] # [doc = ""] # [doc = "# <weight>"] # [doc = "- O(1) lookup and insert"] # [doc = "# </weight>"] set_threshold { threshold : :: core :: primitive :: u32 , } , # [codec (index = 1)] # [doc = "Stores a method name on chain under an associated resource ID."] # [doc = ""] # [doc = "# <weight>"] # [doc = "- O(1) write"] # [doc = "# </weight>"] set_resource { id : [:: core :: primitive :: u8 ; 32usize] , method : :: std :: vec :: Vec < :: core :: primitive :: u8 > , } , # [codec (index = 2)] # [doc = "Removes a resource ID from the resource mapping."] # [doc = ""] # [doc = "After this call, bridge transfers with the associated resource ID"] # [doc = "will be rejected."] # [doc = ""] # [doc = "# <weight>"] # [doc = "- O(1) removal"] # [doc = "# </weight>"] remove_resource { id : [:: core :: primitive :: u8 ; 32usize] , } , # [codec (index = 3)] # [doc = "Enables a chain ID as a source or destination for a bridge transfer."] # [doc = ""] # [doc = "# <weight>"] # [doc = "- O(1) lookup and insert"] # [doc = "# </weight>"] whitelist_chain { id : :: core :: primitive :: u64 , } , # [codec (index = 4)] # [doc = "Adds a new relayer to the relayer set."] # [doc = ""] # [doc = "# <weight>"] # [doc = "- O(1) lookup and insert"] # [doc = "# </weight>"] add_relayer { v : :: subxt :: sp_core :: crypto :: AccountId32 , } , # [codec (index = 5)] # [doc = "Removes an existing relayer from the set."] # [doc = ""] # [doc = "# <weight>"] # [doc = "- O(1) lookup and removal"] # [doc = "# </weight>"] remove_relayer { v : :: subxt :: sp_core :: crypto :: AccountId32 , } , # [codec (index = 6)] # [doc = "Commits a vote in favour of the provided proposal."] # [doc = ""] # [doc = "If a proposal with the given nonce and source chain ID does not"] # [doc = "already exist, it will be created with an initial vote in favour"] # [doc = "from the caller."] # [doc = ""] # [doc = "# <weight>"] # [doc = "- weight of proposed call, regardless of whether execution is performed"] # [doc = "# </weight>"] acknowledge_proposal { nonce : :: core :: primitive :: u64 , src_id : :: core :: primitive :: u64 , r_id : [:: core :: primitive :: u8 ; 32usize] , call : :: std :: boxed :: Box < runtime_types :: egg_standalone_runtime :: Call > , } , # [codec (index = 7)] # [doc = "Commits a vote against a provided proposal."] # [doc = ""] # [doc = "# <weight>"] # [doc = "- Fixed, since execution of proposal should not be included"] # [doc = "# </weight>"] reject_proposal { nonce : :: core :: primitive :: u64 , src_id : :: core :: primitive :: u64 , r_id : [:: core :: primitive :: u8 ; 32usize] , call : :: std :: boxed :: Box < runtime_types :: egg_standalone_runtime :: Call > , } , # [codec (index = 8)] # [doc = "Evaluate the state of a proposal given the current vote threshold."] # [doc = ""] # [doc = "A proposal with enough votes will be either executed or cancelled,"] # [doc = "and the status will be updated accordingly."] # [doc = ""] # [doc = "# <weight>"] # [doc = "- weight of proposed call, regardless of whether execution is performed"] # [doc = "# </weight>"] eval_vote_state { nonce : :: core :: primitive :: u64 , src_id : :: core :: primitive :: u64 , prop : :: std :: boxed :: Box < runtime_types :: egg_standalone_runtime :: Call > , } , } # [derive (:: subxt :: codec :: Decode , :: subxt :: codec :: Encode , Clone , Debug , Eq , PartialEq)] pub enum Error { # [codec (index = 0)] # [doc = "Account does not have correct permissions"] InvalidPermissions , # [codec (index = 1)] # [doc = "Relayer threshold not set"] ThresholdNotSet , # [codec (index = 2)] # [doc = "Provided chain Id is not valid"] InvalidChainId , # [codec (index = 3)] # [doc = "Relayer threshold cannot be 0"] InvalidThreshold , # [codec (index = 4)] # [doc = "Interactions with this chain is not permitted"] ChainNotWhitelisted , # [codec (index = 5)] # [doc = "Chain has already been enabled"] ChainAlreadyWhitelisted , # [codec (index = 6)] # [doc = "Resource ID provided isn't mapped to anything"] ResourceDoesNotExist , # [codec (index = 7)] # [doc = "Relayer already in set"] RelayerAlreadyExists , # [codec (index = 8)] # [doc = "Provided accountId is not a relayer"] RelayerInvalid , # [codec (index = 9)] # [doc = "Protected operation, must be performed by relayer"] MustBeRelayer , # [codec (index = 10)] # [doc = "Relayer has already submitted some vote for this proposal"] RelayerAlreadyVoted , # [codec (index = 11)] # [doc = "A proposal with these parameters has already been submitted"] ProposalAlreadyExists , # [codec (index = 12)] # [doc = "No proposal with the ID was found"] ProposalDoesNotExist , # [codec (index = 13)] # [doc = "Cannot complete proposal, needs more votes"] ProposalNotComplete , # [codec (index = 14)] # [doc = "Proposal has either failed or succeeded"] ProposalAlreadyComplete , # [codec (index = 15)] # [doc = "Lifetime of proposal has been exceeded"] ProposalExpired , } # [derive (:: subxt :: codec :: Decode , :: subxt :: codec :: Encode , Clone , Debug , Eq , PartialEq)] pub enum Event { # [codec (index = 0)] # [doc = "Vote threshold has changed (new_threshold)"] RelayerThresholdChanged { new_threshold : :: core :: primitive :: u32 , } , # [codec (index = 1)] # [doc = "Chain now available for transfers (chain_id)"] ChainWhitelisted { chain_id : :: core :: primitive :: u64 , } , # [codec (index = 2)] # [doc = "Relayer added to set"] RelayerAdded { relayer_id : :: subxt :: sp_core :: crypto :: AccountId32 , } , # [codec (index = 3)] # [doc = "Relayer removed from set"] RelayerRemoved { relayer_id : :: subxt :: sp_core :: crypto :: AccountId32 , } , # [codec (index = 4)] # [doc = "Vote submitted in favour of proposal"] VoteFor { chain_id : :: core :: primitive :: u64 , deposit_nonce : :: core :: primitive :: u64 , who : :: subxt :: sp_core :: crypto :: AccountId32 , } , # [codec (index = 5)] # [doc = "Vot submitted against proposal"] VoteAgainst { chain_id : :: core :: primitive :: u64 , deposit_nonce : :: core :: primitive :: u64 , who : :: subxt :: sp_core :: crypto :: AccountId32 , } , # [codec (index = 6)] # [doc = "Voting successful for a proposal"] ProposalApproved { chain_id : :: core :: primitive :: u64 , deposit_nonce : :: core :: primitive :: u64 , } , # [codec (index = 7)] # [doc = "Voting rejected a proposal"] ProposalRejected { chain_id : :: core :: primitive :: u64 , deposit_nonce : :: core :: primitive :: u64 , } , # [codec (index = 8)] # [doc = "Execution of call succeeded"] ProposalSucceeded { chain_id : :: core :: primitive :: u64 , deposit_nonce : :: core :: primitive :: u64 , } , # [codec (index = 9)] # [doc = "Execution of call failed"] ProposalFailed { chain_id : :: core :: primitive :: u64 , deposit_nonce : :: core :: primitive :: u64 , } , } } pub mod types { use super :: runtime_types ; # [derive (:: subxt :: codec :: Decode , :: subxt :: codec :: Encode , Clone , Debug , Eq , PartialEq)] pub enum ProposalStatus { # [codec (index = 0)] Initiated , # [codec (index = 1)] Approved , # [codec (index = 2)] Rejected , } # [derive (:: subxt :: codec :: Decode , :: subxt :: codec :: Encode , Clone , Debug , Eq , PartialEq)] pub struct ProposalVotes < _0 , _1 > { pub votes_for : :: std :: vec :: Vec < _0 > , pub votes_against : :: std :: vec :: Vec < _0 > , pub status : runtime_types :: pallet_bridge :: types :: ProposalStatus , pub expiry : _1 , } } } pub mod pallet_child_bounties { use super :: runtime_types ; pub mod pallet { use super :: runtime_types ; # [derive (:: subxt :: codec :: Decode , :: subxt :: codec :: Encode , Clone , Debug , Eq , PartialEq)] pub enum Call { # [codec (index = 0)] # [doc = "Add a new child-bounty."] # [doc = ""] # [doc = "The dispatch origin for this call must be the curator of parent"] # [doc = "bounty and the parent bounty must be in \"active\" state."] # [doc = ""] # [doc = "Child-bounty gets added successfully & fund gets transferred from"] # [doc = "parent bounty to child-bounty account, if parent bounty has enough"] # [doc = "funds, else the call fails."] # [doc = ""] # [doc = "Upper bound to maximum number of active  child bounties that can be"] # [doc = "added are managed via runtime trait config"] # [doc = "[`Config::MaxActiveChildBountyCount`]."] # [doc = ""] # [doc = "If the call is success, the status of child-bounty is updated to"] # [doc = "\"Added\"."] # [doc = ""] # [doc = "- `parent_bounty_id`: Index of parent bounty for which child-bounty is being added."] # [doc = "- `value`: Value for executing the proposal."] # [doc = "- `description`: Text description for the child-bounty."] add_child_bounty { # [codec (compact)] parent_bounty_id : :: core :: primitive :: u32 , # [codec (compact)] value : :: core :: primitive :: u128 , description : :: std :: vec :: Vec < :: core :: primitive :: u8 > , } , # [codec (index = 1)] # [doc = "Propose curator for funded child-bounty."] # [doc = ""] # [doc = "The dispatch origin for this call must be curator of parent bounty."] # [doc = ""] # [doc = "Parent bounty must be in active state, for this child-bounty call to"] # [doc = "work."] # [doc = ""] # [doc = "Child-bounty must be in \"Added\" state, for processing the call. And"] # [doc = "state of child-bounty is moved to \"CuratorProposed\" on successful"] # [doc = "call completion."] # [doc = ""] # [doc = "- `parent_bounty_id`: Index of parent bounty."] # [doc = "- `child_bounty_id`: Index of child bounty."] # [doc = "- `curator`: Address of child-bounty curator."] # [doc = "- `fee`: payment fee to child-bounty curator for execution."] propose_curator { # [codec (compact)] parent_bounty_id : :: core :: primitive :: u32 , # [codec (compact)] child_bounty_id : :: core :: primitive :: u32 , curator : :: subxt :: sp_runtime :: MultiAddress < :: subxt :: sp_core :: crypto :: AccountId32 , :: core :: primitive :: u32 > , # [codec (compact)] fee : :: core :: primitive :: u128 , } , # [codec (index = 2)] # [doc = "Accept the curator role for the child-bounty."] # [doc = ""] # [doc = "The dispatch origin for this call must be the curator of this"] # [doc = "child-bounty."] # [doc = ""] # [doc = "A deposit will be reserved from the curator and refund upon"] # [doc = "successful payout or cancellation."] # [doc = ""] # [doc = "Fee for curator is deducted from curator fee of parent bounty."] # [doc = ""] # [doc = "Parent bounty must be in active state, for this child-bounty call to"] # [doc = "work."] # [doc = ""] # [doc = "Child-bounty must be in \"CuratorProposed\" state, for processing the"] # [doc = "call. And state of child-bounty is moved to \"Active\" on successful"] # [doc = "call completion."] # [doc = ""] # [doc = "- `parent_bounty_id`: Index of parent bounty."] # [doc = "- `child_bounty_id`: Index of child bounty."] accept_curator { # [codec (compact)] parent_bounty_id : :: core :: primitive :: u32 , # [codec (compact)] child_bounty_id : :: core :: primitive :: u32 , } , # [codec (index = 3)] # [doc = "Unassign curator from a child-bounty."] # [doc = ""] # [doc = "The dispatch origin for this call can be either `RejectOrigin`, or"] # [doc = "the curator of the parent bounty, or any signed origin."] # [doc = ""] # [doc = "For the origin other than T::RejectOrigin and the child-bounty"] # [doc = "curator, parent bounty must be in active state, for this call to"] # [doc = "work. We allow child-bounty curator and T::RejectOrigin to execute"] # [doc = "this call irrespective of the parent bounty state."] # [doc = ""] # [doc = "If this function is called by the `RejectOrigin` or the"] # [doc = "parent bounty curator, we assume that the child-bounty curator is"] # [doc = "malicious or inactive. As a result, child-bounty curator deposit is"] # [doc = "slashed."] # [doc = ""] # [doc = "If the origin is the child-bounty curator, we take this as a sign"] # [doc = "that they are unable to do their job, and are willingly giving up."] # [doc = "We could slash the deposit, but for now we allow them to unreserve"] # [doc = "their deposit and exit without issue. (We may want to change this if"] # [doc = "it is abused.)"] # [doc = ""] # [doc = "Finally, the origin can be anyone iff the child-bounty curator is"] # [doc = "\"inactive\". Expiry update due of parent bounty is used to estimate"] # [doc = "inactive state of child-bounty curator."] # [doc = ""] # [doc = "This allows anyone in the community to call out that a child-bounty"] # [doc = "curator is not doing their due diligence, and we should pick a new"] # [doc = "one. In this case the child-bounty curator deposit is slashed."] # [doc = ""] # [doc = "State of child-bounty is moved to Added state on successful call"] # [doc = "completion."] # [doc = ""] # [doc = "- `parent_bounty_id`: Index of parent bounty."] # [doc = "- `child_bounty_id`: Index of child bounty."] unassign_curator { # [codec (compact)] parent_bounty_id : :: core :: primitive :: u32 , # [codec (compact)] child_bounty_id : :: core :: primitive :: u32 , } , # [codec (index = 4)] # [doc = "Award child-bounty to a beneficiary."] # [doc = ""] # [doc = "The beneficiary will be able to claim the funds after a delay."] # [doc = ""] # [doc = "The dispatch origin for this call must be the parent curator or"] # [doc = "curator of this child-bounty."] # [doc = ""] # [doc = "Parent bounty must be in active state, for this child-bounty call to"] # [doc = "work."] # [doc = ""] # [doc = "Child-bounty must be in active state, for processing the call. And"] # [doc = "state of child-bounty is moved to \"PendingPayout\" on successful call"] # [doc = "completion."] # [doc = ""] # [doc = "- `parent_bounty_id`: Index of parent bounty."] # [doc = "- `child_bounty_id`: Index of child bounty."] # [doc = "- `beneficiary`: Beneficiary account."] award_child_bounty { # [codec (compact)] parent_bounty_id : :: core :: primitive :: u32 , # [codec (compact)] child_bounty_id : :: core :: primitive :: u32 , beneficiary : :: subxt :: sp_runtime :: MultiAddress < :: subxt :: sp_core :: crypto :: AccountId32 , :: core :: primitive :: u32 > , } , # [codec (index = 5)] # [doc = "Claim the payout from an awarded child-bounty after payout delay."] # [doc = ""] # [doc = "The dispatch origin for this call may be any signed origin."] # [doc = ""] # [doc = "Call works independent of parent bounty state, No need for parent"] # [doc = "bounty to be in active state."] # [doc = ""] # [doc = "The Beneficiary is paid out with agreed bounty value. Curator fee is"] # [doc = "paid & curator deposit is unreserved."] # [doc = ""] # [doc = "Child-bounty must be in \"PendingPayout\" state, for processing the"] # [doc = "call. And instance of child-bounty is removed from the state on"] # [doc = "successful call completion."] # [doc = ""] # [doc = "- `parent_bounty_id`: Index of parent bounty."] # [doc = "- `child_bounty_id`: Index of child bounty."] claim_child_bounty { # [codec (compact)] parent_bounty_id : :: core :: primitive :: u32 , # [codec (compact)] child_bounty_id : :: core :: primitive :: u32 , } , # [codec (index = 6)] # [doc = "Cancel a proposed or active child-bounty. Child-bounty account funds"] # [doc = "are transferred to parent bounty account. The child-bounty curator"] # [doc = "deposit may be unreserved if possible."] # [doc = ""] # [doc = "The dispatch origin for this call must be either parent curator or"] # [doc = "`T::RejectOrigin`."] # [doc = ""] # [doc = "If the state of child-bounty is `Active`, curator deposit is"] # [doc = "unreserved."] # [doc = ""] # [doc = "If the state of child-bounty is `PendingPayout`, call fails &"] # [doc = "returns `PendingPayout` error."] # [doc = ""] # [doc = "For the origin other than T::RejectOrigin, parent bounty must be in"] # [doc = "active state, for this child-bounty call to work. For origin"] # [doc = "T::RejectOrigin execution is forced."] # [doc = ""] # [doc = "Instance of child-bounty is removed from the state on successful"] # [doc = "call completion."] # [doc = ""] # [doc = "- `parent_bounty_id`: Index of parent bounty."] # [doc = "- `child_bounty_id`: Index of child bounty."] close_child_bounty { # [codec (compact)] parent_bounty_id : :: core :: primitive :: u32 , # [codec (compact)] child_bounty_id : :: core :: primitive :: u32 , } , } # [derive (:: subxt :: codec :: Decode , :: subxt :: codec :: Encode , Clone , Debug , Eq , PartialEq)] pub enum Error { # [codec (index = 0)] # [doc = "The parent bounty is not in active state."] ParentBountyNotActive , # [codec (index = 1)] # [doc = "The bounty balance is not enough to add new child-bounty."] InsufficientBountyBalance , # [codec (index = 2)] # [doc = "Number of child bounties exceeds limit `MaxActiveChildBountyCount`."] TooManyChildBounties , } # [derive (:: subxt :: codec :: Decode , :: subxt :: codec :: Encode , Clone , Debug , Eq , PartialEq)] pub enum Event { # [codec (index = 0)] # [doc = "A child-bounty is added."] Added { index : :: core :: primitive :: u32 , child_index : :: core :: primitive :: u32 , } , # [codec (index = 1)] # [doc = "A child-bounty is awarded to a beneficiary."] Awarded { index : :: core :: primitive :: u32 , child_index : :: core :: primitive :: u32 , beneficiary : :: subxt :: sp_core :: crypto :: AccountId32 , } , # [codec (index = 2)] # [doc = "A child-bounty is claimed by beneficiary."] Claimed { index : :: core :: primitive :: u32 , child_index : :: core :: primitive :: u32 , payout : :: core :: primitive :: u128 , beneficiary : :: subxt :: sp_core :: crypto :: AccountId32 , } , # [codec (index = 3)] # [doc = "A child-bounty is cancelled."] Canceled { index : :: core :: primitive :: u32 , child_index : :: core :: primitive :: u32 , } , } } # [derive (:: subxt :: codec :: Decode , :: subxt :: codec :: Encode , Clone , Debug , Eq , PartialEq)] pub struct ChildBounty < _0 , _1 , _2 > { pub parent_bounty : _2 , pub value : _1 , pub fee : _1 , pub curator_deposit : _1 , pub status : runtime_types :: pallet_child_bounties :: ChildBountyStatus < _0 , _2 > , } # [derive (:: subxt :: codec :: Decode , :: subxt :: codec :: Encode , Clone , Debug , Eq , PartialEq)] pub enum ChildBountyStatus < _0 , _1 > { # [codec (index = 0)] Added , # [codec (index = 1)] CuratorProposed { curator : _0 , } , # [codec (index = 2)] Active { curator : _0 , } , # [codec (index = 3)] PendingPayout { curator : _0 , beneficiary : _0 , unlock_at : _1 , } , } } pub mod pallet_collective { use super :: runtime_types ; pub mod pallet { use super :: runtime_types ; # [derive (:: subxt :: codec :: Decode , :: subxt :: codec :: Encode , Clone , Debug , Eq , PartialEq)] pub enum Call { # [codec (index = 0)] # [doc = "Set the collective's membership."] # [doc = ""] # [doc = "- `new_members`: The new member list. Be nice to the chain and provide it sorted."] # [doc = "- `prime`: The prime member whose vote sets the default."] # [doc = "- `old_count`: The upper bound for the previous number of members in storage. Used for"] # [doc = "  weight estimation."] # [doc = ""] # [doc = "Requires root origin."] # [doc = ""] # [doc = "NOTE: Does not enforce the expected `MaxMembers` limit on the amount of members, but"] # [doc = "      the weight estimations rely on it to estimate dispatchable weight."] # [doc = ""] # [doc = "# WARNING:"] # [doc = ""] # [doc = "The `pallet-collective` can also be managed by logic outside of the pallet through the"] # [doc = "implementation of the trait [`ChangeMembers`]."] # [doc = "Any call to `set_members` must be careful that the member set doesn't get out of sync"] # [doc = "with other logic managing the member set."] # [doc = ""] # [doc = "# <weight>"] # [doc = "## Weight"] # [doc = "- `O(MP + N)` where:"] # [doc = "  - `M` old-members-count (code- and governance-bounded)"] # [doc = "  - `N` new-members-count (code- and governance-bounded)"] # [doc = "  - `P` proposals-count (code-bounded)"] # [doc = "- DB:"] # [doc = "  - 1 storage mutation (codec `O(M)` read, `O(N)` write) for reading and writing the"] # [doc = "    members"] # [doc = "  - 1 storage read (codec `O(P)`) for reading the proposals"] # [doc = "  - `P` storage mutations (codec `O(M)`) for updating the votes for each proposal"] # [doc = "  - 1 storage write (codec `O(1)`) for deleting the old `prime` and setting the new one"] # [doc = "# </weight>"] set_members { new_members : :: std :: vec :: Vec < :: subxt :: sp_core :: crypto :: AccountId32 > , prime : :: core :: option :: Option < :: subxt :: sp_core :: crypto :: AccountId32 > , old_count : :: core :: primitive :: u32 , } , # [codec (index = 1)] # [doc = "Dispatch a proposal from a member using the `Member` origin."] # [doc = ""] # [doc = "Origin must be a member of the collective."] # [doc = ""] # [doc = "# <weight>"] # [doc = "## Weight"] # [doc = "- `O(M + P)` where `M` members-count (code-bounded) and `P` complexity of dispatching"] # [doc = "  `proposal`"] # [doc = "- DB: 1 read (codec `O(M)`) + DB access of `proposal`"] # [doc = "- 1 event"] # [doc = "# </weight>"] execute { proposal : :: std :: boxed :: Box < runtime_types :: egg_standalone_runtime :: Call > , # [codec (compact)] length_bound : :: core :: primitive :: u32 , } , # [codec (index = 2)] # [doc = "Add a new proposal to either be voted on or executed directly."] # [doc = ""] # [doc = "Requires the sender to be member."] # [doc = ""] # [doc = "`threshold` determines whether `proposal` is executed directly (`threshold < 2`)"] # [doc = "or put up for voting."] # [doc = ""] # [doc = "# <weight>"] # [doc = "## Weight"] # [doc = "- `O(B + M + P1)` or `O(B + M + P2)` where:"] # [doc = "  - `B` is `proposal` size in bytes (length-fee-bounded)"] # [doc = "  - `M` is members-count (code- and governance-bounded)"] # [doc = "  - branching is influenced by `threshold` where:"] # [doc = "    - `P1` is proposal execution complexity (`threshold < 2`)"] # [doc = "    - `P2` is proposals-count (code-bounded) (`threshold >= 2`)"] # [doc = "- DB:"] # [doc = "  - 1 storage read `is_member` (codec `O(M)`)"] # [doc = "  - 1 storage read `ProposalOf::contains_key` (codec `O(1)`)"] # [doc = "  - DB accesses influenced by `threshold`:"] # [doc = "    - EITHER storage accesses done by `proposal` (`threshold < 2`)"] # [doc = "    - OR proposal insertion (`threshold <= 2`)"] # [doc = "      - 1 storage mutation `Proposals` (codec `O(P2)`)"] # [doc = "      - 1 storage mutation `ProposalCount` (codec `O(1)`)"] # [doc = "      - 1 storage write `ProposalOf` (codec `O(B)`)"] # [doc = "      - 1 storage write `Voting` (codec `O(M)`)"] # [doc = "  - 1 event"] # [doc = "# </weight>"] propose { # [codec (compact)] threshold : :: core :: primitive :: u32 , proposal : :: std :: boxed :: Box < runtime_types :: egg_standalone_runtime :: Call > , # [codec (compact)] length_bound : :: core :: primitive :: u32 , } , # [codec (index = 3)] # [doc = "Add an aye or nay vote for the sender to the given proposal."] # [doc = ""] # [doc = "Requires the sender to be a member."] # [doc = ""] # [doc = "Transaction fees will be waived if the member is voting on any particular proposal"] # [doc = "for the first time and the call is successful. Subsequent vote changes will charge a"] # [doc = "fee."] # [doc = "# <weight>"] # [doc = "## Weight"] # [doc = "- `O(M)` where `M` is members-count (code- and governance-bounded)"] # [doc = "- DB:"] # [doc = "  - 1 storage read `Members` (codec `O(M)`)"] # [doc = "  - 1 storage mutation `Voting` (codec `O(M)`)"] # [doc = "- 1 event"] # [doc = "# </weight>"] vote { proposal : :: subxt :: sp_core :: H256 , # [codec (compact)] index : :: core :: primitive :: u32 , approve : :: core :: primitive :: bool , } , # [codec (index = 4)] # [doc = "Close a vote that is either approved, disapproved or whose voting period has ended."] # [doc = ""] # [doc = "May be called by any signed account in order to finish voting and close the proposal."] # [doc = ""] # [doc = "If called before the end of the voting period it will only close the vote if it is"] # [doc = "has enough votes to be approved or disapproved."] # [doc = ""] # [doc = "If called after the end of the voting period abstentions are counted as rejections"] # [doc = "unless there is a prime member set and the prime member cast an approval."] # [doc = ""] # [doc = "If the close operation completes successfully with disapproval, the transaction fee will"] # [doc = "be waived. Otherwise execution of the approved operation will be charged to the caller."] # [doc = ""] # [doc = "+ `proposal_weight_bound`: The maximum amount of weight consumed by executing the closed"] # [doc = "proposal."] # [doc = "+ `length_bound`: The upper bound for the length of the proposal in storage. Checked via"] # [doc = "`storage::read` so it is `size_of::<u32>() == 4` larger than the pure length."] # [doc = ""] # [doc = "# <weight>"] # [doc = "## Weight"] # [doc = "- `O(B + M + P1 + P2)` where:"] # [doc = "  - `B` is `proposal` size in bytes (length-fee-bounded)"] # [doc = "  - `M` is members-count (code- and governance-bounded)"] # [doc = "  - `P1` is the complexity of `proposal` preimage."] # [doc = "  - `P2` is proposal-count (code-bounded)"] # [doc = "- DB:"] # [doc = " - 2 storage reads (`Members`: codec `O(M)`, `Prime`: codec `O(1)`)"] # [doc = " - 3 mutations (`Voting`: codec `O(M)`, `ProposalOf`: codec `O(B)`, `Proposals`: codec"] # [doc = "   `O(P2)`)"] # [doc = " - any mutations done while executing `proposal` (`P1`)"] # [doc = "- up to 3 events"] # [doc = "# </weight>"] close { proposal_hash : :: subxt :: sp_core :: H256 , # [codec (compact)] index : :: core :: primitive :: u32 , # [codec (compact)] proposal_weight_bound : :: core :: primitive :: u64 , # [codec (compact)] length_bound : :: core :: primitive :: u32 , } , # [codec (index = 5)] # [doc = "Disapprove a proposal, close, and remove it from the system, regardless of its current"] # [doc = "state."] # [doc = ""] # [doc = "Must be called by the Root origin."] # [doc = ""] # [doc = "Parameters:"] # [doc = "* `proposal_hash`: The hash of the proposal that should be disapproved."] # [doc = ""] # [doc = "# <weight>"] # [doc = "Complexity: O(P) where P is the number of max proposals"] # [doc = "DB Weight:"] # [doc = "* Reads: Proposals"] # [doc = "* Writes: Voting, Proposals, ProposalOf"] # [doc = "# </weight>"] disapprove_proposal { proposal_hash : :: subxt :: sp_core :: H256 , } , } # [derive (:: subxt :: codec :: Decode , :: subxt :: codec :: Encode , Clone , Debug , Eq , PartialEq)] pub enum Error { # [codec (index = 0)] # [doc = "Account is not a member"] NotMember , # [codec (index = 1)] # [doc = "Duplicate proposals not allowed"] DuplicateProposal , # [codec (index = 2)] # [doc = "Proposal must exist"] ProposalMissing , # [codec (index = 3)] # [doc = "Mismatched index"] WrongIndex , # [codec (index = 4)] # [doc = "Duplicate vote ignored"] DuplicateVote , # [codec (index = 5)] # [doc = "Members are already initialized!"] AlreadyInitialized , # [codec (index = 6)] # [doc = "The close call was made too early, before the end of the voting."] TooEarly , # [codec (index = 7)] # [doc = "There can only be a maximum of `MaxProposals` active proposals."] TooManyProposals , # [codec (index = 8)] # [doc = "The given weight bound for the proposal was too low."] WrongProposalWeight , # [codec (index = 9)] # [doc = "The given length bound for the proposal was too low."] WrongProposalLength , } # [derive (:: subxt :: codec :: Decode , :: subxt :: codec :: Encode , Clone , Debug , Eq , PartialEq)] pub enum Event { # [codec (index = 0)] # [doc = "A motion (given hash) has been proposed (by given account) with a threshold (given"] # [doc = "`MemberCount`)."] Proposed { account : :: subxt :: sp_core :: crypto :: AccountId32 , proposal_index : :: core :: primitive :: u32 , proposal_hash : :: subxt :: sp_core :: H256 , threshold : :: core :: primitive :: u32 , } , # [codec (index = 1)] # [doc = "A motion (given hash) has been voted on by given account, leaving"] # [doc = "a tally (yes votes and no votes given respectively as `MemberCount`)."] Voted { account : :: subxt :: sp_core :: crypto :: AccountId32 , proposal_hash : :: subxt :: sp_core :: H256 , voted : :: core :: primitive :: bool , yes : :: core :: primitive :: u32 , no : :: core :: primitive :: u32 , } , # [codec (index = 2)] # [doc = "A motion was approved by the required threshold."] Approved { proposal_hash : :: subxt :: sp_core :: H256 , } , # [codec (index = 3)] # [doc = "A motion was not approved by the required threshold."] Disapproved { proposal_hash : :: subxt :: sp_core :: H256 , } , # [codec (index = 4)] # [doc = "A motion was executed; result will be `Ok` if it returned without error."] Executed { proposal_hash : :: subxt :: sp_core :: H256 , result : :: core :: result :: Result < () , runtime_types :: sp_runtime :: DispatchError > , } , # [codec (index = 5)] # [doc = "A single member did some action; result will be `Ok` if it returned without error."] MemberExecuted { proposal_hash : :: subxt :: sp_core :: H256 , result : :: core :: result :: Result < () , runtime_types :: sp_runtime :: DispatchError > , } , # [codec (index = 6)] # [doc = "A proposal was closed because its threshold was reached or after its duration was up."] Closed { proposal_hash : :: subxt :: sp_core :: H256 , yes : :: core :: primitive :: u32 , no : :: core :: primitive :: u32 , } , } } # [derive (:: subxt :: codec :: Decode , :: subxt :: codec :: Encode , Clone , Debug , Eq , PartialEq)] pub enum RawOrigin < _0 > { # [codec (index = 0)] Members (:: core :: primitive :: u32 , :: core :: primitive :: u32 ,) , # [codec (index = 1)] Member (_0 ,) , # [codec (index = 2)] _Phantom , } # [derive (:: subxt :: codec :: Decode , :: subxt :: codec :: Encode , Clone , Debug , Eq , PartialEq)] pub struct Votes < _0 , _1 > { pub index : _1 , pub threshold : _1 , pub ayes : :: std :: vec :: Vec < _0 > , pub nays : :: std :: vec :: Vec < _0 > , pub end : _1 , } } pub mod pallet_democracy { use super :: runtime_types ; pub mod conviction { use super :: runtime_types ; # [derive (:: subxt :: codec :: Decode , :: subxt :: codec :: Encode , Clone , Debug , Eq , PartialEq)] pub enum Conviction { # [codec (index = 0)] None , # [codec (index = 1)] Locked1x , # [codec (index = 2)] Locked2x , # [codec (index = 3)] Locked3x , # [codec (index = 4)] Locked4x , # [codec (index = 5)] Locked5x , # [codec (index = 6)] Locked6x , } } pub mod pallet { use super :: runtime_types ; # [derive (:: subxt :: codec :: Decode , :: subxt :: codec :: Encode , Clone , Debug , Eq , PartialEq)] pub enum Call { # [codec (index = 0)] # [doc = "Propose a sensitive action to be taken."] # [doc = ""] # [doc = "The dispatch origin of this call must be _Signed_ and the sender must"] # [doc = "have funds to cover the deposit."] # [doc = ""] # [doc = "- `proposal_hash`: The hash of the proposal preimage."] # [doc = "- `value`: The amount of deposit (must be at least `MinimumDeposit`)."] # [doc = ""] # [doc = "Emits `Proposed`."] # [doc = ""] # [doc = "Weight: `O(p)`"] propose { proposal_hash : :: subxt :: sp_core :: H256 , # [codec (compact)] value : :: core :: primitive :: u128 , } , # [codec (index = 1)] # [doc = "Signals agreement with a particular proposal."] # [doc = ""] # [doc = "The dispatch origin of this call must be _Signed_ and the sender"] # [doc = "must have funds to cover the deposit, equal to the original deposit."] # [doc = ""] # [doc = "- `proposal`: The index of the proposal to second."] # [doc = "- `seconds_upper_bound`: an upper bound on the current number of seconds on this"] # [doc = "  proposal. Extrinsic is weighted according to this value with no refund."] # [doc = ""] # [doc = "Weight: `O(S)` where S is the number of seconds a proposal already has."] second { # [codec (compact)] proposal : :: core :: primitive :: u32 , # [codec (compact)] seconds_upper_bound : :: core :: primitive :: u32 , } , # [codec (index = 2)] # [doc = "Vote in a referendum. If `vote.is_aye()`, the vote is to enact the proposal;"] # [doc = "otherwise it is a vote to keep the status quo."] # [doc = ""] # [doc = "The dispatch origin of this call must be _Signed_."] # [doc = ""] # [doc = "- `ref_index`: The index of the referendum to vote for."] # [doc = "- `vote`: The vote configuration."] # [doc = ""] # [doc = "Weight: `O(R)` where R is the number of referendums the voter has voted on."] vote { # [codec (compact)] ref_index : :: core :: primitive :: u32 , vote : runtime_types :: pallet_democracy :: vote :: AccountVote < :: core :: primitive :: u128 > , } , # [codec (index = 3)] # [doc = "Schedule an emergency cancellation of a referendum. Cannot happen twice to the same"] # [doc = "referendum."] # [doc = ""] # [doc = "The dispatch origin of this call must be `CancellationOrigin`."] # [doc = ""] # [doc = "-`ref_index`: The index of the referendum to cancel."] # [doc = ""] # [doc = "Weight: `O(1)`."] emergency_cancel { ref_index : :: core :: primitive :: u32 , } , # [codec (index = 4)] # [doc = "Schedule a referendum to be tabled once it is legal to schedule an external"] # [doc = "referendum."] # [doc = ""] # [doc = "The dispatch origin of this call must be `ExternalOrigin`."] # [doc = ""] # [doc = "- `proposal_hash`: The preimage hash of the proposal."] # [doc = ""] # [doc = "Weight: `O(V)` with V number of vetoers in the blacklist of proposal."] # [doc = "  Decoding vec of length V. Charged as maximum"] external_propose { proposal_hash : :: subxt :: sp_core :: H256 , } , # [codec (index = 5)] # [doc = "Schedule a majority-carries referendum to be tabled next once it is legal to schedule"] # [doc = "an external referendum."] # [doc = ""] # [doc = "The dispatch of this call must be `ExternalMajorityOrigin`."] # [doc = ""] # [doc = "- `proposal_hash`: The preimage hash of the proposal."] # [doc = ""] # [doc = "Unlike `external_propose`, blacklisting has no effect on this and it may replace a"] # [doc = "pre-scheduled `external_propose` call."] # [doc = ""] # [doc = "Weight: `O(1)`"] external_propose_majority { proposal_hash : :: subxt :: sp_core :: H256 , } , # [codec (index = 6)] # [doc = "Schedule a negative-turnout-bias referendum to be tabled next once it is legal to"] # [doc = "schedule an external referendum."] # [doc = ""] # [doc = "The dispatch of this call must be `ExternalDefaultOrigin`."] # [doc = ""] # [doc = "- `proposal_hash`: The preimage hash of the proposal."] # [doc = ""] # [doc = "Unlike `external_propose`, blacklisting has no effect on this and it may replace a"] # [doc = "pre-scheduled `external_propose` call."] # [doc = ""] # [doc = "Weight: `O(1)`"] external_propose_default { proposal_hash : :: subxt :: sp_core :: H256 , } , # [codec (index = 7)] # [doc = "Schedule the currently externally-proposed majority-carries referendum to be tabled"] # [doc = "immediately. If there is no externally-proposed referendum currently, or if there is one"] # [doc = "but it is not a majority-carries referendum then it fails."] # [doc = ""] # [doc = "The dispatch of this call must be `FastTrackOrigin`."] # [doc = ""] # [doc = "- `proposal_hash`: The hash of the current external proposal."] # [doc = "- `voting_period`: The period that is allowed for voting on this proposal."] # [doc = "\tMust be always greater than zero."] # [doc = "\tFor `FastTrackOrigin` must be equal or greater than `FastTrackVotingPeriod`."] # [doc = "- `delay`: The number of block after voting has ended in approval and this should be"] # [doc = "  enacted. This doesn't have a minimum amount."] # [doc = ""] # [doc = "Emits `Started`."] # [doc = ""] # [doc = "Weight: `O(1)`"] fast_track { proposal_hash : :: subxt :: sp_core :: H256 , voting_period : :: core :: primitive :: u32 , delay : :: core :: primitive :: u32 , } , # [codec (index = 8)] # [doc = "Veto and blacklist the external proposal hash."] # [doc = ""] # [doc = "The dispatch origin of this call must be `VetoOrigin`."] # [doc = ""] # [doc = "- `proposal_hash`: The preimage hash of the proposal to veto and blacklist."] # [doc = ""] # [doc = "Emits `Vetoed`."] # [doc = ""] # [doc = "Weight: `O(V + log(V))` where V is number of `existing vetoers`"] veto_external { proposal_hash : :: subxt :: sp_core :: H256 , } , # [codec (index = 9)] # [doc = "Remove a referendum."] # [doc = ""] # [doc = "The dispatch origin of this call must be _Root_."] # [doc = ""] # [doc = "- `ref_index`: The index of the referendum to cancel."] # [doc = ""] # [doc = "# Weight: `O(1)`."] cancel_referendum { # [codec (compact)] ref_index : :: core :: primitive :: u32 , } , # [codec (index = 10)] # [doc = "Cancel a proposal queued for enactment."] # [doc = ""] # [doc = "The dispatch origin of this call must be _Root_."] # [doc = ""] # [doc = "- `which`: The index of the referendum to cancel."] # [doc = ""] # [doc = "Weight: `O(D)` where `D` is the items in the dispatch queue. Weighted as `D = 10`."] cancel_queued { which : :: core :: primitive :: u32 , } , # [codec (index = 11)] # [doc = "Delegate the voting power (with some given conviction) of the sending account."] # [doc = ""] # [doc = "The balance delegated is locked for as long as it's delegated, and thereafter for the"] # [doc = "time appropriate for the conviction's lock period."] # [doc = ""] # [doc = "The dispatch origin of this call must be _Signed_, and the signing account must either:"] # [doc = "  - be delegating already; or"] # [doc = "  - have no voting activity (if there is, then it will need to be removed/consolidated"] # [doc = "    through `reap_vote` or `unvote`)."] # [doc = ""] # [doc = "- `to`: The account whose voting the `target` account's voting power will follow."] # [doc = "- `conviction`: The conviction that will be attached to the delegated votes. When the"] # [doc = "  account is undelegated, the funds will be locked for the corresponding period."] # [doc = "- `balance`: The amount of the account's balance to be used in delegating. This must not"] # [doc = "  be more than the account's current balance."] # [doc = ""] # [doc = "Emits `Delegated`."] # [doc = ""] # [doc = "Weight: `O(R)` where R is the number of referendums the voter delegating to has"] # [doc = "  voted on. Weight is charged as if maximum votes."] delegate { to : :: subxt :: sp_core :: crypto :: AccountId32 , conviction : runtime_types :: pallet_democracy :: conviction :: Conviction , balance : :: core :: primitive :: u128 , } , # [codec (index = 12)] # [doc = "Undelegate the voting power of the sending account."] # [doc = ""] # [doc = "Tokens may be unlocked following once an amount of time consistent with the lock period"] # [doc = "of the conviction with which the delegation was issued."] # [doc = ""] # [doc = "The dispatch origin of this call must be _Signed_ and the signing account must be"] # [doc = "currently delegating."] # [doc = ""] # [doc = "Emits `Undelegated`."] # [doc = ""] # [doc = "Weight: `O(R)` where R is the number of referendums the voter delegating to has"] # [doc = "  voted on. Weight is charged as if maximum votes."] undelegate , # [codec (index = 13)] # [doc = "Clears all public proposals."] # [doc = ""] # [doc = "The dispatch origin of this call must be _Root_."] # [doc = ""] # [doc = "Weight: `O(1)`."] clear_public_proposals , # [codec (index = 14)] # [doc = "Register the preimage for an upcoming proposal. This doesn't require the proposal to be"] # [doc = "in the dispatch queue but does require a deposit, returned once enacted."] # [doc = ""] # [doc = "The dispatch origin of this call must be _Signed_."] # [doc = ""] # [doc = "- `encoded_proposal`: The preimage of a proposal."] # [doc = ""] # [doc = "Emits `PreimageNoted`."] # [doc = ""] # [doc = "Weight: `O(E)` with E size of `encoded_proposal` (protected by a required deposit)."] note_preimage { encoded_proposal : :: std :: vec :: Vec < :: core :: primitive :: u8 > , } , # [codec (index = 15)] # [doc = "Same as `note_preimage` but origin is `OperationalPreimageOrigin`."] note_preimage_operational { encoded_proposal : :: std :: vec :: Vec < :: core :: primitive :: u8 > , } , # [codec (index = 16)] # [doc = "Register the preimage for an upcoming proposal. This requires the proposal to be"] # [doc = "in the dispatch queue. No deposit is needed. When this call is successful, i.e."] # [doc = "the preimage has not been uploaded before and matches some imminent proposal,"] # [doc = "no fee is paid."] # [doc = ""] # [doc = "The dispatch origin of this call must be _Signed_."] # [doc = ""] # [doc = "- `encoded_proposal`: The preimage of a proposal."] # [doc = ""] # [doc = "Emits `PreimageNoted`."] # [doc = ""] # [doc = "Weight: `O(E)` with E size of `encoded_proposal` (protected by a required deposit)."] note_imminent_preimage { encoded_proposal : :: std :: vec :: Vec < :: core :: primitive :: u8 > , } , # [codec (index = 17)] # [doc = "Same as `note_imminent_preimage` but origin is `OperationalPreimageOrigin`."] note_imminent_preimage_operational { encoded_proposal : :: std :: vec :: Vec < :: core :: primitive :: u8 > , } , # [codec (index = 18)] # [doc = "Remove an expired proposal preimage and collect the deposit."] # [doc = ""] # [doc = "The dispatch origin of this call must be _Signed_."] # [doc = ""] # [doc = "- `proposal_hash`: The preimage hash of a proposal."] # [doc = "- `proposal_length_upper_bound`: an upper bound on length of the proposal. Extrinsic is"] # [doc = "  weighted according to this value with no refund."] # [doc = ""] # [doc = "This will only work after `VotingPeriod` blocks from the time that the preimage was"] # [doc = "noted, if it's the same account doing it. If it's a different account, then it'll only"] # [doc = "work an additional `EnactmentPeriod` later."] # [doc = ""] # [doc = "Emits `PreimageReaped`."] # [doc = ""] # [doc = "Weight: `O(D)` where D is length of proposal."] reap_preimage { proposal_hash : :: subxt :: sp_core :: H256 , # [codec (compact)] proposal_len_upper_bound : :: core :: primitive :: u32 , } , # [codec (index = 19)] # [doc = "Unlock tokens that have an expired lock."] # [doc = ""] # [doc = "The dispatch origin of this call must be _Signed_."] # [doc = ""] # [doc = "- `target`: The account to remove the lock on."] # [doc = ""] # [doc = "Weight: `O(R)` with R number of vote of target."] unlock { target : :: subxt :: sp_core :: crypto :: AccountId32 , } , # [codec (index = 20)] # [doc = "Remove a vote for a referendum."] # [doc = ""] # [doc = "If:"] # [doc = "- the referendum was cancelled, or"] # [doc = "- the referendum is ongoing, or"] # [doc = "- the referendum has ended such that"] # [doc = "  - the vote of the account was in opposition to the result; or"] # [doc = "  - there was no conviction to the account's vote; or"] # [doc = "  - the account made a split vote"] # [doc = "...then the vote is removed cleanly and a following call to `unlock` may result in more"] # [doc = "funds being available."] # [doc = ""] # [doc = "If, however, the referendum has ended and:"] # [doc = "- it finished corresponding to the vote of the account, and"] # [doc = "- the account made a standard vote with conviction, and"] # [doc = "- the lock period of the conviction is not over"] # [doc = "...then the lock will be aggregated into the overall account's lock, which may involve"] # [doc = "*overlocking* (where the two locks are combined into a single lock that is the maximum"] # [doc = "of both the amount locked and the time is it locked for)."] # [doc = ""] # [doc = "The dispatch origin of this call must be _Signed_, and the signer must have a vote"] # [doc = "registered for referendum `index`."] # [doc = ""] # [doc = "- `index`: The index of referendum of the vote to be removed."] # [doc = ""] # [doc = "Weight: `O(R + log R)` where R is the number of referenda that `target` has voted on."] # [doc = "  Weight is calculated for the maximum number of vote."] remove_vote { index : :: core :: primitive :: u32 , } , # [codec (index = 21)] # [doc = "Remove a vote for a referendum."] # [doc = ""] # [doc = "If the `target` is equal to the signer, then this function is exactly equivalent to"] # [doc = "`remove_vote`. If not equal to the signer, then the vote must have expired,"] # [doc = "either because the referendum was cancelled, because the voter lost the referendum or"] # [doc = "because the conviction period is over."] # [doc = ""] # [doc = "The dispatch origin of this call must be _Signed_."] # [doc = ""] # [doc = "- `target`: The account of the vote to be removed; this account must have voted for"] # [doc = "  referendum `index`."] # [doc = "- `index`: The index of referendum of the vote to be removed."] # [doc = ""] # [doc = "Weight: `O(R + log R)` where R is the number of referenda that `target` has voted on."] # [doc = "  Weight is calculated for the maximum number of vote."] remove_other_vote { target : :: subxt :: sp_core :: crypto :: AccountId32 , index : :: core :: primitive :: u32 , } , # [codec (index = 22)] # [doc = "Enact a proposal from a referendum. For now we just make the weight be the maximum."] enact_proposal { proposal_hash : :: subxt :: sp_core :: H256 , index : :: core :: primitive :: u32 , } , # [codec (index = 23)] # [doc = "Permanently place a proposal into the blacklist. This prevents it from ever being"] # [doc = "proposed again."] # [doc = ""] # [doc = "If called on a queued public or external proposal, then this will result in it being"] # [doc = "removed. If the `ref_index` supplied is an active referendum with the proposal hash,"] # [doc = "then it will be cancelled."] # [doc = ""] # [doc = "The dispatch origin of this call must be `BlacklistOrigin`."] # [doc = ""] # [doc = "- `proposal_hash`: The proposal hash to blacklist permanently."] # [doc = "- `ref_index`: An ongoing referendum whose hash is `proposal_hash`, which will be"] # [doc = "cancelled."] # [doc = ""] # [doc = "Weight: `O(p)` (though as this is an high-privilege dispatch, we assume it has a"] # [doc = "  reasonable value)."] blacklist { proposal_hash : :: subxt :: sp_core :: H256 , maybe_ref_index : :: core :: option :: Option < :: core :: primitive :: u32 > , } , # [codec (index = 24)] # [doc = "Remove a proposal."] # [doc = ""] # [doc = "The dispatch origin of this call must be `CancelProposalOrigin`."] # [doc = ""] # [doc = "- `prop_index`: The index of the proposal to cancel."] # [doc = ""] # [doc = "Weight: `O(p)` where `p = PublicProps::<T>::decode_len()`"] cancel_proposal { # [codec (compact)] prop_index : :: core :: primitive :: u32 , } , } # [derive (:: subxt :: codec :: Decode , :: subxt :: codec :: Encode , Clone , Debug , Eq , PartialEq)] pub enum Error { # [codec (index = 0)] # [doc = "Value too low"] ValueLow , # [codec (index = 1)] # [doc = "Proposal does not exist"] ProposalMissing , # [codec (index = 2)] # [doc = "Cannot cancel the same proposal twice"] AlreadyCanceled , # [codec (index = 3)] # [doc = "Proposal already made"] DuplicateProposal , # [codec (index = 4)] # [doc = "Proposal still blacklisted"] ProposalBlacklisted , # [codec (index = 5)] # [doc = "Next external proposal not simple majority"] NotSimpleMajority , # [codec (index = 6)] # [doc = "Invalid hash"] InvalidHash , # [codec (index = 7)] # [doc = "No external proposal"] NoProposal , # [codec (index = 8)] # [doc = "Identity may not veto a proposal twice"] AlreadyVetoed , # [codec (index = 9)] # [doc = "Preimage already noted"] DuplicatePreimage , # [codec (index = 10)] # [doc = "Not imminent"] NotImminent , # [codec (index = 11)] # [doc = "Too early"] TooEarly , # [codec (index = 12)] # [doc = "Imminent"] Imminent , # [codec (index = 13)] # [doc = "Preimage not found"] PreimageMissing , # [codec (index = 14)] # [doc = "Vote given for invalid referendum"] ReferendumInvalid , # [codec (index = 15)] # [doc = "Invalid preimage"] PreimageInvalid , # [codec (index = 16)] # [doc = "No proposals waiting"] NoneWaiting , # [codec (index = 17)] # [doc = "The given account did not vote on the referendum."] NotVoter , # [codec (index = 18)] # [doc = "The actor has no permission to conduct the action."] NoPermission , # [codec (index = 19)] # [doc = "The account is already delegating."] AlreadyDelegating , # [codec (index = 20)] # [doc = "Too high a balance was provided that the account cannot afford."] InsufficientFunds , # [codec (index = 21)] # [doc = "The account is not currently delegating."] NotDelegating , # [codec (index = 22)] # [doc = "The account currently has votes attached to it and the operation cannot succeed until"] # [doc = "these are removed, either through `unvote` or `reap_vote`."] VotesExist , # [codec (index = 23)] # [doc = "The instant referendum origin is currently disallowed."] InstantNotAllowed , # [codec (index = 24)] # [doc = "Delegation to oneself makes no sense."] Nonsense , # [codec (index = 25)] # [doc = "Invalid upper bound."] WrongUpperBound , # [codec (index = 26)] # [doc = "Maximum number of votes reached."] MaxVotesReached , # [codec (index = 27)] # [doc = "Maximum number of proposals reached."] TooManyProposals , # [codec (index = 28)] # [doc = "Voting period too low"] VotingPeriodLow , } # [derive (:: subxt :: codec :: Decode , :: subxt :: codec :: Encode , Clone , Debug , Eq , PartialEq)] pub enum Event { # [codec (index = 0)] # [doc = "A motion has been proposed by a public account."] Proposed { proposal_index : :: core :: primitive :: u32 , deposit : :: core :: primitive :: u128 , } , # [codec (index = 1)] # [doc = "A public proposal has been tabled for referendum vote."] Tabled { proposal_index : :: core :: primitive :: u32 , deposit : :: core :: primitive :: u128 , depositors : :: std :: vec :: Vec < :: subxt :: sp_core :: crypto :: AccountId32 > , } , # [codec (index = 2)] # [doc = "An external proposal has been tabled."] ExternalTabled , # [codec (index = 3)] # [doc = "A referendum has begun."] Started { ref_index : :: core :: primitive :: u32 , threshold : runtime_types :: pallet_democracy :: vote_threshold :: VoteThreshold , } , # [codec (index = 4)] # [doc = "A proposal has been approved by referendum."] Passed { ref_index : :: core :: primitive :: u32 , } , # [codec (index = 5)] # [doc = "A proposal has been rejected by referendum."] NotPassed { ref_index : :: core :: primitive :: u32 , } , # [codec (index = 6)] # [doc = "A referendum has been cancelled."] Cancelled { ref_index : :: core :: primitive :: u32 , } , # [codec (index = 7)] # [doc = "A proposal has been enacted."] Executed { ref_index : :: core :: primitive :: u32 , result : :: core :: result :: Result < () , runtime_types :: sp_runtime :: DispatchError > , } , # [codec (index = 8)] # [doc = "An account has delegated their vote to another account."] Delegated { who : :: subxt :: sp_core :: crypto :: AccountId32 , target : :: subxt :: sp_core :: crypto :: AccountId32 , } , # [codec (index = 9)] # [doc = "An account has cancelled a previous delegation operation."] Undelegated { account : :: subxt :: sp_core :: crypto :: AccountId32 , } , # [codec (index = 10)] # [doc = "An external proposal has been vetoed."] Vetoed { who : :: subxt :: sp_core :: crypto :: AccountId32 , proposal_hash : :: subxt :: sp_core :: H256 , until : :: core :: primitive :: u32 , } , # [codec (index = 11)] # [doc = "A proposal's preimage was noted, and the deposit taken."] PreimageNoted { proposal_hash : :: subxt :: sp_core :: H256 , who : :: subxt :: sp_core :: crypto :: AccountId32 , deposit : :: core :: primitive :: u128 , } , # [codec (index = 12)] # [doc = "A proposal preimage was removed and used (the deposit was returned)."] PreimageUsed { proposal_hash : :: subxt :: sp_core :: H256 , provider : :: subxt :: sp_core :: crypto :: AccountId32 , deposit : :: core :: primitive :: u128 , } , # [codec (index = 13)] # [doc = "A proposal could not be executed because its preimage was invalid."] PreimageInvalid { proposal_hash : :: subxt :: sp_core :: H256 , ref_index : :: core :: primitive :: u32 , } , # [codec (index = 14)] # [doc = "A proposal could not be executed because its preimage was missing."] PreimageMissing { proposal_hash : :: subxt :: sp_core :: H256 , ref_index : :: core :: primitive :: u32 , } , # [codec (index = 15)] # [doc = "A registered preimage was removed and the deposit collected by the reaper."] PreimageReaped { proposal_hash : :: subxt :: sp_core :: H256 , provider : :: subxt :: sp_core :: crypto :: AccountId32 , deposit : :: core :: primitive :: u128 , reaper : :: subxt :: sp_core :: crypto :: AccountId32 , } , # [codec (index = 16)] # [doc = "A proposal_hash has been blacklisted permanently."] Blacklisted { proposal_hash : :: subxt :: sp_core :: H256 , } , # [codec (index = 17)] # [doc = "An account has voted in a referendum"] Voted { voter : :: subxt :: sp_core :: crypto :: AccountId32 , ref_index : :: core :: primitive :: u32 , vote : runtime_types :: pallet_democracy :: vote :: AccountVote < :: core :: primitive :: u128 > , } , # [codec (index = 18)] # [doc = "An account has secconded a proposal"] Seconded { seconder : :: subxt :: sp_core :: crypto :: AccountId32 , prop_index : :: core :: primitive :: u32 , } , # [codec (index = 19)] # [doc = "A proposal got canceled."] ProposalCanceled { prop_index : :: core :: primitive :: u32 , } , } } pub mod types { use super :: runtime_types ; # [derive (:: subxt :: codec :: Decode , :: subxt :: codec :: Encode , Clone , Debug , Eq , PartialEq)] pub struct Delegations < _0 > { pub votes : _0 , pub capital : _0 , } # [derive (:: subxt :: codec :: Decode , :: subxt :: codec :: Encode , Clone , Debug , Eq , PartialEq)] pub enum ReferendumInfo < _0 , _1 , _2 > { # [codec (index = 0)] Ongoing (runtime_types :: pallet_democracy :: types :: ReferendumStatus < _0 , _1 , _2 > ,) , # [codec (index = 1)] Finished { approved : :: core :: primitive :: bool , end : _0 , } , } # [derive (:: subxt :: codec :: Decode , :: subxt :: codec :: Encode , Clone , Debug , Eq , PartialEq)] pub struct ReferendumStatus < _0 , _1 , _2 > { pub end : _0 , pub proposal_hash : _1 , pub threshold : runtime_types :: pallet_democracy :: vote_threshold :: VoteThreshold , pub delay : _0 , pub tally : runtime_types :: pallet_democracy :: types :: Tally < _2 > , } # [derive (:: subxt :: codec :: Decode , :: subxt :: codec :: Encode , Clone , Debug , Eq , PartialEq)] pub struct Tally < _0 > { pub ayes : _0 , pub nays : _0 , pub turnout : _0 , } } pub mod vote { use super :: runtime_types ; # [derive (:: subxt :: codec :: Decode , :: subxt :: codec :: Encode , Clone , Debug , Eq , PartialEq)] pub enum AccountVote < _0 > { # [codec (index = 0)] Standard { vote : runtime_types :: pallet_democracy :: vote :: Vote , balance : _0 , } , # [codec (index = 1)] Split { aye : _0 , nay : _0 , } , } # [derive (:: subxt :: codec :: Decode , :: subxt :: codec :: Encode , Clone , Debug , Eq , PartialEq)] pub struct PriorLock < _0 , _1 > (pub _0 , pub _1 ,) ; # [derive (:: subxt :: codec :: CompactAs , :: subxt :: codec :: Decode , :: subxt :: codec :: Encode , Clone , Debug , Eq , PartialEq)] pub struct Vote (pub :: core :: primitive :: u8 ,) ; # [derive (:: subxt :: codec :: Decode , :: subxt :: codec :: Encode , Clone , Debug , Eq , PartialEq)] pub enum Voting < _0 , _1 , _2 > { # [codec (index = 0)] Direct { votes : :: std :: vec :: Vec < (_2 , runtime_types :: pallet_democracy :: vote :: AccountVote < _0 > ,) > , delegations : runtime_types :: pallet_democracy :: types :: Delegations < _0 > , prior : runtime_types :: pallet_democracy :: vote :: PriorLock < _2 , _0 > , } , # [codec (index = 1)] Delegating { balance : _0 , target : _1 , conviction : runtime_types :: pallet_democracy :: conviction :: Conviction , delegations : runtime_types :: pallet_democracy :: types :: Delegations < _0 > , prior : runtime_types :: pallet_democracy :: vote :: PriorLock < _2 , _0 > , } , } } pub mod vote_threshold { use super :: runtime_types ; # [derive (:: subxt :: codec :: Decode , :: subxt :: codec :: Encode , Clone , Debug , Eq , PartialEq)] pub enum VoteThreshold { # [codec (index = 0)] SuperMajorityApprove , # [codec (index = 1)] SuperMajorityAgainst , # [codec (index = 2)] SimpleMajority , } } # [derive (:: subxt :: codec :: Decode , :: subxt :: codec :: Encode , Clone , Debug , Eq , PartialEq)] pub enum PreimageStatus < _0 , _1 , _2 > { # [codec (index = 0)] Missing (_2 ,) , # [codec (index = 1)] Available { data : :: std :: vec :: Vec < :: core :: primitive :: u8 > , provider : _0 , deposit : _1 , since : _2 , expiry : :: core :: option :: Option < _2 > , } , } # [derive (:: subxt :: codec :: Decode , :: subxt :: codec :: Encode , Clone , Debug , Eq , PartialEq)] pub enum Releases { # [codec (index = 0)] V1 , } } pub mod pallet_dkg_metadata { use super :: runtime_types ; pub mod pallet { use super :: runtime_types ; # [derive (:: subxt :: codec :: Decode , :: subxt :: codec :: Encode , Clone , Debug , Eq , PartialEq)] pub enum Call { # [codec (index = 0)] # [doc = "Set the pending signature threshold for the session following the next session."] # [doc = ""] # [doc = "We cannot assume that the next DKG has not already completed keygen."] # [doc = "After all, if we are in a new session the next DKG may have already completed."] # [doc = "Therefore, when we update the thresholds we are updating a threshold"] # [doc = "that will become the next threshold after the next session update."] # [doc = ""] # [doc = "* `origin` - The account origin."] # [doc = "* `new_threshold` - The new signature threshold for the DKG."] set_signature_threshold { new_threshold : :: core :: primitive :: u16 , } , # [codec (index = 1)] # [doc = "Set the pending keygen threshold for the session following the next session."] # [doc = ""] # [doc = "We cannot assume that the next DKG has not already completed keygen."] # [doc = "After all, if we are in a new session the next DKG may have already completed."] # [doc = "Therefore, when we update the thresholds we are updating a threshold"] # [doc = "that will become the next threshold after the next session update."] # [doc = ""] # [doc = "* `origin` - The account origin."] # [doc = "* `new_threshold` - The new keygen threshold for the DKG."] set_keygen_threshold { new_threshold : :: core :: primitive :: u16 , } , # [codec (index = 2)] # [doc = "Sets the delay when a unsigned `RefreshProposal` will be added to the unsigned"] # [doc = "proposal queue."] # [doc = ""] # [doc = "* `origin` - The account origin."] # [doc = "* `new_delay` - The percentage of elapsed session duration to wait before adding an"] # [doc = "  unsigned refresh proposal to the unsigned proposal queue."] set_refresh_delay { new_delay : :: core :: primitive :: u8 , } , # [codec (index = 3)] # [doc = "Submits and stores the active public key for the genesis session into the on-chain"] # [doc = "storage. This is primarily used to separate the genesis public key submission from"] # [doc = "non-genesis rounds."] # [doc = ""] # [doc = "Can only be submitted by the current authorities. It is also required that a"] # [doc = "`SignatureThreshold` of submissions is reached in order to successfully"] # [doc = "store the public key on-chain."] # [doc = ""] # [doc = "* `origin` - The account origin."] # [doc = "* `keys_and_signatures` - The aggregated public keys and signatures for possible current"] # [doc = "  DKG public keys."] submit_public_key { keys_and_signatures : runtime_types :: dkg_runtime_primitives :: AggregatedPublicKeys , } , # [codec (index = 4)] # [doc = "Submits and stores the next public key for the next session into the on-chain storage."] # [doc = ""] # [doc = "Can only be submitted by the next authorities. It is also required that a"] # [doc = "`NextSignatureThreshold` of submissions is reached in order to successfully"] # [doc = "store the public key on-chain."] # [doc = ""] # [doc = "* `origin` - The account origin."] # [doc = "* `keys_and_signatures` - The aggregated public keys and signatures for possible next"] # [doc = "  DKG public keys."] submit_next_public_key { keys_and_signatures : runtime_types :: dkg_runtime_primitives :: AggregatedPublicKeys , } , # [codec (index = 5)] # [doc = "Submits the public key signature for the key refresh/rotation process."] # [doc = ""] # [doc = "The signature is the signature of the next public key `RefreshProposal`, signed by the"] # [doc = "current DKG. It is stored on-chain only if it verifies successfully against the current"] # [doc = "DKG's public key. Successful storage of this public key signature also removes"] # [doc = "the unsigned `RefreshProposal` from the unsigned queue."] # [doc = ""] # [doc = "For manual refreshes, after the signature is submitted and stored on-chain,"] # [doc = "the keys are immediately refreshed and the authority set is immediately rotated"] # [doc = "and incremented."] # [doc = ""] # [doc = "* `origin` - The account origin."] # [doc = "* `signature_proposal` - The signed refresh proposal containing the public key signature"] # [doc = "  and nonce."] submit_public_key_signature { signature_proposal : runtime_types :: dkg_runtime_primitives :: proposal :: RefreshProposalSigned , } , # [codec (index = 6)] # [doc = "Submits misbehaviour reports on chain. Signatures of the offending authority are"] # [doc = "verified against the current or next authorities depending on the type of misbehaviour."] # [doc = "- Keygen: Verifies against the next authorities, since they are doing keygen."] # [doc = "- Signing: Verifies against the current authorities, since they are doing signing."] # [doc = ""] # [doc = "Verifies the reports against the respective thresholds and if enough reports are met"] # [doc = "begins to jail and decrease the reputation of the offending authority."] # [doc = ""] # [doc = "The misbehaviour reputation update is:"] # [doc = "\tAUTHORITY_REPUTATION = DECAY_PERCENTAGE * AUTHORITY_REPUTATION"] # [doc = ""] # [doc = "If there are not enough unjailed keygen authorities to perform a keygen after the next"] # [doc = "session, then we deduct the pending keygen threshold (and pending signing threshold)"] # [doc = "accordingly."] # [doc = ""] # [doc = "* `origin` - The account origin."] # [doc = "* `reports` - The aggregated misbehaviour reports containing signatures of an offending"] # [doc = "  authority"] submit_misbehaviour_reports { reports : runtime_types :: dkg_runtime_primitives :: AggregatedMisbehaviourReports < runtime_types :: dkg_runtime_primitives :: crypto :: Public > , } , # [codec (index = 7)] # [doc = "Attempts to remove an authority from all possible jails (keygen & signing)."] # [doc = "This can only be called by the controller of the authority in jail. The"] # [doc = "origin must map directly to the authority in jail."] # [doc = ""] # [doc = "The authority's jail sentence for either keygen or signing must be elapsed"] # [doc = "for the authority to be removed from the jail."] # [doc = ""] # [doc = "* `origin` - The account origin."] unjail , # [codec (index = 8)] # [doc = "Force removes an authority from keygen jail."] # [doc = ""] # [doc = "Can only be called by the root origin."] # [doc = ""] # [doc = "* `origin` - The account origin."] # [doc = "* `authority` - The authority to be removed from the keygen jail."] force_unjail_keygen { authority : runtime_types :: dkg_runtime_primitives :: crypto :: Public , } , # [codec (index = 9)] # [doc = "Force removes an authority from signing jail."] # [doc = ""] # [doc = "Can only be called by the root origin."] # [doc = ""] # [doc = "* `origin` - The account origin."] # [doc = "* `authority` - The authority to be removed from the signing jail."] force_unjail_signing { authority : runtime_types :: dkg_runtime_primitives :: crypto :: Public , } , # [codec (index = 10)] # [doc = "Manually Update the `RefreshNonce` (increment it by one)."] # [doc = ""] # [doc = "Can only be called by the root origin."] # [doc = ""] # [doc = "* `origin` - The account origin."] # [doc = "**Important**: This function is only available for testing purposes."] manual_increment_nonce , # [codec (index = 11)] # [doc = "Manual Trigger DKG Refresh process."] # [doc = ""] # [doc = "Can only be called by the root origin."] # [doc = ""] # [doc = "* `origin` - The account that is initiating the refresh process."] # [doc = "**Important**: This function is only available for testing purposes."] manual_refresh , # [codec (index = 12)] # [doc = "Forcefully rotate the DKG"] # [doc = ""] # [doc = "This forces the next authorities into the current authority spot and"] # [doc = "automatically increments the authority ID. It uses `change_authorities`"] # [doc = "to execute the rotation forcefully."] force_change_authorities , } # [derive (:: subxt :: codec :: Decode , :: subxt :: codec :: Encode , Clone , Debug , Eq , PartialEq)] pub enum Error { # [codec (index = 0)] # [doc = "No mapped account to authority"] NoMappedAccount , # [codec (index = 1)] # [doc = "Invalid threshold"] InvalidThreshold , # [codec (index = 2)] # [doc = "Must be queued  to become an authority"] MustBeAQueuedAuthority , # [codec (index = 3)] # [doc = "Must be an an authority"] MustBeAnActiveAuthority , # [codec (index = 4)] # [doc = "Refresh delay should be in the range of 0% - 100%"] InvalidRefreshDelay , # [codec (index = 5)] # [doc = "Invalid public key submission"] InvalidPublicKeys , # [codec (index = 6)] # [doc = "Already submitted a public key"] AlreadySubmittedPublicKey , # [codec (index = 7)] # [doc = "Already submitted a public key signature"] AlreadySubmittedSignature , # [codec (index = 8)] # [doc = "Used signature from past sessions"] UsedSignature , # [codec (index = 9)] # [doc = "Invalid public key signature submission"] InvalidSignature , # [codec (index = 10)] # [doc = "Invalid misbehaviour reports"] InvalidMisbehaviourReports , # [codec (index = 11)] # [doc = "DKG Refresh is already in progress."] RefreshInProgress , # [codec (index = 12)] # [doc = "Manual DKG Refresh failed to progress."] ManualRefreshFailed , # [codec (index = 13)] # [doc = "No NextPublicKey stored on-chain."] NoNextPublicKey , # [codec (index = 14)] # [doc = "Must be calling from the controller account"] InvalidControllerAccount , } # [derive (:: subxt :: codec :: Decode , :: subxt :: codec :: Encode , Clone , Debug , Eq , PartialEq)] pub enum Event { # [codec (index = 0)] # [doc = "Current public key submitted"] PublicKeySubmitted { compressed_pub_key : :: std :: vec :: Vec < :: core :: primitive :: u8 > , uncompressed_pub_key : :: std :: vec :: Vec < :: core :: primitive :: u8 > , } , # [codec (index = 1)] # [doc = "Next public key submitted"] NextPublicKeySubmitted { compressed_pub_key : :: std :: vec :: Vec < :: core :: primitive :: u8 > , uncompressed_pub_key : :: std :: vec :: Vec < :: core :: primitive :: u8 > , } , # [codec (index = 2)] # [doc = "Next public key signature submitted"] NextPublicKeySignatureSubmitted { pub_key_sig : :: std :: vec :: Vec < :: core :: primitive :: u8 > , } , # [codec (index = 3)] # [doc = "Current Public Key Changed."] PublicKeyChanged { compressed_pub_key : :: std :: vec :: Vec < :: core :: primitive :: u8 > , uncompressed_pub_key : :: std :: vec :: Vec < :: core :: primitive :: u8 > , } , # [codec (index = 4)] # [doc = "Current Public Key Signature Changed."] PublicKeySignatureChanged { pub_key_sig : :: std :: vec :: Vec < :: core :: primitive :: u8 > , } , # [codec (index = 5)] # [doc = "Misbehaviour reports submitted"] MisbehaviourReportsSubmitted { misbehaviour_type : runtime_types :: dkg_runtime_primitives :: MisbehaviourType , reporters : :: std :: vec :: Vec < runtime_types :: dkg_runtime_primitives :: crypto :: Public > , } , # [codec (index = 6)] # [doc = "Refresh DKG Keys Finished (forcefully)."] RefreshKeysFinished { next_authority_set_id : :: core :: primitive :: u64 , } , } } pub mod types { use super :: runtime_types ; # [derive (:: subxt :: codec :: Decode , :: subxt :: codec :: Encode , Clone , Debug , Eq , PartialEq)] pub struct RoundMetadata { pub curr_round_pub_key : :: std :: vec :: Vec < :: core :: primitive :: u8 > , pub next_round_pub_key : :: std :: vec :: Vec < :: core :: primitive :: u8 > , pub refresh_signature : :: std :: vec :: Vec < :: core :: primitive :: u8 > , } } } pub mod pallet_dkg_proposal_handler { use super :: runtime_types ; pub mod pallet { use super :: runtime_types ; # [derive (:: subxt :: codec :: Decode , :: subxt :: codec :: Encode , Clone , Debug , Eq , PartialEq)] pub enum Call { # [codec (index = 0)] submit_signed_proposals { props : :: std :: vec :: Vec < runtime_types :: dkg_runtime_primitives :: proposal :: Proposal > , } , # [codec (index = 1)] # [doc = "Force submit an unsigned proposal to the DKG"] # [doc = ""] # [doc = "There are certain proposals we'd like to be proposable only"] # [doc = "through root actions. The currently supported proposals are"] # [doc = "\t1. Updating"] force_submit_unsigned_proposal { prop : runtime_types :: dkg_runtime_primitives :: proposal :: Proposal , } , } # [derive (:: subxt :: codec :: Decode , :: subxt :: codec :: Encode , Clone , Debug , Eq , PartialEq)] pub enum Error { # [codec (index = 0)] # [doc = "Error names should be descriptive."] NoneValue , # [codec (index = 1)] # [doc = "Errors should have helpful documentation associated with them."] StorageOverflow , # [codec (index = 2)] # [doc = "Proposal format is invalid"] ProposalFormatInvalid , # [codec (index = 3)] # [doc = "Proposal signature is invalid"] ProposalSignatureInvalid , # [codec (index = 4)] # [doc = "No proposal with the ID was found"] ProposalDoesNotExists , # [codec (index = 5)] # [doc = "Proposal with the ID has already been submitted"] ProposalAlreadyExists , # [codec (index = 6)] # [doc = "Chain id is invalid"] ChainIdInvalid , # [codec (index = 7)] # [doc = "Proposal length exceeds max allowed per batch"] ProposalsLengthOverflow , } # [derive (:: subxt :: codec :: Decode , :: subxt :: codec :: Encode , Clone , Debug , Eq , PartialEq)] pub enum Event { # [codec (index = 0)] # [doc = "Event Emitted when we encounter a Proposal with invalid Signature."] InvalidProposalSignature { kind : runtime_types :: dkg_runtime_primitives :: proposal :: ProposalKind , data : :: std :: vec :: Vec < :: core :: primitive :: u8 > , invalid_signature : :: std :: vec :: Vec < :: core :: primitive :: u8 > , expected_public_key : :: core :: option :: Option < :: std :: vec :: Vec < :: core :: primitive :: u8 > > , actual_public_key : :: core :: option :: Option < :: std :: vec :: Vec < :: core :: primitive :: u8 > > , } , # [codec (index = 1)] # [doc = "Event When a Proposal Gets Signed by DKG."] ProposalSigned { key : runtime_types :: dkg_runtime_primitives :: proposal :: DKGPayloadKey , target_chain : runtime_types :: webb_proposals :: header :: TypedChainId , data : :: std :: vec :: Vec < :: core :: primitive :: u8 > , signature : :: std :: vec :: Vec < :: core :: primitive :: u8 > , } , } } } pub mod pallet_dkg_proposals { use super :: runtime_types ; pub mod pallet { use super :: runtime_types ; # [derive (:: subxt :: codec :: Decode , :: subxt :: codec :: Encode , Clone , Debug , Eq , PartialEq)] pub enum Call { # [codec (index = 0)] # [doc = "Sets the vote threshold for proposals."] # [doc = ""] # [doc = "This threshold is used to determine how many votes are required"] # [doc = "before a proposal is executed."] # [doc = ""] # [doc = "# <weight>"] # [doc = "- O(1) lookup and insert"] # [doc = "# </weight>"] set_threshold { threshold : :: core :: primitive :: u32 , } , # [codec (index = 1)] # [doc = "Stores a method name on chain under an associated resource ID."] # [doc = ""] # [doc = "# <weight>"] # [doc = "- O(1) write"] # [doc = "# </weight>"] set_resource { id : runtime_types :: webb_proposals :: header :: ResourceId , method : :: std :: vec :: Vec < :: core :: primitive :: u8 > , } , # [codec (index = 2)] # [doc = "Removes a resource ID from the resource mapping."] # [doc = ""] # [doc = "After this call, bridge transfers with the associated resource ID"] # [doc = "will be rejected."] # [doc = ""] # [doc = "# <weight>"] # [doc = "- O(1) removal"] # [doc = "# </weight>"] remove_resource { id : runtime_types :: webb_proposals :: header :: ResourceId , } , # [codec (index = 3)] # [doc = "Enables a chain ID as a source or destination for a bridge transfer."] # [doc = ""] # [doc = "# <weight>"] # [doc = "- O(1) lookup and insert"] # [doc = "# </weight>"] whitelist_chain { chain_id : runtime_types :: webb_proposals :: header :: TypedChainId , } , # [codec (index = 4)] # [doc = "Adds a new proposer to the proposer set."] # [doc = ""] # [doc = "# <weight>"] # [doc = "- O(1) lookup and insert"] # [doc = "# </weight>"] add_proposer { native_account : :: subxt :: sp_core :: crypto :: AccountId32 , external_account : :: std :: vec :: Vec < :: core :: primitive :: u8 > , } , # [codec (index = 5)] # [doc = "Removes an existing proposer from the set."] # [doc = ""] # [doc = "# <weight>"] # [doc = "- O(1) lookup and removal"] # [doc = "# </weight>"] remove_proposer { v : :: subxt :: sp_core :: crypto :: AccountId32 , } , # [codec (index = 6)] # [doc = "Commits a vote in favour of the provided proposal."] # [doc = ""] # [doc = "If a proposal with the given nonce and source chain ID does not"] # [doc = "already exist, it will be created with an initial vote in favour"] # [doc = "from the caller."] # [doc = ""] # [doc = "# <weight>"] # [doc = "- weight of proposed call, regardless of whether execution is performed"] # [doc = "# </weight>"] acknowledge_proposal { nonce : runtime_types :: webb_proposals :: nonce :: Nonce , src_chain_id : runtime_types :: webb_proposals :: header :: TypedChainId , r_id : runtime_types :: webb_proposals :: header :: ResourceId , prop : :: std :: vec :: Vec < :: core :: primitive :: u8 > , } , # [codec (index = 7)] # [doc = "Commits a vote against a provided proposal."] # [doc = ""] # [doc = "# <weight>"] # [doc = "- Fixed, since execution of proposal should not be included"] # [doc = "# </weight>"] reject_proposal { nonce : runtime_types :: webb_proposals :: nonce :: Nonce , src_chain_id : runtime_types :: webb_proposals :: header :: TypedChainId , r_id : runtime_types :: webb_proposals :: header :: ResourceId , prop : :: std :: vec :: Vec < :: core :: primitive :: u8 > , } , # [codec (index = 8)] # [doc = "Evaluate the state of a proposal given the current vote threshold."] # [doc = ""] # [doc = "A proposal with enough votes will be either executed or cancelled,"] # [doc = "and the status will be updated accordingly."] # [doc = ""] # [doc = "# <weight>"] # [doc = "- weight of proposed call, regardless of whether execution is performed"] # [doc = "# </weight>"] eval_vote_state { nonce : runtime_types :: webb_proposals :: nonce :: Nonce , src_chain_id : runtime_types :: webb_proposals :: header :: TypedChainId , prop : :: std :: vec :: Vec < :: core :: primitive :: u8 > , } , } # [derive (:: subxt :: codec :: Decode , :: subxt :: codec :: Encode , Clone , Debug , Eq , PartialEq)] pub enum Error { # [codec (index = 0)] # [doc = "Account does not have correct permissions"] InvalidPermissions , # [codec (index = 1)] # [doc = "Proposer threshold not set"] ThresholdNotSet , # [codec (index = 2)] # [doc = "Provided chain Id is not valid"] InvalidChainId , # [codec (index = 3)] # [doc = "Proposer threshold cannot be 0"] InvalidThreshold , # [codec (index = 4)] # [doc = "Interactions with this chain is not permitted"] ChainNotWhitelisted , # [codec (index = 5)] # [doc = "Chain has already been enabled"] ChainAlreadyWhitelisted , # [codec (index = 6)] # [doc = "Resource ID provided isn't mapped to anything"] ResourceDoesNotExist , # [codec (index = 7)] # [doc = "Proposer already in set"] ProposerAlreadyExists , # [codec (index = 8)] # [doc = "Provided accountId is not a proposer"] ProposerInvalid , # [codec (index = 9)] # [doc = "Protected operation, must be performed by proposer"] MustBeProposer , # [codec (index = 10)] # [doc = "Proposer has already submitted some vote for this proposal"] ProposerAlreadyVoted , # [codec (index = 11)] # [doc = "A proposal with these parameters has already been submitted"] ProposalAlreadyExists , # [codec (index = 12)] # [doc = "No proposal with the ID was found"] ProposalDoesNotExist , # [codec (index = 13)] # [doc = "Cannot complete proposal, needs more votes"] ProposalNotComplete , # [codec (index = 14)] # [doc = "Proposal has either failed or succeeded"] ProposalAlreadyComplete , # [codec (index = 15)] # [doc = "Lifetime of proposal has been exceeded"] ProposalExpired , # [codec (index = 16)] # [doc = "Proposer Count is Zero"] ProposerCountIsZero , } # [derive (:: subxt :: codec :: Decode , :: subxt :: codec :: Encode , Clone , Debug , Eq , PartialEq)] pub enum Event { # [codec (index = 0)] # [doc = "Vote threshold has changed (new_threshold)"] ProposerThresholdChanged { new_threshold : :: core :: primitive :: u32 , } , # [codec (index = 1)] # [doc = "Chain now available for transfers (chain_id)"] ChainWhitelisted { chain_id : runtime_types :: webb_proposals :: header :: TypedChainId , } , # [codec (index = 2)] # [doc = "Proposer added to set"] ProposerAdded { proposer_id : :: subxt :: sp_core :: crypto :: AccountId32 , } , # [codec (index = 3)] # [doc = "Proposer removed from set"] ProposerRemoved { proposer_id : :: subxt :: sp_core :: crypto :: AccountId32 , } , # [codec (index = 4)] # [doc = "Vote submitted in favour of proposal"] VoteFor { chain_id : runtime_types :: webb_proposals :: header :: TypedChainId , proposal_nonce : runtime_types :: webb_proposals :: nonce :: Nonce , who : :: subxt :: sp_core :: crypto :: AccountId32 , } , # [codec (index = 5)] # [doc = "Vot submitted against proposal"] VoteAgainst { chain_id : runtime_types :: webb_proposals :: header :: TypedChainId , proposal_nonce : runtime_types :: webb_proposals :: nonce :: Nonce , who : :: subxt :: sp_core :: crypto :: AccountId32 , } , # [codec (index = 6)] # [doc = "Voting successful for a proposal"] ProposalApproved { chain_id : runtime_types :: webb_proposals :: header :: TypedChainId , proposal_nonce : runtime_types :: webb_proposals :: nonce :: Nonce , } , # [codec (index = 7)] # [doc = "Voting rejected a proposal"] ProposalRejected { chain_id : runtime_types :: webb_proposals :: header :: TypedChainId , proposal_nonce : runtime_types :: webb_proposals :: nonce :: Nonce , } , # [codec (index = 8)] # [doc = "Execution of call succeeded"] ProposalSucceeded { chain_id : runtime_types :: webb_proposals :: header :: TypedChainId , proposal_nonce : runtime_types :: webb_proposals :: nonce :: Nonce , } , # [codec (index = 9)] # [doc = "Execution of call failed"] ProposalFailed { chain_id : runtime_types :: webb_proposals :: header :: TypedChainId , proposal_nonce : runtime_types :: webb_proposals :: nonce :: Nonce , } , # [codec (index = 10)] # [doc = "Proposers have been reset"] AuthorityProposersReset { proposers : :: std :: vec :: Vec < :: subxt :: sp_core :: crypto :: AccountId32 > , } , } } pub mod types { use super :: runtime_types ; # [derive (:: subxt :: codec :: Decode , :: subxt :: codec :: Encode , Clone , Debug , Eq , PartialEq)] pub enum ProposalStatus { # [codec (index = 0)] Initiated , # [codec (index = 1)] Approved , # [codec (index = 2)] Rejected , } # [derive (:: subxt :: codec :: Decode , :: subxt :: codec :: Encode , Clone , Debug , Eq , PartialEq)] pub struct ProposalVotes < _0 , _1 > { pub votes_for : :: std :: vec :: Vec < _0 > , pub votes_against : :: std :: vec :: Vec < _0 > , pub status : runtime_types :: pallet_dkg_proposals :: types :: ProposalStatus , pub expiry : _1 , } } } pub mod pallet_election_provider_multi_phase { use super :: runtime_types ; pub mod pallet { use super :: runtime_types ; # [derive (:: subxt :: codec :: Decode , :: subxt :: codec :: Encode , Clone , Debug , Eq , PartialEq)] pub enum Call { # [codec (index = 0)] # [doc = "Submit a solution for the unsigned phase."] # [doc = ""] # [doc = "The dispatch origin fo this call must be __none__."] # [doc = ""] # [doc = "This submission is checked on the fly. Moreover, this unsigned solution is only"] # [doc = "validated when submitted to the pool from the **local** node. Effectively, this means"] # [doc = "that only active validators can submit this transaction when authoring a block (similar"] # [doc = "to an inherent)."] # [doc = ""] # [doc = "To prevent any incorrect solution (and thus wasted time/weight), this transaction will"] # [doc = "panic if the solution submitted by the validator is invalid in any way, effectively"] # [doc = "putting their authoring reward at risk."] # [doc = ""] # [doc = "No deposit or reward is associated with this submission."] submit_unsigned { raw_solution : :: std :: boxed :: Box < runtime_types :: pallet_election_provider_multi_phase :: RawSolution < runtime_types :: egg_standalone_runtime :: NposSolution16 > > , witness : runtime_types :: pallet_election_provider_multi_phase :: SolutionOrSnapshotSize , } , # [codec (index = 1)] # [doc = "Set a new value for `MinimumUntrustedScore`."] # [doc = ""] # [doc = "Dispatch origin must be aligned with `T::ForceOrigin`."] # [doc = ""] # [doc = "This check can be turned off by setting the value to `None`."] set_minimum_untrusted_score { maybe_next_score : :: core :: option :: Option < runtime_types :: sp_npos_elections :: ElectionScore > , } , # [codec (index = 2)] # [doc = "Set a solution in the queue, to be handed out to the client of this pallet in the next"] # [doc = "call to `ElectionProvider::elect`."] # [doc = ""] # [doc = "This can only be set by `T::ForceOrigin`, and only when the phase is `Emergency`."] # [doc = ""] # [doc = "The solution is not checked for any feasibility and is assumed to be trustworthy, as any"] # [doc = "feasibility check itself can in principle cause the election process to fail (due to"] # [doc = "memory/weight constrains)."] set_emergency_election_result { supports : :: std :: vec :: Vec < (:: subxt :: sp_core :: crypto :: AccountId32 , runtime_types :: sp_npos_elections :: Support < :: subxt :: sp_core :: crypto :: AccountId32 > ,) > , } , # [codec (index = 3)] # [doc = "Submit a solution for the signed phase."] # [doc = ""] # [doc = "The dispatch origin fo this call must be __signed__."] # [doc = ""] # [doc = "The solution is potentially queued, based on the claimed score and processed at the end"] # [doc = "of the signed phase."] # [doc = ""] # [doc = "A deposit is reserved and recorded for the solution. Based on the outcome, the solution"] # [doc = "might be rewarded, slashed, or get all or a part of the deposit back."] submit { raw_solution : :: std :: boxed :: Box < runtime_types :: pallet_election_provider_multi_phase :: RawSolution < runtime_types :: egg_standalone_runtime :: NposSolution16 > > , } , # [codec (index = 4)] # [doc = "Trigger the governance fallback."] # [doc = ""] # [doc = "This can only be called when [`Phase::Emergency`] is enabled, as an alternative to"] # [doc = "calling [`Call::set_emergency_election_result`]."] governance_fallback { maybe_max_voters : :: core :: option :: Option < :: core :: primitive :: u32 > , maybe_max_targets : :: core :: option :: Option < :: core :: primitive :: u32 > , } , } # [derive (:: subxt :: codec :: Decode , :: subxt :: codec :: Encode , Clone , Debug , Eq , PartialEq)] pub enum Error { # [codec (index = 0)] # [doc = "Submission was too early."] PreDispatchEarlySubmission , # [codec (index = 1)] # [doc = "Wrong number of winners presented."] PreDispatchWrongWinnerCount , # [codec (index = 2)] # [doc = "Submission was too weak, score-wise."] PreDispatchWeakSubmission , # [codec (index = 3)] # [doc = "The queue was full, and the solution was not better than any of the existing ones."] SignedQueueFull , # [codec (index = 4)] # [doc = "The origin failed to pay the deposit."] SignedCannotPayDeposit , # [codec (index = 5)] # [doc = "Witness data to dispatchable is invalid."] SignedInvalidWitness , # [codec (index = 6)] # [doc = "The signed submission consumes too much weight"] SignedTooMuchWeight , # [codec (index = 7)] # [doc = "OCW submitted solution for wrong round"] OcwCallWrongEra , # [codec (index = 8)] # [doc = "Snapshot metadata should exist but didn't."] MissingSnapshotMetadata , # [codec (index = 9)] # [doc = "`Self::insert_submission` returned an invalid index."] InvalidSubmissionIndex , # [codec (index = 10)] # [doc = "The call is not allowed at this point."] CallNotAllowed , # [codec (index = 11)] # [doc = "The fallback failed"] FallbackFailed , } # [derive (:: subxt :: codec :: Decode , :: subxt :: codec :: Encode , Clone , Debug , Eq , PartialEq)] pub enum Event { # [codec (index = 0)] # [doc = "A solution was stored with the given compute."] # [doc = ""] # [doc = "If the solution is signed, this means that it hasn't yet been processed. If the"] # [doc = "solution is unsigned, this means that it has also been processed."] # [doc = ""] # [doc = "The `bool` is `true` when a previous solution was ejected to make room for this one."] SolutionStored { election_compute : runtime_types :: pallet_election_provider_multi_phase :: ElectionCompute , prev_ejected : :: core :: primitive :: bool , } , # [codec (index = 1)] # [doc = "The election has been finalized, with `Some` of the given computation, or else if the"] # [doc = "election failed, `None`."] ElectionFinalized { election_compute : :: core :: option :: Option < runtime_types :: pallet_election_provider_multi_phase :: ElectionCompute > , } , # [codec (index = 2)] # [doc = "An account has been rewarded for their signed submission being finalized."] Rewarded { account : :: subxt :: sp_core :: crypto :: AccountId32 , value : :: core :: primitive :: u128 , } , # [codec (index = 3)] # [doc = "An account has been slashed for submitting an invalid signed submission."] Slashed { account : :: subxt :: sp_core :: crypto :: AccountId32 , value : :: core :: primitive :: u128 , } , # [codec (index = 4)] # [doc = "The signed phase of the given round has started."] SignedPhaseStarted { round : :: core :: primitive :: u32 , } , # [codec (index = 5)] # [doc = "The unsigned phase of the given round has started."] UnsignedPhaseStarted { round : :: core :: primitive :: u32 , } , } } pub mod signed { use super :: runtime_types ; # [derive (:: subxt :: codec :: Decode , :: subxt :: codec :: Encode , Clone , Debug , Eq , PartialEq)] pub struct SignedSubmission < _0 , _1 , _2 > { pub who : _0 , pub deposit : _1 , pub raw_solution : runtime_types :: pallet_election_provider_multi_phase :: RawSolution < _2 > , pub call_fee : _1 , } } # [derive (:: subxt :: codec :: Decode , :: subxt :: codec :: Encode , Clone , Debug , Eq , PartialEq)] pub enum ElectionCompute { # [codec (index = 0)] OnChain , # [codec (index = 1)] Signed , # [codec (index = 2)] Unsigned , # [codec (index = 3)] Fallback , # [codec (index = 4)] Emergency , } # [derive (:: subxt :: codec :: Decode , :: subxt :: codec :: Encode , Clone , Debug , Eq , PartialEq)] pub enum Phase < _0 > { # [codec (index = 0)] Off , # [codec (index = 1)] Signed , # [codec (index = 2)] Unsigned ((:: core :: primitive :: bool , _0 ,) ,) , # [codec (index = 3)] Emergency , } # [derive (:: subxt :: codec :: Decode , :: subxt :: codec :: Encode , Clone , Debug , Eq , PartialEq)] pub struct RawSolution < _0 > { pub solution : _0 , pub score : runtime_types :: sp_npos_elections :: ElectionScore , pub round : :: core :: primitive :: u32 , } # [derive (:: subxt :: codec :: Decode , :: subxt :: codec :: Encode , Clone , Debug , Eq , PartialEq)] pub struct ReadySolution < _0 > { pub supports : :: std :: vec :: Vec < (_0 , runtime_types :: sp_npos_elections :: Support < _0 > ,) > , pub score : runtime_types :: sp_npos_elections :: ElectionScore , pub compute : runtime_types :: pallet_election_provider_multi_phase :: ElectionCompute , } # [derive (:: subxt :: codec :: Decode , :: subxt :: codec :: Encode , Clone , Debug , Eq , PartialEq)] pub struct RoundSnapshot { pub voters : :: std :: vec :: Vec < (:: subxt :: sp_core :: crypto :: AccountId32 , :: core :: primitive :: u64 , runtime_types :: sp_runtime :: bounded :: bounded_vec :: BoundedVec < :: subxt :: sp_core :: crypto :: AccountId32 > ,) > , pub targets : :: std :: vec :: Vec < :: subxt :: sp_core :: crypto :: AccountId32 > , } # [derive (:: subxt :: codec :: Decode , :: subxt :: codec :: Encode , Clone , Debug , Eq , PartialEq)] pub struct SolutionOrSnapshotSize { # [codec (compact)] pub voters : :: core :: primitive :: u32 , # [codec (compact)] pub targets : :: core :: primitive :: u32 , } } pub mod pallet_elections_phragmen { use super :: runtime_types ; pub mod pallet { use super :: runtime_types ; # [derive (:: subxt :: codec :: Decode , :: subxt :: codec :: Encode , Clone , Debug , Eq , PartialEq)] pub enum Call { # [codec (index = 0)] # [doc = "Vote for a set of candidates for the upcoming round of election. This can be called to"] # [doc = "set the initial votes, or update already existing votes."] # [doc = ""] # [doc = "Upon initial voting, `value` units of `who`'s balance is locked and a deposit amount is"] # [doc = "reserved. The deposit is based on the number of votes and can be updated over time."] # [doc = ""] # [doc = "The `votes` should:"] # [doc = "  - not be empty."] # [doc = "  - be less than the number of possible candidates. Note that all current members and"] # [doc = "    runners-up are also automatically candidates for the next round."] # [doc = ""] # [doc = "If `value` is more than `who`'s free balance, then the maximum of the two is used."] # [doc = ""] # [doc = "The dispatch origin of this call must be signed."] # [doc = ""] # [doc = "### Warning"] # [doc = ""] # [doc = "It is the responsibility of the caller to **NOT** place all of their balance into the"] # [doc = "lock and keep some for further operations."] # [doc = ""] # [doc = "# <weight>"] # [doc = "We assume the maximum weight among all 3 cases: vote_equal, vote_more and vote_less."] # [doc = "# </weight>"] vote { votes : :: std :: vec :: Vec < :: subxt :: sp_core :: crypto :: AccountId32 > , # [codec (compact)] value : :: core :: primitive :: u128 , } , # [codec (index = 1)] # [doc = "Remove `origin` as a voter."] # [doc = ""] # [doc = "This removes the lock and returns the deposit."] # [doc = ""] # [doc = "The dispatch origin of this call must be signed and be a voter."] remove_voter , # [codec (index = 2)] # [doc = "Submit oneself for candidacy. A fixed amount of deposit is recorded."] # [doc = ""] # [doc = "All candidates are wiped at the end of the term. They either become a member/runner-up,"] # [doc = "or leave the system while their deposit is slashed."] # [doc = ""] # [doc = "The dispatch origin of this call must be signed."] # [doc = ""] # [doc = "### Warning"] # [doc = ""] # [doc = "Even if a candidate ends up being a member, they must call [`Call::renounce_candidacy`]"] # [doc = "to get their deposit back. Losing the spot in an election will always lead to a slash."] # [doc = ""] # [doc = "# <weight>"] # [doc = "The number of current candidates must be provided as witness data."] # [doc = "# </weight>"] submit_candidacy { # [codec (compact)] candidate_count : :: core :: primitive :: u32 , } , # [codec (index = 3)] # [doc = "Renounce one's intention to be a candidate for the next election round. 3 potential"] # [doc = "outcomes exist:"] # [doc = ""] # [doc = "- `origin` is a candidate and not elected in any set. In this case, the deposit is"] # [doc = "  unreserved, returned and origin is removed as a candidate."] # [doc = "- `origin` is a current runner-up. In this case, the deposit is unreserved, returned and"] # [doc = "  origin is removed as a runner-up."] # [doc = "- `origin` is a current member. In this case, the deposit is unreserved and origin is"] # [doc = "  removed as a member, consequently not being a candidate for the next round anymore."] # [doc = "  Similar to [`remove_member`](Self::remove_member), if replacement runners exists, they"] # [doc = "  are immediately used. If the prime is renouncing, then no prime will exist until the"] # [doc = "  next round."] # [doc = ""] # [doc = "The dispatch origin of this call must be signed, and have one of the above roles."] # [doc = ""] # [doc = "# <weight>"] # [doc = "The type of renouncing must be provided as witness data."] # [doc = "# </weight>"] renounce_candidacy { renouncing : runtime_types :: pallet_elections_phragmen :: Renouncing , } , # [codec (index = 4)] # [doc = "Remove a particular member from the set. This is effective immediately and the bond of"] # [doc = "the outgoing member is slashed."] # [doc = ""] # [doc = "If a runner-up is available, then the best runner-up will be removed and replaces the"] # [doc = "outgoing member. Otherwise, a new phragmen election is started."] # [doc = ""] # [doc = "The dispatch origin of this call must be root."] # [doc = ""] # [doc = "Note that this does not affect the designated block number of the next election."] # [doc = ""] # [doc = "# <weight>"] # [doc = "If we have a replacement, we use a small weight. Else, since this is a root call and"] # [doc = "will go into phragmen, we assume full block for now."] # [doc = "# </weight>"] remove_member { who : :: subxt :: sp_runtime :: MultiAddress < :: subxt :: sp_core :: crypto :: AccountId32 , :: core :: primitive :: u32 > , has_replacement : :: core :: primitive :: bool , } , # [codec (index = 5)] # [doc = "Clean all voters who are defunct (i.e. they do not serve any purpose at all). The"] # [doc = "deposit of the removed voters are returned."] # [doc = ""] # [doc = "This is an root function to be used only for cleaning the state."] # [doc = ""] # [doc = "The dispatch origin of this call must be root."] # [doc = ""] # [doc = "# <weight>"] # [doc = "The total number of voters and those that are defunct must be provided as witness data."] # [doc = "# </weight>"] clean_defunct_voters { num_voters : :: core :: primitive :: u32 , num_defunct : :: core :: primitive :: u32 , } , } # [derive (:: subxt :: codec :: Decode , :: subxt :: codec :: Encode , Clone , Debug , Eq , PartialEq)] pub enum Error { # [codec (index = 0)] # [doc = "Cannot vote when no candidates or members exist."] UnableToVote , # [codec (index = 1)] # [doc = "Must vote for at least one candidate."] NoVotes , # [codec (index = 2)] # [doc = "Cannot vote more than candidates."] TooManyVotes , # [codec (index = 3)] # [doc = "Cannot vote more than maximum allowed."] MaximumVotesExceeded , # [codec (index = 4)] # [doc = "Cannot vote with stake less than minimum balance."] LowBalance , # [codec (index = 5)] # [doc = "Voter can not pay voting bond."] UnableToPayBond , # [codec (index = 6)] # [doc = "Must be a voter."] MustBeVoter , # [codec (index = 7)] # [doc = "Cannot report self."] ReportSelf , # [codec (index = 8)] # [doc = "Duplicated candidate submission."] DuplicatedCandidate , # [codec (index = 9)] # [doc = "Member cannot re-submit candidacy."] MemberSubmit , # [codec (index = 10)] # [doc = "Runner cannot re-submit candidacy."] RunnerUpSubmit , # [codec (index = 11)] # [doc = "Candidate does not have enough funds."] InsufficientCandidateFunds , # [codec (index = 12)] # [doc = "Not a member."] NotMember , # [codec (index = 13)] # [doc = "The provided count of number of candidates is incorrect."] InvalidWitnessData , # [codec (index = 14)] # [doc = "The provided count of number of votes is incorrect."] InvalidVoteCount , # [codec (index = 15)] # [doc = "The renouncing origin presented a wrong `Renouncing` parameter."] InvalidRenouncing , # [codec (index = 16)] # [doc = "Prediction regarding replacement after member removal is wrong."] InvalidReplacement , } # [derive (:: subxt :: codec :: Decode , :: subxt :: codec :: Encode , Clone , Debug , Eq , PartialEq)] pub enum Event { # [codec (index = 0)] # [doc = "A new term with new_members. This indicates that enough candidates existed to run"] # [doc = "the election, not that enough have has been elected. The inner value must be examined"] # [doc = "for this purpose. A `NewTerm(\\[\\])` indicates that some candidates got their bond"] # [doc = "slashed and none were elected, whilst `EmptyTerm` means that no candidates existed to"] # [doc = "begin with."] NewTerm { new_members : :: std :: vec :: Vec < (:: subxt :: sp_core :: crypto :: AccountId32 , :: core :: primitive :: u128 ,) > , } , # [codec (index = 1)] # [doc = "No (or not enough) candidates existed for this round. This is different from"] # [doc = "`NewTerm(\\[\\])`. See the description of `NewTerm`."] EmptyTerm , # [codec (index = 2)] # [doc = "Internal error happened while trying to perform election."] ElectionError , # [codec (index = 3)] # [doc = "A member has been removed. This should always be followed by either `NewTerm` or"] # [doc = "`EmptyTerm`."] MemberKicked { member : :: subxt :: sp_core :: crypto :: AccountId32 , } , # [codec (index = 4)] # [doc = "Someone has renounced their candidacy."] Renounced { candidate : :: subxt :: sp_core :: crypto :: AccountId32 , } , # [codec (index = 5)] # [doc = "A candidate was slashed by amount due to failing to obtain a seat as member or"] # [doc = "runner-up."] # [doc = ""] # [doc = "Note that old members and runners-up are also candidates."] CandidateSlashed { candidate : :: subxt :: sp_core :: crypto :: AccountId32 , amount : :: core :: primitive :: u128 , } , # [codec (index = 6)] # [doc = "A seat holder was slashed by amount by being forcefully removed from the set."] SeatHolderSlashed { seat_holder : :: subxt :: sp_core :: crypto :: AccountId32 , amount : :: core :: primitive :: u128 , } , } } # [derive (:: subxt :: codec :: Decode , :: subxt :: codec :: Encode , Clone , Debug , Eq , PartialEq)] pub enum Renouncing { # [codec (index = 0)] Member , # [codec (index = 1)] RunnerUp , # [codec (index = 2)] Candidate (# [codec (compact)] :: core :: primitive :: u32 ,) , } # [derive (:: subxt :: codec :: Decode , :: subxt :: codec :: Encode , Clone , Debug , Eq , PartialEq)] pub struct SeatHolder < _0 , _1 > { pub who : _0 , pub stake : _1 , pub deposit : _1 , } # [derive (:: subxt :: codec :: Decode , :: subxt :: codec :: Encode , Clone , Debug , Eq , PartialEq)] pub struct Voter < _0 , _1 > { pub votes : :: std :: vec :: Vec < _0 > , pub stake : _1 , pub deposit : _1 , } } pub mod pallet_grandpa { use super :: runtime_types ; pub mod pallet { use super :: runtime_types ; # [derive (:: subxt :: codec :: Decode , :: subxt :: codec :: Encode , Clone , Debug , Eq , PartialEq)] pub enum Call { # [codec (index = 0)] # [doc = "Report voter equivocation/misbehavior. This method will verify the"] # [doc = "equivocation proof and validate the given key ownership proof"] # [doc = "against the extracted offender. If both are valid, the offence"] # [doc = "will be reported."] report_equivocation { equivocation_proof : :: std :: boxed :: Box < runtime_types :: sp_finality_grandpa :: EquivocationProof < :: subxt :: sp_core :: H256 , :: core :: primitive :: u32 > > , key_owner_proof : runtime_types :: sp_session :: MembershipProof , } , # [codec (index = 1)] # [doc = "Report voter equivocation/misbehavior. This method will verify the"] # [doc = "equivocation proof and validate the given key ownership proof"] # [doc = "against the extracted offender. If both are valid, the offence"] # [doc = "will be reported."] # [doc = ""] # [doc = "This extrinsic must be called unsigned and it is expected that only"] # [doc = "block authors will call it (validated in `ValidateUnsigned`), as such"] # [doc = "if the block author is defined it will be defined as the equivocation"] # [doc = "reporter."] report_equivocation_unsigned { equivocation_proof : :: std :: boxed :: Box < runtime_types :: sp_finality_grandpa :: EquivocationProof < :: subxt :: sp_core :: H256 , :: core :: primitive :: u32 > > , key_owner_proof : runtime_types :: sp_session :: MembershipProof , } , # [codec (index = 2)] # [doc = "Note that the current authority set of the GRANDPA finality gadget has stalled."] # [doc = ""] # [doc = "This will trigger a forced authority set change at the beginning of the next session, to"] # [doc = "be enacted `delay` blocks after that. The `delay` should be high enough to safely assume"] # [doc = "that the block signalling the forced change will not be re-orged e.g. 1000 blocks."] # [doc = "The block production rate (which may be slowed down because of finality lagging) should"] # [doc = "be taken into account when choosing the `delay`. The GRANDPA voters based on the new"] # [doc = "authority will start voting on top of `best_finalized_block_number` for new finalized"] # [doc = "blocks. `best_finalized_block_number` should be the highest of the latest finalized"] # [doc = "block of all validators of the new authority set."] # [doc = ""] # [doc = "Only callable by root."] note_stalled { delay : :: core :: primitive :: u32 , best_finalized_block_number : :: core :: primitive :: u32 , } , } # [derive (:: subxt :: codec :: Decode , :: subxt :: codec :: Encode , Clone , Debug , Eq , PartialEq)] pub enum Error { # [codec (index = 0)] # [doc = "Attempt to signal GRANDPA pause when the authority set isn't live"] # [doc = "(either paused or already pending pause)."] PauseFailed , # [codec (index = 1)] # [doc = "Attempt to signal GRANDPA resume when the authority set isn't paused"] # [doc = "(either live or already pending resume)."] ResumeFailed , # [codec (index = 2)] # [doc = "Attempt to signal GRANDPA change with one already pending."] ChangePending , # [codec (index = 3)] # [doc = "Cannot signal forced change so soon after last."] TooSoon , # [codec (index = 4)] # [doc = "A key ownership proof provided as part of an equivocation report is invalid."] InvalidKeyOwnershipProof , # [codec (index = 5)] # [doc = "An equivocation proof provided as part of an equivocation report is invalid."] InvalidEquivocationProof , # [codec (index = 6)] # [doc = "A given equivocation report is valid but already previously reported."] DuplicateOffenceReport , } # [derive (:: subxt :: codec :: Decode , :: subxt :: codec :: Encode , Clone , Debug , Eq , PartialEq)] pub enum Event { # [codec (index = 0)] # [doc = "New authority set has been applied."] NewAuthorities { authority_set : :: std :: vec :: Vec < (runtime_types :: sp_finality_grandpa :: app :: Public , :: core :: primitive :: u64 ,) > , } , # [codec (index = 1)] # [doc = "Current authority set has been paused."] Paused , # [codec (index = 2)] # [doc = "Current authority set has been resumed."] Resumed , } } # [derive (:: subxt :: codec :: Decode , :: subxt :: codec :: Encode , Clone , Debug , Eq , PartialEq)] pub struct StoredPendingChange < _0 > { pub scheduled_at : _0 , pub delay : _0 , pub next_authorities : runtime_types :: sp_runtime :: bounded :: weak_bounded_vec :: WeakBoundedVec < (runtime_types :: sp_finality_grandpa :: app :: Public , :: core :: primitive :: u64 ,) > , pub forced : :: core :: option :: Option < _0 > , } # [derive (:: subxt :: codec :: Decode , :: subxt :: codec :: Encode , Clone , Debug , Eq , PartialEq)] pub enum StoredState < _0 > { # [codec (index = 0)] Live , # [codec (index = 1)] PendingPause { scheduled_at : _0 , delay : _0 , } , # [codec (index = 2)] Paused , # [codec (index = 3)] PendingResume { scheduled_at : _0 , delay : _0 , } , } } pub mod pallet_hasher { use super :: runtime_types ; pub mod pallet { use super :: runtime_types ; # [derive (:: subxt :: codec :: Decode , :: subxt :: codec :: Encode , Clone , Debug , Eq , PartialEq)] pub enum Call { # [codec (index = 0)] force_set_parameters { parameters : :: std :: vec :: Vec < :: core :: primitive :: u8 > , } , } # [derive (:: subxt :: codec :: Decode , :: subxt :: codec :: Encode , Clone , Debug , Eq , PartialEq)] pub enum Error { # [codec (index = 0)] # [doc = "Parameters haven't been initialized"] ParametersNotInitialized , # [codec (index = 1)] # [doc = "Error during hashing"] HashError , } # [derive (:: subxt :: codec :: Decode , :: subxt :: codec :: Encode , Clone , Debug , Eq , PartialEq)] pub enum Event { } } } pub mod pallet_indices { use super :: runtime_types ; pub mod pallet { use super :: runtime_types ; # [derive (:: subxt :: codec :: Decode , :: subxt :: codec :: Encode , Clone , Debug , Eq , PartialEq)] pub enum Call { # [codec (index = 0)] # [doc = "Assign an previously unassigned index."] # [doc = ""] # [doc = "Payment: `Deposit` is reserved from the sender account."] # [doc = ""] # [doc = "The dispatch origin for this call must be _Signed_."] # [doc = ""] # [doc = "- `index`: the index to be claimed. This must not be in use."] # [doc = ""] # [doc = "Emits `IndexAssigned` if successful."] # [doc = ""] # [doc = "# <weight>"] # [doc = "- `O(1)`."] # [doc = "- One storage mutation (codec `O(1)`)."] # [doc = "- One reserve operation."] # [doc = "- One event."] # [doc = "-------------------"] # [doc = "- DB Weight: 1 Read/Write (Accounts)"] # [doc = "# </weight>"] claim { index : :: core :: primitive :: u32 , } , # [codec (index = 1)] # [doc = "Assign an index already owned by the sender to another account. The balance reservation"] # [doc = "is effectively transferred to the new account."] # [doc = ""] # [doc = "The dispatch origin for this call must be _Signed_."] # [doc = ""] # [doc = "- `index`: the index to be re-assigned. This must be owned by the sender."] # [doc = "- `new`: the new owner of the index. This function is a no-op if it is equal to sender."] # [doc = ""] # [doc = "Emits `IndexAssigned` if successful."] # [doc = ""] # [doc = "# <weight>"] # [doc = "- `O(1)`."] # [doc = "- One storage mutation (codec `O(1)`)."] # [doc = "- One transfer operation."] # [doc = "- One event."] # [doc = "-------------------"] # [doc = "- DB Weight:"] # [doc = "   - Reads: Indices Accounts, System Account (recipient)"] # [doc = "   - Writes: Indices Accounts, System Account (recipient)"] # [doc = "# </weight>"] transfer { new : :: subxt :: sp_core :: crypto :: AccountId32 , index : :: core :: primitive :: u32 , } , # [codec (index = 2)] # [doc = "Free up an index owned by the sender."] # [doc = ""] # [doc = "Payment: Any previous deposit placed for the index is unreserved in the sender account."] # [doc = ""] # [doc = "The dispatch origin for this call must be _Signed_ and the sender must own the index."] # [doc = ""] # [doc = "- `index`: the index to be freed. This must be owned by the sender."] # [doc = ""] # [doc = "Emits `IndexFreed` if successful."] # [doc = ""] # [doc = "# <weight>"] # [doc = "- `O(1)`."] # [doc = "- One storage mutation (codec `O(1)`)."] # [doc = "- One reserve operation."] # [doc = "- One event."] # [doc = "-------------------"] # [doc = "- DB Weight: 1 Read/Write (Accounts)"] # [doc = "# </weight>"] free { index : :: core :: primitive :: u32 , } , # [codec (index = 3)] # [doc = "Force an index to an account. This doesn't require a deposit. If the index is already"] # [doc = "held, then any deposit is reimbursed to its current owner."] # [doc = ""] # [doc = "The dispatch origin for this call must be _Root_."] # [doc = ""] # [doc = "- `index`: the index to be (re-)assigned."] # [doc = "- `new`: the new owner of the index. This function is a no-op if it is equal to sender."] # [doc = "- `freeze`: if set to `true`, will freeze the index so it cannot be transferred."] # [doc = ""] # [doc = "Emits `IndexAssigned` if successful."] # [doc = ""] # [doc = "# <weight>"] # [doc = "- `O(1)`."] # [doc = "- One storage mutation (codec `O(1)`)."] # [doc = "- Up to one reserve operation."] # [doc = "- One event."] # [doc = "-------------------"] # [doc = "- DB Weight:"] # [doc = "   - Reads: Indices Accounts, System Account (original owner)"] # [doc = "   - Writes: Indices Accounts, System Account (original owner)"] # [doc = "# </weight>"] force_transfer { new : :: subxt :: sp_core :: crypto :: AccountId32 , index : :: core :: primitive :: u32 , freeze : :: core :: primitive :: bool , } , # [codec (index = 4)] # [doc = "Freeze an index so it will always point to the sender account. This consumes the"] # [doc = "deposit."] # [doc = ""] # [doc = "The dispatch origin for this call must be _Signed_ and the signing account must have a"] # [doc = "non-frozen account `index`."] # [doc = ""] # [doc = "- `index`: the index to be frozen in place."] # [doc = ""] # [doc = "Emits `IndexFrozen` if successful."] # [doc = ""] # [doc = "# <weight>"] # [doc = "- `O(1)`."] # [doc = "- One storage mutation (codec `O(1)`)."] # [doc = "- Up to one slash operation."] # [doc = "- One event."] # [doc = "-------------------"] # [doc = "- DB Weight: 1 Read/Write (Accounts)"] # [doc = "# </weight>"] freeze { index : :: core :: primitive :: u32 , } , } # [derive (:: subxt :: codec :: Decode , :: subxt :: codec :: Encode , Clone , Debug , Eq , PartialEq)] pub enum Error { # [codec (index = 0)] # [doc = "The index was not already assigned."] NotAssigned , # [codec (index = 1)] # [doc = "The index is assigned to another account."] NotOwner , # [codec (index = 2)] # [doc = "The index was not available."] InUse , # [codec (index = 3)] # [doc = "The source and destination accounts are identical."] NotTransfer , # [codec (index = 4)] # [doc = "The index is permanent and may not be freed/changed."] Permanent , } # [derive (:: subxt :: codec :: Decode , :: subxt :: codec :: Encode , Clone , Debug , Eq , PartialEq)] pub enum Event { # [codec (index = 0)] # [doc = "A account index was assigned."] IndexAssigned { who : :: subxt :: sp_core :: crypto :: AccountId32 , index : :: core :: primitive :: u32 , } , # [codec (index = 1)] # [doc = "A account index has been freed up (unassigned)."] IndexFreed { index : :: core :: primitive :: u32 , } , # [codec (index = 2)] # [doc = "A account index has been frozen to its current account ID."] IndexFrozen { index : :: core :: primitive :: u32 , who : :: subxt :: sp_core :: crypto :: AccountId32 , } , } } } pub mod pallet_linkable_tree { use super :: runtime_types ; pub mod pallet { use super :: runtime_types ; # [derive (:: subxt :: codec :: Decode , :: subxt :: codec :: Encode , Clone , Debug , Eq , PartialEq)] pub enum Call { # [codec (index = 0)] create { max_edges : :: core :: primitive :: u32 , depth : :: core :: primitive :: u8 , } , } # [derive (:: subxt :: codec :: Decode , :: subxt :: codec :: Encode , Clone , Debug , Eq , PartialEq)] pub enum Error { # [codec (index = 0)] UnknownRoot , # [codec (index = 1)] # [doc = "Invalid Merkle Roots"] InvalidMerkleRoots , # [codec (index = 2)] # [doc = "Invalid neighbor root passed in withdrawal"] # [doc = "(neighbor root is not in neighbor history)"] InvalidNeighborWithdrawRoot , # [codec (index = 3)] # [doc = "Anchor is at maximum number of edges for the given tree"] TooManyEdges , # [codec (index = 4)] # [doc = "Edge already exists"] EdgeAlreadyExists , # [codec (index = 5)] # [doc = "Edge does not exist"] EdgeDoesntExists , } # [derive (:: subxt :: codec :: Decode , :: subxt :: codec :: Encode , Clone , Debug , Eq , PartialEq)] pub enum Event { # [codec (index = 0)] # [doc = "New tree created"] LinkableTreeCreation { tree_id : :: core :: primitive :: u32 , } , } } pub mod types { use super :: runtime_types ; # [derive (:: subxt :: codec :: Decode , :: subxt :: codec :: Encode , Clone , Debug , Eq , PartialEq)] pub struct EdgeMetadata < _0 , _1 , _2 > { pub src_chain_id : _0 , pub root : _1 , pub latest_leaf_index : _2 , pub target : _1 , } } } pub mod pallet_mixer { use super :: runtime_types ; pub mod pallet { use super :: runtime_types ; # [derive (:: subxt :: codec :: Decode , :: subxt :: codec :: Encode , Clone , Debug , Eq , PartialEq)] pub enum Call { # [codec (index = 0)] create { deposit_size : :: core :: primitive :: u128 , depth : :: core :: primitive :: u8 , asset : :: core :: primitive :: u32 , } , # [codec (index = 1)] deposit { tree_id : :: core :: primitive :: u32 , leaf : runtime_types :: egg_standalone_runtime :: protocol_substrate_config :: Element , } , # [codec (index = 2)] withdraw { id : :: core :: primitive :: u32 , proof_bytes : :: std :: vec :: Vec < :: core :: primitive :: u8 > , root : runtime_types :: egg_standalone_runtime :: protocol_substrate_config :: Element , nullifier_hash : runtime_types :: egg_standalone_runtime :: protocol_substrate_config :: Element , recipient : :: subxt :: sp_core :: crypto :: AccountId32 , relayer : :: subxt :: sp_core :: crypto :: AccountId32 , fee : :: core :: primitive :: u128 , refund : :: core :: primitive :: u128 , } , } # [derive (:: subxt :: codec :: Decode , :: subxt :: codec :: Encode , Clone , Debug , Eq , PartialEq)] pub enum Error { # [codec (index = 0)] # [doc = "Account does not have correct permissions"] InvalidPermissions , # [codec (index = 1)] # [doc = "Invalid withdraw proof"] InvalidWithdrawProof , # [codec (index = 2)] # [doc = "Invalid nullifier that is already used"] # [doc = "(this error is returned when a nullifier is used twice)"] AlreadyRevealedNullifier , # [codec (index = 3)] InvalidArbitraryData , # [codec (index = 4)] # [doc = "Invalid root"] UnknownRoot , # [codec (index = 5)] # [doc = "No mixer found"] NoMixerFound , } # [derive (:: subxt :: codec :: Decode , :: subxt :: codec :: Encode , Clone , Debug , Eq , PartialEq)] pub enum Event { # [codec (index = 0)] # [doc = "New tree created"] MixerCreation { tree_id : :: core :: primitive :: u32 , } , # [codec (index = 1)] Deposit { tree_id : :: core :: primitive :: u32 , leaf : runtime_types :: egg_standalone_runtime :: protocol_substrate_config :: Element , } , # [codec (index = 2)] Withdraw { tree_id : :: core :: primitive :: u32 , recipient : :: subxt :: sp_core :: crypto :: AccountId32 , } , } } pub mod types { use super :: runtime_types ; # [derive (:: subxt :: codec :: Decode , :: subxt :: codec :: Encode , Clone , Debug , Eq , PartialEq)] pub struct MixerMetadata < _0 , _1 > { pub deposit_size : _0 , pub asset : _1 , } } } pub mod pallet_mt { use super :: runtime_types ; pub mod pallet { use super :: runtime_types ; # [derive (:: subxt :: codec :: Decode , :: subxt :: codec :: Encode , Clone , Debug , Eq , PartialEq)] pub enum Call { # [codec (index = 0)] create { depth : :: core :: primitive :: u8 , } , # [codec (index = 1)] insert { tree_id : :: core :: primitive :: u32 , leaf : runtime_types :: egg_standalone_runtime :: protocol_substrate_config :: Element , } , # [codec (index = 2)] force_set_default_hashes { default_hashes : :: std :: vec :: Vec < runtime_types :: egg_standalone_runtime :: protocol_substrate_config :: Element > , } , } # [derive (:: subxt :: codec :: Decode , :: subxt :: codec :: Encode , Clone , Debug , Eq , PartialEq)] pub enum Error { # [codec (index = 0)] # [doc = "Account does not have correct permissions"] InvalidPermissions , # [codec (index = 1)] # [doc = "Invalid depth of the tree specified"] InvalidTreeDepth , # [codec (index = 2)] # [doc = "Invalid  leaf index,  either taken or too large"] InvalidLeafIndex , # [codec (index = 3)] # [doc = "Tree is full"] ExceedsMaxLeaves , # [codec (index = 4)] # [doc = "Tree doesnt exist"] TreeDoesntExist , # [codec (index = 5)] # [doc = "Invalid length for default hashes"] ExceedsMaxDefaultHashes , } # [derive (:: subxt :: codec :: Decode , :: subxt :: codec :: Encode , Clone , Debug , Eq , PartialEq)] pub enum Event { # [codec (index = 0)] # [doc = "New tree created"] TreeCreation { tree_id : :: core :: primitive :: u32 , who : :: subxt :: sp_core :: crypto :: AccountId32 , } , # [codec (index = 1)] # [doc = "New leaf inserted"] LeafInsertion { tree_id : :: core :: primitive :: u32 , leaf_index : :: core :: primitive :: u32 , leaf : runtime_types :: egg_standalone_runtime :: protocol_substrate_config :: Element , } , } } pub mod types { use super :: runtime_types ; # [derive (:: subxt :: codec :: Decode , :: subxt :: codec :: Encode , Clone , Debug , Eq , PartialEq)] pub struct TreeMetadata < _0 , _1 , _2 > { pub creator : :: core :: option :: Option < _0 > , pub paused : :: core :: primitive :: bool , pub leaf_count : _1 , pub max_leaves : _1 , pub depth : :: core :: primitive :: u8 , pub root : _2 , pub edge_nodes : :: std :: vec :: Vec < _2 > , } } } pub mod pallet_nomination_pools { use super :: runtime_types ; pub mod pallet { use super :: runtime_types ; # [derive (:: subxt :: codec :: Decode , :: subxt :: codec :: Encode , Clone , Debug , Eq , PartialEq)] pub enum Call { # [codec (index = 0)] # [doc = "Stake funds with a pool. The amount to bond is transferred from the member to the"] # [doc = "pools account and immediately increases the pools bond."] # [doc = ""] # [doc = "# Note"] # [doc = ""] # [doc = "* An account can only be a member of a single pool."] # [doc = "* An account cannot join the same pool multiple times."] # [doc = "* This call will *not* dust the member account, so the member must have at least"] # [doc = "  `existential deposit + amount` in their account."] # [doc = "* Only a pool with [`PoolState::Open`] can be joined"] join { # [codec (compact)] amount : :: core :: primitive :: u128 , pool_id : :: core :: primitive :: u32 , } , # [codec (index = 1)] # [doc = "Bond `extra` more funds from `origin` into the pool to which they already belong."] # [doc = ""] # [doc = "Additional funds can come from either the free balance of the account, of from the"] # [doc = "accumulated rewards, see [`BondExtra`]."] bond_extra { extra : runtime_types :: pallet_nomination_pools :: BondExtra < :: core :: primitive :: u128 > , } , # [codec (index = 2)] # [doc = "A bonded member can use this to claim their payout based on the rewards that the pool"] # [doc = "has accumulated since their last claimed payout (OR since joining if this is there first"] # [doc = "time claiming rewards). The payout will be transferred to the member's account."] # [doc = ""] # [doc = "The member will earn rewards pro rata based on the members stake vs the sum of the"] # [doc = "members in the pools stake. Rewards do not \"expire\"."] claim_payout , # [codec (index = 3)] # [doc = "Unbond up to `unbonding_points` of the `member_account`'s funds from the pool. It"] # [doc = "implicitly collects the rewards one last time, since not doing so would mean some"] # [doc = "rewards would be forfeited."] # [doc = ""] # [doc = "Under certain conditions, this call can be dispatched permissionlessly (i.e. by any"] # [doc = "account)."] # [doc = ""] # [doc = "# Conditions for a permissionless dispatch."] # [doc = ""] # [doc = "* The pool is blocked and the caller is either the root or state-toggler. This is"] # [doc = "  refereed to as a kick."] # [doc = "* The pool is destroying and the member is not the depositor."] # [doc = "* The pool is destroying, the member is the depositor and no other members are in the"] # [doc = "  pool."] # [doc = ""] # [doc = "## Conditions for permissioned dispatch (i.e. the caller is also the"] # [doc = "`member_account`):"] # [doc = ""] # [doc = "* The caller is not the depositor."] # [doc = "* The caller is the depositor, the pool is destroying and no other members are in the"] # [doc = "  pool."] # [doc = ""] # [doc = "# Note"] # [doc = ""] # [doc = "If there are too many unlocking chunks to unbond with the pool account,"] # [doc = "[`Call::pool_withdraw_unbonded`] can be called to try and minimize unlocking chunks. If"] # [doc = "there are too many unlocking chunks, the result of this call will likely be the"] # [doc = "`NoMoreChunks` error from the staking system."] unbond { member_account : :: subxt :: sp_core :: crypto :: AccountId32 , # [codec (compact)] unbonding_points : :: core :: primitive :: u128 , } , # [codec (index = 4)] # [doc = "Call `withdraw_unbonded` for the pools account. This call can be made by any account."] # [doc = ""] # [doc = "This is useful if their are too many unlocking chunks to call `unbond`, and some"] # [doc = "can be cleared by withdrawing. In the case there are too many unlocking chunks, the user"] # [doc = "would probably see an error like `NoMoreChunks` emitted from the staking system when"] # [doc = "they attempt to unbond."] pool_withdraw_unbonded { pool_id : :: core :: primitive :: u32 , num_slashing_spans : :: core :: primitive :: u32 , } , # [codec (index = 5)] # [doc = "Withdraw unbonded funds from `member_account`. If no bonded funds can be unbonded, an"] # [doc = "error is returned."] # [doc = ""] # [doc = "Under certain conditions, this call can be dispatched permissionlessly (i.e. by any"] # [doc = "account)."] # [doc = ""] # [doc = "# Conditions for a permissionless dispatch"] # [doc = ""] # [doc = "* The pool is in destroy mode and the target is not the depositor."] # [doc = "* The target is the depositor and they are the only member in the sub pools."] # [doc = "* The pool is blocked and the caller is either the root or state-toggler."] # [doc = ""] # [doc = "# Conditions for permissioned dispatch"] # [doc = ""] # [doc = "* The caller is the target and they are not the depositor."] # [doc = ""] # [doc = "# Note"] # [doc = ""] # [doc = "If the target is the depositor, the pool will be destroyed."] withdraw_unbonded { member_account : :: subxt :: sp_core :: crypto :: AccountId32 , num_slashing_spans : :: core :: primitive :: u32 , } , # [codec (index = 6)] # [doc = "Create a new delegation pool."] # [doc = ""] # [doc = "# Arguments"] # [doc = ""] # [doc = "* `amount` - The amount of funds to delegate to the pool. This also acts of a sort of"] # [doc = "  deposit since the pools creator cannot fully unbond funds until the pool is being"] # [doc = "  destroyed."] # [doc = "* `index` - A disambiguation index for creating the account. Likely only useful when"] # [doc = "  creating multiple pools in the same extrinsic."] # [doc = "* `root` - The account to set as [`PoolRoles::root`]."] # [doc = "* `nominator` - The account to set as the [`PoolRoles::nominator`]."] # [doc = "* `state_toggler` - The account to set as the [`PoolRoles::state_toggler`]."] # [doc = ""] # [doc = "# Note"] # [doc = ""] # [doc = "In addition to `amount`, the caller will transfer the existential deposit; so the caller"] # [doc = "needs at have at least `amount + existential_deposit` transferrable."] create { # [codec (compact)] amount : :: core :: primitive :: u128 , root : :: subxt :: sp_core :: crypto :: AccountId32 , nominator : :: subxt :: sp_core :: crypto :: AccountId32 , state_toggler : :: subxt :: sp_core :: crypto :: AccountId32 , } , # [codec (index = 7)] # [doc = "Nominate on behalf of the pool."] # [doc = ""] # [doc = "The dispatch origin of this call must be signed by the pool nominator or the pool"] # [doc = "root role."] # [doc = ""] # [doc = "This directly forward the call to the staking pallet, on behalf of the pool bonded"] # [doc = "account."] nominate { pool_id : :: core :: primitive :: u32 , validators : :: std :: vec :: Vec < :: subxt :: sp_core :: crypto :: AccountId32 > , } , # [codec (index = 8)] # [doc = "Set a new state for the pool."] # [doc = ""] # [doc = "The dispatch origin of this call must be signed by the state toggler, or the root role"] # [doc = "of the pool."] set_state { pool_id : :: core :: primitive :: u32 , state : runtime_types :: pallet_nomination_pools :: PoolState , } , # [codec (index = 9)] # [doc = "Set a new metadata for the pool."] # [doc = ""] # [doc = "The dispatch origin of this call must be signed by the state toggler, or the root role"] # [doc = "of the pool."] set_metadata { pool_id : :: core :: primitive :: u32 , metadata : :: std :: vec :: Vec < :: core :: primitive :: u8 > , } , # [codec (index = 10)] # [doc = "Update configurations for the nomination pools. The origin for this call must be"] # [doc = "Root."] # [doc = ""] # [doc = "# Arguments"] # [doc = ""] # [doc = "* `min_join_bond` - Set [`MinJoinBond`]."] # [doc = "* `min_create_bond` - Set [`MinCreateBond`]."] # [doc = "* `max_pools` - Set [`MaxPools`]."] # [doc = "* `max_members` - Set [`MaxPoolMembers`]."] # [doc = "* `max_members_per_pool` - Set [`MaxPoolMembersPerPool`]."] set_configs { min_join_bond : runtime_types :: pallet_nomination_pools :: ConfigOp < :: core :: primitive :: u128 > , min_create_bond : runtime_types :: pallet_nomination_pools :: ConfigOp < :: core :: primitive :: u128 > , max_pools : runtime_types :: pallet_nomination_pools :: ConfigOp < :: core :: primitive :: u32 > , max_members : runtime_types :: pallet_nomination_pools :: ConfigOp < :: core :: primitive :: u32 > , max_members_per_pool : runtime_types :: pallet_nomination_pools :: ConfigOp < :: core :: primitive :: u32 > , } , # [codec (index = 11)] # [doc = "Update the roles of the pool."] # [doc = ""] # [doc = "The root is the only entity that can change any of the roles, including itself,"] # [doc = "excluding the depositor, who can never change."] # [doc = ""] # [doc = "It emits an event, notifying UIs of the role change. This event is quite relevant to"] # [doc = "most pool members and they should be informed of changes to pool roles."] update_roles { pool_id : :: core :: primitive :: u32 , new_root : runtime_types :: pallet_nomination_pools :: ConfigOp < :: subxt :: sp_core :: crypto :: AccountId32 > , new_nominator : runtime_types :: pallet_nomination_pools :: ConfigOp < :: subxt :: sp_core :: crypto :: AccountId32 > , new_state_toggler : runtime_types :: pallet_nomination_pools :: ConfigOp < :: subxt :: sp_core :: crypto :: AccountId32 > , } , # [codec (index = 12)] # [doc = "Chill on behalf of the pool."] # [doc = ""] # [doc = "The dispatch origin of this call must be signed by the pool nominator or the pool"] # [doc = "root role, same as [`Pallet::nominate`]."] # [doc = ""] # [doc = "This directly forward the call to the staking pallet, on behalf of the pool bonded"] # [doc = "account."] chill { pool_id : :: core :: primitive :: u32 , } , } # [derive (:: subxt :: codec :: Decode , :: subxt :: codec :: Encode , Clone , Debug , Eq , PartialEq)] pub enum DefensiveError { # [codec (index = 0)] NotEnoughSpaceInUnbondPool , # [codec (index = 1)] PoolNotFound , # [codec (index = 2)] RewardPoolNotFound , # [codec (index = 3)] SubPoolsNotFound , # [codec (index = 4)] BondedStashKilledPrematurely , } # [derive (:: subxt :: codec :: Decode , :: subxt :: codec :: Encode , Clone , Debug , Eq , PartialEq)] pub enum Error { # [codec (index = 0)] # [doc = "A (bonded) pool id does not exist."] PoolNotFound , # [codec (index = 1)] # [doc = "An account is not a member."] PoolMemberNotFound , # [codec (index = 2)] # [doc = "A reward pool does not exist. In all cases this is a system logic error."] RewardPoolNotFound , # [codec (index = 3)] # [doc = "A sub pool does not exist."] SubPoolsNotFound , # [codec (index = 4)] # [doc = "An account is already delegating in another pool. An account may only belong to one"] # [doc = "pool at a time."] AccountBelongsToOtherPool , # [codec (index = 5)] # [doc = "The member is fully unbonded (and thus cannot access the bonded and reward pool"] # [doc = "anymore to, for example, collect rewards)."] FullyUnbonding , # [codec (index = 6)] # [doc = "The member cannot unbond further chunks due to reaching the limit."] MaxUnbondingLimit , # [codec (index = 7)] # [doc = "None of the funds can be withdrawn yet because the bonding duration has not passed."] CannotWithdrawAny , # [codec (index = 8)] # [doc = "The amount does not meet the minimum bond to either join or create a pool."] MinimumBondNotMet , # [codec (index = 9)] # [doc = "The transaction could not be executed due to overflow risk for the pool."] OverflowRisk , # [codec (index = 10)] # [doc = "A pool must be in [`PoolState::Destroying`] in order for the depositor to unbond or for"] # [doc = "other members to be permissionlessly unbonded."] NotDestroying , # [codec (index = 11)] # [doc = "The depositor must be the only member in the bonded pool in order to unbond. And the"] # [doc = "depositor must be the only member in the sub pools in order to withdraw unbonded."] NotOnlyPoolMember , # [codec (index = 12)] # [doc = "The caller does not have nominating permissions for the pool."] NotNominator , # [codec (index = 13)] # [doc = "Either a) the caller cannot make a valid kick or b) the pool is not destroying."] NotKickerOrDestroying , # [codec (index = 14)] # [doc = "The pool is not open to join"] NotOpen , # [codec (index = 15)] # [doc = "The system is maxed out on pools."] MaxPools , # [codec (index = 16)] # [doc = "Too many members in the pool or system."] MaxPoolMembers , # [codec (index = 17)] # [doc = "The pools state cannot be changed."] CanNotChangeState , # [codec (index = 18)] # [doc = "The caller does not have adequate permissions."] DoesNotHavePermission , # [codec (index = 19)] # [doc = "Metadata exceeds [`Config::MaxMetadataLen`]"] MetadataExceedsMaxLen , # [codec (index = 20)] # [doc = "Some error occurred that should never happen. This should be reported to the"] # [doc = "maintainers."] Defensive (runtime_types :: pallet_nomination_pools :: pallet :: DefensiveError ,) , # [codec (index = 21)] # [doc = "Not enough points. Ty unbonding less."] NotEnoughPointsToUnbond , # [codec (index = 22)] # [doc = "Partial unbonding now allowed permissionlessly."] PartialUnbondNotAllowedPermissionlessly , } # [derive (:: subxt :: codec :: Decode , :: subxt :: codec :: Encode , Clone , Debug , Eq , PartialEq)] pub enum Event { # [codec (index = 0)] # [doc = "A pool has been created."] Created { depositor : :: subxt :: sp_core :: crypto :: AccountId32 , pool_id : :: core :: primitive :: u32 , } , # [codec (index = 1)] # [doc = "A member has became bonded in a pool."] Bonded { member : :: subxt :: sp_core :: crypto :: AccountId32 , pool_id : :: core :: primitive :: u32 , bonded : :: core :: primitive :: u128 , joined : :: core :: primitive :: bool , } , # [codec (index = 2)] # [doc = "A payout has been made to a member."] PaidOut { member : :: subxt :: sp_core :: crypto :: AccountId32 , pool_id : :: core :: primitive :: u32 , payout : :: core :: primitive :: u128 , } , # [codec (index = 3)] # [doc = "A member has unbonded from their pool."] # [doc = ""] # [doc = "- `balance` is the corresponding balance of the number of points that has been"] # [doc = "  requested to be unbonded (the argument of the `unbond` transaction) from the bonded"] # [doc = "  pool."] # [doc = "- `points` is the number of points that are issued as a result of `balance` being"] # [doc = "dissolved into the corresponding unbonding pool."] # [doc = ""] # [doc = "In the absence of slashing, these values will match. In the presence of slashing, the"] # [doc = "number of points that are issued in the unbonding pool will be less than the amount"] # [doc = "requested to be unbonded."] Unbonded { member : :: subxt :: sp_core :: crypto :: AccountId32 , pool_id : :: core :: primitive :: u32 , balance : :: core :: primitive :: u128 , points : :: core :: primitive :: u128 , } , # [codec (index = 4)] # [doc = "A member has withdrawn from their pool."] # [doc = ""] # [doc = "The given number of `points` have been dissolved in return of `balance`."] # [doc = ""] # [doc = "Similar to `Unbonded` event, in the absence of slashing, the ratio of point to balance"] # [doc = "will be 1."] Withdrawn { member : :: subxt :: sp_core :: crypto :: AccountId32 , pool_id : :: core :: primitive :: u32 , balance : :: core :: primitive :: u128 , points : :: core :: primitive :: u128 , } , # [codec (index = 5)] # [doc = "A pool has been destroyed."] Destroyed { pool_id : :: core :: primitive :: u32 , } , # [codec (index = 6)] # [doc = "The state of a pool has changed"] StateChanged { pool_id : :: core :: primitive :: u32 , new_state : runtime_types :: pallet_nomination_pools :: PoolState , } , # [codec (index = 7)] # [doc = "A member has been removed from a pool."] # [doc = ""] # [doc = "The removal can be voluntary (withdrawn all unbonded funds) or involuntary (kicked)."] MemberRemoved { pool_id : :: core :: primitive :: u32 , member : :: subxt :: sp_core :: crypto :: AccountId32 , } , # [codec (index = 8)] # [doc = "The roles of a pool have been updated to the given new roles. Note that the depositor"] # [doc = "can never change."] RolesUpdated { root : :: core :: option :: Option < :: subxt :: sp_core :: crypto :: AccountId32 > , state_toggler : :: core :: option :: Option < :: subxt :: sp_core :: crypto :: AccountId32 > , nominator : :: core :: option :: Option < :: subxt :: sp_core :: crypto :: AccountId32 > , } , # [codec (index = 9)] # [doc = "The active balance of pool `pool_id` has been slashed to `balance`."] PoolSlashed { pool_id : :: core :: primitive :: u32 , balance : :: core :: primitive :: u128 , } , # [codec (index = 10)] # [doc = "The unbond pool at `era` of pool `pool_id` has been slashed to `balance`."] UnbondingPoolSlashed { pool_id : :: core :: primitive :: u32 , era : :: core :: primitive :: u32 , balance : :: core :: primitive :: u128 , } , } } # [derive (:: subxt :: codec :: Decode , :: subxt :: codec :: Encode , Clone , Debug , Eq , PartialEq)] pub enum BondExtra < _0 > { # [codec (index = 0)] FreeBalance (_0 ,) , # [codec (index = 1)] Rewards , } # [derive (:: subxt :: codec :: Decode , :: subxt :: codec :: Encode , Clone , Debug , Eq , PartialEq)] pub struct BondedPoolInner { pub points : :: core :: primitive :: u128 , pub state : runtime_types :: pallet_nomination_pools :: PoolState , pub member_counter : :: core :: primitive :: u32 , pub roles : runtime_types :: pallet_nomination_pools :: PoolRoles < :: subxt :: sp_core :: crypto :: AccountId32 > , } # [derive (:: subxt :: codec :: Decode , :: subxt :: codec :: Encode , Clone , Debug , Eq , PartialEq)] pub enum ConfigOp < _0 > { # [codec (index = 0)] Noop , # [codec (index = 1)] Set (_0 ,) , # [codec (index = 2)] Remove , } # [derive (:: subxt :: codec :: Decode , :: subxt :: codec :: Encode , Clone , Debug , Eq , PartialEq)] pub struct PoolMember { pub pool_id : :: core :: primitive :: u32 , pub points : :: core :: primitive :: u128 , pub reward_pool_total_earnings : :: core :: primitive :: u128 , pub unbonding_eras : runtime_types :: sp_runtime :: bounded :: bounded_btree_map :: BoundedBTreeMap < :: core :: primitive :: u32 , :: core :: primitive :: u128 > , } # [derive (:: subxt :: codec :: Decode , :: subxt :: codec :: Encode , Clone , Debug , Eq , PartialEq)] pub struct PoolRoles < _0 > { pub depositor : _0 , pub root : :: core :: option :: Option < _0 > , pub nominator : :: core :: option :: Option < _0 > , pub state_toggler : :: core :: option :: Option < _0 > , } # [derive (:: subxt :: codec :: Decode , :: subxt :: codec :: Encode , Clone , Debug , Eq , PartialEq)] pub enum PoolState { # [codec (index = 0)] Open , # [codec (index = 1)] Blocked , # [codec (index = 2)] Destroying , } # [derive (:: subxt :: codec :: Decode , :: subxt :: codec :: Encode , Clone , Debug , Eq , PartialEq)] pub struct RewardPool { pub balance : :: core :: primitive :: u128 , pub total_earnings : :: core :: primitive :: u128 , pub points : runtime_types :: primitive_types :: U256 , } # [derive (:: subxt :: codec :: Decode , :: subxt :: codec :: Encode , Clone , Debug , Eq , PartialEq)] pub struct SubPools { pub no_era : runtime_types :: pallet_nomination_pools :: UnbondPool , pub with_era : runtime_types :: sp_runtime :: bounded :: bounded_btree_map :: BoundedBTreeMap < :: core :: primitive :: u32 , runtime_types :: pallet_nomination_pools :: UnbondPool > , } # [derive (:: subxt :: codec :: Decode , :: subxt :: codec :: Encode , Clone , Debug , Eq , PartialEq)] pub struct UnbondPool { pub points : :: core :: primitive :: u128 , pub balance : :: core :: primitive :: u128 , } } pub mod pallet_offences { use super :: runtime_types ; pub mod pallet { use super :: runtime_types ; # [derive (:: subxt :: codec :: Decode , :: subxt :: codec :: Encode , Clone , Debug , Eq , PartialEq)] pub enum Event { # [codec (index = 0)] # [doc = "There is an offence reported of the given `kind` happened at the `session_index` and"] # [doc = "(kind-specific) time slot. This event is not deposited for duplicate slashes."] # [doc = "\\[kind, timeslot\\]."] Offence { kind : [:: core :: primitive :: u8 ; 16usize] , timeslot : :: std :: vec :: Vec < :: core :: primitive :: u8 > , } , } } } pub mod pallet_preimage { use super :: runtime_types ; pub mod pallet { use super :: runtime_types ; # [derive (:: subxt :: codec :: Decode , :: subxt :: codec :: Encode , Clone , Debug , Eq , PartialEq)] pub enum Call { # [codec (index = 0)] # [doc = "Register a preimage on-chain."] # [doc = ""] # [doc = "If the preimage was previously requested, no fees or deposits are taken for providing"] # [doc = "the preimage. Otherwise, a deposit is taken proportional to the size of the preimage."] note_preimage { bytes : :: std :: vec :: Vec < :: core :: primitive :: u8 > , } , # [codec (index = 1)] # [doc = "Clear an unrequested preimage from the runtime storage."] unnote_preimage { hash : :: subxt :: sp_core :: H256 , } , # [codec (index = 2)] # [doc = "Request a preimage be uploaded to the chain without paying any fees or deposits."] # [doc = ""] # [doc = "If the preimage requests has already been provided on-chain, we unreserve any deposit"] # [doc = "a user may have paid, and take the control of the preimage out of their hands."] request_preimage { hash : :: subxt :: sp_core :: H256 , } , # [codec (index = 3)] # [doc = "Clear a previously made request for a preimage."] # [doc = ""] # [doc = "NOTE: THIS MUST NOT BE CALLED ON `hash` MORE TIMES THAN `request_preimage`."] unrequest_preimage { hash : :: subxt :: sp_core :: H256 , } , } # [derive (:: subxt :: codec :: Decode , :: subxt :: codec :: Encode , Clone , Debug , Eq , PartialEq)] pub enum Error { # [codec (index = 0)] # [doc = "Preimage is too large to store on-chain."] TooLarge , # [codec (index = 1)] # [doc = "Preimage has already been noted on-chain."] AlreadyNoted , # [codec (index = 2)] # [doc = "The user is not authorized to perform this action."] NotAuthorized , # [codec (index = 3)] # [doc = "The preimage cannot be removed since it has not yet been noted."] NotNoted , # [codec (index = 4)] # [doc = "A preimage may not be removed when there are outstanding requests."] Requested , # [codec (index = 5)] # [doc = "The preimage request cannot be removed since no outstanding requests exist."] NotRequested , } # [derive (:: subxt :: codec :: Decode , :: subxt :: codec :: Encode , Clone , Debug , Eq , PartialEq)] pub enum Event { # [codec (index = 0)] # [doc = "A preimage has been noted."] Noted { hash : :: subxt :: sp_core :: H256 , } , # [codec (index = 1)] # [doc = "A preimage has been requested."] Requested { hash : :: subxt :: sp_core :: H256 , } , # [codec (index = 2)] # [doc = "A preimage has ben cleared."] Cleared { hash : :: subxt :: sp_core :: H256 , } , } } # [derive (:: subxt :: codec :: Decode , :: subxt :: codec :: Encode , Clone , Debug , Eq , PartialEq)] pub enum RequestStatus < _0 , _1 > { # [codec (index = 0)] Unrequested (:: core :: option :: Option < (_0 , _1 ,) > ,) , # [codec (index = 1)] Requested (:: core :: primitive :: u32 ,) , } } pub mod pallet_scheduler { use super :: runtime_types ; pub mod pallet { use super :: runtime_types ; # [derive (:: subxt :: codec :: Decode , :: subxt :: codec :: Encode , Clone , Debug , Eq , PartialEq)] pub enum Call { # [codec (index = 0)] # [doc = "Anonymously schedule a task."] schedule { when : :: core :: primitive :: u32 , maybe_periodic : :: core :: option :: Option < (:: core :: primitive :: u32 , :: core :: primitive :: u32 ,) > , priority : :: core :: primitive :: u8 , call : :: std :: boxed :: Box < runtime_types :: frame_support :: traits :: schedule :: MaybeHashed < runtime_types :: egg_standalone_runtime :: Call , :: subxt :: sp_core :: H256 > > , } , # [codec (index = 1)] # [doc = "Cancel an anonymously scheduled task."] cancel { when : :: core :: primitive :: u32 , index : :: core :: primitive :: u32 , } , # [codec (index = 2)] # [doc = "Schedule a named task."] schedule_named { id : :: std :: vec :: Vec < :: core :: primitive :: u8 > , when : :: core :: primitive :: u32 , maybe_periodic : :: core :: option :: Option < (:: core :: primitive :: u32 , :: core :: primitive :: u32 ,) > , priority : :: core :: primitive :: u8 , call : :: std :: boxed :: Box < runtime_types :: frame_support :: traits :: schedule :: MaybeHashed < runtime_types :: egg_standalone_runtime :: Call , :: subxt :: sp_core :: H256 > > , } , # [codec (index = 3)] # [doc = "Cancel a named scheduled task."] cancel_named { id : :: std :: vec :: Vec < :: core :: primitive :: u8 > , } , # [codec (index = 4)] # [doc = "Anonymously schedule a task after a delay."] # [doc = ""] # [doc = "# <weight>"] # [doc = "Same as [`schedule`]."] # [doc = "# </weight>"] schedule_after { after : :: core :: primitive :: u32 , maybe_periodic : :: core :: option :: Option < (:: core :: primitive :: u32 , :: core :: primitive :: u32 ,) > , priority : :: core :: primitive :: u8 , call : :: std :: boxed :: Box < runtime_types :: frame_support :: traits :: schedule :: MaybeHashed < runtime_types :: egg_standalone_runtime :: Call , :: subxt :: sp_core :: H256 > > , } , # [codec (index = 5)] # [doc = "Schedule a named task after a delay."] # [doc = ""] # [doc = "# <weight>"] # [doc = "Same as [`schedule_named`](Self::schedule_named)."] # [doc = "# </weight>"] schedule_named_after { id : :: std :: vec :: Vec < :: core :: primitive :: u8 > , after : :: core :: primitive :: u32 , maybe_periodic : :: core :: option :: Option < (:: core :: primitive :: u32 , :: core :: primitive :: u32 ,) > , priority : :: core :: primitive :: u8 , call : :: std :: boxed :: Box < runtime_types :: frame_support :: traits :: schedule :: MaybeHashed < runtime_types :: egg_standalone_runtime :: Call , :: subxt :: sp_core :: H256 > > , } , } # [derive (:: subxt :: codec :: Decode , :: subxt :: codec :: Encode , Clone , Debug , Eq , PartialEq)] pub enum Error { # [codec (index = 0)] # [doc = "Failed to schedule a call"] FailedToSchedule , # [codec (index = 1)] # [doc = "Cannot find the scheduled call."] NotFound , # [codec (index = 2)] # [doc = "Given target block number is in the past."] TargetBlockNumberInPast , # [codec (index = 3)] # [doc = "Reschedule failed because it does not change scheduled time."] RescheduleNoChange , } # [derive (:: subxt :: codec :: Decode , :: subxt :: codec :: Encode , Clone , Debug , Eq , PartialEq)] pub enum Event { # [codec (index = 0)] # [doc = "Scheduled some task."] Scheduled { when : :: core :: primitive :: u32 , index : :: core :: primitive :: u32 , } , # [codec (index = 1)] # [doc = "Canceled some task."] Canceled { when : :: core :: primitive :: u32 , index : :: core :: primitive :: u32 , } , # [codec (index = 2)] # [doc = "Dispatched some task."] Dispatched { task : (:: core :: primitive :: u32 , :: core :: primitive :: u32 ,) , id : :: core :: option :: Option < :: std :: vec :: Vec < :: core :: primitive :: u8 > > , result : :: core :: result :: Result < () , runtime_types :: sp_runtime :: DispatchError > , } , # [codec (index = 3)] # [doc = "The call for the provided hash was not found so the task has been aborted."] CallLookupFailed { task : (:: core :: primitive :: u32 , :: core :: primitive :: u32 ,) , id : :: core :: option :: Option < :: std :: vec :: Vec < :: core :: primitive :: u8 > > , error : runtime_types :: frame_support :: traits :: schedule :: LookupError , } , } } # [derive (:: subxt :: codec :: Decode , :: subxt :: codec :: Encode , Clone , Debug , Eq , PartialEq)] pub struct ScheduledV3 < _0 , _1 , _2 , _3 > { pub maybe_id : :: core :: option :: Option < :: std :: vec :: Vec < :: core :: primitive :: u8 > > , pub priority : :: core :: primitive :: u8 , pub call : _0 , pub maybe_periodic : :: core :: option :: Option < (_1 , _1 ,) > , pub origin : _2 , # [codec (skip)] pub __subxt_unused_type_params : :: core :: marker :: PhantomData < _3 > } } pub mod pallet_session { use super :: runtime_types ; pub mod pallet { use super :: runtime_types ; # [derive (:: subxt :: codec :: Decode , :: subxt :: codec :: Encode , Clone , Debug , Eq , PartialEq)] pub enum Call { # [codec (index = 0)] # [doc = "Sets the session key(s) of the function caller to `keys`."] # [doc = "Allows an account to set its session key prior to becoming a validator."] # [doc = "This doesn't take effect until the next session."] # [doc = ""] # [doc = "The dispatch origin of this function must be signed."] # [doc = ""] # [doc = "# <weight>"] # [doc = "- Complexity: `O(1)`. Actual cost depends on the number of length of"] # [doc = "  `T::Keys::key_ids()` which is fixed."] # [doc = "- DbReads: `origin account`, `T::ValidatorIdOf`, `NextKeys`"] # [doc = "- DbWrites: `origin account`, `NextKeys`"] # [doc = "- DbReads per key id: `KeyOwner`"] # [doc = "- DbWrites per key id: `KeyOwner`"] # [doc = "# </weight>"] set_keys { keys : runtime_types :: egg_standalone_runtime :: opaque :: SessionKeys , proof : :: std :: vec :: Vec < :: core :: primitive :: u8 > , } , # [codec (index = 1)] # [doc = "Removes any session key(s) of the function caller."] # [doc = ""] # [doc = "This doesn't take effect until the next session."] # [doc = ""] # [doc = "The dispatch origin of this function must be Signed and the account must be either be"] # [doc = "convertible to a validator ID using the chain's typical addressing system (this usually"] # [doc = "means being a controller account) or directly convertible into a validator ID (which"] # [doc = "usually means being a stash account)."] # [doc = ""] # [doc = "# <weight>"] # [doc = "- Complexity: `O(1)` in number of key types. Actual cost depends on the number of length"] # [doc = "  of `T::Keys::key_ids()` which is fixed."] # [doc = "- DbReads: `T::ValidatorIdOf`, `NextKeys`, `origin account`"] # [doc = "- DbWrites: `NextKeys`, `origin account`"] # [doc = "- DbWrites per key id: `KeyOwner`"] # [doc = "# </weight>"] purge_keys , } # [derive (:: subxt :: codec :: Decode , :: subxt :: codec :: Encode , Clone , Debug , Eq , PartialEq)] pub enum Error { # [codec (index = 0)] # [doc = "Invalid ownership proof."] InvalidProof , # [codec (index = 1)] # [doc = "No associated validator ID for account."] NoAssociatedValidatorId , # [codec (index = 2)] # [doc = "Registered duplicate key."] DuplicatedKey , # [codec (index = 3)] # [doc = "No keys are associated with this account."] NoKeys , # [codec (index = 4)] # [doc = "Key setting account is not live, so it's impossible to associate keys."] NoAccount , } # [derive (:: subxt :: codec :: Decode , :: subxt :: codec :: Encode , Clone , Debug , Eq , PartialEq)] pub enum Event { # [codec (index = 0)] # [doc = "New session has happened. Note that the argument is the session index, not the"] # [doc = "block number as the type might suggest."] NewSession { session_index : :: core :: primitive :: u32 , } , } } } pub mod pallet_signature_bridge { use super :: runtime_types ; pub mod pallet { use super :: runtime_types ; # [derive (:: subxt :: codec :: Decode , :: subxt :: codec :: Encode , Clone , Debug , Eq , PartialEq)] pub enum Call { # [codec (index = 0)] # [doc = "Sets the maintainer."] set_maintainer { message : :: std :: vec :: Vec < :: core :: primitive :: u8 > , signature : :: std :: vec :: Vec < :: core :: primitive :: u8 > , } , # [codec (index = 1)] force_set_maintainer { new_maintainer : :: std :: vec :: Vec < :: core :: primitive :: u8 > , } , # [codec (index = 2)] # [doc = "Stores a method name on chain under an associated resource ID."] # [doc = ""] # [doc = "# <weight>"] # [doc = "- O(1) write"] # [doc = "# </weight>"] set_resource { id : [:: core :: primitive :: u8 ; 32usize] , } , # [codec (index = 3)] # [doc = "Removes a resource ID from the resource mapping."] # [doc = ""] # [doc = "After this call, bridge transfers with the associated resource ID"] # [doc = "will be rejected."] # [doc = ""] # [doc = "# <weight>"] # [doc = "- O(1) removal"] # [doc = "# </weight>"] remove_resource { id : [:: core :: primitive :: u8 ; 32usize] , } , # [codec (index = 4)] # [doc = "Enables a chain ID as a source or destination for a bridge transfer."] # [doc = ""] # [doc = "# <weight>"] # [doc = "- O(1) lookup and insert"] # [doc = "# </weight>"] whitelist_chain { id : :: core :: primitive :: u64 , } , # [codec (index = 5)] # [doc = "@param origin"] # [doc = "@param src_id"] # [doc = "@param call: the dispatchable call corresponding to a"] # [doc = "handler function"] # [doc = "@param proposal_data: (r_id, nonce, 4 bytes of zeroes, call)"] # [doc = "@param signature: a signature over the proposal_data"] # [doc = ""] # [doc = "We check:"] # [doc = "1. That the signature is actually over the proposal data"] # [doc = "2. Add ResourceId to the Storage"] # [doc = "3. That the call from the proposal data and the call input parameter to the function are"] # [doc = "consistent with each other 4. That the execution chain id type parsed from the r_id is"] # [doc = "indeed this chain's id type"] # [doc = ""] # [doc = "If all these checks pass then we call finalize_execution which actually executes the"] # [doc = "dispatchable call. The dispatchable call is usually a handler function, for instance in"] # [doc = "the anchor-handler or token-wrapper-handler pallet."] # [doc = ""] # [doc = "There are a few TODOs left in the function."] # [doc = ""] # [doc = "In the set_resource_with_signature"] # [doc = "# <weight>"] # [doc = "- weight of proposed call, regardless of whether execution is performed"] # [doc = "# </weight>"] set_resource_with_signature { src_id : :: core :: primitive :: u64 , call : :: std :: boxed :: Box < runtime_types :: egg_standalone_runtime :: Call > , proposal_data : :: std :: vec :: Vec < :: core :: primitive :: u8 > , signature : :: std :: vec :: Vec < :: core :: primitive :: u8 > , } , # [codec (index = 6)] # [doc = "@param origin"] # [doc = "@param src_id"] # [doc = "@param call: the dispatchable call corresponding to a"] # [doc = "handler function"] # [doc = "@param proposal_data: (r_id, nonce, 4 bytes of zeroes, call)"] # [doc = "@param signature: a signature over the proposal_data"] # [doc = ""] # [doc = "We check:"] # [doc = "1. That the signature is actually over the proposal data"] # [doc = "2. That the r_id parsed from the proposal data exists"] # [doc = "3. That the call from the proposal data and the call input parameter to the function are"] # [doc = "consistent with each other 4. That the execution chain id type parsed from the r_id is"] # [doc = "indeed this chain's id type"] # [doc = ""] # [doc = "If all these checks pass then we call finalize_execution which actually executes the"] # [doc = "dispatchable call. The dispatchable call is usually a handler function, for instance in"] # [doc = "the anchor-handler or token-wrapper-handler pallet."] # [doc = ""] # [doc = "There are a few TODOs left in the function."] # [doc = ""] # [doc = "In the execute_proposal"] # [doc = "# <weight>"] # [doc = "- weight of proposed call, regardless of whether execution is performed"] # [doc = "# </weight>"] execute_proposal { src_id : :: core :: primitive :: u64 , call : :: std :: boxed :: Box < runtime_types :: egg_standalone_runtime :: Call > , proposal_data : :: std :: vec :: Vec < :: core :: primitive :: u8 > , signature : :: std :: vec :: Vec < :: core :: primitive :: u8 > , } , } # [derive (:: subxt :: codec :: Decode , :: subxt :: codec :: Encode , Clone , Debug , Eq , PartialEq)] pub enum Error { # [codec (index = 0)] # [doc = "Account does not have correct permissions"] InvalidPermissions , # [codec (index = 1)] # [doc = "Provided chain Id is not valid"] InvalidChainId , # [codec (index = 2)] # [doc = "Interactions with this chain is not permitted"] ChainNotWhitelisted , # [codec (index = 3)] # [doc = "Chain has already been enabled"] ChainAlreadyWhitelisted , # [codec (index = 4)] # [doc = "Resource ID provided isn't mapped to anything"] ResourceDoesNotExist , # [codec (index = 5)] # [doc = "Resource ID provided is already mapped to anchor"] ResourceAlreadyExists , # [codec (index = 6)] # [doc = "Provided signature is not from the active maintainer"] SignatureInvalid , # [codec (index = 7)] # [doc = "Protected operation, must be performed by relayer"] MustBeMaintainer , # [codec (index = 8)] # [doc = "A proposal with these parameters has already been submitted"] ProposalAlreadyExists , # [codec (index = 9)] # [doc = "Call does not match parsed call from proposal data"] CallNotConsistentWithProposalData , # [codec (index = 10)] # [doc = "Call does not match resource id according to resources mapping"] CallDoesNotMatchResourceId , # [codec (index = 11)] # [doc = "Chain Id Type from the r_id does not match this chain"] IncorrectExecutionChainIdType , # [codec (index = 12)] # [doc = "Invalid nonce"] InvalidNonce , # [codec (index = 13)] # [doc = "Invalid proposal data"] InvalidProposalData , } # [derive (:: subxt :: codec :: Decode , :: subxt :: codec :: Encode , Clone , Debug , Eq , PartialEq)] pub enum Event { # [codec (index = 0)] # [doc = "Maintainer is set"] MaintainerSet { old_maintainer : :: std :: vec :: Vec < :: core :: primitive :: u8 > , new_maintainer : :: std :: vec :: Vec < :: core :: primitive :: u8 > , } , # [codec (index = 1)] # [doc = "Chain now available for transfers (chain_id)"] ChainWhitelisted { chain_id : :: core :: primitive :: u64 , } , # [codec (index = 2)] # [doc = "Proposal has been approved"] ProposalApproved { chain_id : :: core :: primitive :: u64 , proposal_nonce : :: core :: primitive :: u32 , } , # [codec (index = 3)] # [doc = "Execution of call succeeded"] ProposalSucceeded { chain_id : :: core :: primitive :: u64 , proposal_nonce : :: core :: primitive :: u32 , } , # [codec (index = 4)] # [doc = "Execution of call failed"] ProposalFailed { chain_id : :: core :: primitive :: u64 , proposal_nonce : :: core :: primitive :: u32 , } , } } } pub mod pallet_staking { use super :: runtime_types ; pub mod pallet { use super :: runtime_types ; pub mod pallet { use super :: runtime_types ; # [derive (:: subxt :: codec :: Decode , :: subxt :: codec :: Encode , Clone , Debug , Eq , PartialEq)] pub enum Call { # [codec (index = 0)] # [doc = "Take the origin account as a stash and lock up `value` of its balance. `controller` will"] # [doc = "be the account that controls it."] # [doc = ""] # [doc = "`value` must be more than the `minimum_balance` specified by `T::Currency`."] # [doc = ""] # [doc = "The dispatch origin for this call must be _Signed_ by the stash account."] # [doc = ""] # [doc = "Emits `Bonded`."] # [doc = "# <weight>"] # [doc = "- Independent of the arguments. Moderate complexity."] # [doc = "- O(1)."] # [doc = "- Three extra DB entries."] # [doc = ""] # [doc = "NOTE: Two of the storage writes (`Self::bonded`, `Self::payee`) are _never_ cleaned"] # [doc = "unless the `origin` falls below _existential deposit_ and gets removed as dust."] # [doc = "------------------"] # [doc = "# </weight>"] bond { controller : :: subxt :: sp_runtime :: MultiAddress < :: subxt :: sp_core :: crypto :: AccountId32 , :: core :: primitive :: u32 > , # [codec (compact)] value : :: core :: primitive :: u128 , payee : runtime_types :: pallet_staking :: RewardDestination < :: subxt :: sp_core :: crypto :: AccountId32 > , } , # [codec (index = 1)] # [doc = "Add some extra amount that have appeared in the stash `free_balance` into the balance up"] # [doc = "for staking."] # [doc = ""] # [doc = "The dispatch origin for this call must be _Signed_ by the stash, not the controller."] # [doc = ""] # [doc = "Use this if there are additional funds in your stash account that you wish to bond."] # [doc = "Unlike [`bond`](Self::bond) or [`unbond`](Self::unbond) this function does not impose"] # [doc = "any limitation on the amount that can be added."] # [doc = ""] # [doc = "Emits `Bonded`."] # [doc = ""] # [doc = "# <weight>"] # [doc = "- Independent of the arguments. Insignificant complexity."] # [doc = "- O(1)."] # [doc = "# </weight>"] bond_extra { # [codec (compact)] max_additional : :: core :: primitive :: u128 , } , # [codec (index = 2)] # [doc = "Schedule a portion of the stash to be unlocked ready for transfer out after the bond"] # [doc = "period ends. If this leaves an amount actively bonded less than"] # [doc = "T::Currency::minimum_balance(), then it is increased to the full amount."] # [doc = ""] # [doc = "The dispatch origin for this call must be _Signed_ by the controller, not the stash."] # [doc = ""] # [doc = "Once the unlock period is done, you can call `withdraw_unbonded` to actually move"] # [doc = "the funds out of management ready for transfer."] # [doc = ""] # [doc = "No more than a limited number of unlocking chunks (see `MaxUnlockingChunks`)"] # [doc = "can co-exists at the same time. In that case, [`Call::withdraw_unbonded`] need"] # [doc = "to be called first to remove some of the chunks (if possible)."] # [doc = ""] # [doc = "If a user encounters the `InsufficientBond` error when calling this extrinsic,"] # [doc = "they should call `chill` first in order to free up their bonded funds."] # [doc = ""] # [doc = "Emits `Unbonded`."] # [doc = ""] # [doc = "See also [`Call::withdraw_unbonded`]."] unbond { # [codec (compact)] value : :: core :: primitive :: u128 , } , # [codec (index = 3)] # [doc = "Remove any unlocked chunks from the `unlocking` queue from our management."] # [doc = ""] # [doc = "This essentially frees up that balance to be used by the stash account to do"] # [doc = "whatever it wants."] # [doc = ""] # [doc = "The dispatch origin for this call must be _Signed_ by the controller."] # [doc = ""] # [doc = "Emits `Withdrawn`."] # [doc = ""] # [doc = "See also [`Call::unbond`]."] # [doc = ""] # [doc = "# <weight>"] # [doc = "Complexity O(S) where S is the number of slashing spans to remove"] # [doc = "NOTE: Weight annotation is the kill scenario, we refund otherwise."] # [doc = "# </weight>"] withdraw_unbonded { num_slashing_spans : :: core :: primitive :: u32 , } , # [codec (index = 4)] # [doc = "Declare the desire to validate for the origin controller."] # [doc = ""] # [doc = "Effects will be felt at the beginning of the next era."] # [doc = ""] # [doc = "The dispatch origin for this call must be _Signed_ by the controller, not the stash."] validate { prefs : runtime_types :: pallet_staking :: ValidatorPrefs , } , # [codec (index = 5)] # [doc = "Declare the desire to nominate `targets` for the origin controller."] # [doc = ""] # [doc = "Effects will be felt at the beginning of the next era."] # [doc = ""] # [doc = "The dispatch origin for this call must be _Signed_ by the controller, not the stash."] # [doc = ""] # [doc = "# <weight>"] # [doc = "- The transaction's complexity is proportional to the size of `targets` (N)"] # [doc = "which is capped at CompactAssignments::LIMIT (T::MaxNominations)."] # [doc = "- Both the reads and writes follow a similar pattern."] # [doc = "# </weight>"] nominate { targets : :: std :: vec :: Vec < :: subxt :: sp_runtime :: MultiAddress < :: subxt :: sp_core :: crypto :: AccountId32 , :: core :: primitive :: u32 > > , } , # [codec (index = 6)] # [doc = "Declare no desire to either validate or nominate."] # [doc = ""] # [doc = "Effects will be felt at the beginning of the next era."] # [doc = ""] # [doc = "The dispatch origin for this call must be _Signed_ by the controller, not the stash."] # [doc = ""] # [doc = "# <weight>"] # [doc = "- Independent of the arguments. Insignificant complexity."] # [doc = "- Contains one read."] # [doc = "- Writes are limited to the `origin` account key."] # [doc = "# </weight>"] chill , # [codec (index = 7)] # [doc = "(Re-)set the payment target for a controller."] # [doc = ""] # [doc = "Effects will be felt instantly (as soon as this function is completed successfully)."] # [doc = ""] # [doc = "The dispatch origin for this call must be _Signed_ by the controller, not the stash."] # [doc = ""] # [doc = "# <weight>"] # [doc = "- Independent of the arguments. Insignificant complexity."] # [doc = "- Contains a limited number of reads."] # [doc = "- Writes are limited to the `origin` account key."] # [doc = "---------"] # [doc = "- Weight: O(1)"] # [doc = "- DB Weight:"] # [doc = "    - Read: Ledger"] # [doc = "    - Write: Payee"] # [doc = "# </weight>"] set_payee { payee : runtime_types :: pallet_staking :: RewardDestination < :: subxt :: sp_core :: crypto :: AccountId32 > , } , # [codec (index = 8)] # [doc = "(Re-)set the controller of a stash."] # [doc = ""] # [doc = "Effects will be felt instantly (as soon as this function is completed successfully)."] # [doc = ""] # [doc = "The dispatch origin for this call must be _Signed_ by the stash, not the controller."] # [doc = ""] # [doc = "# <weight>"] # [doc = "- Independent of the arguments. Insignificant complexity."] # [doc = "- Contains a limited number of reads."] # [doc = "- Writes are limited to the `origin` account key."] # [doc = "----------"] # [doc = "Weight: O(1)"] # [doc = "DB Weight:"] # [doc = "- Read: Bonded, Ledger New Controller, Ledger Old Controller"] # [doc = "- Write: Bonded, Ledger New Controller, Ledger Old Controller"] # [doc = "# </weight>"] set_controller { controller : :: subxt :: sp_runtime :: MultiAddress < :: subxt :: sp_core :: crypto :: AccountId32 , :: core :: primitive :: u32 > , } , # [codec (index = 9)] # [doc = "Sets the ideal number of validators."] # [doc = ""] # [doc = "The dispatch origin must be Root."] # [doc = ""] # [doc = "# <weight>"] # [doc = "Weight: O(1)"] # [doc = "Write: Validator Count"] # [doc = "# </weight>"] set_validator_count { # [codec (compact)] new : :: core :: primitive :: u32 , } , # [codec (index = 10)] # [doc = "Increments the ideal number of validators."] # [doc = ""] # [doc = "The dispatch origin must be Root."] # [doc = ""] # [doc = "# <weight>"] # [doc = "Same as [`Self::set_validator_count`]."] # [doc = "# </weight>"] increase_validator_count { # [codec (compact)] additional : :: core :: primitive :: u32 , } , # [codec (index = 11)] # [doc = "Scale up the ideal number of validators by a factor."] # [doc = ""] # [doc = "The dispatch origin must be Root."] # [doc = ""] # [doc = "# <weight>"] # [doc = "Same as [`Self::set_validator_count`]."] # [doc = "# </weight>"] scale_validator_count { factor : runtime_types :: sp_arithmetic :: per_things :: Percent , } , # [codec (index = 12)] # [doc = "Force there to be no new eras indefinitely."] # [doc = ""] # [doc = "The dispatch origin must be Root."] # [doc = ""] # [doc = "# Warning"] # [doc = ""] # [doc = "The election process starts multiple blocks before the end of the era."] # [doc = "Thus the election process may be ongoing when this is called. In this case the"] # [doc = "election will continue until the next era is triggered."] # [doc = ""] # [doc = "# <weight>"] # [doc = "- No arguments."] # [doc = "- Weight: O(1)"] # [doc = "- Write: ForceEra"] # [doc = "# </weight>"] force_no_eras , # [codec (index = 13)] # [doc = "Force there to be a new era at the end of the next session. After this, it will be"] # [doc = "reset to normal (non-forced) behaviour."] # [doc = ""] # [doc = "The dispatch origin must be Root."] # [doc = ""] # [doc = "# Warning"] # [doc = ""] # [doc = "The election process starts multiple blocks before the end of the era."] # [doc = "If this is called just before a new era is triggered, the election process may not"] # [doc = "have enough blocks to get a result."] # [doc = ""] # [doc = "# <weight>"] # [doc = "- No arguments."] # [doc = "- Weight: O(1)"] # [doc = "- Write ForceEra"] # [doc = "# </weight>"] force_new_era , # [codec (index = 14)] # [doc = "Set the validators who cannot be slashed (if any)."] # [doc = ""] # [doc = "The dispatch origin must be Root."] set_invulnerables { invulnerables : :: std :: vec :: Vec < :: subxt :: sp_core :: crypto :: AccountId32 > , } , # [codec (index = 15)] # [doc = "Force a current staker to become completely unstaked, immediately."] # [doc = ""] # [doc = "The dispatch origin must be Root."] force_unstake { stash : :: subxt :: sp_core :: crypto :: AccountId32 , num_slashing_spans : :: core :: primitive :: u32 , } , # [codec (index = 16)] # [doc = "Force there to be a new era at the end of sessions indefinitely."] # [doc = ""] # [doc = "The dispatch origin must be Root."] # [doc = ""] # [doc = "# Warning"] # [doc = ""] # [doc = "The election process starts multiple blocks before the end of the era."] # [doc = "If this is called just before a new era is triggered, the election process may not"] # [doc = "have enough blocks to get a result."] force_new_era_always , # [codec (index = 17)] # [doc = "Cancel enactment of a deferred slash."] # [doc = ""] # [doc = "Can be called by the `T::SlashCancelOrigin`."] # [doc = ""] # [doc = "Parameters: era and indices of the slashes for that era to kill."] cancel_deferred_slash { era : :: core :: primitive :: u32 , slash_indices : :: std :: vec :: Vec < :: core :: primitive :: u32 > , } , # [codec (index = 18)] # [doc = "Pay out all the stakers behind a single validator for a single era."] # [doc = ""] # [doc = "- `validator_stash` is the stash account of the validator. Their nominators, up to"] # [doc = "  `T::MaxNominatorRewardedPerValidator`, will also receive their rewards."] # [doc = "- `era` may be any era between `[current_era - history_depth; current_era]`."] # [doc = ""] # [doc = "The origin of this call must be _Signed_. Any account can call this function, even if"] # [doc = "it is not one of the stakers."] # [doc = ""] # [doc = "# <weight>"] # [doc = "- Time complexity: at most O(MaxNominatorRewardedPerValidator)."] # [doc = "- Contains a limited number of reads and writes."] # [doc = "-----------"] # [doc = "N is the Number of payouts for the validator (including the validator)"] # [doc = "Weight:"] # [doc = "- Reward Destination Staked: O(N)"] # [doc = "- Reward Destination Controller (Creating): O(N)"] # [doc = ""] # [doc = "  NOTE: weights are assuming that payouts are made to alive stash account (Staked)."] # [doc = "  Paying even a dead controller is cheaper weight-wise. We don't do any refunds here."] # [doc = "# </weight>"] payout_stakers { validator_stash : :: subxt :: sp_core :: crypto :: AccountId32 , era : :: core :: primitive :: u32 , } , # [codec (index = 19)] # [doc = "Rebond a portion of the stash scheduled to be unlocked."] # [doc = ""] # [doc = "The dispatch origin must be signed by the controller."] # [doc = ""] # [doc = "# <weight>"] # [doc = "- Time complexity: O(L), where L is unlocking chunks"] # [doc = "- Bounded by `MaxUnlockingChunks`."] # [doc = "- Storage changes: Can't increase storage, only decrease it."] # [doc = "# </weight>"] rebond { # [codec (compact)] value : :: core :: primitive :: u128 , } , # [codec (index = 20)] # [doc = "Set `HistoryDepth` value. This function will delete any history information"] # [doc = "when `HistoryDepth` is reduced."] # [doc = ""] # [doc = "Parameters:"] # [doc = "- `new_history_depth`: The new history depth you would like to set."] # [doc = "- `era_items_deleted`: The number of items that will be deleted by this dispatch. This"] # [doc = "  should report all the storage items that will be deleted by clearing old era history."] # [doc = "  Needed to report an accurate weight for the dispatch. Trusted by `Root` to report an"] # [doc = "  accurate number."] # [doc = ""] # [doc = "Origin must be root."] # [doc = ""] # [doc = "# <weight>"] # [doc = "- E: Number of history depths removed, i.e. 10 -> 7 = 3"] # [doc = "- Weight: O(E)"] # [doc = "- DB Weight:"] # [doc = "    - Reads: Current Era, History Depth"] # [doc = "    - Writes: History Depth"] # [doc = "    - Clear Prefix Each: Era Stakers, EraStakersClipped, ErasValidatorPrefs"] # [doc = "    - Writes Each: ErasValidatorReward, ErasRewardPoints, ErasTotalStake,"] # [doc = "      ErasStartSessionIndex"] # [doc = "# </weight>"] set_history_depth { # [codec (compact)] new_history_depth : :: core :: primitive :: u32 , # [codec (compact)] era_items_deleted : :: core :: primitive :: u32 , } , # [codec (index = 21)] # [doc = "Remove all data structures concerning a staker/stash once it is at a state where it can"] # [doc = "be considered `dust` in the staking system. The requirements are:"] # [doc = ""] # [doc = "1. the `total_balance` of the stash is below existential deposit."] # [doc = "2. or, the `ledger.total` of the stash is below existential deposit."] # [doc = ""] # [doc = "The former can happen in cases like a slash; the latter when a fully unbonded account"] # [doc = "is still receiving staking rewards in `RewardDestination::Staked`."] # [doc = ""] # [doc = "It can be called by anyone, as long as `stash` meets the above requirements."] # [doc = ""] # [doc = "Refunds the transaction fees upon successful execution."] reap_stash { stash : :: subxt :: sp_core :: crypto :: AccountId32 , num_slashing_spans : :: core :: primitive :: u32 , } , # [codec (index = 22)] # [doc = "Remove the given nominations from the calling validator."] # [doc = ""] # [doc = "Effects will be felt at the beginning of the next era."] # [doc = ""] # [doc = "The dispatch origin for this call must be _Signed_ by the controller, not the stash."] # [doc = ""] # [doc = "- `who`: A list of nominator stash accounts who are nominating this validator which"] # [doc = "  should no longer be nominating this validator."] # [doc = ""] # [doc = "Note: Making this call only makes sense if you first set the validator preferences to"] # [doc = "block any further nominations."] kick { who : :: std :: vec :: Vec < :: subxt :: sp_runtime :: MultiAddress < :: subxt :: sp_core :: crypto :: AccountId32 , :: core :: primitive :: u32 > > , } , # [codec (index = 23)] # [doc = "Update the various staking configurations ."] # [doc = ""] # [doc = "* `min_nominator_bond`: The minimum active bond needed to be a nominator."] # [doc = "* `min_validator_bond`: The minimum active bond needed to be a validator."] # [doc = "* `max_nominator_count`: The max number of users who can be a nominator at once. When"] # [doc = "  set to `None`, no limit is enforced."] # [doc = "* `max_validator_count`: The max number of users who can be a validator at once. When"] # [doc = "  set to `None`, no limit is enforced."] # [doc = "* `chill_threshold`: The ratio of `max_nominator_count` or `max_validator_count` which"] # [doc = "  should be filled in order for the `chill_other` transaction to work."] # [doc = "* `min_commission`: The minimum amount of commission that each validators must maintain."] # [doc = "  This is checked only upon calling `validate`. Existing validators are not affected."] # [doc = ""] # [doc = "Origin must be Root to call this function."] # [doc = ""] # [doc = "NOTE: Existing nominators and validators will not be affected by this update."] # [doc = "to kick people under the new limits, `chill_other` should be called."] set_staking_configs { min_nominator_bond : runtime_types :: pallet_staking :: pallet :: pallet :: ConfigOp < :: core :: primitive :: u128 > , min_validator_bond : runtime_types :: pallet_staking :: pallet :: pallet :: ConfigOp < :: core :: primitive :: u128 > , max_nominator_count : runtime_types :: pallet_staking :: pallet :: pallet :: ConfigOp < :: core :: primitive :: u32 > , max_validator_count : runtime_types :: pallet_staking :: pallet :: pallet :: ConfigOp < :: core :: primitive :: u32 > , chill_threshold : runtime_types :: pallet_staking :: pallet :: pallet :: ConfigOp < runtime_types :: sp_arithmetic :: per_things :: Percent > , min_commission : runtime_types :: pallet_staking :: pallet :: pallet :: ConfigOp < runtime_types :: sp_arithmetic :: per_things :: Perbill > , } , # [codec (index = 24)] # [doc = "Declare a `controller` to stop participating as either a validator or nominator."] # [doc = ""] # [doc = "Effects will be felt at the beginning of the next era."] # [doc = ""] # [doc = "The dispatch origin for this call must be _Signed_, but can be called by anyone."] # [doc = ""] # [doc = "If the caller is the same as the controller being targeted, then no further checks are"] # [doc = "enforced, and this function behaves just like `chill`."] # [doc = ""] # [doc = "If the caller is different than the controller being targeted, the following conditions"] # [doc = "must be met:"] # [doc = ""] # [doc = "* `controller` must belong to a nominator who has become non-decodable,"] # [doc = ""] # [doc = "Or:"] # [doc = ""] # [doc = "* A `ChillThreshold` must be set and checked which defines how close to the max"] # [doc = "  nominators or validators we must reach before users can start chilling one-another."] # [doc = "* A `MaxNominatorCount` and `MaxValidatorCount` must be set which is used to determine"] # [doc = "  how close we are to the threshold."] # [doc = "* A `MinNominatorBond` and `MinValidatorBond` must be set and checked, which determines"] # [doc = "  if this is a person that should be chilled because they have not met the threshold"] # [doc = "  bond required."] # [doc = ""] # [doc = "This can be helpful if bond requirements are updated, and we need to remove old users"] # [doc = "who do not satisfy these requirements."] chill_other { controller : :: subxt :: sp_core :: crypto :: AccountId32 , } , # [codec (index = 25)] # [doc = "Force a validator to have at least the minimum commission. This will not affect a"] # [doc = "validator who already has a commission greater than or equal to the minimum. Any account"] # [doc = "can call this."] force_apply_min_commission { validator_stash : :: subxt :: sp_core :: crypto :: AccountId32 , } , } # [derive (:: subxt :: codec :: Decode , :: subxt :: codec :: Encode , Clone , Debug , Eq , PartialEq)] pub enum ConfigOp < _0 > { # [codec (index = 0)] Noop , # [codec (index = 1)] Set (_0 ,) , # [codec (index = 2)] Remove , } # [derive (:: subxt :: codec :: Decode , :: subxt :: codec :: Encode , Clone , Debug , Eq , PartialEq)] pub enum Error { # [codec (index = 0)] # [doc = "Not a controller account."] NotController , # [codec (index = 1)] # [doc = "Not a stash account."] NotStash , # [codec (index = 2)] # [doc = "Stash is already bonded."] AlreadyBonded , # [codec (index = 3)] # [doc = "Controller is already paired."] AlreadyPaired , # [codec (index = 4)] # [doc = "Targets cannot be empty."] EmptyTargets , # [codec (index = 5)] # [doc = "Duplicate index."] DuplicateIndex , # [codec (index = 6)] # [doc = "Slash record index out of bounds."] InvalidSlashIndex , # [codec (index = 7)] # [doc = "Cannot have a validator or nominator role, with value less than the minimum defined by"] # [doc = "governance (see `MinValidatorBond` and `MinNominatorBond`). If unbonding is the"] # [doc = "intention, `chill` first to remove one's role as validator/nominator."] InsufficientBond , # [codec (index = 8)] # [doc = "Can not schedule more unlock chunks."] NoMoreChunks , # [codec (index = 9)] # [doc = "Can not rebond without unlocking chunks."] NoUnlockChunk , # [codec (index = 10)] # [doc = "Attempting to target a stash that still has funds."] FundedTarget , # [codec (index = 11)] # [doc = "Invalid era to reward."] InvalidEraToReward , # [codec (index = 12)] # [doc = "Invalid number of nominations."] InvalidNumberOfNominations , # [codec (index = 13)] # [doc = "Items are not sorted and unique."] NotSortedAndUnique , # [codec (index = 14)] # [doc = "Rewards for this era have already been claimed for this validator."] AlreadyClaimed , # [codec (index = 15)] # [doc = "Incorrect previous history depth input provided."] IncorrectHistoryDepth , # [codec (index = 16)] # [doc = "Incorrect number of slashing spans provided."] IncorrectSlashingSpans , # [codec (index = 17)] # [doc = "Internal state has become somehow corrupted and the operation cannot continue."] BadState , # [codec (index = 18)] # [doc = "Too many nomination targets supplied."] TooManyTargets , # [codec (index = 19)] # [doc = "A nomination target was supplied that was blocked or otherwise not a validator."] BadTarget , # [codec (index = 20)] # [doc = "The user has enough bond and thus cannot be chilled forcefully by an external person."] CannotChillOther , # [codec (index = 21)] # [doc = "There are too many nominators in the system. Governance needs to adjust the staking"] # [doc = "settings to keep things safe for the runtime."] TooManyNominators , # [codec (index = 22)] # [doc = "There are too many validators in the system. Governance needs to adjust the staking"] # [doc = "settings to keep things safe for the runtime."] TooManyValidators , # [codec (index = 23)] # [doc = "Commission is too low. Must be at least `MinCommission`."] CommissionTooLow , } # [derive (:: subxt :: codec :: Decode , :: subxt :: codec :: Encode , Clone , Debug , Eq , PartialEq)] pub enum Event { # [codec (index = 0)] # [doc = "The era payout has been set; the first balance is the validator-payout; the second is"] # [doc = "the remainder from the maximum amount of reward."] # [doc = "\\[era_index, validator_payout, remainder\\]"] EraPaid (:: core :: primitive :: u32 , :: core :: primitive :: u128 , :: core :: primitive :: u128 ,) , # [codec (index = 1)] # [doc = "The nominator has been rewarded by this amount. \\[stash, amount\\]"] Rewarded (:: subxt :: sp_core :: crypto :: AccountId32 , :: core :: primitive :: u128 ,) , # [codec (index = 2)] # [doc = "One validator (and its nominators) has been slashed by the given amount."] # [doc = "\\[validator, amount\\]"] Slashed (:: subxt :: sp_core :: crypto :: AccountId32 , :: core :: primitive :: u128 ,) , # [codec (index = 3)] # [doc = "An old slashing report from a prior era was discarded because it could"] # [doc = "not be processed. \\[session_index\\]"] OldSlashingReportDiscarded (:: core :: primitive :: u32 ,) , # [codec (index = 4)] # [doc = "A new set of stakers was elected."] StakersElected , # [codec (index = 5)] # [doc = "An account has bonded this amount. \\[stash, amount\\]"] # [doc = ""] # [doc = "NOTE: This event is only emitted when funds are bonded via a dispatchable. Notably,"] # [doc = "it will not be emitted for staking rewards when they are added to stake."] Bonded (:: subxt :: sp_core :: crypto :: AccountId32 , :: core :: primitive :: u128 ,) , # [codec (index = 6)] # [doc = "An account has unbonded this amount. \\[stash, amount\\]"] Unbonded (:: subxt :: sp_core :: crypto :: AccountId32 , :: core :: primitive :: u128 ,) , # [codec (index = 7)] # [doc = "An account has called `withdraw_unbonded` and removed unbonding chunks worth `Balance`"] # [doc = "from the unlocking queue. \\[stash, amount\\]"] Withdrawn (:: subxt :: sp_core :: crypto :: AccountId32 , :: core :: primitive :: u128 ,) , # [codec (index = 8)] # [doc = "A nominator has been kicked from a validator. \\[nominator, stash\\]"] Kicked (:: subxt :: sp_core :: crypto :: AccountId32 , :: subxt :: sp_core :: crypto :: AccountId32 ,) , # [codec (index = 9)] # [doc = "The election failed. No new era is planned."] StakingElectionFailed , # [codec (index = 10)] # [doc = "An account has stopped participating as either a validator or nominator."] # [doc = "\\[stash\\]"] Chilled (:: subxt :: sp_core :: crypto :: AccountId32 ,) , # [codec (index = 11)] # [doc = "The stakers' rewards are getting paid. \\[era_index, validator_stash\\]"] PayoutStarted (:: core :: primitive :: u32 , :: subxt :: sp_core :: crypto :: AccountId32 ,) , # [codec (index = 12)] # [doc = "A validator has set their preferences."] ValidatorPrefsSet (:: subxt :: sp_core :: crypto :: AccountId32 , runtime_types :: pallet_staking :: ValidatorPrefs ,) , } } } pub mod slashing { use super :: runtime_types ; # [derive (:: subxt :: codec :: Decode , :: subxt :: codec :: Encode , Clone , Debug , Eq , PartialEq)] pub struct SlashingSpans { pub span_index : :: core :: primitive :: u32 , pub last_start : :: core :: primitive :: u32 , pub last_nonzero_slash : :: core :: primitive :: u32 , pub prior : :: std :: vec :: Vec < :: core :: primitive :: u32 > , } # [derive (:: subxt :: codec :: Decode , :: subxt :: codec :: Encode , Clone , Debug , Eq , PartialEq)] pub struct SpanRecord < _0 > { pub slashed : _0 , pub paid_out : _0 , } } # [derive (:: subxt :: codec :: Decode , :: subxt :: codec :: Encode , Clone , Debug , Eq , PartialEq)] pub struct ActiveEraInfo { pub index : :: core :: primitive :: u32 , pub start : :: core :: option :: Option < :: core :: primitive :: u64 > , } # [derive (:: subxt :: codec :: Decode , :: subxt :: codec :: Encode , Clone , Debug , Eq , PartialEq)] pub struct EraRewardPoints < _0 > { pub total : :: core :: primitive :: u32 , pub individual : :: subxt :: KeyedVec < _0 , :: core :: primitive :: u32 > , } # [derive (:: subxt :: codec :: Decode , :: subxt :: codec :: Encode , Clone , Debug , Eq , PartialEq)] pub struct Exposure < _0 , _1 > { # [codec (compact)] pub total : _1 , # [codec (compact)] pub own : _1 , pub others : :: std :: vec :: Vec < runtime_types :: pallet_staking :: IndividualExposure < _0 , _1 > > , } # [derive (:: subxt :: codec :: Decode , :: subxt :: codec :: Encode , Clone , Debug , Eq , PartialEq)] pub enum Forcing { # [codec (index = 0)] NotForcing , # [codec (index = 1)] ForceNew , # [codec (index = 2)] ForceNone , # [codec (index = 3)] ForceAlways , } # [derive (:: subxt :: codec :: Decode , :: subxt :: codec :: Encode , Clone , Debug , Eq , PartialEq)] pub struct IndividualExposure < _0 , _1 > { pub who : _0 , # [codec (compact)] pub value : _1 , } # [derive (:: subxt :: codec :: Decode , :: subxt :: codec :: Encode , Clone , Debug , Eq , PartialEq)] pub struct Nominations { pub targets : runtime_types :: sp_runtime :: bounded :: bounded_vec :: BoundedVec < :: subxt :: sp_core :: crypto :: AccountId32 > , pub submitted_in : :: core :: primitive :: u32 , pub suppressed : :: core :: primitive :: bool , } # [derive (:: subxt :: codec :: Decode , :: subxt :: codec :: Encode , Clone , Debug , Eq , PartialEq)] pub enum Releases { # [codec (index = 0)] V1_0_0Ancient , # [codec (index = 1)] V2_0_0 , # [codec (index = 2)] V3_0_0 , # [codec (index = 3)] V4_0_0 , # [codec (index = 4)] V5_0_0 , # [codec (index = 5)] V6_0_0 , # [codec (index = 6)] V7_0_0 , # [codec (index = 7)] V8_0_0 , # [codec (index = 8)] V9_0_0 , } # [derive (:: subxt :: codec :: Decode , :: subxt :: codec :: Encode , Clone , Debug , Eq , PartialEq)] pub enum RewardDestination < _0 > { # [codec (index = 0)] Staked , # [codec (index = 1)] Stash , # [codec (index = 2)] Controller , # [codec (index = 3)] Account (_0 ,) , # [codec (index = 4)] None , } # [derive (:: subxt :: codec :: Decode , :: subxt :: codec :: Encode , Clone , Debug , Eq , PartialEq)] pub struct StakingLedger { pub stash : :: subxt :: sp_core :: crypto :: AccountId32 , # [codec (compact)] pub total : :: core :: primitive :: u128 , # [codec (compact)] pub active : :: core :: primitive :: u128 , pub unlocking : runtime_types :: sp_runtime :: bounded :: bounded_vec :: BoundedVec < runtime_types :: pallet_staking :: UnlockChunk < :: core :: primitive :: u128 > > , pub claimed_rewards : :: std :: vec :: Vec < :: core :: primitive :: u32 > , } # [derive (:: subxt :: codec :: Decode , :: subxt :: codec :: Encode , Clone , Debug , Eq , PartialEq)] pub struct UnappliedSlash < _0 , _1 > { pub validator : _0 , pub own : _1 , pub others : :: std :: vec :: Vec < (_0 , _1 ,) > , pub reporters : :: std :: vec :: Vec < _0 > , pub payout : _1 , } # [derive (:: subxt :: codec :: Decode , :: subxt :: codec :: Encode , Clone , Debug , Eq , PartialEq)] pub struct UnlockChunk < _0 > { # [codec (compact)] pub value : _0 , # [codec (compact)] pub era : :: core :: primitive :: u32 , } # [derive (:: subxt :: codec :: Decode , :: subxt :: codec :: Encode , Clone , Debug , Eq , PartialEq)] pub struct ValidatorPrefs { # [codec (compact)] pub commission : runtime_types :: sp_arithmetic :: per_things :: Perbill , pub blocked : :: core :: primitive :: bool , } } pub mod pallet_sudo { use super :: runtime_types ; pub mod pallet { use super :: runtime_types ; # [derive (:: subxt :: codec :: Decode , :: subxt :: codec :: Encode , Clone , Debug , Eq , PartialEq)] pub enum Call { # [codec (index = 0)] # [doc = "Authenticates the sudo key and dispatches a function call with `Root` origin."] # [doc = ""] # [doc = "The dispatch origin for this call must be _Signed_."] # [doc = ""] # [doc = "# <weight>"] # [doc = "- O(1)."] # [doc = "- Limited storage reads."] # [doc = "- One DB write (event)."] # [doc = "- Weight of derivative `call` execution + 10,000."] # [doc = "# </weight>"] sudo { call : :: std :: boxed :: Box < runtime_types :: egg_standalone_runtime :: Call > , } , # [codec (index = 1)] # [doc = "Authenticates the sudo key and dispatches a function call with `Root` origin."] # [doc = "This function does not check the weight of the call, and instead allows the"] # [doc = "Sudo user to specify the weight of the call."] # [doc = ""] # [doc = "The dispatch origin for this call must be _Signed_."] # [doc = ""] # [doc = "# <weight>"] # [doc = "- O(1)."] # [doc = "- The weight of this call is defined by the caller."] # [doc = "# </weight>"] sudo_unchecked_weight { call : :: std :: boxed :: Box < runtime_types :: egg_standalone_runtime :: Call > , weight : :: core :: primitive :: u64 , } , # [codec (index = 2)] # [doc = "Authenticates the current sudo key and sets the given AccountId (`new`) as the new sudo"] # [doc = "key."] # [doc = ""] # [doc = "The dispatch origin for this call must be _Signed_."] # [doc = ""] # [doc = "# <weight>"] # [doc = "- O(1)."] # [doc = "- Limited storage reads."] # [doc = "- One DB change."] # [doc = "# </weight>"] set_key { new : :: subxt :: sp_runtime :: MultiAddress < :: subxt :: sp_core :: crypto :: AccountId32 , :: core :: primitive :: u32 > , } , # [codec (index = 3)] # [doc = "Authenticates the sudo key and dispatches a function call with `Signed` origin from"] # [doc = "a given account."] # [doc = ""] # [doc = "The dispatch origin for this call must be _Signed_."] # [doc = ""] # [doc = "# <weight>"] # [doc = "- O(1)."] # [doc = "- Limited storage reads."] # [doc = "- One DB write (event)."] # [doc = "- Weight of derivative `call` execution + 10,000."] # [doc = "# </weight>"] sudo_as { who : :: subxt :: sp_runtime :: MultiAddress < :: subxt :: sp_core :: crypto :: AccountId32 , :: core :: primitive :: u32 > , call : :: std :: boxed :: Box < runtime_types :: egg_standalone_runtime :: Call > , } , } # [derive (:: subxt :: codec :: Decode , :: subxt :: codec :: Encode , Clone , Debug , Eq , PartialEq)] pub enum Error { # [codec (index = 0)] # [doc = "Sender must be the Sudo account"] RequireSudo , } # [derive (:: subxt :: codec :: Decode , :: subxt :: codec :: Encode , Clone , Debug , Eq , PartialEq)] pub enum Event { # [codec (index = 0)] # [doc = "A sudo just took place. \\[result\\]"] Sudid { sudo_result : :: core :: result :: Result < () , runtime_types :: sp_runtime :: DispatchError > , } , # [codec (index = 1)] # [doc = "The \\[sudoer\\] just switched identity; the old key is supplied if one existed."] KeyChanged { old_sudoer : :: core :: option :: Option < :: subxt :: sp_core :: crypto :: AccountId32 > , } , # [codec (index = 2)] # [doc = "A sudo just took place. \\[result\\]"] SudoAsDone { sudo_result : :: core :: result :: Result < () , runtime_types :: sp_runtime :: DispatchError > , } , } } } pub mod pallet_timestamp { use super :: runtime_types ; pub mod pallet { use super :: runtime_types ; # [derive (:: subxt :: codec :: Decode , :: subxt :: codec :: Encode , Clone , Debug , Eq , PartialEq)] pub enum Call { # [codec (index = 0)] # [doc = "Set the current time."] # [doc = ""] # [doc = "This call should be invoked exactly once per block. It will panic at the finalization"] # [doc = "phase, if this call hasn't been invoked by that time."] # [doc = ""] # [doc = "The timestamp should be greater than the previous one by the amount specified by"] # [doc = "`MinimumPeriod`."] # [doc = ""] # [doc = "The dispatch origin for this call must be `Inherent`."] # [doc = ""] # [doc = "# <weight>"] # [doc = "- `O(1)` (Note that implementations of `OnTimestampSet` must also be `O(1)`)"] # [doc = "- 1 storage read and 1 storage mutation (codec `O(1)`). (because of `DidUpdate::take` in"] # [doc = "  `on_finalize`)"] # [doc = "- 1 event handler `on_timestamp_set`. Must be `O(1)`."] # [doc = "# </weight>"] set { # [codec (compact)] now : :: core :: primitive :: u64 , } , } } } pub mod pallet_token_wrapper { use super :: runtime_types ; pub mod pallet { use super :: runtime_types ; # [derive (:: subxt :: codec :: Decode , :: subxt :: codec :: Encode , Clone , Debug , Eq , PartialEq)] pub enum Call { # [codec (index = 0)] set_wrapping_fee { fee : :: core :: primitive :: u128 , into_pool_share_id : :: core :: primitive :: u32 , } , # [codec (index = 1)] wrap { from_asset_id : :: core :: primitive :: u32 , into_pool_share_id : :: core :: primitive :: u32 , amount : :: core :: primitive :: u128 , recipient : :: subxt :: sp_core :: crypto :: AccountId32 , } , # [codec (index = 2)] unwrap { from_pool_share_id : :: core :: primitive :: u32 , into_asset_id : :: core :: primitive :: u32 , amount : :: core :: primitive :: u128 , recipient : :: subxt :: sp_core :: crypto :: AccountId32 , } , } # [derive (:: subxt :: codec :: Decode , :: subxt :: codec :: Encode , Clone , Debug , Eq , PartialEq)] pub enum Error { # [codec (index = 0)] # [doc = "Invalid transaction amount"] InvalidAmount , # [codec (index = 1)] # [doc = "AssetId not found in selected pool share"] UnregisteredAssetId , # [codec (index = 2)] # [doc = "Assets not found in selected pool"] NotFoundInPool , # [codec (index = 3)] # [doc = "Insufficient Balance for an asset"] InsufficientBalance , # [codec (index = 4)] NoWrappingFeePercentFound , } # [derive (:: subxt :: codec :: Decode , :: subxt :: codec :: Encode , Clone , Debug , Eq , PartialEq)] pub enum Event { # [codec (index = 0)] WrappedToken { pool_share_asset : :: core :: primitive :: u32 , asset_id : :: core :: primitive :: u32 , amount : :: core :: primitive :: u128 , recipient : :: subxt :: sp_core :: crypto :: AccountId32 , } , # [codec (index = 1)] UnwrappedToken { pool_share_asset : :: core :: primitive :: u32 , asset_id : :: core :: primitive :: u32 , amount : :: core :: primitive :: u128 , recipient : :: subxt :: sp_core :: crypto :: AccountId32 , } , # [codec (index = 2)] UpdatedWrappingFeePercent { into_pool_share_id : :: core :: primitive :: u32 , wrapping_fee_percent : :: core :: primitive :: u128 , } , } } } pub mod pallet_transaction_payment { use super :: runtime_types ; pub mod pallet { use super :: runtime_types ; # [derive (:: subxt :: codec :: Decode , :: subxt :: codec :: Encode , Clone , Debug , Eq , PartialEq)] pub enum Event { # [codec (index = 0)] # [doc = "A transaction fee `actual_fee`, of which `tip` was added to the minimum inclusion fee,"] # [doc = "has been paid by `who`."] TransactionFeePaid { who : :: subxt :: sp_core :: crypto :: AccountId32 , actual_fee : :: core :: primitive :: u128 , tip : :: core :: primitive :: u128 , } , } } # [derive (:: subxt :: codec :: Decode , :: subxt :: codec :: Encode , Clone , Debug , Eq , PartialEq)] pub struct ChargeTransactionPayment (# [codec (compact)] pub :: core :: primitive :: u128 ,) ; # [derive (:: subxt :: codec :: Decode , :: subxt :: codec :: Encode , Clone , Debug , Eq , PartialEq)] pub enum Releases { # [codec (index = 0)] V1Ancient , # [codec (index = 1)] V2 , } } pub mod pallet_treasury { use super :: runtime_types ; pub mod pallet { use super :: runtime_types ; # [derive (:: subxt :: codec :: Decode , :: subxt :: codec :: Encode , Clone , Debug , Eq , PartialEq)] pub enum Call { # [codec (index = 0)] # [doc = "Put forward a suggestion for spending. A deposit proportional to the value"] # [doc = "is reserved and slashed if the proposal is rejected. It is returned once the"] # [doc = "proposal is awarded."] # [doc = ""] # [doc = "# <weight>"] # [doc = "- Complexity: O(1)"] # [doc = "- DbReads: `ProposalCount`, `origin account`"] # [doc = "- DbWrites: `ProposalCount`, `Proposals`, `origin account`"] # [doc = "# </weight>"] propose_spend { # [codec (compact)] value : :: core :: primitive :: u128 , beneficiary : :: subxt :: sp_runtime :: MultiAddress < :: subxt :: sp_core :: crypto :: AccountId32 , :: core :: primitive :: u32 > , } , # [codec (index = 1)] # [doc = "Reject a proposed spend. The original deposit will be slashed."] # [doc = ""] # [doc = "May only be called from `T::RejectOrigin`."] # [doc = ""] # [doc = "# <weight>"] # [doc = "- Complexity: O(1)"] # [doc = "- DbReads: `Proposals`, `rejected proposer account`"] # [doc = "- DbWrites: `Proposals`, `rejected proposer account`"] # [doc = "# </weight>"] reject_proposal { # [codec (compact)] proposal_id : :: core :: primitive :: u32 , } , # [codec (index = 2)] # [doc = "Approve a proposal. At a later time, the proposal will be allocated to the beneficiary"] # [doc = "and the original deposit will be returned."] # [doc = ""] # [doc = "May only be called from `T::ApproveOrigin`."] # [doc = ""] # [doc = "# <weight>"] # [doc = "- Complexity: O(1)."] # [doc = "- DbReads: `Proposals`, `Approvals`"] # [doc = "- DbWrite: `Approvals`"] # [doc = "# </weight>"] approve_proposal { # [codec (compact)] proposal_id : :: core :: primitive :: u32 , } , # [codec (index = 3)] # [doc = "Propose and approve a spend of treasury funds."] # [doc = ""] # [doc = "- `origin`: Must be `SpendOrigin` with the `Success` value being at least `amount`."] # [doc = "- `amount`: The amount to be transferred from the treasury to the `beneficiary`."] # [doc = "- `beneficiary`: The destination account for the transfer."] # [doc = ""] # [doc = "NOTE: For record-keeping purposes, the proposer is deemed to be equivalent to the"] # [doc = "beneficiary."] spend { # [codec (compact)] amount : :: core :: primitive :: u128 , beneficiary : :: subxt :: sp_runtime :: MultiAddress < :: subxt :: sp_core :: crypto :: AccountId32 , :: core :: primitive :: u32 > , } , # [codec (index = 4)] # [doc = "Force a previously approved proposal to be removed from the approval queue."] # [doc = "The original deposit will no longer be returned."] # [doc = ""] # [doc = "May only be called from `T::RejectOrigin`."] # [doc = "- `proposal_id`: The index of a proposal"] # [doc = ""] # [doc = "# <weight>"] # [doc = "- Complexity: O(A) where `A` is the number of approvals"] # [doc = "- Db reads and writes: `Approvals`"] # [doc = "# </weight>"] # [doc = ""] # [doc = "Errors:"] # [doc = "- `ProposalNotApproved`: The `proposal_id` supplied was not found in the approval queue,"] # [doc = "i.e., the proposal has not been approved. This could also mean the proposal does not"] # [doc = "exist altogether, thus there is no way it would have been approved in the first place."] remove_approval { # [codec (compact)] proposal_id : :: core :: primitive :: u32 , } , } # [derive (:: subxt :: codec :: Decode , :: subxt :: codec :: Encode , Clone , Debug , Eq , PartialEq)] pub enum Error { # [codec (index = 0)] # [doc = "Proposer's balance is too low."] InsufficientProposersBalance , # [codec (index = 1)] # [doc = "No proposal or bounty at that index."] InvalidIndex , # [codec (index = 2)] # [doc = "Too many approvals in the queue."] TooManyApprovals , # [codec (index = 3)] # [doc = "The spend origin is valid but the amount it is allowed to spend is lower than the"] # [doc = "amount to be spent."] InsufficientPermission , # [codec (index = 4)] # [doc = "Proposal has not been approved."] ProposalNotApproved , } # [derive (:: subxt :: codec :: Decode , :: subxt :: codec :: Encode , Clone , Debug , Eq , PartialEq)] pub enum Event { # [codec (index = 0)] # [doc = "New proposal."] Proposed { proposal_index : :: core :: primitive :: u32 , } , # [codec (index = 1)] # [doc = "We have ended a spend period and will now allocate funds."] Spending { budget_remaining : :: core :: primitive :: u128 , } , # [codec (index = 2)] # [doc = "Some funds have been allocated."] Awarded { proposal_index : :: core :: primitive :: u32 , award : :: core :: primitive :: u128 , account : :: subxt :: sp_core :: crypto :: AccountId32 , } , # [codec (index = 3)] # [doc = "A proposal was rejected; funds were slashed."] Rejected { proposal_index : :: core :: primitive :: u32 , slashed : :: core :: primitive :: u128 , } , # [codec (index = 4)] # [doc = "Some of our funds have been burnt."] Burnt { burnt_funds : :: core :: primitive :: u128 , } , # [codec (index = 5)] # [doc = "Spending has finished; this is the amount that rolls over until next spend."] Rollover { rollover_balance : :: core :: primitive :: u128 , } , # [codec (index = 6)] # [doc = "Some funds have been deposited."] Deposit { value : :: core :: primitive :: u128 , } , # [codec (index = 7)] # [doc = "A new spend proposal has been approved."] SpendApproved { proposal_index : :: core :: primitive :: u32 , amount : :: core :: primitive :: u128 , beneficiary : :: subxt :: sp_core :: crypto :: AccountId32 , } , } } # [derive (:: subxt :: codec :: Decode , :: subxt :: codec :: Encode , Clone , Debug , Eq , PartialEq)] pub struct Proposal < _0 , _1 > { pub proposer : _0 , pub value : _1 , pub beneficiary : _0 , pub bond : _1 , } } pub mod pallet_vanchor { use super :: runtime_types ; pub mod pallet { use super :: runtime_types ; # [derive (:: subxt :: codec :: Decode , :: subxt :: codec :: Encode , Clone , Debug , Eq , PartialEq)] pub enum Call { # [codec (index = 0)] create { max_edges : :: core :: primitive :: u32 , depth : :: core :: primitive :: u8 , asset : :: core :: primitive :: u32 , } , # [codec (index = 1)] transact { id : :: core :: primitive :: u32 , proof_data : runtime_types :: webb_primitives :: types :: vanchor :: ProofData < runtime_types :: egg_standalone_runtime :: protocol_substrate_config :: Element > , ext_data : runtime_types :: webb_primitives :: types :: vanchor :: ExtData < :: subxt :: sp_core :: crypto :: AccountId32 , :: core :: primitive :: i128 , :: core :: primitive :: u128 > , } , # [codec (index = 2)] set_max_deposit_amount { max_deposit_amount : :: core :: primitive :: u128 , } , # [codec (index = 3)] set_min_withdraw_amount { min_withdraw_amount : :: core :: primitive :: u128 , } , } # [derive (:: subxt :: codec :: Decode , :: subxt :: codec :: Encode , Clone , Debug , Eq , PartialEq)] pub enum Error { # [codec (index = 0)] # [doc = "Invalid transaction proof"] InvalidTransactionProof , # [codec (index = 1)] # [doc = "Variable Anchor not found."] NoVAnchorFound , # [codec (index = 2)] # [doc = "Invalid nullifier that is already used"] # [doc = "(this error is returned when a nullifier is used twice)"] AlreadyRevealedNullifier , # [codec (index = 3)] InvalidExtAmount , # [codec (index = 4)] InvalidDepositAmount , # [codec (index = 5)] InvalidWithdrawAmount , # [codec (index = 6)] InvalidExtData , # [codec (index = 7)] InvalidInputNullifiers , # [codec (index = 8)] InvalidFee , # [codec (index = 9)] InvalidPublicAmount , } # [derive (:: subxt :: codec :: Decode , :: subxt :: codec :: Encode , Clone , Debug , Eq , PartialEq)] pub enum Event { # [codec (index = 0)] # [doc = "New tree created"] VAnchorCreation { tree_id : :: core :: primitive :: u32 , } , # [codec (index = 1)] # [doc = "Transaction has been made"] Transaction { transactor : :: subxt :: sp_core :: crypto :: AccountId32 , tree_id : :: core :: primitive :: u32 , leafs : :: std :: vec :: Vec < runtime_types :: egg_standalone_runtime :: protocol_substrate_config :: Element > , amount : :: core :: primitive :: i128 , } , # [codec (index = 2)] # [doc = "Deposit hook has executed successfully"] Deposit { depositor : :: subxt :: sp_core :: crypto :: AccountId32 , tree_id : :: core :: primitive :: u32 , leaf : runtime_types :: egg_standalone_runtime :: protocol_substrate_config :: Element , } , # [codec (index = 3)] MaxDepositAmountChanged { max_deposit_amount : :: core :: primitive :: u128 , } , # [codec (index = 4)] MinWithdrawAmountChanged { min_withdraw_amount : :: core :: primitive :: u128 , } , } } } pub mod pallet_vanchor_handler { use super :: runtime_types ; pub mod pallet { use super :: runtime_types ; # [derive (:: subxt :: codec :: Decode , :: subxt :: codec :: Encode , Clone , Debug , Eq , PartialEq)] pub enum Call { # [codec (index = 0)] # [doc = "This will be called by bridge when proposal to create a"] # [doc = "vanchor has been successfully voted on."] execute_vanchor_create_proposal { src_chain_id : :: core :: primitive :: u64 , r_id : [:: core :: primitive :: u8 ; 32usize] , max_edges : :: core :: primitive :: u32 , tree_depth : :: core :: primitive :: u8 , asset : :: core :: primitive :: u32 , } , # [codec (index = 1)] # [doc = "This will be called by bridge when proposal to add/update edge of a"] # [doc = "vanchor has been successfully voted on."] execute_vanchor_update_proposal { r_id : [:: core :: primitive :: u8 ; 32usize] , vanchor_metadata : runtime_types :: pallet_linkable_tree :: types :: EdgeMetadata < :: core :: primitive :: u64 , runtime_types :: egg_standalone_runtime :: protocol_substrate_config :: Element , :: core :: primitive :: u32 > , } , # [codec (index = 2)] # [doc = "This will by called by bridge when proposal to set new resource for"] # [doc = "handler has been successfully voted on"] execute_set_resource_proposal { r_id : [:: core :: primitive :: u8 ; 32usize] , target : runtime_types :: webb_proposals :: header :: TargetSystem , } , } # [derive (:: subxt :: codec :: Decode , :: subxt :: codec :: Encode , Clone , Debug , Eq , PartialEq)] pub enum Error { # [codec (index = 0)] # [doc = "Access violation."] InvalidPermissions , # [codec (index = 1)] ResourceIsAlreadyAnchored , # [codec (index = 2)] AnchorHandlerNotFound , # [codec (index = 3)] SourceChainIdNotFound , # [codec (index = 4)] # [doc = "Storage overflowed."] StorageOverflow , } # [derive (:: subxt :: codec :: Decode , :: subxt :: codec :: Encode , Clone , Debug , Eq , PartialEq)] pub enum Event { # [codec (index = 0)] AnchorCreated , # [codec (index = 1)] AnchorEdgeAdded , # [codec (index = 2)] AnchorEdgeUpdated , # [codec (index = 3)] ResourceAnchored , } } pub mod types { use super :: runtime_types ; # [derive (:: subxt :: codec :: Decode , :: subxt :: codec :: Encode , Clone , Debug , Eq , PartialEq)] pub struct UpdateRecord < _0 , _1 , _2 , _3 , _4 > { pub tree_id : _0 , pub resource_id : _1 , pub edge_metadata : runtime_types :: pallet_linkable_tree :: types :: EdgeMetadata < _2 , _3 , _0 > , # [codec (skip)] pub __subxt_unused_type_params : :: core :: marker :: PhantomData < _4 > } } } pub mod pallet_verifier { use super :: runtime_types ; pub mod pallet { use super :: runtime_types ; # [derive (:: subxt :: codec :: Decode , :: subxt :: codec :: Encode , Clone , Debug , Eq , PartialEq)] pub enum Call { # [codec (index = 0)] force_set_parameters { parameters : :: std :: vec :: Vec < :: core :: primitive :: u8 > , } , } # [derive (:: subxt :: codec :: Decode , :: subxt :: codec :: Encode , Clone , Debug , Eq , PartialEq)] pub enum Error { # [codec (index = 0)] # [doc = "Parameters haven't been initialized"] ParametersNotInitialized , # [codec (index = 1)] # [doc = "Error during verification"] VerifyError , } # [derive (:: subxt :: codec :: Decode , :: subxt :: codec :: Encode , Clone , Debug , Eq , PartialEq)] pub enum Event { } } } pub mod primitive_types { use super :: runtime_types ; # [derive (:: subxt :: codec :: Decode , :: subxt :: codec :: Encode , Clone , Debug , Eq , PartialEq)] pub struct H256 (pub [:: core :: primitive :: u8 ; 32usize] ,) ; # [derive (:: subxt :: codec :: Decode , :: subxt :: codec :: Encode , Clone , Debug , Eq , PartialEq)] pub struct U256 (pub [:: core :: primitive :: u64 ; 4usize] ,) ; } pub mod sp_arithmetic { use super :: runtime_types ; pub mod fixed_point { use super :: runtime_types ; # [derive (:: subxt :: codec :: CompactAs , :: subxt :: codec :: Decode , :: subxt :: codec :: Encode , Clone , Debug , Eq , PartialEq)] pub struct FixedU128 (pub :: core :: primitive :: u128 ,) ; } pub mod per_things { use super :: runtime_types ; # [derive (:: subxt :: codec :: CompactAs , :: subxt :: codec :: Decode , :: subxt :: codec :: Encode , Clone , Debug , Eq , PartialEq)] pub struct PerU16 (pub :: core :: primitive :: u16 ,) ; # [derive (:: subxt :: codec :: CompactAs , :: subxt :: codec :: Decode , :: subxt :: codec :: Encode , Clone , Debug , Eq , PartialEq)] pub struct Perbill (pub :: core :: primitive :: u32 ,) ; # [derive (:: subxt :: codec :: CompactAs , :: subxt :: codec :: Decode , :: subxt :: codec :: Encode , Clone , Debug , Eq , PartialEq)] pub struct Percent (pub :: core :: primitive :: u8 ,) ; # [derive (:: subxt :: codec :: CompactAs , :: subxt :: codec :: Decode , :: subxt :: codec :: Encode , Clone , Debug , Eq , PartialEq)] pub struct Permill (pub :: core :: primitive :: u32 ,) ; } } pub mod sp_consensus_aura { use super :: runtime_types ; pub mod sr25519 { use super :: runtime_types ; pub mod app_sr25519 { use super :: runtime_types ; # [derive (:: subxt :: codec :: Decode , :: subxt :: codec :: Encode , Clone , Debug , Eq , PartialEq)] pub struct Public (pub runtime_types :: sp_core :: sr25519 :: Public ,) ; } } } pub mod sp_consensus_slots { use super :: runtime_types ; # [derive (:: subxt :: codec :: CompactAs , :: subxt :: codec :: Decode , :: subxt :: codec :: Encode , Clone , Debug , Eq , PartialEq)] pub struct Slot (pub :: core :: primitive :: u64 ,) ; } pub mod sp_core { use super :: runtime_types ; pub mod crypto { use super :: runtime_types ; # [derive (:: subxt :: codec :: Decode , :: subxt :: codec :: Encode , Clone , Debug , Eq , PartialEq)] pub struct AccountId32 (pub [:: core :: primitive :: u8 ; 32usize] ,) ; # [derive (:: subxt :: codec :: Decode , :: subxt :: codec :: Encode , Clone , Debug , Eq , PartialEq)] pub struct KeyTypeId (pub [:: core :: primitive :: u8 ; 4usize] ,) ; } pub mod ecdsa { use super :: runtime_types ; # [derive (:: subxt :: codec :: Decode , :: subxt :: codec :: Encode , Clone , Debug , Eq , PartialEq)] pub struct Public (pub [:: core :: primitive :: u8 ; 33usize] ,) ; # [derive (:: subxt :: codec :: Decode , :: subxt :: codec :: Encode , Clone , Debug , Eq , PartialEq)] pub struct Signature (pub [:: core :: primitive :: u8 ; 65usize] ,) ; } pub mod ed25519 { use super :: runtime_types ; # [derive (:: subxt :: codec :: Decode , :: subxt :: codec :: Encode , Clone , Debug , Eq , PartialEq)] pub struct Public (pub [:: core :: primitive :: u8 ; 32usize] ,) ; # [derive (:: subxt :: codec :: Decode , :: subxt :: codec :: Encode , Clone , Debug , Eq , PartialEq)] pub struct Signature (pub [:: core :: primitive :: u8 ; 64usize] ,) ; } pub mod sr25519 { use super :: runtime_types ; # [derive (:: subxt :: codec :: Decode , :: subxt :: codec :: Encode , Clone , Debug , Eq , PartialEq)] pub struct Public (pub [:: core :: primitive :: u8 ; 32usize] ,) ; # [derive (:: subxt :: codec :: Decode , :: subxt :: codec :: Encode , Clone , Debug , Eq , PartialEq)] pub struct Signature (pub [:: core :: primitive :: u8 ; 64usize] ,) ; } # [derive (:: subxt :: codec :: Decode , :: subxt :: codec :: Encode , Clone , Debug , Eq , PartialEq)] pub enum Void { } } pub mod sp_finality_grandpa { use super :: runtime_types ; pub mod app { use super :: runtime_types ; # [derive (:: subxt :: codec :: Decode , :: subxt :: codec :: Encode , Clone , Debug , Eq , PartialEq)] pub struct Public (pub runtime_types :: sp_core :: ed25519 :: Public ,) ; # [derive (:: subxt :: codec :: Decode , :: subxt :: codec :: Encode , Clone , Debug , Eq , PartialEq)] pub struct Signature (pub runtime_types :: sp_core :: ed25519 :: Signature ,) ; } # [derive (:: subxt :: codec :: Decode , :: subxt :: codec :: Encode , Clone , Debug , Eq , PartialEq)] pub enum Equivocation < _0 , _1 > { # [codec (index = 0)] Prevote (runtime_types :: finality_grandpa :: Equivocation < runtime_types :: sp_finality_grandpa :: app :: Public , runtime_types :: finality_grandpa :: Prevote < _0 , _1 > , runtime_types :: sp_finality_grandpa :: app :: Signature > ,) , # [codec (index = 1)] Precommit (runtime_types :: finality_grandpa :: Equivocation < runtime_types :: sp_finality_grandpa :: app :: Public , runtime_types :: finality_grandpa :: Precommit < _0 , _1 > , runtime_types :: sp_finality_grandpa :: app :: Signature > ,) , } # [derive (:: subxt :: codec :: Decode , :: subxt :: codec :: Encode , Clone , Debug , Eq , PartialEq)] pub struct EquivocationProof < _0 , _1 > { pub set_id : :: core :: primitive :: u64 , pub equivocation : runtime_types :: sp_finality_grandpa :: Equivocation < _0 , _1 > , } } pub mod sp_npos_elections { use super :: runtime_types ; # [derive (:: subxt :: codec :: Decode , :: subxt :: codec :: Encode , Clone , Debug , Eq , PartialEq)] pub struct ElectionScore { pub minimal_stake : :: core :: primitive :: u128 , pub sum_stake : :: core :: primitive :: u128 , pub sum_stake_squared : :: core :: primitive :: u128 , } # [derive (:: subxt :: codec :: Decode , :: subxt :: codec :: Encode , Clone , Debug , Eq , PartialEq)] pub struct Support < _0 > { pub total : :: core :: primitive :: u128 , pub voters : :: std :: vec :: Vec < (_0 , :: core :: primitive :: u128 ,) > , } } pub mod sp_runtime { use super :: runtime_types ; pub mod bounded { use super :: runtime_types ; pub mod bounded_btree_map { use super :: runtime_types ; # [derive (:: subxt :: codec :: Decode , :: subxt :: codec :: Encode , Clone , Debug , Eq , PartialEq)] pub struct BoundedBTreeMap < _0 , _1 > (pub :: subxt :: KeyedVec < _0 , _1 > ,) ; } pub mod bounded_vec { use super :: runtime_types ; # [derive (:: subxt :: codec :: Decode , :: subxt :: codec :: Encode , Clone , Debug , Eq , PartialEq)] pub struct BoundedVec < _0 > (pub :: std :: vec :: Vec < _0 > ,) ; } pub mod weak_bounded_vec { use super :: runtime_types ; # [derive (:: subxt :: codec :: Decode , :: subxt :: codec :: Encode , Clone , Debug , Eq , PartialEq)] pub struct WeakBoundedVec < _0 > (pub :: std :: vec :: Vec < _0 > ,) ; } } pub mod generic { use super :: runtime_types ; pub mod digest { use super :: runtime_types ; # [derive (:: subxt :: codec :: Decode , :: subxt :: codec :: Encode , Clone , Debug , Eq , PartialEq)] pub struct Digest { pub logs : :: std :: vec :: Vec < runtime_types :: sp_runtime :: generic :: digest :: DigestItem > , } # [derive (:: subxt :: codec :: Decode , :: subxt :: codec :: Encode , Clone , Debug , Eq , PartialEq)] pub enum DigestItem { # [codec (index = 6)] PreRuntime ([:: core :: primitive :: u8 ; 4usize] , :: std :: vec :: Vec < :: core :: primitive :: u8 > ,) , # [codec (index = 4)] Consensus ([:: core :: primitive :: u8 ; 4usize] , :: std :: vec :: Vec < :: core :: primitive :: u8 > ,) , # [codec (index = 5)] Seal ([:: core :: primitive :: u8 ; 4usize] , :: std :: vec :: Vec < :: core :: primitive :: u8 > ,) , # [codec (index = 0)] Other (:: std :: vec :: Vec < :: core :: primitive :: u8 > ,) , # [codec (index = 8)] RuntimeEnvironmentUpdated , } } pub mod era { use super :: runtime_types ; # [derive (:: subxt :: codec :: Decode , :: subxt :: codec :: Encode , Clone , Debug , Eq , PartialEq)] pub enum Era { # [codec (index = 0)] Immortal , # [codec (index = 1)] Mortal1 (:: core :: primitive :: u8 ,) , # [codec (index = 2)] Mortal2 (:: core :: primitive :: u8 ,) , # [codec (index = 3)] Mortal3 (:: core :: primitive :: u8 ,) , # [codec (index = 4)] Mortal4 (:: core :: primitive :: u8 ,) , # [codec (index = 5)] Mortal5 (:: core :: primitive :: u8 ,) , # [codec (index = 6)] Mortal6 (:: core :: primitive :: u8 ,) , # [codec (index = 7)] Mortal7 (:: core :: primitive :: u8 ,) , # [codec (index = 8)] Mortal8 (:: core :: primitive :: u8 ,) , # [codec (index = 9)] Mortal9 (:: core :: primitive :: u8 ,) , # [codec (index = 10)] Mortal10 (:: core :: primitive :: u8 ,) , # [codec (index = 11)] Mortal11 (:: core :: primitive :: u8 ,) , # [codec (index = 12)] Mortal12 (:: core :: primitive :: u8 ,) , # [codec (index = 13)] Mortal13 (:: core :: primitive :: u8 ,) , # [codec (index = 14)] Mortal14 (:: core :: primitive :: u8 ,) , # [codec (index = 15)] Mortal15 (:: core :: primitive :: u8 ,) , # [codec (index = 16)] Mortal16 (:: core :: primitive :: u8 ,) , # [codec (index = 17)] Mortal17 (:: core :: primitive :: u8 ,) , # [codec (index = 18)] Mortal18 (:: core :: primitive :: u8 ,) , # [codec (index = 19)] Mortal19 (:: core :: primitive :: u8 ,) , # [codec (index = 20)] Mortal20 (:: core :: primitive :: u8 ,) , # [codec (index = 21)] Mortal21 (:: core :: primitive :: u8 ,) , # [codec (index = 22)] Mortal22 (:: core :: primitive :: u8 ,) , # [codec (index = 23)] Mortal23 (:: core :: primitive :: u8 ,) , # [codec (index = 24)] Mortal24 (:: core :: primitive :: u8 ,) , # [codec (index = 25)] Mortal25 (:: core :: primitive :: u8 ,) , # [codec (index = 26)] Mortal26 (:: core :: primitive :: u8 ,) , # [codec (index = 27)] Mortal27 (:: core :: primitive :: u8 ,) , # [codec (index = 28)] Mortal28 (:: core :: primitive :: u8 ,) , # [codec (index = 29)] Mortal29 (:: core :: primitive :: u8 ,) , # [codec (index = 30)] Mortal30 (:: core :: primitive :: u8 ,) , # [codec (index = 31)] Mortal31 (:: core :: primitive :: u8 ,) , # [codec (index = 32)] Mortal32 (:: core :: primitive :: u8 ,) , # [codec (index = 33)] Mortal33 (:: core :: primitive :: u8 ,) , # [codec (index = 34)] Mortal34 (:: core :: primitive :: u8 ,) , # [codec (index = 35)] Mortal35 (:: core :: primitive :: u8 ,) , # [codec (index = 36)] Mortal36 (:: core :: primitive :: u8 ,) , # [codec (index = 37)] Mortal37 (:: core :: primitive :: u8 ,) , # [codec (index = 38)] Mortal38 (:: core :: primitive :: u8 ,) , # [codec (index = 39)] Mortal39 (:: core :: primitive :: u8 ,) , # [codec (index = 40)] Mortal40 (:: core :: primitive :: u8 ,) , # [codec (index = 41)] Mortal41 (:: core :: primitive :: u8 ,) , # [codec (index = 42)] Mortal42 (:: core :: primitive :: u8 ,) , # [codec (index = 43)] Mortal43 (:: core :: primitive :: u8 ,) , # [codec (index = 44)] Mortal44 (:: core :: primitive :: u8 ,) , # [codec (index = 45)] Mortal45 (:: core :: primitive :: u8 ,) , # [codec (index = 46)] Mortal46 (:: core :: primitive :: u8 ,) , # [codec (index = 47)] Mortal47 (:: core :: primitive :: u8 ,) , # [codec (index = 48)] Mortal48 (:: core :: primitive :: u8 ,) , # [codec (index = 49)] Mortal49 (:: core :: primitive :: u8 ,) , # [codec (index = 50)] Mortal50 (:: core :: primitive :: u8 ,) , # [codec (index = 51)] Mortal51 (:: core :: primitive :: u8 ,) , # [codec (index = 52)] Mortal52 (:: core :: primitive :: u8 ,) , # [codec (index = 53)] Mortal53 (:: core :: primitive :: u8 ,) , # [codec (index = 54)] Mortal54 (:: core :: primitive :: u8 ,) , # [codec (index = 55)] Mortal55 (:: core :: primitive :: u8 ,) , # [codec (index = 56)] Mortal56 (:: core :: primitive :: u8 ,) , # [codec (index = 57)] Mortal57 (:: core :: primitive :: u8 ,) , # [codec (index = 58)] Mortal58 (:: core :: primitive :: u8 ,) , # [codec (index = 59)] Mortal59 (:: core :: primitive :: u8 ,) , # [codec (index = 60)] Mortal60 (:: core :: primitive :: u8 ,) , # [codec (index = 61)] Mortal61 (:: core :: primitive :: u8 ,) , # [codec (index = 62)] Mortal62 (:: core :: primitive :: u8 ,) , # [codec (index = 63)] Mortal63 (:: core :: primitive :: u8 ,) , # [codec (index = 64)] Mortal64 (:: core :: primitive :: u8 ,) , # [codec (index = 65)] Mortal65 (:: core :: primitive :: u8 ,) , # [codec (index = 66)] Mortal66 (:: core :: primitive :: u8 ,) , # [codec (index = 67)] Mortal67 (:: core :: primitive :: u8 ,) , # [codec (index = 68)] Mortal68 (:: core :: primitive :: u8 ,) , # [codec (index = 69)] Mortal69 (:: core :: primitive :: u8 ,) , # [codec (index = 70)] Mortal70 (:: core :: primitive :: u8 ,) , # [codec (index = 71)] Mortal71 (:: core :: primitive :: u8 ,) , # [codec (index = 72)] Mortal72 (:: core :: primitive :: u8 ,) , # [codec (index = 73)] Mortal73 (:: core :: primitive :: u8 ,) , # [codec (index = 74)] Mortal74 (:: core :: primitive :: u8 ,) , # [codec (index = 75)] Mortal75 (:: core :: primitive :: u8 ,) , # [codec (index = 76)] Mortal76 (:: core :: primitive :: u8 ,) , # [codec (index = 77)] Mortal77 (:: core :: primitive :: u8 ,) , # [codec (index = 78)] Mortal78 (:: core :: primitive :: u8 ,) , # [codec (index = 79)] Mortal79 (:: core :: primitive :: u8 ,) , # [codec (index = 80)] Mortal80 (:: core :: primitive :: u8 ,) , # [codec (index = 81)] Mortal81 (:: core :: primitive :: u8 ,) , # [codec (index = 82)] Mortal82 (:: core :: primitive :: u8 ,) , # [codec (index = 83)] Mortal83 (:: core :: primitive :: u8 ,) , # [codec (index = 84)] Mortal84 (:: core :: primitive :: u8 ,) , # [codec (index = 85)] Mortal85 (:: core :: primitive :: u8 ,) , # [codec (index = 86)] Mortal86 (:: core :: primitive :: u8 ,) , # [codec (index = 87)] Mortal87 (:: core :: primitive :: u8 ,) , # [codec (index = 88)] Mortal88 (:: core :: primitive :: u8 ,) , # [codec (index = 89)] Mortal89 (:: core :: primitive :: u8 ,) , # [codec (index = 90)] Mortal90 (:: core :: primitive :: u8 ,) , # [codec (index = 91)] Mortal91 (:: core :: primitive :: u8 ,) , # [codec (index = 92)] Mortal92 (:: core :: primitive :: u8 ,) , # [codec (index = 93)] Mortal93 (:: core :: primitive :: u8 ,) , # [codec (index = 94)] Mortal94 (:: core :: primitive :: u8 ,) , # [codec (index = 95)] Mortal95 (:: core :: primitive :: u8 ,) , # [codec (index = 96)] Mortal96 (:: core :: primitive :: u8 ,) , # [codec (index = 97)] Mortal97 (:: core :: primitive :: u8 ,) , # [codec (index = 98)] Mortal98 (:: core :: primitive :: u8 ,) , # [codec (index = 99)] Mortal99 (:: core :: primitive :: u8 ,) , # [codec (index = 100)] Mortal100 (:: core :: primitive :: u8 ,) , # [codec (index = 101)] Mortal101 (:: core :: primitive :: u8 ,) , # [codec (index = 102)] Mortal102 (:: core :: primitive :: u8 ,) , # [codec (index = 103)] Mortal103 (:: core :: primitive :: u8 ,) , # [codec (index = 104)] Mortal104 (:: core :: primitive :: u8 ,) , # [codec (index = 105)] Mortal105 (:: core :: primitive :: u8 ,) , # [codec (index = 106)] Mortal106 (:: core :: primitive :: u8 ,) , # [codec (index = 107)] Mortal107 (:: core :: primitive :: u8 ,) , # [codec (index = 108)] Mortal108 (:: core :: primitive :: u8 ,) , # [codec (index = 109)] Mortal109 (:: core :: primitive :: u8 ,) , # [codec (index = 110)] Mortal110 (:: core :: primitive :: u8 ,) , # [codec (index = 111)] Mortal111 (:: core :: primitive :: u8 ,) , # [codec (index = 112)] Mortal112 (:: core :: primitive :: u8 ,) , # [codec (index = 113)] Mortal113 (:: core :: primitive :: u8 ,) , # [codec (index = 114)] Mortal114 (:: core :: primitive :: u8 ,) , # [codec (index = 115)] Mortal115 (:: core :: primitive :: u8 ,) , # [codec (index = 116)] Mortal116 (:: core :: primitive :: u8 ,) , # [codec (index = 117)] Mortal117 (:: core :: primitive :: u8 ,) , # [codec (index = 118)] Mortal118 (:: core :: primitive :: u8 ,) , # [codec (index = 119)] Mortal119 (:: core :: primitive :: u8 ,) , # [codec (index = 120)] Mortal120 (:: core :: primitive :: u8 ,) , # [codec (index = 121)] Mortal121 (:: core :: primitive :: u8 ,) , # [codec (index = 122)] Mortal122 (:: core :: primitive :: u8 ,) , # [codec (index = 123)] Mortal123 (:: core :: primitive :: u8 ,) , # [codec (index = 124)] Mortal124 (:: core :: primitive :: u8 ,) , # [codec (index = 125)] Mortal125 (:: core :: primitive :: u8 ,) , # [codec (index = 126)] Mortal126 (:: core :: primitive :: u8 ,) , # [codec (index = 127)] Mortal127 (:: core :: primitive :: u8 ,) , # [codec (index = 128)] Mortal128 (:: core :: primitive :: u8 ,) , # [codec (index = 129)] Mortal129 (:: core :: primitive :: u8 ,) , # [codec (index = 130)] Mortal130 (:: core :: primitive :: u8 ,) , # [codec (index = 131)] Mortal131 (:: core :: primitive :: u8 ,) , # [codec (index = 132)] Mortal132 (:: core :: primitive :: u8 ,) , # [codec (index = 133)] Mortal133 (:: core :: primitive :: u8 ,) , # [codec (index = 134)] Mortal134 (:: core :: primitive :: u8 ,) , # [codec (index = 135)] Mortal135 (:: core :: primitive :: u8 ,) , # [codec (index = 136)] Mortal136 (:: core :: primitive :: u8 ,) , # [codec (index = 137)] Mortal137 (:: core :: primitive :: u8 ,) , # [codec (index = 138)] Mortal138 (:: core :: primitive :: u8 ,) , # [codec (index = 139)] Mortal139 (:: core :: primitive :: u8 ,) , # [codec (index = 140)] Mortal140 (:: core :: primitive :: u8 ,) , # [codec (index = 141)] Mortal141 (:: core :: primitive :: u8 ,) , # [codec (index = 142)] Mortal142 (:: core :: primitive :: u8 ,) , # [codec (index = 143)] Mortal143 (:: core :: primitive :: u8 ,) , # [codec (index = 144)] Mortal144 (:: core :: primitive :: u8 ,) , # [codec (index = 145)] Mortal145 (:: core :: primitive :: u8 ,) , # [codec (index = 146)] Mortal146 (:: core :: primitive :: u8 ,) , # [codec (index = 147)] Mortal147 (:: core :: primitive :: u8 ,) , # [codec (index = 148)] Mortal148 (:: core :: primitive :: u8 ,) , # [codec (index = 149)] Mortal149 (:: core :: primitive :: u8 ,) , # [codec (index = 150)] Mortal150 (:: core :: primitive :: u8 ,) , # [codec (index = 151)] Mortal151 (:: core :: primitive :: u8 ,) , # [codec (index = 152)] Mortal152 (:: core :: primitive :: u8 ,) , # [codec (index = 153)] Mortal153 (:: core :: primitive :: u8 ,) , # [codec (index = 154)] Mortal154 (:: core :: primitive :: u8 ,) , # [codec (index = 155)] Mortal155 (:: core :: primitive :: u8 ,) , # [codec (index = 156)] Mortal156 (:: core :: primitive :: u8 ,) , # [codec (index = 157)] Mortal157 (:: core :: primitive :: u8 ,) , # [codec (index = 158)] Mortal158 (:: core :: primitive :: u8 ,) , # [codec (index = 159)] Mortal159 (:: core :: primitive :: u8 ,) , # [codec (index = 160)] Mortal160 (:: core :: primitive :: u8 ,) , # [codec (index = 161)] Mortal161 (:: core :: primitive :: u8 ,) , # [codec (index = 162)] Mortal162 (:: core :: primitive :: u8 ,) , # [codec (index = 163)] Mortal163 (:: core :: primitive :: u8 ,) , # [codec (index = 164)] Mortal164 (:: core :: primitive :: u8 ,) , # [codec (index = 165)] Mortal165 (:: core :: primitive :: u8 ,) , # [codec (index = 166)] Mortal166 (:: core :: primitive :: u8 ,) , # [codec (index = 167)] Mortal167 (:: core :: primitive :: u8 ,) , # [codec (index = 168)] Mortal168 (:: core :: primitive :: u8 ,) , # [codec (index = 169)] Mortal169 (:: core :: primitive :: u8 ,) , # [codec (index = 170)] Mortal170 (:: core :: primitive :: u8 ,) , # [codec (index = 171)] Mortal171 (:: core :: primitive :: u8 ,) , # [codec (index = 172)] Mortal172 (:: core :: primitive :: u8 ,) , # [codec (index = 173)] Mortal173 (:: core :: primitive :: u8 ,) , # [codec (index = 174)] Mortal174 (:: core :: primitive :: u8 ,) , # [codec (index = 175)] Mortal175 (:: core :: primitive :: u8 ,) , # [codec (index = 176)] Mortal176 (:: core :: primitive :: u8 ,) , # [codec (index = 177)] Mortal177 (:: core :: primitive :: u8 ,) , # [codec (index = 178)] Mortal178 (:: core :: primitive :: u8 ,) , # [codec (index = 179)] Mortal179 (:: core :: primitive :: u8 ,) , # [codec (index = 180)] Mortal180 (:: core :: primitive :: u8 ,) , # [codec (index = 181)] Mortal181 (:: core :: primitive :: u8 ,) , # [codec (index = 182)] Mortal182 (:: core :: primitive :: u8 ,) , # [codec (index = 183)] Mortal183 (:: core :: primitive :: u8 ,) , # [codec (index = 184)] Mortal184 (:: core :: primitive :: u8 ,) , # [codec (index = 185)] Mortal185 (:: core :: primitive :: u8 ,) , # [codec (index = 186)] Mortal186 (:: core :: primitive :: u8 ,) , # [codec (index = 187)] Mortal187 (:: core :: primitive :: u8 ,) , # [codec (index = 188)] Mortal188 (:: core :: primitive :: u8 ,) , # [codec (index = 189)] Mortal189 (:: core :: primitive :: u8 ,) , # [codec (index = 190)] Mortal190 (:: core :: primitive :: u8 ,) , # [codec (index = 191)] Mortal191 (:: core :: primitive :: u8 ,) , # [codec (index = 192)] Mortal192 (:: core :: primitive :: u8 ,) , # [codec (index = 193)] Mortal193 (:: core :: primitive :: u8 ,) , # [codec (index = 194)] Mortal194 (:: core :: primitive :: u8 ,) , # [codec (index = 195)] Mortal195 (:: core :: primitive :: u8 ,) , # [codec (index = 196)] Mortal196 (:: core :: primitive :: u8 ,) , # [codec (index = 197)] Mortal197 (:: core :: primitive :: u8 ,) , # [codec (index = 198)] Mortal198 (:: core :: primitive :: u8 ,) , # [codec (index = 199)] Mortal199 (:: core :: primitive :: u8 ,) , # [codec (index = 200)] Mortal200 (:: core :: primitive :: u8 ,) , # [codec (index = 201)] Mortal201 (:: core :: primitive :: u8 ,) , # [codec (index = 202)] Mortal202 (:: core :: primitive :: u8 ,) , # [codec (index = 203)] Mortal203 (:: core :: primitive :: u8 ,) , # [codec (index = 204)] Mortal204 (:: core :: primitive :: u8 ,) , # [codec (index = 205)] Mortal205 (:: core :: primitive :: u8 ,) , # [codec (index = 206)] Mortal206 (:: core :: primitive :: u8 ,) , # [codec (index = 207)] Mortal207 (:: core :: primitive :: u8 ,) , # [codec (index = 208)] Mortal208 (:: core :: primitive :: u8 ,) , # [codec (index = 209)] Mortal209 (:: core :: primitive :: u8 ,) , # [codec (index = 210)] Mortal210 (:: core :: primitive :: u8 ,) , # [codec (index = 211)] Mortal211 (:: core :: primitive :: u8 ,) , # [codec (index = 212)] Mortal212 (:: core :: primitive :: u8 ,) , # [codec (index = 213)] Mortal213 (:: core :: primitive :: u8 ,) , # [codec (index = 214)] Mortal214 (:: core :: primitive :: u8 ,) , # [codec (index = 215)] Mortal215 (:: core :: primitive :: u8 ,) , # [codec (index = 216)] Mortal216 (:: core :: primitive :: u8 ,) , # [codec (index = 217)] Mortal217 (:: core :: primitive :: u8 ,) , # [codec (index = 218)] Mortal218 (:: core :: primitive :: u8 ,) , # [codec (index = 219)] Mortal219 (:: core :: primitive :: u8 ,) , # [codec (index = 220)] Mortal220 (:: core :: primitive :: u8 ,) , # [codec (index = 221)] Mortal221 (:: core :: primitive :: u8 ,) , # [codec (index = 222)] Mortal222 (:: core :: primitive :: u8 ,) , # [codec (index = 223)] Mortal223 (:: core :: primitive :: u8 ,) , # [codec (index = 224)] Mortal224 (:: core :: primitive :: u8 ,) , # [codec (index = 225)] Mortal225 (:: core :: primitive :: u8 ,) , # [codec (index = 226)] Mortal226 (:: core :: primitive :: u8 ,) , # [codec (index = 227)] Mortal227 (:: core :: primitive :: u8 ,) , # [codec (index = 228)] Mortal228 (:: core :: primitive :: u8 ,) , # [codec (index = 229)] Mortal229 (:: core :: primitive :: u8 ,) , # [codec (index = 230)] Mortal230 (:: core :: primitive :: u8 ,) , # [codec (index = 231)] Mortal231 (:: core :: primitive :: u8 ,) , # [codec (index = 232)] Mortal232 (:: core :: primitive :: u8 ,) , # [codec (index = 233)] Mortal233 (:: core :: primitive :: u8 ,) , # [codec (index = 234)] Mortal234 (:: core :: primitive :: u8 ,) , # [codec (index = 235)] Mortal235 (:: core :: primitive :: u8 ,) , # [codec (index = 236)] Mortal236 (:: core :: primitive :: u8 ,) , # [codec (index = 237)] Mortal237 (:: core :: primitive :: u8 ,) , # [codec (index = 238)] Mortal238 (:: core :: primitive :: u8 ,) , # [codec (index = 239)] Mortal239 (:: core :: primitive :: u8 ,) , # [codec (index = 240)] Mortal240 (:: core :: primitive :: u8 ,) , # [codec (index = 241)] Mortal241 (:: core :: primitive :: u8 ,) , # [codec (index = 242)] Mortal242 (:: core :: primitive :: u8 ,) , # [codec (index = 243)] Mortal243 (:: core :: primitive :: u8 ,) , # [codec (index = 244)] Mortal244 (:: core :: primitive :: u8 ,) , # [codec (index = 245)] Mortal245 (:: core :: primitive :: u8 ,) , # [codec (index = 246)] Mortal246 (:: core :: primitive :: u8 ,) , # [codec (index = 247)] Mortal247 (:: core :: primitive :: u8 ,) , # [codec (index = 248)] Mortal248 (:: core :: primitive :: u8 ,) , # [codec (index = 249)] Mortal249 (:: core :: primitive :: u8 ,) , # [codec (index = 250)] Mortal250 (:: core :: primitive :: u8 ,) , # [codec (index = 251)] Mortal251 (:: core :: primitive :: u8 ,) , # [codec (index = 252)] Mortal252 (:: core :: primitive :: u8 ,) , # [codec (index = 253)] Mortal253 (:: core :: primitive :: u8 ,) , # [codec (index = 254)] Mortal254 (:: core :: primitive :: u8 ,) , # [codec (index = 255)] Mortal255 (:: core :: primitive :: u8 ,) , } } pub mod header { use super :: runtime_types ; # [derive (:: subxt :: codec :: Decode , :: subxt :: codec :: Encode , Clone , Debug , Eq , PartialEq)] pub struct Header < _0 , _1 > { pub parent_hash : :: subxt :: sp_core :: H256 , # [codec (compact)] pub number : _0 , pub state_root : :: subxt :: sp_core :: H256 , pub extrinsics_root : :: subxt :: sp_core :: H256 , pub digest : runtime_types :: sp_runtime :: generic :: digest :: Digest , # [codec (skip)] pub __subxt_unused_type_params : :: core :: marker :: PhantomData < _1 > } } pub mod unchecked_extrinsic { use super :: runtime_types ; # [derive (:: subxt :: codec :: Decode , :: subxt :: codec :: Encode , Clone , Debug , Eq , PartialEq)] pub struct UncheckedExtrinsic < _0 , _1 , _2 , _3 > (pub :: std :: vec :: Vec < :: core :: primitive :: u8 > , # [codec (skip)] pub :: core :: marker :: PhantomData < (_1 , _0 , _2 , _3) >) ; } } pub mod multiaddress { use super :: runtime_types ; # [derive (:: subxt :: codec :: Decode , :: subxt :: codec :: Encode , Clone , Debug , Eq , PartialEq)] pub enum MultiAddress < _0 , _1 > { # [codec (index = 0)] Id (_0 ,) , # [codec (index = 1)] Index (# [codec (compact)] _1 ,) , # [codec (index = 2)] Raw (:: std :: vec :: Vec < :: core :: primitive :: u8 > ,) , # [codec (index = 3)] Address32 ([:: core :: primitive :: u8 ; 32usize] ,) , # [codec (index = 4)] Address20 ([:: core :: primitive :: u8 ; 20usize] ,) , } } pub mod traits { use super :: runtime_types ; # [derive (:: subxt :: codec :: Decode , :: subxt :: codec :: Encode , Clone , Debug , Eq , PartialEq)] pub struct BlakeTwo256 ; } # [derive (:: subxt :: codec :: Decode , :: subxt :: codec :: Encode , Clone , Debug , Eq , PartialEq)] pub enum ArithmeticError { # [codec (index = 0)] Underflow , # [codec (index = 1)] Overflow , # [codec (index = 2)] DivisionByZero , } # [derive (:: subxt :: codec :: Decode , :: subxt :: codec :: Encode , Clone , Debug , Eq , PartialEq)] pub enum DispatchError { # [codec (index = 0)] Other , # [codec (index = 1)] CannotLookup , # [codec (index = 2)] BadOrigin , # [codec (index = 3)] Module (runtime_types :: sp_runtime :: ModuleError ,) , # [codec (index = 4)] ConsumerRemaining , # [codec (index = 5)] NoProviders , # [codec (index = 6)] TooManyConsumers , # [codec (index = 7)] Token (runtime_types :: sp_runtime :: TokenError ,) , # [codec (index = 8)] Arithmetic (runtime_types :: sp_runtime :: ArithmeticError ,) , # [codec (index = 9)] Transactional (runtime_types :: sp_runtime :: TransactionalError ,) , } # [derive (:: subxt :: codec :: Decode , :: subxt :: codec :: Encode , Clone , Debug , Eq , PartialEq)] pub struct ModuleError { pub index : :: core :: primitive :: u8 , pub error : [:: core :: primitive :: u8 ; 4usize] , } # [derive (:: subxt :: codec :: Decode , :: subxt :: codec :: Encode , Clone , Debug , Eq , PartialEq)] pub enum MultiSignature { # [codec (index = 0)] Ed25519 (runtime_types :: sp_core :: ed25519 :: Signature ,) , # [codec (index = 1)] Sr25519 (runtime_types :: sp_core :: sr25519 :: Signature ,) , # [codec (index = 2)] Ecdsa (runtime_types :: sp_core :: ecdsa :: Signature ,) , } # [derive (:: subxt :: codec :: Decode , :: subxt :: codec :: Encode , Clone , Debug , Eq , PartialEq)] pub enum TokenError { # [codec (index = 0)] NoFunds , # [codec (index = 1)] WouldDie , # [codec (index = 2)] BelowMinimum , # [codec (index = 3)] CannotCreate , # [codec (index = 4)] UnknownAsset , # [codec (index = 5)] Frozen , # [codec (index = 6)] Unsupported , } # [derive (:: subxt :: codec :: Decode , :: subxt :: codec :: Encode , Clone , Debug , Eq , PartialEq)] pub enum TransactionalError { # [codec (index = 0)] LimitReached , # [codec (index = 1)] NoLayer , } } pub mod sp_session { use super :: runtime_types ; # [derive (:: subxt :: codec :: Decode , :: subxt :: codec :: Encode , Clone , Debug , Eq , PartialEq)] pub struct MembershipProof { pub session : :: core :: primitive :: u32 , pub trie_nodes : :: std :: vec :: Vec < :: std :: vec :: Vec < :: core :: primitive :: u8 > > , pub validator_count : :: core :: primitive :: u32 , } } pub mod sp_staking { use super :: runtime_types ; pub mod offence { use super :: runtime_types ; # [derive (:: subxt :: codec :: Decode , :: subxt :: codec :: Encode , Clone , Debug , Eq , PartialEq)] pub struct OffenceDetails < _0 , _1 > { pub offender : _1 , pub reporters : :: std :: vec :: Vec < _0 > , } } } pub mod sp_version { use super :: runtime_types ; # [derive (:: subxt :: codec :: Decode , :: subxt :: codec :: Encode , Clone , Debug , Eq , PartialEq)] pub struct RuntimeVersion { pub spec_name : :: std :: string :: String , pub impl_name : :: std :: string :: String , pub authoring_version : :: core :: primitive :: u32 , pub spec_version : :: core :: primitive :: u32 , pub impl_version : :: core :: primitive :: u32 , pub apis : :: std :: vec :: Vec < ([:: core :: primitive :: u8 ; 8usize] , :: core :: primitive :: u32 ,) > , pub transaction_version : :: core :: primitive :: u32 , pub state_version : :: core :: primitive :: u8 , } } pub mod webb_primitives { use super :: runtime_types ; pub mod types { use super :: runtime_types ; pub mod vanchor { use super :: runtime_types ; # [derive (:: subxt :: codec :: Decode , :: subxt :: codec :: Encode , Clone , Debug , Eq , PartialEq)] pub struct ExtData < _0 , _1 , _2 > { pub recipient : _0 , pub relayer : _0 , pub ext_amount : _1 , pub fee : _2 , pub encrypted_output1 : :: std :: vec :: Vec < :: core :: primitive :: u8 > , pub encrypted_output2 : :: std :: vec :: Vec < :: core :: primitive :: u8 > , } # [derive (:: subxt :: codec :: Decode , :: subxt :: codec :: Encode , Clone , Debug , Eq , PartialEq)] pub struct ProofData < _0 > { pub proof : :: std :: vec :: Vec < :: core :: primitive :: u8 > , pub public_amount : _0 , pub roots : :: std :: vec :: Vec < _0 > , pub input_nullifiers : :: std :: vec :: Vec < _0 > , pub output_commitments : :: std :: vec :: Vec < _0 > , pub ext_data_hash : _0 , } # [derive (:: subxt :: codec :: Decode , :: subxt :: codec :: Encode , Clone , Debug , Eq , PartialEq)] pub struct VAnchorMetadata < _0 , _1 > { pub creator : :: core :: option :: Option < _0 > , pub asset : _1 , } } # [derive (:: subxt :: codec :: Decode , :: subxt :: codec :: Encode , Clone , Debug , Eq , PartialEq)] pub struct DepositDetails < _0 , _1 > { pub depositor : _0 , pub deposit : _1 , } } } pub mod webb_proposals { use super :: runtime_types ; pub mod header { use super :: runtime_types ; # [derive (:: subxt :: codec :: Decode , :: subxt :: codec :: Encode , Clone , Debug , Eq , PartialEq)] pub struct ResourceId (pub [:: core :: primitive :: u8 ; 32usize] ,) ; # [derive (:: subxt :: codec :: Decode , :: subxt :: codec :: Encode , Clone , Debug , Eq , PartialEq)] pub enum TargetSystem { # [codec (index = 0)] ContractAddress ([:: core :: primitive :: u8 ; 20usize] ,) , # [codec (index = 1)] TreeId (:: core :: primitive :: u32 ,) , } # [derive (:: subxt :: codec :: Decode , :: subxt :: codec :: Encode , Clone , Debug , Eq , PartialEq)] pub enum TypedChainId { # [codec (index = 0)] None , # [codec (index = 1)] Evm (:: core :: primitive :: u32 ,) , # [codec (index = 2)] Substrate (:: core :: primitive :: u32 ,) , # [codec (index = 3)] PolkadotParachain (:: core :: primitive :: u32 ,) , # [codec (index = 4)] KusamaParachain (:: core :: primitive :: u32 ,) , # [codec (index = 5)] RococoParachain (:: core :: primitive :: u32 ,) , # [codec (index = 6)] Cosmos (:: core :: primitive :: u32 ,) , # [codec (index = 7)] Solana (:: core :: primitive :: u32 ,) , # [codec (index = 8)] Ink (:: core :: primitive :: u32 ,) , } } pub mod nonce { use super :: runtime_types ; # [derive (:: subxt :: codec :: CompactAs , :: subxt :: codec :: Decode , :: subxt :: codec :: Encode , Clone , Debug , Eq , PartialEq)] pub struct Nonce (pub :: core :: primitive :: u32 ,) ; } } } # [doc = r" The default error type returned when there is a runtime issue."] pub type DispatchError = runtime_types :: sp_runtime :: DispatchError ; impl :: subxt :: HasModuleError for runtime_types :: sp_runtime :: DispatchError { fn module_error_data (& self) -> Option < :: subxt :: ModuleErrorData > { if let Self :: Module (module_error) = self { Some (:: subxt :: ModuleErrorData { pallet_index : module_error . index , error : module_error . error }) } else { None } } } pub struct RuntimeApi < T : :: subxt :: Config , X > { pub client : :: subxt :: Client < T > , marker : :: core :: marker :: PhantomData < X > , } impl < T , X > :: core :: convert :: From < :: subxt :: Client < T >> for RuntimeApi < T , X > where T : :: subxt :: Config , X : :: subxt :: extrinsic :: ExtrinsicParams < T > { fn from (client : :: subxt :: Client < T >) -> Self { Self { client , marker : :: core :: marker :: PhantomData } } } impl < 'a , T , X > RuntimeApi < T , X > where T : :: subxt :: Config , X : :: subxt :: extrinsic :: ExtrinsicParams < T > , { pub fn validate_metadata (& 'a self) -> Result < () , :: subxt :: MetadataError > { if self . client . metadata () . metadata_hash (& PALLETS) != [7u8 , 212u8 , 209u8 , 47u8 , 52u8 , 195u8 , 31u8 , 225u8 , 47u8 , 60u8 , 249u8 , 50u8 , 29u8 , 217u8 , 178u8 , 45u8 , 221u8 , 169u8 , 250u8 , 220u8 , 113u8 , 165u8 , 148u8 , 10u8 , 1u8 , 244u8 , 125u8 , 53u8 , 164u8 , 199u8 , 247u8 , 124u8 ,] { Err (:: subxt :: MetadataError :: IncompatibleMetadata) } else { Ok (()) } } pub fn constants (& 'a self) -> ConstantsApi < 'a , T > { ConstantsApi { client : & self . client } } pub fn storage (& 'a self) -> StorageApi < 'a , T > { StorageApi { client : & self . client } } pub fn tx (& 'a self) -> TransactionApi < 'a , T , X > { TransactionApi { client : & self . client , marker : :: core :: marker :: PhantomData } } pub fn events (& 'a self) -> EventsApi < 'a , T > { EventsApi { client : & self . client } } } pub struct EventsApi < 'a , T : :: subxt :: Config > { client : & 'a :: subxt :: Client < T > , } impl < 'a , T : :: subxt :: Config > EventsApi < 'a , T > { pub async fn at (& self , block_hash : T :: Hash) -> Result < :: subxt :: events :: Events < 'a , T , Event > , :: subxt :: BasicError > { :: subxt :: events :: at :: < T , Event > (self . client , block_hash) . await } pub async fn subscribe (& self) -> Result < :: subxt :: events :: EventSubscription < 'a , :: subxt :: events :: EventSub < T :: Header > , T , Event > , :: subxt :: BasicError > { :: subxt :: events :: subscribe :: < T , Event > (self . client) . await } pub async fn subscribe_finalized (& self) -> Result < :: subxt :: events :: EventSubscription < 'a , :: subxt :: events :: FinalizedEventSub < 'a , T :: Header > , T , Event > , :: subxt :: BasicError > { :: subxt :: events :: subscribe_finalized :: < T , Event > (self . client) . await } } pub struct ConstantsApi < 'a , T : :: subxt :: Config > { client : & 'a :: subxt :: Client < T > , } impl < 'a , T : :: subxt :: Config > ConstantsApi < 'a , T > { pub fn system (& self) -> system :: constants :: ConstantsApi < 'a , T > { system :: constants :: ConstantsApi :: new (self . client) } pub fn timestamp (& self) -> timestamp :: constants :: ConstantsApi < 'a , T > { timestamp :: constants :: ConstantsApi :: new (self . client) } pub fn balances (& self) -> balances :: constants :: ConstantsApi < 'a , T > { balances :: constants :: ConstantsApi :: new (self . client) } pub fn transaction_payment (& self) -> transaction_payment :: constants :: ConstantsApi < 'a , T > { transaction_payment :: constants :: ConstantsApi :: new (self . client) } pub fn authorship (& self) -> authorship :: constants :: ConstantsApi < 'a , T > { authorship :: constants :: ConstantsApi :: new (self . client) } pub fn grandpa (& self) -> grandpa :: constants :: ConstantsApi < 'a , T > { grandpa :: constants :: ConstantsApi :: new (self . client) } pub fn indices (& self) -> indices :: constants :: ConstantsApi < 'a , T > { indices :: constants :: ConstantsApi :: new (self . client) } pub fn democracy (& self) -> democracy :: constants :: ConstantsApi < 'a , T > { democracy :: constants :: ConstantsApi :: new (self . client) } pub fn elections (& self) -> elections :: constants :: ConstantsApi < 'a , T > { elections :: constants :: ConstantsApi :: new (self . client) } pub fn election_provider_multi_phase (& self) -> election_provider_multi_phase :: constants :: ConstantsApi < 'a , T > { election_provider_multi_phase :: constants :: ConstantsApi :: new (self . client) } pub fn staking (& self) -> staking :: constants :: ConstantsApi < 'a , T > { staking :: constants :: ConstantsApi :: new (self . client) } pub fn treasury (& self) -> treasury :: constants :: ConstantsApi < 'a , T > { treasury :: constants :: ConstantsApi :: new (self . client) } pub fn bounties (& self) -> bounties :: constants :: ConstantsApi < 'a , T > { bounties :: constants :: ConstantsApi :: new (self . client) } pub fn child_bounties (& self) -> child_bounties :: constants :: ConstantsApi < 'a , T > { child_bounties :: constants :: ConstantsApi :: new (self . client) } pub fn bags_list (& self) -> bags_list :: constants :: ConstantsApi < 'a , T > { bags_list :: constants :: ConstantsApi :: new (self . client) } pub fn nomination_pools (& self) -> nomination_pools :: constants :: ConstantsApi < 'a , T > { nomination_pools :: constants :: ConstantsApi :: new (self . client) } pub fn scheduler (& self) -> scheduler :: constants :: ConstantsApi < 'a , T > { scheduler :: constants :: ConstantsApi :: new (self . client) } pub fn dkg (& self) -> dkg :: constants :: ConstantsApi < 'a , T > { dkg :: constants :: ConstantsApi :: new (self . client) } pub fn dkg_proposals (& self) -> dkg_proposals :: constants :: ConstantsApi < 'a , T > { dkg_proposals :: constants :: ConstantsApi :: new (self . client) } pub fn dkg_proposal_handler (& self) -> dkg_proposal_handler :: constants :: ConstantsApi < 'a , T > { dkg_proposal_handler :: constants :: ConstantsApi :: new (self . client) } pub fn asset_registry (& self) -> asset_registry :: constants :: ConstantsApi < 'a , T > { asset_registry :: constants :: ConstantsApi :: new (self . client) } pub fn currencies (& self) -> currencies :: constants :: ConstantsApi < 'a , T > { currencies :: constants :: ConstantsApi :: new (self . client) } pub fn tokens (& self) -> tokens :: constants :: ConstantsApi < 'a , T > { tokens :: constants :: ConstantsApi :: new (self . client) } pub fn token_wrapper (& self) -> token_wrapper :: constants :: ConstantsApi < 'a , T > { token_wrapper :: constants :: ConstantsApi :: new (self . client) } pub fn linkable_tree_bn254 (& self) -> linkable_tree_bn254 :: constants :: ConstantsApi < 'a , T > { linkable_tree_bn254 :: constants :: ConstantsApi :: new (self . client) } pub fn mixer_bn254 (& self) -> mixer_bn254 :: constants :: ConstantsApi < 'a , T > { mixer_bn254 :: constants :: ConstantsApi :: new (self . client) } pub fn signature_bridge (& self) -> signature_bridge :: constants :: ConstantsApi < 'a , T > { signature_bridge :: constants :: ConstantsApi :: new (self . client) } pub fn bridge (& self) -> bridge :: constants :: ConstantsApi < 'a , T > { bridge :: constants :: ConstantsApi :: new (self . client) } pub fn v_anchor_bn254 (& self) -> v_anchor_bn254 :: constants :: ConstantsApi < 'a , T > { v_anchor_bn254 :: constants :: ConstantsApi :: new (self . client) } } pub struct StorageApi < 'a , T : :: subxt :: Config > { client : & 'a :: subxt :: Client < T > , } impl < 'a , T > StorageApi < 'a , T > where T : :: subxt :: Config , { pub fn system (& self) -> system :: storage :: StorageApi < 'a , T > { system :: storage :: StorageApi :: new (self . client) } pub fn timestamp (& self) -> timestamp :: storage :: StorageApi < 'a , T > { timestamp :: storage :: StorageApi :: new (self . client) } pub fn sudo (& self) -> sudo :: storage :: StorageApi < 'a , T > { sudo :: storage :: StorageApi :: new (self . client) } pub fn randomness_collective_flip (& self) -> randomness_collective_flip :: storage :: StorageApi < 'a , T > { randomness_collective_flip :: storage :: StorageApi :: new (self . client) } pub fn balances (& self) -> balances :: storage :: StorageApi < 'a , T > { balances :: storage :: StorageApi :: new (self . client) } pub fn transaction_payment (& self) -> transaction_payment :: storage :: StorageApi < 'a , T > { transaction_payment :: storage :: StorageApi :: new (self . client) } pub fn authorship (& self) -> authorship :: storage :: StorageApi < 'a , T > { authorship :: storage :: StorageApi :: new (self . client) } pub fn aura (& self) -> aura :: storage :: StorageApi < 'a , T > { aura :: storage :: StorageApi :: new (self . client) } pub fn grandpa (& self) -> grandpa :: storage :: StorageApi < 'a , T > { grandpa :: storage :: StorageApi :: new (self . client) } pub fn indices (& self) -> indices :: storage :: StorageApi < 'a , T > { indices :: storage :: StorageApi :: new (self . client) } pub fn democracy (& self) -> democracy :: storage :: StorageApi < 'a , T > { democracy :: storage :: StorageApi :: new (self . client) } pub fn council (& self) -> council :: storage :: StorageApi < 'a , T > { council :: storage :: StorageApi :: new (self . client) } pub fn elections (& self) -> elections :: storage :: StorageApi < 'a , T > { elections :: storage :: StorageApi :: new (self . client) } pub fn election_provider_multi_phase (& self) -> election_provider_multi_phase :: storage :: StorageApi < 'a , T > { election_provider_multi_phase :: storage :: StorageApi :: new (self . client) } pub fn staking (& self) -> staking :: storage :: StorageApi < 'a , T > { staking :: storage :: StorageApi :: new (self . client) } pub fn session (& self) -> session :: storage :: StorageApi < 'a , T > { session :: storage :: StorageApi :: new (self . client) } pub fn treasury (& self) -> treasury :: storage :: StorageApi < 'a , T > { treasury :: storage :: StorageApi :: new (self . client) } pub fn bounties (& self) -> bounties :: storage :: StorageApi < 'a , T > { bounties :: storage :: StorageApi :: new (self . client) } pub fn child_bounties (& self) -> child_bounties :: storage :: StorageApi < 'a , T > { child_bounties :: storage :: StorageApi :: new (self . client) } pub fn bags_list (& self) -> bags_list :: storage :: StorageApi < 'a , T > { bags_list :: storage :: StorageApi :: new (self . client) } pub fn nomination_pools (& self) -> nomination_pools :: storage :: StorageApi < 'a , T > { nomination_pools :: storage :: StorageApi :: new (self . client) } pub fn scheduler (& self) -> scheduler :: storage :: StorageApi < 'a , T > { scheduler :: storage :: StorageApi :: new (self . client) } pub fn preimage (& self) -> preimage :: storage :: StorageApi < 'a , T > { preimage :: storage :: StorageApi :: new (self . client) } pub fn offences (& self) -> offences :: storage :: StorageApi < 'a , T > { offences :: storage :: StorageApi :: new (self . client) } pub fn dkg (& self) -> dkg :: storage :: StorageApi < 'a , T > { dkg :: storage :: StorageApi :: new (self . client) } pub fn dkg_proposals (& self) -> dkg_proposals :: storage :: StorageApi < 'a , T > { dkg_proposals :: storage :: StorageApi :: new (self . client) } pub fn dkg_proposal_handler (& self) -> dkg_proposal_handler :: storage :: StorageApi < 'a , T > { dkg_proposal_handler :: storage :: StorageApi :: new (self . client) } pub fn hasher_bn254 (& self) -> hasher_bn254 :: storage :: StorageApi < 'a , T > { hasher_bn254 :: storage :: StorageApi :: new (self . client) } pub fn asset_registry (& self) -> asset_registry :: storage :: StorageApi < 'a , T > { asset_registry :: storage :: StorageApi :: new (self . client) } pub fn tokens (& self) -> tokens :: storage :: StorageApi < 'a , T > { tokens :: storage :: StorageApi :: new (self . client) } pub fn token_wrapper (& self) -> token_wrapper :: storage :: StorageApi < 'a , T > { token_wrapper :: storage :: StorageApi :: new (self . client) } pub fn mixer_verifier_bn254 (& self) -> mixer_verifier_bn254 :: storage :: StorageApi < 'a , T > { mixer_verifier_bn254 :: storage :: StorageApi :: new (self . client) } pub fn anchor_verifier_bn254 (& self) -> anchor_verifier_bn254 :: storage :: StorageApi < 'a , T > { anchor_verifier_bn254 :: storage :: StorageApi :: new (self . client) } pub fn merkle_tree_bn254 (& self) -> merkle_tree_bn254 :: storage :: StorageApi < 'a , T > { merkle_tree_bn254 :: storage :: StorageApi :: new (self . client) } pub fn linkable_tree_bn254 (& self) -> linkable_tree_bn254 :: storage :: StorageApi < 'a , T > { linkable_tree_bn254 :: storage :: StorageApi :: new (self . client) } pub fn mixer_bn254 (& self) -> mixer_bn254 :: storage :: StorageApi < 'a , T > { mixer_bn254 :: storage :: StorageApi :: new (self . client) } pub fn signature_bridge (& self) -> signature_bridge :: storage :: StorageApi < 'a , T > { signature_bridge :: storage :: StorageApi :: new (self . client) } pub fn v_anchor_verifier2x2_bn254 (& self) -> v_anchor_verifier2x2_bn254 :: storage :: StorageApi < 'a , T > { v_anchor_verifier2x2_bn254 :: storage :: StorageApi :: new (self . client) } pub fn bridge (& self) -> bridge :: storage :: StorageApi < 'a , T > { bridge :: storage :: StorageApi :: new (self . client) } pub fn v_anchor_bn254 (& self) -> v_anchor_bn254 :: storage :: StorageApi < 'a , T > { v_anchor_bn254 :: storage :: StorageApi :: new (self . client) } pub fn v_anchor_handler_bn254 (& self) -> v_anchor_handler_bn254 :: storage :: StorageApi < 'a , T > { v_anchor_handler_bn254 :: storage :: StorageApi :: new (self . client) } } pub struct TransactionApi < 'a , T : :: subxt :: Config , X > { client : & 'a :: subxt :: Client < T > , marker : :: core :: marker :: PhantomData < X > , } impl < 'a , T , X > TransactionApi < 'a , T , X > where T : :: subxt :: Config , X : :: subxt :: extrinsic :: ExtrinsicParams < T > , { pub fn system (& self) -> system :: calls :: TransactionApi < 'a , T , X > { system :: calls :: TransactionApi :: new (self . client) } pub fn timestamp (& self) -> timestamp :: calls :: TransactionApi < 'a , T , X > { timestamp :: calls :: TransactionApi :: new (self . client) } pub fn sudo (& self) -> sudo :: calls :: TransactionApi < 'a , T , X > { sudo :: calls :: TransactionApi :: new (self . client) } pub fn balances (& self) -> balances :: calls :: TransactionApi < 'a , T , X > { balances :: calls :: TransactionApi :: new (self . client) } pub fn authorship (& self) -> authorship :: calls :: TransactionApi < 'a , T , X > { authorship :: calls :: TransactionApi :: new (self . client) } pub fn grandpa (& self) -> grandpa :: calls :: TransactionApi < 'a , T , X > { grandpa :: calls :: TransactionApi :: new (self . client) } pub fn indices (& self) -> indices :: calls :: TransactionApi < 'a , T , X > { indices :: calls :: TransactionApi :: new (self . client) } pub fn democracy (& self) -> democracy :: calls :: TransactionApi < 'a , T , X > { democracy :: calls :: TransactionApi :: new (self . client) } pub fn council (& self) -> council :: calls :: TransactionApi < 'a , T , X > { council :: calls :: TransactionApi :: new (self . client) } pub fn elections (& self) -> elections :: calls :: TransactionApi < 'a , T , X > { elections :: calls :: TransactionApi :: new (self . client) } pub fn election_provider_multi_phase (& self) -> election_provider_multi_phase :: calls :: TransactionApi < 'a , T , X > { election_provider_multi_phase :: calls :: TransactionApi :: new (self . client) } pub fn staking (& self) -> staking :: calls :: TransactionApi < 'a , T , X > { staking :: calls :: TransactionApi :: new (self . client) } pub fn session (& self) -> session :: calls :: TransactionApi < 'a , T , X > { session :: calls :: TransactionApi :: new (self . client) } pub fn treasury (& self) -> treasury :: calls :: TransactionApi < 'a , T , X > { treasury :: calls :: TransactionApi :: new (self . client) } pub fn bounties (& self) -> bounties :: calls :: TransactionApi < 'a , T , X > { bounties :: calls :: TransactionApi :: new (self . client) } pub fn child_bounties (& self) -> child_bounties :: calls :: TransactionApi < 'a , T , X > { child_bounties :: calls :: TransactionApi :: new (self . client) } pub fn bags_list (& self) -> bags_list :: calls :: TransactionApi < 'a , T , X > { bags_list :: calls :: TransactionApi :: new (self . client) } pub fn nomination_pools (& self) -> nomination_pools :: calls :: TransactionApi < 'a , T , X > { nomination_pools :: calls :: TransactionApi :: new (self . client) } pub fn scheduler (& self) -> scheduler :: calls :: TransactionApi < 'a , T , X > { scheduler :: calls :: TransactionApi :: new (self . client) } pub fn preimage (& self) -> preimage :: calls :: TransactionApi < 'a , T , X > { preimage :: calls :: TransactionApi :: new (self . client) } pub fn dkg (& self) -> dkg :: calls :: TransactionApi < 'a , T , X > { dkg :: calls :: TransactionApi :: new (self . client) } pub fn dkg_proposals (& self) -> dkg_proposals :: calls :: TransactionApi < 'a , T , X > { dkg_proposals :: calls :: TransactionApi :: new (self . client) } pub fn dkg_proposal_handler (& self) -> dkg_proposal_handler :: calls :: TransactionApi < 'a , T , X > { dkg_proposal_handler :: calls :: TransactionApi :: new (self . client) } pub fn hasher_bn254 (& self) -> hasher_bn254 :: calls :: TransactionApi < 'a , T , X > { hasher_bn254 :: calls :: TransactionApi :: new (self . client) } pub fn asset_registry (& self) -> asset_registry :: calls :: TransactionApi < 'a , T , X > { asset_registry :: calls :: TransactionApi :: new (self . client) } pub fn currencies (& self) -> currencies :: calls :: TransactionApi < 'a , T , X > { currencies :: calls :: TransactionApi :: new (self . client) } pub fn tokens (& self) -> tokens :: calls :: TransactionApi < 'a , T , X > { tokens :: calls :: TransactionApi :: new (self . client) } pub fn token_wrapper (& self) -> token_wrapper :: calls :: TransactionApi < 'a , T , X > { token_wrapper :: calls :: TransactionApi :: new (self . client) } pub fn mixer_verifier_bn254 (& self) -> mixer_verifier_bn254 :: calls :: TransactionApi < 'a , T , X > { mixer_verifier_bn254 :: calls :: TransactionApi :: new (self . client) } pub fn anchor_verifier_bn254 (& self) -> anchor_verifier_bn254 :: calls :: TransactionApi < 'a , T , X > { anchor_verifier_bn254 :: calls :: TransactionApi :: new (self . client) } pub fn merkle_tree_bn254 (& self) -> merkle_tree_bn254 :: calls :: TransactionApi < 'a , T , X > { merkle_tree_bn254 :: calls :: TransactionApi :: new (self . client) } pub fn linkable_tree_bn254 (& self) -> linkable_tree_bn254 :: calls :: TransactionApi < 'a , T , X > { linkable_tree_bn254 :: calls :: TransactionApi :: new (self . client) } pub fn mixer_bn254 (& self) -> mixer_bn254 :: calls :: TransactionApi < 'a , T , X > { mixer_bn254 :: calls :: TransactionApi :: new (self . client) } pub fn signature_bridge (& self) -> signature_bridge :: calls :: TransactionApi < 'a , T , X > { signature_bridge :: calls :: TransactionApi :: new (self . client) } pub fn v_anchor_verifier2x2_bn254 (& self) -> v_anchor_verifier2x2_bn254 :: calls :: TransactionApi < 'a , T , X > { v_anchor_verifier2x2_bn254 :: calls :: TransactionApi :: new (self . client) } pub fn bridge (& self) -> bridge :: calls :: TransactionApi < 'a , T , X > { bridge :: calls :: TransactionApi :: new (self . client) } pub fn v_anchor_bn254 (& self) -> v_anchor_bn254 :: calls :: TransactionApi < 'a , T , X > { v_anchor_bn254 :: calls :: TransactionApi :: new (self . client) } pub fn v_anchor_handler_bn254 (& self) -> v_anchor_handler_bn254 :: calls :: TransactionApi < 'a , T , X > { v_anchor_handler_bn254 :: calls :: TransactionApi :: new (self . client) } } }